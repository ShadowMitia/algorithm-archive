<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Computus - Arcane Algorithm Archive</title>


        <!-- Custom HTML head -->

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../index.html"><strong aria-hidden="true">1.</strong> Algorithm Archive</a></li><li class="chapter-item expanded "><a href="../introduction/introduction.html"><strong aria-hidden="true">2.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="../how_to_contribute/how_to_contribute.html"><strong aria-hidden="true">3.</strong> How To Contribute</a></li><li class="chapter-item expanded "><a href="../plotting/plotting.html"><strong aria-hidden="true">4.</strong> Plotting</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../domain_coloring/domain_coloring.html"><strong aria-hidden="true">4.1.</strong> Domain Coloring</a></li><li class="chapter-item expanded "><a href="../IFS/IFS.html"><strong aria-hidden="true">4.2.</strong> Iterated Function Systems</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../barnsley/barnsley.html"><strong aria-hidden="true">4.2.1.</strong> The Barnsley Fern</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="../data_structures/data_structures.html"><strong aria-hidden="true">5.</strong> Data Structures</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../stacks_and_queues/stacks_and_queues.html"><strong aria-hidden="true">5.1.</strong> Stacks and Queues</a></li></ol></li><li class="chapter-item expanded "><a href="../mathematical_background/mathematical_background.html"><strong aria-hidden="true">6.</strong> Mathematical Background</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../notation/notation.html"><strong aria-hidden="true">6.1.</strong> Complexity Notation</a></li><li class="chapter-item expanded "><a href="../affine_transformations/affine_transformations.html"><strong aria-hidden="true">6.2.</strong> Affine Transformations</a></li><li class="chapter-item expanded "><a href="../bitlogic/bitlogic.html"><strong aria-hidden="true">6.3.</strong> Bit Logic</a></li><li class="chapter-item expanded "><a href="../taylor_series_expansion/taylor_series_expansion.html"><strong aria-hidden="true">6.4.</strong> Taylor Series</a></li><li class="chapter-item expanded "><a href="../convolutions/convolutions.html"><strong aria-hidden="true">6.5.</strong> Convolutions</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../convolutions/1d/1d.html"><strong aria-hidden="true">6.5.1.</strong> Convolutions in 1D</a></li><li class="chapter-item expanded "><a href="../convolutions/multiplication/multiplication.html"><strong aria-hidden="true">6.5.2.</strong> Multiplication as a Convolution</a></li><li class="chapter-item expanded "><a href="../convolutions/2d/2d.html"><strong aria-hidden="true">6.5.3.</strong> Convolutions of Images (2D)</a></li><li class="chapter-item expanded "><a href="../convolutions/convolutional_theorem/convolutional_theorem.html"><strong aria-hidden="true">6.5.4.</strong> Convolutional Theorem</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="../tree_traversal/tree_traversal.html"><strong aria-hidden="true">7.</strong> Tree Traversal</a></li><li class="chapter-item expanded "><a href="../euclidean_algorithm/euclidean_algorithm.html"><strong aria-hidden="true">8.</strong> Euclidean Algorithm</a></li><li class="chapter-item expanded "><a href="../monte_carlo_integration/monte_carlo_integration.html"><strong aria-hidden="true">9.</strong> Monte Carlo</a></li><li class="chapter-item expanded "><a href="../matrix_methods/matrix_methods.html"><strong aria-hidden="true">10.</strong> Matrix Methods</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../gaussian_elimination/gaussian_elimination.html"><strong aria-hidden="true">10.1.</strong> Gaussian Elimination</a></li><li class="chapter-item expanded "><a href="../thomas_algorithm/thomas_algorithm.html"><strong aria-hidden="true">10.2.</strong> Thomas Algorithm</a></li></ol></li><li class="chapter-item expanded "><a href="../computational_geometry/computational_geometry.html"><strong aria-hidden="true">11.</strong> Computational Geometry</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../gift_wrapping/gift_wrapping.html"><strong aria-hidden="true">11.1.</strong> Gift Wrapping</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../jarvis_march/jarvis_march.html"><strong aria-hidden="true">11.1.1.</strong> Jarvis March</a></li><li class="chapter-item expanded "><a href="../graham_scan/graham_scan.html"><strong aria-hidden="true">11.1.2.</strong> Graham Scan</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="../cooley_tukey/cooley_tukey.html"><strong aria-hidden="true">12.</strong> FFT</a></li><li class="chapter-item expanded "><a href="../decision_problems/decision_problems.html"><strong aria-hidden="true">13.</strong> Decision Problems</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../stable_marriage_problem/stable_marriage_problem.html"><strong aria-hidden="true">13.1.</strong> Stable Marriage Problem</a></li></ol></li><li class="chapter-item expanded "><a href="../physics_solvers/physics_solvers.html"><strong aria-hidden="true">14.</strong> Physics Solvers</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../verlet_integration/verlet_integration.html"><strong aria-hidden="true">14.1.</strong> Verlet Integration</a></li><li class="chapter-item expanded "><a href="../quantum_systems/quantum_systems.html"><strong aria-hidden="true">14.2.</strong> Quantum Systems</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../split-operator_method/split-operator_method.html"><strong aria-hidden="true">14.2.1.</strong> Split-Operator Method</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="../data_compression/data_compression.html"><strong aria-hidden="true">15.</strong> Data Compression</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../huffman_encoding/huffman_encoding.html"><strong aria-hidden="true">15.1.</strong> Huffman Encoding</a></li></ol></li><li class="chapter-item expanded "><a href="../computer_graphics/computer_graphics.html"><strong aria-hidden="true">16.</strong> Computer Graphics</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../flood_fill/flood_fill.html"><strong aria-hidden="true">16.1.</strong> Flood Fill</a></li></ol></li><li class="chapter-item expanded "><a href="../quantum_information/quantum_information.html"><strong aria-hidden="true">17.</strong> Quantum Information</a></li><li class="chapter-item expanded "><a href="../computus/computus.html" class="active"><strong aria-hidden="true">18.</strong> Computus</a></li><li class="chapter-item expanded "><a href="../approximate_counting/approximate_counting.html"><strong aria-hidden="true">19.</strong> Approximate Counting Algorithm</a></li><li class="chapter-item expanded affix "><a href="../bibliography.html">Bibliography</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Arcane Algorithm Archive</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/algorithm-archivists/algorithm-archive/" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="the-easter-algorithm-computus"><a class="header" href="#the-easter-algorithm-computus">The Easter Algorithm (Computus)</a></h1>
<p>Though the word <em>Computus</em> can technically describe any sort of computation {{#cite bede725&quot; | cite }} or else a set of medieval tables for calculating various astrological events {{ &quot;dictcomputus}}, it is also one of the most common historical names for the calculation of the Christian holiday of Easter every year.
Nominally, Easter happens the Sunday after the first full moon after the spring equinox (roughly March 21st).
This particular full moon is known by a number of names, such as the Pink (Strawberry) Moon, Hunter's Moon, or the Snow Moon, along with several others.
The most common name for it is the paschal full moon, which translates to &quot;Passover&quot; in Greek and signifies an important Jewish festival.</p>
<p>For the first few centuries, the date of Easter each year was dictated by the Pope; however, after the church grew, it was no longer straightforward to communicate this date to all of Christendom.
As such, the church did what it could to algorithmically generate tables for clergy to determine the date of Easter each year.
To this day, the calculation of Easter still poses a problem, with western and eastern (orthodox) churches celebrating on different dates approximately 50% of the time.</p>
<p>I'll be honest, there is a lot of good, Christian drama surrounding the calculation of this event and it's remarkably interesting to read about [<a href="../bibliography.html#bien2004">bien2004</a>].
Suffice it to say that the date of Easter bamboozled many historical scholars, with at least one algorithm appearing in the early archives of the now famous scientific journal of <em>Nature</em> [<a href="../bibliography.html#computus1876">computus1876</a>].
The calculation was so complicated that even Frederick Gauss had to try his hand at it (and failed before being corrected by one of his students).</p>
<p>Essentially, the date of Easter depends on both the lunar and solar cycles
The date of the paschal full moon, for example, is static in the lunar calendar, but it is not in the solar calendar.
In this way, computus is the act of mapping a lunar cycle onto the Gregorian (solar) calendar everyone knows and loves.
Because many different calendar systems have existed throughout history, there was a natural question as to <em>which</em> calendar system would be used to calculate the precise date of Easter.
The western churches chose the Gregorian calendar and the eastern churches chosethe Julian one, and this is one reason why western and eastern churches sometimes celebrate on different dates.
That said, the Gregorian calendar more accurately represents the true date of the paschal full moon, so the western church's approach ended up being more precise.</p>
<p>Though there are many methods to calculate Easter, for now, we will focus only on Gauss's algorithm; however, we mayl certainly come back (in subsequent years) to incorporate other Easter algorithms if there is demand.
These algorithms are some of my favorite gems in the history of algorithm design because of all the drama surrounding the calculation of something that seems trivial!
After all, how hard could it be to calculate Easter?</p>
<h2 id="gausss-easter-algorithm-history"><a class="header" href="#gausss-easter-algorithm-history">Gauss's Easter algorithm history</a></h2>
<p>Gauss is known for a lot of things: Gaussian elimination, the Cooley-Tukey method before Cooley or Tukey even existed, Gauss's Law for electromagnetism, etc.
One thing he is <em>not</em> particularly well known for is an algorithm he devised in 1800, which was later corrected by his student Peter Paul Tittle in 1816.
In fact, there were a series of publications from Gauss in this era all relating to the precise date of Easter.
The legend goes that Gauss actually did not know his real birthday in the Gregorian calendar and used this same algorithm to determine it.
Apparently, his mother only told him that he was born on a Wednesday 8 days before Ascension Day in 1777, which corresponds to April 30th [<a href="../bibliography.html#bien2004">bien2004</a>].</p>
<p>Honestly, Gauss's Easter algorithm was the 19th century equivalent of undocumented code.
I could imagine Gauss grumpily &quot;patching&quot; his method when users complained that it did not work on dates past 4200 or even certain dates within his own era!
When some of his compatriots (such as Johann Lambert and Jean Joseph Delambre) expressed their concern over the method's performance, Gauss replied by saying,</p>
<blockquote>
<p>The investigation by which the formula [...] is found is based on higher arithmetic, for which I presumably cannot refer to any publication.</p>
</blockquote>
<p>Which was the 19th century equivalent of saying, &quot;you are too dumb to understand my genius.&quot;
I have definitely met a few fledgling programmers who feel the same, but none of them were anywhere near as prolific as Gauss.</p>
<p>One of the most important fans of Gauss's work was Servois, who created a calendar based on Gauss's 1800 publication, shown below:</p>
<img class="center" src="res/servois_1800.png" alt="Servois' 1800 table"  style="width:80%">
<p>This calendar shows the date the paschal full moon, indicating that Easter will be the following Sunday [<a href="../bibliography.html#servois">servois</a>].
In this table, a value greater than 22 indicates the full moon will be on the presented number (date) in March and a value less than 22 indicates the full moon will be on that date in April.
The \( y \)-axis of this table indicates the decade and the \( x \)-axis indicates the precise year.
Admittedly, the notation is a bit funky, but it was 1813.
Times were different then.</p>
<p>The task for this chapter will be to explain (to the best of my abilities) how one would go about using Gauss's Easter algorithm to calculate the date of Easter for any given year (within the limitations of the algorithm).</p>
<h2 id="background"><a class="header" href="#background">Background</a></h2>
<p>Because Easter is the Sunday following the paschal full moon, which is the first full moon of spring, Gauss's algorithm is tasked at finding a way to map the lunar calendar to the Gregorian (solar) calendar.
For this reason, before discussing the algorithm, itself, we must first introduce both calendar systems.
The Gregorian (solar) calendar has been created to mark Earth's full revolution around the Sun, which is approximately 365.2425 days.
Unfortunately, days are based on the Earth's rotation about its axis, not its revolution around the Sun, so the number of days in a year is not an integer number (such as 365).
This discrepancy has actually lead to a large number of calendar systems, including one invented by Gauss, himself [<a href="../bibliography.html#standish2004">standish2004</a>].
Before the Gregorian calendar, there was another correction made from an old Roman calendar to set the days in a year to be 365.25 days.
This was called the Julian calendar.
From there, the Julian calendar was further corrected to the Gregorian calendar with 365.2425 days.
Though there is only a small change necessary to use Gauss's Easter algorithm for the Julian calendar, this will not be covered here; however, if you want to see this, we can add it in upon request.</p>
<p>To account for the non-integer nature of the Gregorian year, a leap day is celebrated on February 29th every 4 years, with exception of when the year is a multiple of 100, where no leap-day is observed; if the year is divisible by 400, however, a leap day is still observed.
This means that every 400 years, there are 97 leap days.
This is why a leap day was celebrated in 2020 and 2000, but was not in 1900.
If at this point, you feel like your favorite calendar system is held together by duct tape and string, you would be right.</p>
<p>In addition to the solar year, Gauss's Easter algorithm also needs to keep the lunar year into account.
A lunar month corresponds to the time it takes the Moon to complete one full revolution around the Earth.
In most cases, this is approximately 27.5 days [<a href="../bibliography.html#lunar_month_wiki">lunar_month_wiki</a>].
That said, space is complicated and the Moon is not the only revolving body.
Lunar phases are related to the time it takes for the Moon to return to its location <em>in relation to</em> the line connecting the Sun and Earth, as shown below:</p>
<img class="center" src="res/orbit.svg" alt="Synodic half year"  style="width:90%">
<p>This is called the synodic month and will be the approximation used for this chapter.
Below, we also show a snapshot of this simulation after 6 synodic months:</p>
<img class="center" src="res/synodic_half_year.png" alt="Synodic half year"  style="width:90%">
<p>Here, we show an outline of the Earth and Moon in an arbitrary initial position, each with an angle of \( -\frac{\pi}{4} \) from the horizontal axis.
In addition, we show the location of the Moon and Earth again after 6 synodic months and additional outlines for each intermediate synodic month.
Red lines are drawn from the center of the sun to the moon to indicate the positioning of the moon in relation to the sun and earth.
In all positions, the Moon is hidden behind the Earth, creating the full moon phase.
In this way, the synodic month is the time between two consecutive phases, which is slightly longer than the time it takes to revolve around the Earth and return to the same angle (here \( \frac{\pi}{4} \)).
Each synodic month is approximately 29.5 days, so a synodic year of 12 lunar months is 354 days, which is 11 days shorter than the normal 365 days in a Gregorian year.
The following is a pictorial representation of offset between a solar and lunar year:</p>
<img class="center" src="res/orbit.png" alt="Full year"  style="width:90%">
<p>Here, we see the Sun at the center, with the Earth and Moon starting the year at an angle of \( -\frac{\pi}{4} \) from the horizontal axis.
The initial location of the Earth and Moon are shown as an outline with the letter &quot;A&quot; at their center.
After a full synodic lunar year (12 lunar months), another outline of the Earth and Moon are shown at position B, and after a full Gregorian year, they are shown in position C.
An arc is then drawn showing the difference of 11 days between the Earth's position after a synodic year, and another arc is drawn to show the difference between the Moon's position after a full Gregorian year.</p>
<p>Because the synodic month and the solar year are not synchronized, the phase of the Moon will be different on the same day of the Gregorian year.
That said, the lunar and solar calendars will re-synchronize roughly every 19 years.
For example, if there is a new moon on January 1st, 2020, there will not be a new moon on January 1st, 2021; however, there <em>will</em> be a new moon on January 1st, 2039.
This 19-year cycle where the Moon and Sun are waiting to re-synchronize is known as the Metonic cycle and has been studied for centuries.</p>
<p>This cycle allows us to somewhat easily transition between solar and lunar calendars.
If we imagine any Gregorian date (let's say January 1st again for clarity), the moon could be in one of 19 different phases, as shown below:</p>
<img class="center" src="res/metonic.png" alt="Metonic cycle"  style="width:90%">
<p>Here, we show each possible phase of the moon as an outline, but the actual phase as a grey circle.
Essentially, by knowing what year we are on in the Metonic cycle, we can single out which phase of the moon we will see on any given date.
This is powerful and will allow us to find the next full moon by looking ahead a few days.</p>
<p>As a final note, there is a small offset in the Metonic cycle of 1 hour and 45 minutes every 19 years, so in 2500 years, it will be 8 days off, but that's a problem for people in 2500.
For now, we should be able to start discussing the algorithm, itself.</p>
<h2 id="the-algorithm"><a class="header" href="#the-algorithm">The algorithm</a></h2>
<p>As alluded to in Gauss's quote above, the Easter algorithm is closer to a set of formulas than a method used to compute anything on a modern computer.
This is partially because of bad software engineering by Gauss and partially because computers did not really exist at that point.
Considering this method was literally called <em>Computus</em>, there probably was not much to compute at all at the time.
Nowadays, you could more easily find the date of Easter with loops and conditions, but this is the <em>Arcane</em> Algorithm Archive, and this is definitely an arcane algorithm, so let's go!</p>
<p>For this section, we will be following similar notation to Gauss's original 1800 work, which is a bit terse and hard to follow; however, each term is significantly meaningful.
If you are reading this and think you have a better way to present anything, please let us know (with an issue or pull request on github) and we can correct the text!</p>
<p>This method can be split into 2 parts:</p>
<ol>
<li>Calculating the days from March 21st to the next full moon</li>
<li>Calculating the days from the full moon to the next Sunday</li>
</ol>
<p>In the following sections, we will discuss both individually.</p>
<h3 id="calculating-the-date-of-the-next-full-moon"><a class="header" href="#calculating-the-date-of-the-next-full-moon">Calculating the date of the next full moon</a></h3>
<p>To start, we will be calculating \( d \), which is the number of days until the next full moon from March 21st (the first day of spring according to the pope).
To calculate this, we need to first calculate a number of auxiliary variables, starting with the current year's location on the Metonic calendar,
\[ a = \text{year}~%~19, \]
where \( % \) is the modulo operator and 19 is the length of the Metonic calendar in years.
From here, we also need to calculate an offset to \( a \), and for this we need the century index,
\[ k = \left\lfloor\frac{\text{year}}{100}\right\rfloor, \]
where \( \lfloor\cdot\rfloor \) is the flooring operation of rounding the value down to the nearest integer.
With this, we can calculate the shift in the Metonic cycle to be,</p>
<p>\[ p = \left\lfloor\frac{13+8k}{25}\right\rfloor. \]</p>
<p>This expression represents the fact that the Metonic cycle will be 8 days off every 2500 years and adds an additional offset of 13 to ensure the Metonic cycle aligns with empirical observation.</p>
<p>At this point, we know what year we are at on the Metonic calendar and have calculated an offset accordingly; however, we have yet to take into account leap years.
As stated above, there are 97 leap days every 400 years, and the calculation of \( p \) above requires correction for the 3 leap days missed.
If one adds 25 leap days per century and subtracts \( k \), they will find 96 leap days every 400 years instead, which is a close approximation, but off by one.
This accounts for the fact that leap days are not celebrated on years that are multiples of 100.
There is, however, an exception made for years that are multiples of 400, which is why Gauss calculated an additional variable,</p>
<p>\[ q = \left\lfloor\frac{k}{4}\right\rfloor. \]</p>
<p>This means that \( 100-k-q \) will provide the appropriate number of leap days every 400 years.
After this is found, we then calculate a sum of all offsets within a lunar month.</p>
<p>\[ M = (15-p+k-q)~%~30 \]</p>
<p>where 15 is an offset indicating that the full moon on year 0 is 15 days from March 21st, \( p \) is the number of days we are off from the Metonic cycle, and \( k-q \) are non-observed leap days.
The values of \( p \), \( k \), and \( q \) all provide <em>century</em> offsets, which means that the value of \( M \) will provide the correct starting point for each century.
The \( %30 \) (modulo 30 arithmetic) constricts our calculation to be within a single synodic lunar month of approximately 30 days.</p>
<p>With all this information, we can finally calculate the number of days from March 21st until the first full moon, as</p>
<p>\[ d = (19a+M)~%~30 \]</p>
<p>Again, the \( %~30 \) operation makes sense here because there is no way the next full moon could occur over 30 days (a synodic lunar month) from March 21st.
At first glance, this is simply a calculation of \( a \) (where we are on the Metonic cycle) with some offset, \( M \).
This is true, but there is an additional multiplicative factor of 19.
One might be tempted to wave this away by saying, &quot;19 is the number of years in the Metonic cycle, so this makes sense!&quot;
The truth is that that 19 is a bit more complicated.
This calculation is a calculation of <em>days</em>, not years.</p>
<p>Every 12 lunar months is roughly 354 days, which is 11 days shorter than 365.
This means that every year in the Metonic cycle, the lunar phase will be 11 days behind.
It just so happens that \( -11~%~30 = 19 \).
Thus, \( 19a \) is a combination of this 11 day offset and the fact that we are using modulo 30 arithmetic.
After 19 years, the lunar calendar will be a full 365 days off in the solar calendar, but again, we only care about <em>day</em> offsets in this calculation.
No one really keeps track of lunar years, just solar ones.</p>
<p>Regardless, we now have \( d \), the number of days until the next full moon.
Interestingly, this is all the information necessary to replicate Servois's table above.
From here, we simply need to create a two-dimensional array with the decade on the \( y \) axis and year on the \( x \) axis and set within it the value of \( (21+d)~%~31 \), where the 21 represents the 21st of March, and the \( %~31 \) comes from the fact that there are 31 days in March.
For example, if we were to do this computation for the years from 2000 to 2099, we would find the following table:</p>
<img class="center" src="res/servois_2000.png" alt="Servois' 2000 table"  style="width:90%">
<p>Which shows that the date of the paschal full moon for 2020 is April 9th.
Now we can move on to finding the precise date of Easter, which should be the following Sunday</p>
<h3 id="calculating-the-next-sunday"><a class="header" href="#calculating-the-next-sunday">Calculating the next Sunday</a></h3>
<p>This calculation will take a few variables from the previous section, namely \( k-q \) (the number of non-observed leap days), and \( d \) (the number of days since March 21st to the next full moon).
For the last calculation, we synchronized the number of days in a lunar month with the Gregorian (solar) calendar.
For this computation, we do similar operations, but for the weekly calendar of 7 days, this value will be stored in \( e \).
The first step is calculating the correct offset each century based on the fact that Jan 1st, in year 1 was a Friday and then accounting for all the non-observed leap days (\( k-q \)),</p>
<p>\[ N = (4+k-q)~%~7. \]</p>
<p>From here, things get a little tricky.
There are 52 weeks in a year, but \( 52\times7=364 \), meaning we are essentially one day off every year, with exception of leap years where we are two days off.
As an example, look at the following table</p>
<table><thead><tr><th>January 1st</th><th>Day of the week</th><th>Special considerations</th></tr></thead><tbody>
<tr><td>2017</td><td>Sunday</td><td>None</td></tr>
<tr><td>2018</td><td>Monday</td><td>None</td></tr>
<tr><td>2019</td><td>Tuesday</td><td>None</td></tr>
<tr><td>2020</td><td>Wednesday</td><td>Leap Year</td></tr>
<tr><td>2021</td><td>Friday</td><td>None</td></tr>
</tbody></table>
<p>Simply put, every year we should subtract one day of the week, but on leap years, we should subtract 2.
To keep tabs on this, we need two separate counts,</p>
<p>\[ b = \text{year}~%~4, \]
and
\[ c = \text{year}~%~7, \]
where \( b \) keeps track of leap years, and \( c \) simply increments by 1 every year.
Through a bit of mathematical magic, we can find the expression \( 2b+4c \), which will be -1 in modulo 7 arithmetic for every year, except leap years where it will be -2.</p>
<p>With all these terms put together, we can finally calculate the offset from the full moon to Easter Sunday as</p>
<p>\[ e = (2b+4c+6d+N)~%~7. \]</p>
<p>Here, all terms are described as above and the multiplicative factor of 6 to \( d \) will provide an offset to Sunday without correcting for leap days.</p>
<h3 id="wrapping-up"><a class="header" href="#wrapping-up">Wrapping up</a></h3>
<p>At this point, we can calculate the days from March 21st to Easter Sunday to be \( d+e \).
In particular</p>
<p>\[
\text{Easter} = \left{
\begin{align}
d+e+22\text{ March}&amp; \qquad \text{if } 22+d+e\leq31 \\
d+e-9\text{ April}&amp; \qquad \text{if } 22+d+e&gt;31 \\
\end{align}
\right.
\]</p>
<p>Remember that March 22nd would be the first possible day to celebrate Easter because March 21st would be the first possible full moon of spring.
All said, there are a few exceptions that are somewhat tricky to understand, namely:</p>
<p>\[
e = \left{
\begin{align}
&amp;e \\
&amp;-1, \qquad \text{if } d=29 \text{ and } e=6 \text{ or } d=28, e=6, \text{ and } a&gt;10
\end{align}
\right.
\]</p>
<p>These conditionals are placed on the output of \( d \) and correspond to when Easter falls on April 26th (if \( d = 29 \)) or April 25th (if \( d = 28 \)).
In both of these cases, we are setting \( e=-1 \), which has the effect of removing a week from the date of Easter.
For example, an Easter that would be celebrated on the 26th would instead be celebrated on the 19th.</p>
<p>Many say that these conditionals are placed on the output for historical reasons, but between you and me, I feel there is a more mathematical reason that I do not fully understand.
After all, why is the correction for \( d=28 \) only placed on the Easter date output on the second half of the Metonic cycle (if \( a &gt; 10 \))?
If you think you might have a better idea as to why these dates are corrected as such, please let us know!</p>
<p>As mentioned, this particular algorithm does not make use of any standard computational techniques.
There are no loops, conditionals, stacks, or queues.
However, there can be no doubt that Gauss was a master of his craft.
The sheer complexity of this calculation both baffles and astounds me -- especially because this was done hundreds of years before computational thinking became common-place.</p>
<p>Sure, this can be done straightforwardly with a calculator, but it is no doubt an algorithm worth discussing and celebrating for its ingenuity at the time of creation.</p>
<h2 id="video-explanation"><a class="header" href="#video-explanation">Video Explanation</a></h2>
<p>Here is a video describing key elements of Gauss's Easter Algorithm:</p>
<div style="text-align:center">
<iframe width="560" height="315" src="https://www.youtube.com/embed/x6Yud882QKE" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
</div>
<h2 id="example-code"><a class="header" href="#example-code">Example Code</a></h2>
<p>Unlike many other chapters in the Algorithm Archive, this particular method can be described almost entirely by mathematical expressions.
As such, it should be relatively straightforward to implement in a number of different languages, and I heartily encourage you to do so!
For now, we have the code outputting a tuple of \( d \) and \( e \), so users can use this to calculate either the date of Easter or Servois's table, depending on their use-case; however, please modify the code however you wish!</p>
<pre><code class="language-julia">function computus(year; servois=false)

    # Year's position on the 19 year metonic cycle
    a = mod(year, 19)

    # Century index
    k = fld(year, 100)

    # Shift of metonic cycle, add a day offset every 300 years
    p = fld(13 + 8 * k, 25)

    # Correction for non-observed leap days
    q = fld(k, 4)

    # Correction to starting point of calculation each century
    M = mod(15 - p + k - q, 30)

    # Number of days from March 21st until the full moon
    d = mod(19 * a + M, 30)

    # Returning if user wants value for Servois' table
    if servois
        return string(mod(21 + d,31))
    end

    # Finding the next Sunday
    # Century-based offset in weekly calculation
    N = mod(4 + k - q, 7)

    # Correction for leap days
    b = mod(year, 4)
    c = mod(year, 7)

    # Days from d to next Sunday
    e = mod(2 * b + 4 * c + 6 * d + N, 7)

    # Historical corrections for April 26 and 25
    if (d == 29 &amp;&amp; e == 6) || (d == 28 &amp;&amp; e == 6 &amp;&amp; a &gt; 10)
        e = -1
    end

    # Determination of the correct month for Easter
    if(22 + d + e &gt; 31)
        return &quot;April &quot; * string(d + e - 9)
    else
        return &quot;March &quot; * string(22 + d + e)
    end
end

# Here, we will output the date of the Paschal full moon
# (using Servois notation), and Easter for 2020-2030

a = collect(2020:2030)
servois_numbers = computus.(a; servois=true)
easter_dates = computus.(a)

println(&quot;The following are the dates of the Paschal full moon (using Servois &quot; *
        &quot;notation) and the date of Easter for 2020-2030 AD:&quot;)
println(&quot;Year\tServois number\tEaster&quot;)
for i = 1:length(a)
    println(&quot;$(a[i])\t$(servois_numbers[i])\t\t$(easter_dates[i])&quot;)
end
</code></pre>
<pre><code class="language-haskell">data Mode = Servois | Easter

computus :: Mode -&gt; Int -&gt; String
computus mode year =
  case mode of
    Servois -&gt;
      -- Value for Servois' table
      show $ (21 + d) `mod` 31
    Easter -&gt;
      -- Determination of the correct month for Easter
      if 22 + d + f &gt; 31
        then &quot;April &quot; ++ show (d + f - 9)
        else &quot;March &quot; ++ show (22 + d + f)
  where
    a, b, c, d, e, f, k, m, n, p, q :: Int
    -- Year's position on the 19 year metonic cycle
    a = year `mod` 19
    -- Century index
    k = year `div` 100
    -- Shift of metonic cycle, add a day offset every 300 years
    p = (13 + 8 * k) `div` 25
    -- Correction for non-observed leap days
    q = k `div` 4
    -- Correction to starting point of calculation each century
    m = (15 - p + k - q) `mod` 30
    -- Number of days from March 21st until the full moon
    d = (19 * a + m) `mod` 30
    -- Finding the next Sunday
    -- Century-based offset in weekly calculation
    n = (4 + k - q) `mod` 7
    -- Correction for leap days
    b = year `mod` 4
    c = year `mod` 7
    -- Days from d to next Sunday
    e = (2 * b + 4 * c + 6 * d + n) `mod` 7
    -- Historical corrections for April 26 and 25
    f =
      if (d == 29 &amp;&amp; e == 6) || (d == 28 &amp;&amp; e == 6 &amp;&amp; a &gt; 10)
        then -1
        else e

-- Here, we will output the date of the Paschal full moon
-- (using Servois notation), and Easter for 2020-2030
main :: IO ()
main = do
  let years :: [Int]
      years = [2020 .. 2030]
      servoisNumbers, easterDates :: [String]
      servoisNumbers = map (computus Servois) years
      easterDates = map (computus Easter) years
  putStrLn &quot;The following are the dates of the Paschal full moon (using Servois notation) and the date of Easter for 2020-2030 AD:&quot;
  putStrLn &quot;Year\tServois number\tEaster&quot;
  let conc :: Int -&gt; String -&gt; String -&gt; String
      conc y s e = show y ++ &quot;\t&quot; ++ s ++ &quot;\t\t&quot; ++ e
  mapM_ putStrLn $ zipWith3 conc years servoisNumbers easterDates
</code></pre>
<pre><code class="language-python">def computus(year, servois=False):
    # Year's position on the 19-year metonic cycle
    a = year % 19

    # Century index
    k = year // 100

    # Shift of metonic cycle, add a day offset every 300 years
    p = (13 + 8 * k) // 25

    # Correction for non-observed leap days
    q = k // 4

    # Correction to starting point of calculation each century
    M = (15 - p + k - q) % 30

    # Number of days from March 21st until the full moon
    d = (19 * a + M) % 30

    # Returning if user wants value for Servois' table
    if servois:
        return str((21 + d) % 31)

    # Finding the next Sunday
    # Century-based offset in weekly calculation
    N = (4 + k - q) % 7

    # Correction for leap days
    b = year % 4
    c = year % 7

    # Days from d to next Sunday
    e = (2 * b + 4 * c + 6 * d + N) % 7

    # Historical corrections for April 26 and 25
    if (d == 29 and e == 6) or (d == 28 and e == 6 and a &gt; 10):
        e = -1

    # Determination of the correct month for Easter
    if 22 + d + e &gt; 31:
        return &quot;April &quot; + str(d + e - 9)
    else:
        return &quot;March &quot; + str(22 + d + e)


# Here, we will output the date of the Paschal full moon
# (using Servois notation), and Easter for 2020-2030

print(
    &quot;The following are the dates of the Paschal full moon (using Servois&quot;,
    &quot;notation) and the date of Easter for 2020-2030 AD:&quot;,
)
print(&quot;Year\tServois number\tEaster&quot;)
for year in range(2020, 2031):
    print(f&quot;{year}\t{computus(year, servois=True)}\t\t{computus(year)}&quot;)
</code></pre>
<pre><code class="language-crystal">def computus(year, servois = false)
  # Year's position on the 19 year metonic cycle
  a = year % 19

  # Century index
  k = year // 100

  # Shift of metonic cycle, add a day offset every 300 years
  p = (13 + 8 * k) // 25

  # Correction for non-observed leap days
  q = k // 4

  # Correction to starting point of calculation each century
  m = (15 - p + k - q) % 30

  # Number of days from March 21st until the full moon
  d = (19 * a + m) % 30

  # Returning if user wants value for Servois' table
  if servois
    return ((21 + d) % 31).to_s
  end

  # Finding the next Sunday
  # Century-based offset in weekly calculation
  n = (4 + k - q) % 7

  # Correction for leap days
  b = year % 4
  c = year % 7

  # Days from d to next Sunday
  e = (2 * b + 4 * c + 6 * d + n) % 7

  # Historical corrections for April 26 and 25
  if (d == 29 &amp;&amp; e == 6) || (d == 28 &amp;&amp; e == 6 &amp;&amp; a &gt; 10)
    e = -1
  end

  # Determination of the correct month for Easter
  if (22 + d + e &gt; 31)
    return &quot;April &quot; + (d + e - 9).to_s
  else
    return &quot;March &quot; + (22 + d + e).to_s
  end
end

# Here, we will output the date of the Paschal full moon
# (using Servois notation), and Easter for 2020-2030
def main
  a = (2020..2030).to_a
  servois_numbers = a.map { |y| computus(y, servois = true) }
  easter_dates = a.map { |y| computus(y) }

  puts &quot;The following are the dates of the Paschal full moon (using Servois &quot; +
       &quot;notation) and the date of Easter for 2020-2030 AD:&quot;
  puts &quot;Year\tServois number\tEaster&quot;
  a.each_index { |i|
    puts &quot;#{a[i]}\t#{servois_numbers[i]}\t\t#{easter_dates[i]}&quot;
  }
end

main
</code></pre>
<pre><pre class="playground"><code class="language-rust">fn computus(year: usize, servois: bool) -&gt; String {
    // Year's position on the 19 year metonic cycle
    let a = year % 19;

    // Century index
    let k = year / 100; // NOTE: dividing integers always truncates the result

    // Shift of metonic cycle, add a day offset every 300 years
    let p = (13 + 8 * k) / 25;

    // Correction for non-observed leap days
    let q = k / 4;

    // Correction to starting point of calculation each century
    let m = (15 - p + k - q) % 30;

    // Number of days from March 21st until the full moon
    let d = (19 * a + m) % 30;

    if servois {
        return ((21 + d) % 31).to_string();
    }

    // Finding the next Sunday
    // Century-based offset in weekly calculation
    let n = (4 + k - q) % 7;

    // Correction for leap days
    let b = year % 4;
    let c = year % 7;

    // Days from d to next Sunday
    let temp_e = ((2 * b + 4 * c + 6 * d + n) % 7) as isize;

    // Historical corrections for April 26 and 25
    let e = if (d == 29 &amp;&amp; temp_e == 6) || (d == 28 &amp;&amp; temp_e == 6 &amp;&amp; a &gt; 10) {
        -1
    } else {
        temp_e
    };

    // Determination of the correct month for Easter
    if (22 + d) as isize + e &gt; 31 {
        format!(&quot;April {}&quot;, d as isize + e - 9)
    } else {
        format!(&quot;March {}&quot;, 22 + d as isize + e)
    }
}

fn main() {
    // Here, we will output the date of the Paschal full moon
    // (using Servois notation), and Easter for 2020-2030

    let years = 2020..=2030;

    println!(
        &quot;The following are the dates of the Paschal full moon (using \
            Servois notation) and the date of Easter for 2020-2030 AD:&quot;
    );
    println!(&quot;Year\tServois number\tEaster&quot;);
    years.for_each(|year| {
        println!(
            &quot;{}\t{:&lt;14}\t{}&quot;,
            year,
            computus(year, true),
            computus(year, false),
        )
    });
}
</code></pre></pre>
<pre><code class="language-powershell">﻿function Calculate-Computus([int]$Year, [switch]$Servois) {

    # Year's position on the 19 year metonic cycle
    $a = $Year % 19

    # Century index
    $k = [Math]::Floor($Year / 100)

    # Shift of metonic cycle, add a day offset every 300 years
    $p = [Math]::Floor((13 + 8 * $k) / 25)

    # Correction for non-observed leap days
    $q = [Math]::Floor($k / 4)

    # Correction to starting point of calculation each century
    $M = (15 - $p + $k - $q) % 30

    # Number of days from March 21st until the full moon
    $d = (19 * $a + $M) % 30

    # Returning if user wants value for Servois' table
    if($Servois) {
        return ((21 + $d) % 31).ToString()
    }

    # Finding the next Sunday
    # Century-based offset in weekly calculation
    $N = (4 + $k - $q) % 7

    # Correction for leap days
    $b = $Year % 4
    $c = $Year % 7

    # Days from d to next Sunday
    $e = (2 * $b + 4 * $c + 6 * $d + $N) % 7

    # Historical corrections for April 26 and 25
    if(($d -eq 29 -and $e -eq 6) -or ($d -eq 28 -and $e -eq 6 -and $a -gt 10)) {
        $e = -1
    }

    # Determination of the correct month for Easter
    if(22 + $d + $e -gt 31) {
        return &quot;April &quot; + ($d + $e - 9)
    }
    else {
        return &quot;March &quot; + (22 + $d + $e)
    }
}


# Here, we will output the date of the Paschal full moon
# (using Servois notation), and Easter for 2020-2030

Write-Host &quot;The following are the dates of the Paschal full moon (using Servois&quot;,
           &quot;notation) and the date of Easter for 2020-2030 AD:&quot;
Write-Host &quot;Year`tServois number`tEaster&quot;
foreach($year in 2020..2030) {
    Write-Host &quot;$year`t$(Calculate-Computus $year -Servois)`t`t$(Calculate-Computus $year)&quot;
}
</code></pre>
<pre><code class="language-c">#include &lt;stdio.h&gt;

char *computus(int year, int servois, char *out, size_t out_size) {
    // Year's position on the 19 year metonic cycle
    int a = year % 19;

    // Century index
    int k = year / 100;

    //Shift of metonic cycle, add a day offset every 300 years
    int p = (13 + 8 * k) / 25;

    // Correction for non-observed leap days
    int q = k / 4;

    // Correction to starting point of calculation each century
    int M = (15 - p + k - q) % 30;

    // Number of days from March 21st until the full moon
    int d = (19 * a + M) % 30;

    // Returning if user wants value for Servois' table
    if (servois) {
        snprintf(out, out_size, &quot;%d&quot;,(21 + d) % 31);
        return out;
    }

    // Finding the next Sunday
    // Century-based offset in weekly calculation
    int N = (4 + k - q) % 7;

    // Correction for leap days
    int b = year % 4;
    int c = year % 7;

    // Days from d to next Sunday
    int e = (2 * b + 4 * c + 6 * d + N) % 7;

    // Historical corrections for April 26 and 25
    if ((d == 29 &amp;&amp; e == 6) || (d == 28 &amp;&amp; e == 6 &amp;&amp; a &gt; 10)) {
        e = -1;
    }

    if ((22 + d + e) &gt; 31) {
        snprintf(out, out_size, &quot;April %d&quot;, d + e - 9);
    } else {
        snprintf(out, out_size, &quot;March %d&quot;, 22 + d + e);
    }

    return out;
}

int main() {
    char tmp1[9], tmp2[9];

    printf(&quot;The following are the dates of the Paschal full moon (using &quot;
           &quot;Servois notation) and the date of Easter for 2020-2030 AD:\n&quot;);

    printf(&quot;Year\tServois number\tEaster\n&quot;);

    for (int year = 2020; year &lt;= 2030; year++) {
        printf(&quot;%d\t\t%s\t%s\n&quot;, year, computus(year, 1, tmp1, 9),
               computus(year, 0, tmp2, 9));
    }

    return 0;
}

</code></pre>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;string&gt;

std::string computus(int year, bool servois = false) {
  // Year's position on the 19 year metonic cycle
  int a = year % 19;

  // Century index
  int k = year / 100;

  // Shift of metonic cycle, add a day offset every 300 years
  int p = (13 + 8 * k) / 25;

  // Correction for non-observed leap days
  int q = k / 4;

  // Correction to starting point of calculation each century
  int M = (15 - p + k - q) % 30;

  // Number of days from March 21st until the full moon
  int d = (19 * a + M) % 30;

  // Returning if user wants value for Servois' table
  if (servois) {
    return std::to_string((21 + d) % 31);
  }

  // Finding the next Sunday
  // Century-based offset in weekly calculation
  int N = (4 + k - q) % 7;

  // Correction for leap days
  int b = year % 4;
  int c = year % 7;

  // Days from d to next Sunday
  int e = (2 * b + 4 * c + 6 * d + N) % 7;

  // Historical corrections for April 26 and 25
  if ((d == 29 &amp;&amp; e == 6) || (d == 28 &amp;&amp; e == 6 &amp;&amp; a &gt; 10)) {
    e = -1;
  }

  // Determination of the correct month for Easter
  return 22 + d + e &gt; 31 ? &quot;April &quot; + std::to_string(d + e - 9)
                         : &quot;March &quot; + std::to_string(22 + d + e);
}

// Here, we will output the date of the Paschal full moon (using Servois
// notation), and Easter for 2020-2030
int main() {
  std::cout &lt;&lt; &quot;The following are the dates of the Paschal full moon (using &quot;
               &quot;Servois notation) and the date of Easter for 2020-2030 AD:\n&quot;
               &quot;Year\tServois number\tEaster\n&quot;;

  for (int year = 2020; year &lt;= 2030; year++) {
    std::cout &lt;&lt; year &lt;&lt; &quot;\t\t&quot; &lt;&lt; computus(year, true) &lt;&lt; '\t'
              &lt;&lt; computus(year) &lt;&lt; std::endl;
  }
}
</code></pre>
<pre><code class="language-lisp">;;;; Gauss's Easter algorithm implementation

(defun computus (year &amp;optional (servois nil))
  &quot;Calculates the day of Easter for a given year and optionally its Servois number&quot;
  (let*
    ((a (mod year 19))                  ; year's position on the 19 year metonic cycle
      (k (floor year 100))              ; century index
      (p (floor (+ 13 (* 8 k)) 25))     ; shift of metonic cycle, add a day offset every 300 years
      (q (floor k 4))                   ; correction for non-observed leap days
      (m (mod (+ 15 (- p) k (- q)) 30)) ; correction to starting point of calculation each century
      (d (mod (+ (* 19 a) m) 30))       ; number of days from March 21st until the full moon
      (n (mod (+ 4 k (- q)) 7))         ; century-based offset in weekly calculation
      (b (mod year 4))                  ; correction for leap days
      (c (mod year 7))                  ; also a correction for leap days
      ;; days from d to next Sunday
      (e (mod (+ (* 2 b) (* 4 c) (* 6 d) n) 7)))
    ;; historical corrections for April 26 and 25
    (when (or (and (eql d 29) (eql e 6)) (and (eql d 28) (eql e 6) (&gt; a 10)))
      (setf e -1))
    (values
      ;; determination of the correct month for Easter
      (if (&gt; (+ 22 d e) 31)
          (format nil &quot;April ~a&quot; (+ d e -9))
          (format nil &quot;March ~a&quot; (+ 22 d e)))
      ;; optionally return a value for the Servois' table
      (if servois (mod (+ 21 d) 31)))))

(format t &quot;~{~a~%~}&quot;
  '(&quot;The following are the dates of the Paschal full moon (using Servois&quot;
     &quot;notation) and the date of Easter for 2020-2030 AD:~%&quot;
     &quot;Year    Servois number    Easter&quot;))
(loop for year from 2020 to 2030 do
  (multiple-value-bind (easter servois) (computus year t)
    (format t &quot;~8a~18a~a~%&quot; year servois easter)))
</code></pre>
<pre><code class="language-nim">import strformat

func computus(year: int, servois: bool = false): string =
  let
    # Year's position on the 19 year metonic cycle
    a = year mod 19
    # Century index
    k = year div 100
    # Shift of metonic cycle, add a day offset every 300 years
    p = (13 + 8 * k) div 25
    # Correction for non-observed leap days
    q = k div 4
    # Correction to starting point of calculation each century
    m = (15 - p + k - q) mod 30
    # Number of days from March 21st until the full moon
    d = (19 * a + m) mod 30
  # Returning of user wants value for Servois' table
  if servois:
    return $((21 + d) mod 31)
  let
    # Find the next Sunday
    # Century-based offset in weekly calculation
    n = (4 + k - q) mod 7
    # Correction for leap days
    b = year mod 4
    c = year mod 7
    # Days from d to next Sunday
    temp_e = (2 * b + 4 * c + 6 * d + n) mod 7
    # Historical corrections for April 26 and 25
    e = if (d == 29 and temp_e == 6) or (d == 28 and temp_e == 6 and a &gt; 10):
          -1
        else:
          temp_e
  # Determination of the correct month for Easter
  if (22 + d + e) &gt; 31:
    result = &quot;April {d + e - 9}&quot;.fmt
  else:
    result = &quot;March {22 + d + e}&quot;.fmt

when isMainModule:
  echo &quot;The following are the dates of the Paschal full moon (using Servois &quot;
  echo &quot;notation) and the date of Easter for 2020-2030 AD:&quot;
  echo &quot;Year Servois number Easter&quot;
  for year in 2020..2030:
    echo &quot;{year} {computus(year, true):14} {computus(year, false):6}&quot;.fmt
</code></pre>
<pre><code class="language-scala">object GaussEaster {
  def computus(year : Int, servois: Boolean = false): String = {
    
    // Year's position on the 19 year metonic cycle
    val a = year % 19

    // Century index
    val k = (year / 100).toInt

    // Shift of metonic cycle, add a day offset every 300 years
    val p = ((13 + 8 * k) / 25).toInt

    // Correction for non-observed leap days
    val q = (k / 4).toInt

    // Correction to starting point of calculation each century
    val M = (15 - p + k - q) % 30

    // Number of days from March 21st until the full moon
    val d = (19 * a + M) % 30

    // Returning if user wants value for Servois' table
    if (servois) 
      return s&quot;${(21 + d) % 31}&quot;
    
    // Finding the next Sunday
    // Century-based offset in weekly calculation
    val N = (4 + k - q) % 7

    // Correction for leap days
    val b = year % 4
    val c = year % 7

    // Days from d to next Sunday
    var e = (2 * b + 4 * c + 6 * d + N) % 7

    // Historical corrections for April 26 and 25
    if ((d == 29 &amp;&amp; e == 6) || (d == 28 &amp;&amp; e == 6 &amp;&amp; a &gt; 10)) {
      e = -1
    }

    // Determination of the correct month for Easter
    if (22 + d + e &gt; 31) 
      s&quot;April ${d + e - 9}&quot;
    else                 
      s&quot;March ${22 + d + e}&quot;
  }
  
  def main(args: Array[String]): Unit = {
    println(&quot;The following are the dates of the Paschal full moon (using &quot; + 
            &quot;Servois notation) and the date of Easter for 2020-2030 AD:\n&quot; +
            &quot;Year\tServois number\tEaster\n&quot;)
    
    for( year &lt;- 2020 to 2030){
      println(s&quot;$year \t\t ${computus(year, true)} \t${computus(year)}&quot;) 
    }
  }
}
</code></pre>
<pre><code class="language-dart">String computus(int year, {bool servois = false}) {
  // Year's position in metonic cycle
  final a = year % 19;

  // Century index
  final k = (year / 100).floor();

  // Shift of metonic cycle, add a day offset every 300 years
  final p = ((13 + 8 * k) / 25).floor();

  // Correction for non-observed leap days
  final q = (k / 4).floor();

  // Correction to starting point of calculation each century
  final M = (15 - p + k - q) % 30;

  // Number of days from March 21st until the full moon
  final d = (19 * a + M) % 30;

  // Returning if user wants value for Servois' table
  if (servois) {
    return ((21 + d) % 31).toString();
  }

  // Finding the next Sunday
  // Century-based offset in weekly calculation
  final N = (4 + k - q) % 7;

  // Correction for leap days
  final b = year % 4;
  final c = year % 7;

  // Days from d to next Sunday
  var e = (2 * b + 4 * c + 6 * d + N) % 7;

  // Historical corrections for April 26 and 25
  if (e == 6) {
    if (d == 29 || (d == 28 &amp;&amp; a &gt; 10)) {
      e = -1;
    }
  }

  // Determination of the correct month for Easter
  if (22 + d + e &gt; 31) {
    return 'April ${d + e - 9}';
  } else {
    return 'March ${22 + d + e}';
  }
}

void main() {
  print(&quot;The following are the dates of the Paschal full moon (using Servois &quot; +
      &quot;notation) and the date of Easter for 2020-2030 AD:&quot;);

  print(&quot;Year\tServois number\tEaster&quot;);

  for (var year = 2020; year &lt;= 2030; year++) {
    final servoisNumber = computus(year, servois: true);
    final easterDate = computus(year);

    print('$year\t$servoisNumber\t\t$easterDate');
  }
}
</code></pre>
<pre><code class="language-javascript">/**
 * In this code, the modulus operator is used.
 * However, this operator in javascript/typescript doesn't support negative numbers.
 * So, where there may be negative numbers, the function mod is used.
 * This function gives the modulo of any relative number a
 */

/**
 * @param {number} a
 * @param {number} b
 * @returns {number}
 */
function mod(a, b) {
  if (a &lt; 0) return mod(a + b, b);
  else return a % b;
}

/**
 * @param {number} year
 * @param {boolean} [servois=false]
 * @returns {string}
 */
function computus(year, servois = false) {
  // Year's position in metonic cycle
  const a = year % 19;

  // Century index
  const k = Math.floor(year / 100);

  // Shift of metonic cycle, add a day offset every 300 years
  const p = Math.floor((13 + 8 * k) / 25);

  // Correction for non-observed leap days
  const q = Math.floor(k / 4);

  // Correction to starting point of calculation each century
  const M = mod(15 - p + k - q, 30);

  // Number of days from March 21st until the full moon
  const d = (19 * a + M) % 30;

  // Returning if user wants value for Servois' table
  if (servois) {
    return ((21 + d) % 31).toString();
  }

  // Finding the next Sunday
  // Century-based offset in weekly calculation
  const N = mod(4 + k - q, 7);

  // Correction for leap days
  const b = year % 4;
  const c = year % 7;

  // Days from d to next Sunday
  let e = (2 * b + 4 * c + 6 * d + N) % 7;

  // Historical corrections for April 26 and 25
  if (e === 6) {
    if (d === 29 || (d === 28 &amp;&amp; a &gt; 10)) {
      e = -1;
    }
  }

  // Determination of the correct month for Easter
  if (22 + d + e &gt; 31) {
    return `April ${d + e - 9}`;
  } else {
    return `March ${22 + d + e}`;
  }
}

console.log(
  &quot;The following are the dates of the Paschal full moon (using Servois &quot; +
    &quot;notation) and the date of Easter for 2020-2030 AD:&quot;
);

const values = [];

for (let year = 2020; year &lt;= 2030; year++) {
  const servoisNumber = computus(year, true);
  const easterDate = computus(year);

  // Creation of an object to be displayed as a line in the output table
  values[year] = {
    &quot;servois number&quot;: +servoisNumber,
    easter: easterDate,
  };
}

console.table(values);
</code></pre>
<pre><code class="language-typescript">/**
 * In this code, the modulus operator is used.
 * However, this operator in javascript/typescript doesn't support negative numbers.
 * So, where there may be negative numbers, the function mod is used.
 * This function gives the modulo of any relative number a
 */

function mod(a: number, b: number): number {
  if (a &lt; 0) {
    return mod(a + b, b);
  } else {
    return a % b;
  }
}
function computus(year: number, servois: boolean = false): string {
  // Year's position in metonic cycle
  const a: number = year % 19;

  // Century index
  const k: number = Math.floor(year / 100);

  // Shift of metonic cycle, add a day offset every 300 years
  const p: number = Math.floor((13 + 8 * k) / 25);

  // Correction for non-observed leap days
  const q: number = Math.floor(k / 4);

  // Correction to starting point of calculation each century
  const M: number = mod(15 - p + k - q, 30);

  // Number of days from March 21st until the full moon
  const d: number = (19 * a + M) % 30;

  // Returning if user wants value for Servois' table
  if (servois) {
    return ((21 + d) % 31).toString();
  }

  // Finding the next Sunday
  // Century-based offset in weekly calculation
  const N: number = mod(4 + k - q, 7);

  // Correction for leap days
  const b: number = year % 4;
  const c: number = year % 7;

  // Days from d to next Sunday
  let e: number = (2 * b + 4 * c + 6 * d + N) % 7;

  // Historical corrections for April 26 and 25
  if (e === 6) {
    if (d === 29 || (d === 28 &amp;&amp; a &gt; 10)) {
      e = -1;
    }
  }

  // Determination of the correct month for Easter
  if (22 + d + e &gt; 31) {
    return `April ${d + e - 9}`;
  } else {
    return `March ${22 + d + e}`;
  }
}

console.log(
  &quot;The following are the dates of the Paschal full moon (using Servois &quot; +
    &quot;notation) and the date of Easter for 2020-2030 AD:&quot;
);

// Type of a line in the output table
interface IOutputLine {
  &quot;servois number&quot;: number;
  easter: string;
}

const values: IOutputLine[] = [];

for (let year = 2020; year &lt;= 2030; year++) {
  const servoisNumber: string = computus(year, true);
  const easterDate: string = computus(year);

  // Creation of an object to be displayed as a line in the output table
  const line: IOutputLine = {
    &quot;servois number&quot;: +servoisNumber,
    easter: easterDate,
  };

  values[year] = line;
}

console.table(values);
</code></pre>
<h3 id="bibliography"><a class="header" href="#bibliography">Bibliography</a></h3>
<p>{% references %} {% endreferences %}</p>
<h2 id="license"><a class="header" href="#license">License</a></h2>
<h5 id="code-examples"><a class="header" href="#code-examples">Code Examples</a></h5>
<p>The code examples are licensed under the MIT license (found in <a href="https://github.com/algorithm-archivists/algorithm-archive/blob/master/LICENSE.md">LICENSE.md</a>).</p>
<h5 id="text"><a class="header" href="#text">Text</a></h5>
<p>The text of this chapter was written by <a href="https://github.com/leios">James Schloss</a> and is licensed under the <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</p>
<p><a href="https://creativecommons.org/licenses/by-sa/4.0/"><p><img  class="center" src="../cc/CC-BY-SA_icon.svg" /></p></a></p>
<h5 id="imagesgraphics"><a class="header" href="#imagesgraphics">Images/Graphics</a></h5>
<ul>
<li>The image &quot;<a href="res/servois_1800.png">Servois 1800 Colored Table</a>&quot; was created by <a href="https://github.com/leios">James Schloss</a> and is licensed under the <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</li>
<li>The image &quot;<a href="res/orbit.svg">Relative Orbits</a>&quot; was created by <a href="https://github.com/lockcmpxchg8beax">Xadisten</a> and was provided during a discussion on Twitch. It is licensed under the <a href="https://creativecommons.org/licenses/by/4.0/legalcode">Creative Commons Attribution 4.0 International License</a>.</li>
<li>The image &quot;<a href="res/synodic_half_year.png">Synodic Half Year</a>&quot; was created by <a href="https://github.com/leios">James Schloss</a> and is licensed under the <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</li>
<li>The image &quot;<a href="res/metonic.png">Metonic shadows</a>&quot; was created by <a href="https://github.com/leios">James Schloss</a> and is licensed under the <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</li>
<li>The image &quot;<a href="res/orbit.png">Full Year Orbit</a>&quot; was created by <a href="https://github.com/leios">James Schloss</a> and is licensed under the <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</li>
<li>The image &quot;<a href="res/servois_2000.png">Servois 2000 Colored Table</a>&quot; was created by <a href="https://github.com/leios">James Schloss</a> and is licensed under the <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../quantum_information/quantum_information.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="../approximate_counting/approximate_counting.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../quantum_information/quantum_information.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="../approximate_counting/approximate_counting.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script type="text/javascript">
            var socket = new WebSocket("ws://0.0.0.0:3000/__livereload");
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->


    </body>
</html>
