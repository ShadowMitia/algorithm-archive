<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Verlet Integration - Arcane Algorithm Archive</title>


        <!-- Custom HTML head -->

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../index.html"><strong aria-hidden="true">1.</strong> Algorithm Archive</a></li><li class="chapter-item expanded "><a href="../introduction/introduction.html"><strong aria-hidden="true">2.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="../how_to_contribute/how_to_contribute.html"><strong aria-hidden="true">3.</strong> How To Contribute</a></li><li class="chapter-item expanded "><a href="../plotting/plotting.html"><strong aria-hidden="true">4.</strong> Plotting</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../domain_coloring/domain_coloring.html"><strong aria-hidden="true">4.1.</strong> Domain Coloring</a></li><li class="chapter-item expanded "><a href="../IFS/IFS.html"><strong aria-hidden="true">4.2.</strong> Iterated Function Systems</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../barnsley/barnsley.html"><strong aria-hidden="true">4.2.1.</strong> The Barnsley Fern</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="../data_structures/data_structures.html"><strong aria-hidden="true">5.</strong> Data Structures</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../stacks_and_queues/stacks_and_queues.html"><strong aria-hidden="true">5.1.</strong> Stacks and Queues</a></li></ol></li><li class="chapter-item expanded "><a href="../mathematical_background/mathematical_background.html"><strong aria-hidden="true">6.</strong> Mathematical Background</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../notation/notation.html"><strong aria-hidden="true">6.1.</strong> Complexity Notation</a></li><li class="chapter-item expanded "><a href="../affine_transformations/affine_transformations.html"><strong aria-hidden="true">6.2.</strong> Affine Transformations</a></li><li class="chapter-item expanded "><a href="../bitlogic/bitlogic.html"><strong aria-hidden="true">6.3.</strong> Bit Logic</a></li><li class="chapter-item expanded "><a href="../taylor_series_expansion/taylor_series_expansion.html"><strong aria-hidden="true">6.4.</strong> Taylor Series</a></li><li class="chapter-item expanded "><a href="../convolutions/convolutions.html"><strong aria-hidden="true">6.5.</strong> Convolutions</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../convolutions/1d/1d.html"><strong aria-hidden="true">6.5.1.</strong> Convolutions in 1D</a></li><li class="chapter-item expanded "><a href="../convolutions/multiplication/multiplication.html"><strong aria-hidden="true">6.5.2.</strong> Multiplication as a Convolution</a></li><li class="chapter-item expanded "><a href="../convolutions/2d/2d.html"><strong aria-hidden="true">6.5.3.</strong> Convolutions of Images (2D)</a></li><li class="chapter-item expanded "><a href="../convolutions/convolutional_theorem/convolutional_theorem.html"><strong aria-hidden="true">6.5.4.</strong> Convolutional Theorem</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="../tree_traversal/tree_traversal.html"><strong aria-hidden="true">7.</strong> Tree Traversal</a></li><li class="chapter-item expanded "><a href="../euclidean_algorithm/euclidean_algorithm.html"><strong aria-hidden="true">8.</strong> Euclidean Algorithm</a></li><li class="chapter-item expanded "><a href="../monte_carlo_integration/monte_carlo_integration.html"><strong aria-hidden="true">9.</strong> Monte Carlo</a></li><li class="chapter-item expanded "><a href="../matrix_methods/matrix_methods.html"><strong aria-hidden="true">10.</strong> Matrix Methods</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../gaussian_elimination/gaussian_elimination.html"><strong aria-hidden="true">10.1.</strong> Gaussian Elimination</a></li><li class="chapter-item expanded "><a href="../thomas_algorithm/thomas_algorithm.html"><strong aria-hidden="true">10.2.</strong> Thomas Algorithm</a></li></ol></li><li class="chapter-item expanded "><a href="../computational_geometry/computational_geometry.html"><strong aria-hidden="true">11.</strong> Computational Geometry</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../gift_wrapping/gift_wrapping.html"><strong aria-hidden="true">11.1.</strong> Gift Wrapping</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../jarvis_march/jarvis_march.html"><strong aria-hidden="true">11.1.1.</strong> Jarvis March</a></li><li class="chapter-item expanded "><a href="../graham_scan/graham_scan.html"><strong aria-hidden="true">11.1.2.</strong> Graham Scan</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="../cooley_tukey/cooley_tukey.html"><strong aria-hidden="true">12.</strong> FFT</a></li><li class="chapter-item expanded "><a href="../decision_problems/decision_problems.html"><strong aria-hidden="true">13.</strong> Decision Problems</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../stable_marriage_problem/stable_marriage_problem.html"><strong aria-hidden="true">13.1.</strong> Stable Marriage Problem</a></li></ol></li><li class="chapter-item expanded "><a href="../physics_solvers/physics_solvers.html"><strong aria-hidden="true">14.</strong> Physics Solvers</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../verlet_integration/verlet_integration.html" class="active"><strong aria-hidden="true">14.1.</strong> Verlet Integration</a></li><li class="chapter-item expanded "><a href="../quantum_systems/quantum_systems.html"><strong aria-hidden="true">14.2.</strong> Quantum Systems</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../split-operator_method/split-operator_method.html"><strong aria-hidden="true">14.2.1.</strong> Split-Operator Method</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="../data_compression/data_compression.html"><strong aria-hidden="true">15.</strong> Data Compression</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../huffman_encoding/huffman_encoding.html"><strong aria-hidden="true">15.1.</strong> Huffman Encoding</a></li></ol></li><li class="chapter-item expanded "><a href="../computer_graphics/computer_graphics.html"><strong aria-hidden="true">16.</strong> Computer Graphics</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../flood_fill/flood_fill.html"><strong aria-hidden="true">16.1.</strong> Flood Fill</a></li></ol></li><li class="chapter-item expanded "><a href="../quantum_information/quantum_information.html"><strong aria-hidden="true">17.</strong> Quantum Information</a></li><li class="chapter-item expanded "><a href="../computus/computus.html"><strong aria-hidden="true">18.</strong> Computus</a></li><li class="chapter-item expanded "><a href="../approximate_counting/approximate_counting.html"><strong aria-hidden="true">19.</strong> Approximate Counting Algorithm</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Arcane Algorithm Archive</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/algorithm-archivists/algorithm-archive/" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="verlet-integration"><a class="header" href="#verlet-integration">Verlet Integration</a></h1>
<p>Verlet integration is essentially a solution to the kinematic equation for the motion of any object,</p>
<p>\[ x = x_0 + v_0t + \frac{1}{2}at^2 + \frac{1}{6}bt^3 + \cdots \]</p>
<p>where \( x \) is the position, \( v \) is the velocity, \( a \) is the acceleration, \( b \) is the often forgotten jerk term, and \( t \) is time. This equation is a central equation to almost every Newtonian physics solver and brings up a class of algorithms known as <em>force integrators</em>. One of the first force integrators to work with is <em>Verlet Integration</em>.</p>
<p>So, let's say we want to solve for the next timestep in \( x \). To a close approximation (actually performing a Taylor Series Expansion about \( x(t\pm \Delta t) \)), that might look like this:</p>
<p>\[ x(t+\Delta t) = x(t) + v(t)\Delta t + \frac{1}{2}a(t)\Delta t^2 + \frac{1}{6}b(t) \Delta t^3 + \mathcal{O}(\Delta t^4) \]</p>
<p>This means that if we need to find the next \( x \), we need the current \( x \), \( v \), \( a \), etc. However, because few people calculate the jerk term, our error is typically \( \mathcal{O}(\Delta t^3) \). That said, we can calculate \( x \) with less knowledge and higher accuracy if we play a trick! Let's say we want to calculate \( x \) of the <em>previous</em> timestep. Again, to a close approximation, that might look like this:</p>
<p>\[ x(t-\Delta t) = x(t) - v(t)\Delta t + \frac{1}{2}a(t)\Delta t^2 - \frac{1}{6}b(t) \Delta t^3 + \mathcal{O}(\Delta t^4) \]</p>
<p>Now, we have two equations to solve for two different timesteps in x, one of which we already have. If we add the two equations together and solve for \( x(t+\Delta t) \), we find that</p>
<p>\[ x(t+ \Delta t) = 2x(t) - x(t-\Delta t) + a(t)\Delta t^2 + \mathcal{O}(\Delta t^4) \]</p>
<p>So, this means we can find our next \( x \) simply by knowing our current \( x \), the \( x \) before that, and the acceleration! No velocity necessary! In addition, this drops the error to \( \mathcal{O}(\Delta t^4) \), which is great!
Here is what it looks like in code:</p>
<pre><code class="language-julia">function verlet(pos::Float64, acc::Float64, dt::Float64)
    prev_pos = pos
    time = 0.0

    while (pos &gt; 0)
        time += dt
        temp_pos = pos
        pos = pos * 2 - prev_pos + acc * dt * dt
        prev_pos = temp_pos
    end

    return time
end
</code></pre>
<pre><code class="language-cpp">double verlet(double pos, double acc, double dt) {

  double prev_pos = pos;
  double time = 0;

  while (pos &gt; 0) {
    time += dt;
    double next_pos = pos * 2 - prev_pos + acc * dt * dt;
    prev_pos = pos;
    pos = next_pos;
  }

  return time;
}
</code></pre>
<pre><code class="language-c">void verlet(double *time, double pos, double acc, double dt) {
    double prev_pos, temp_pos;
    prev_pos = pos;
    *time = 0.0;

    while (pos &gt; 0) {
        *time += dt;
        temp_pos = pos;
        pos = pos * 2 - prev_pos + acc * dt * dt;
        prev_pos = temp_pos;
    }
}
</code></pre>
<pre><code class="language-java">    static double verlet(double pos, double acc, double dt) {

      // Note that we are using a temp variable for the previous position
      double prev_pos, temp_pos, time;
      prev_pos = pos;
      time = 0;

      while (pos &gt; 0) {
            time += dt;
            temp_pos = pos;
            pos = pos*2 - prev_pos + acc * dt * dt;
            prev_pos = temp_pos;
        }

        return time;
    }
</code></pre>
<pre><code class="language-python">def verlet(pos, acc, dt):
    prev_pos = pos
    time = 0

    while pos &gt; 0:
        time += dt
        next_pos = pos * 2 - prev_pos + acc * dt * dt
        prev_pos, pos = pos, next_pos

    return time
</code></pre>
<pre><code class="language-haskell">type Method = Model -&gt; Time -&gt; Particle -&gt; Particle -&gt; Particle

verlet :: Method
verlet acc dt (xOld, _, _, _) (x, _, a, t) = (x', v', a', t + dt)
  where
    x' = 2 * x - xOld + a * dt ^ 2
    v' = 0
    a' = acc (x', v', a, t + dt)
</code></pre>
<pre><code class="language-javascript">function verlet(pos, acc, dt) {
  let prevPos = pos;
  let time = 0;
  let tempPos;

  while (pos &gt; 0) {
    time += dt;
    tempPos = pos;
    pos = pos * 2 - prevPos + acc * dt * dt;
    prevPos = tempPos;
  }

  return time;
}
</code></pre>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn verlet(mut pos: f64, acc: f64, dt: f64) -&gt; f64 {
    let mut prev_pos = pos;
    let mut time = 0.0;

    while pos &gt; 0.0 {
        time += dt;
        let temp_pos = pos;
        pos = pos * 2.0 - prev_pos + acc * dt * dt;
        prev_pos = temp_pos;
    }

    time
}
<span class="boring">}
</span></code></pre></pre>
<pre><code class="language-swift">func verlet(pos: Double, acc: Double, dt: Double) -&gt; Double {
    var pos = pos
    var temp_pos, time: Double
    var prev_pos = pos
    time = 0.0
    
    while (pos &gt; 0) {
        time += dt
        temp_pos = pos
        pos = pos*2 - prev_pos + acc * dt * dt
        prev_pos = temp_pos
    }
    
    return time
}
</code></pre>
<pre><code class="language-fortran">SUBROUTINE verlet(pos, acc, dt, time) 
    IMPLICIT NONE
    REAL(8), INTENT(INOUT) :: pos, acc, dt, time
    REAL(8)                :: prev_pos, next_pos


    prev_pos = pos
    time     = 0d0

    DO
        IF (pos &gt; 0d0) THEN
            time     = time + dt
            next_pos = pos * 2d0 - prev_pos + acc * dt ** 2
            prev_pos = pos
            pos      = next_pos
        ELSE
            EXIT
        END IF
    END DO
END SUBROUTINE verlet
</code></pre>
<p>{% sample lang=&quot;ruby&quot; %}
<a href="code/ruby/verlet.rb">import:1-14, lang=&quot;ruby&quot;</a></p>
<pre><code class="language-go">func verlet(pos, acc, dt float64) (time float64) {
	prevPos := pos
	time = 0

	for pos &gt; 0 {
		time += dt
		nextPos := pos*2 - prevPos + acc*dt*dt
		prevPos, pos = pos, nextPos
	}

	return
}
</code></pre>
<pre><code class="language-asm-x64"># xmm0 - pos
# xmm1 - acc
# xmm2 - dt
# RET xmm0 - time
verlet:
  pxor   xmm7, xmm7                  # Holds 0 for comparisons
  pxor   xmm3, xmm3                  # Holds time value
  comisd xmm0, xmm7                  # Check if pos is greater then 0.0
  jbe    verlet_return
  movsd  xmm6, xmm1                  # xmm6 = acc * dt * dt
  mulsd  xmm6, xmm2
  mulsd  xmm6, xmm2
  movsd  xmm5, xmm0                  # Holds previous position
verlet_loop:
  addsd  xmm3, xmm2                  # Adding dt to time
  movsd  xmm4, xmm0                  # Hold old value of posistion
  addsd  xmm0, xmm0                  # Calculating new position
  subsd  xmm0, xmm5
  addsd  xmm0, xmm6
  movsd  xmm5, xmm4
  comisd xmm0, xmm7                  # Check if position is greater then 0.0
  ja     verlet_loop
verlet_return:
  movsd  xmm0, xmm3                  # Saving time value
  ret
</code></pre>
<pre><code class="language-kotlin">fun verlet(_pos: Double, acc: Double, dt: Double): Double {
    var pos = _pos  // Since function parameter are val and can't be modified
    var prevPos = pos
    var time = 0.0

    while (pos &gt; 0) {
        time += dt
        val nextPos = pos * 2 - prevPos + acc * dt * dt
        prevPos = pos
        pos = nextPos
    }
    return time
}
</code></pre>
<pre><code class="language-nim">func verlet(pos_in, acc, dt: float): float =
  var
    pos: float = pos_in
    prevPos: float = pos
    time: float = 0.0
    tempPos: float

  while pos &gt; 0.0:
    time += dt
    tempPos = pos
    pos = pos * 2 - prevPos + acc * dt * dt
    prevPos = tempPos

  time
</code></pre>
<pre><code class="language-lisp">(defun verlet (pos acc dt)
  &quot;Integrates Newton's equation for motion while pos &gt; 0 using Verlet integration.&quot;
  (loop
    with prev-pos = pos
    for time = 0 then (incf time dt)
    while (&gt; pos 0)
    ;; The starting speed is assumed to be zero.
    do (psetf
         pos (+ (* pos 2) (- prev-pos) (* acc dt dt))
         prev-pos pos)
    finally (return time)))
</code></pre>
<p>Now, obviously this poses a problem; what if we want to calculate a term that requires velocity, like the kinetic energy, \( \frac{1}{2}mv^2 \)? In this case, we certainly cannot get rid of the velocity! Well, we can find the velocity to \( \mathcal{O}(\Delta t^2) \) accuracy by using the Stormer-Verlet method, which is the same as before, but we calculate velocity like so</p>
<p>\[ v(t) = \frac{x(t+\Delta t) - x(t-\Delta t)}{2\Delta t} + \mathcal{O}(\Delta t^2) \]</p>
<p>Note that the 2 in the denominator appears because we are going over 2 timesteps. It's essentially solving \( v=\frac{\Delta x}{\Delta t} \). In addition, we can calculate the velocity of the next timestep like so</p>
<p>\[ v(t+\Delta t) = \frac{x(t+\Delta t) - x(t)}{\Delta t} + \mathcal{O}(\Delta t) \]</p>
<p>However, the error for this is \( \mathcal{O}(\Delta t) \), which is quite poor, but it gets the job done in a pinch.  Here's what it looks like in code:</p>
<pre><code class="language-julia">function stormer_verlet(pos::Float64, acc::Float64, dt::Float64)
    prev_pos = pos
    time = 0.0
    vel = 0.0

    while (pos &gt; 0.0)
        time += dt
        temp_pos = pos
        pos = pos * 2 - prev_pos + acc * dt * dt
        prev_pos = temp_pos

        # Because acceleration is constant, velocity is straightforward
        vel += acc * dt
    end

    return time, vel
end
</code></pre>
<pre><code class="language-cpp">timestep stormer_verlet(double pos, double acc, double dt) {

  double prev_pos = pos;
  double time = 0;
  double vel = 0;
  while (pos &gt; 0) {
    time += dt;
    double next_pos = pos * 2 - prev_pos + acc * dt * dt;
    prev_pos = pos;
    pos = next_pos;

    // The acceleration is constant, so the velocity is
    // straightforward
    vel += acc * dt;
  }

  return timestep { time, vel };
}
</code></pre>
<pre><code class="language-c">void stormer_verlet(double *time, double *vel,
                    double pos, double acc, double dt) {
    double prev_pos, temp_pos;
    prev_pos = pos;
    *vel = 0.0;
    *time = 0.0;

    while (pos &gt; 0) {
        *time += dt;
        temp_pos = pos;
        pos = pos * 2 - prev_pos + acc * dt * dt;
        prev_pos = temp_pos;

        *vel += acc * dt;
    }
}
</code></pre>
<pre><code class="language-java">    static VerletValues stormer_verlet(double pos, double acc, double dt) {

        // Note that we are using a temp variable for the previous position
        double prev_pos, temp_pos, time, vel;
        prev_pos = pos;
        vel = 0;
        time = 0;
        while (pos &gt; 0) {
            time += dt;
            temp_pos = pos;
            pos = pos*2 - prev_pos + acc * dt * dt;
            prev_pos = temp_pos;

            // The acceleration is constant, so the velocity is straightforward
             vel += acc*dt;
        }
      
       return new VerletValues(time, vel);
    }
</code></pre>
<pre><code class="language-python">def stormer_verlet(pos, acc, dt):
    prev_pos = pos
    time = 0
    vel = 0

    while pos &gt; 0:
        time += dt
        next_pos = pos * 2 - prev_pos + acc * dt * dt
        prev_pos, pos = pos, next_pos
        vel += acc * dt

    return time, vel
</code></pre>
<pre><code class="language-haskell">stormerVerlet :: Method
stormerVerlet acc dt (xOld, _, _, _) (x, _, a, t) = (x', v', a', t + dt)
  where
    x' = 2 * x - xOld + a * dt ^ 2
    v' = (x' - x) / dt
    a' = acc (x', v', a, t + dt)
</code></pre>
<pre><code class="language-javascript">function stormerVerlet(pos, acc, dt) {
  let prevPos = pos;
  let time = 0;
  let vel = 0;
  let tempPos;

  while (pos &gt; 0) {
    time += dt;
    tempPos = pos;
    pos = pos * 2 - prevPos + acc * dt * dt;
    prevPos = tempPos;

    vel += acc * dt;
  }

  return { time, vel };
}
</code></pre>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn stormer_verlet(mut pos: f64, acc: f64, dt: f64) -&gt; (f64, f64) {
    let mut prev_pos = pos;
    let mut time = 0.0;
    let mut vel = 0.0;

    while pos &gt; 0.0 {
        time += dt;
        let temp_pos = pos;
        pos = pos * 2.0 - prev_pos + acc * dt * dt;
        prev_pos = temp_pos;

        // Because acceleration is constant, velocity is
        // straightforward
        vel += acc * dt;
    }

    (time, vel)
}
<span class="boring">}
</span></code></pre></pre>
<pre><code class="language-swift">func stormerVerlet(pos: Double, acc: Double, dt: Double) -&gt; (time: Double, vel: Double) {
    var pos = pos
    var temp_pos, time, vel: Double
    var prev_pos = pos
    vel = 0
    time = 0
    
    while (pos &gt; 0) {
        time += dt
        temp_pos = pos
        pos = pos*2 - prev_pos + acc * dt * dt
        prev_pos = temp_pos
        
        vel += acc*dt
    }
    
    return (time:time, vel:vel)
}
</code></pre>
<pre><code class="language-fortran">SUBROUTINE stormer_verlet(pos, acc, dt, time, vel) 
    IMPLICIT NONE
    REAL(8), INTENT(INOUT) :: pos, acc, dt, time, vel
    REAL(8)                :: prev_pos, next_pos

    prev_pos = pos 
    time     = 0d0
    vel      = 0d0

    DO
        IF (pos &gt; 0d0) THEN
            time     = time + dt
            next_pos = pos * 2 - prev_pos + acc * dt ** 2
            prev_pos = pos
            pos      = next_pos
            vel      = vel + acc * dt
        ELSE
            EXIT
        END IF
    END DO
END SUBROUTINE stormer_verlet 
</code></pre>
<p>{% sample lang=&quot;ruby&quot; %}
<a href="code/ruby/verlet.rb">import:16-32, lang=&quot;ruby&quot;</a></p>
<pre><code class="language-go">func stormerVerlet(pos, acc, dt float64) (time, vel float64) {
	prevPos := pos
	time, vel = 0, 0

	for pos &gt; 0 {
		time += dt
		vel += acc * dt
		nextPos := pos*2 - prevPos + acc*dt*dt
		prevPos, pos = pos, nextPos
	}

	return
}
</code></pre>
<pre><code class="language-asm-x64"># xmm0 - pos
# xmm1 - acc
# xmm2 - dt
# RET xmm0 - time
# RET xmm1 - velocity
stormer_verlet:
  pxor   xmm7, xmm7                  # Holds 0 for comparisons
  pxor   xmm3, xmm3                  # Holds time value
  comisd xmm0, xmm7                  # Check if pos is greater then 0.0
  jbe    stormer_verlet_return
  movsd  xmm6, xmm1                  # xmm6 = acc * dt * dt
  mulsd  xmm6, xmm2
  mulsd  xmm6, xmm2
  movsd  xmm5, xmm0                  # Holds previous position
stormer_verlet_loop:
  addsd  xmm3, xmm2                  # Adding dt to time
  movsd  xmm4, xmm0                  # Hold old value of posistion
  addsd  xmm0, xmm0                  # Calculating new position
  subsd  xmm0, xmm5
  addsd  xmm0, xmm6
  movsd  xmm5, xmm4
  comisd xmm0, xmm7                  # Check if position is greater then 0.0
  ja     stormer_verlet_loop
stormer_verlet_return:
  movsd  xmm0, xmm3                  # Saving time and velocity
  mulsd  xmm3, xmm1
  movsd  xmm1, xmm3
  ret
</code></pre>
<pre><code class="language-kotlin">fun stormerVerlet(_pos: Double, acc: Double, dt: Double): VerletValues {
    var pos = _pos
    var prevPos = pos
    var time = 0.0
    var vel = 0.0
    while (pos &gt; 0) {
        time += dt
        val nextPos = pos * 2 - prevPos + acc * dt * dt
        prevPos = pos
        pos = nextPos
        vel += acc * dt
    }
    return VerletValues(time, vel)
}
</code></pre>
<pre><code class="language-nim">func stormerVerlet(pos_in, acc, dt: float): (float, float) =
  var
    pos: float = pos_in
    prevPos: float = pos
    time: float = 0.0
    vel: float = 0.0
    tempPos: float

  while pos &gt; 0.0:
    time += dt
    tempPos = pos
    pos = pos * 2 - prevPos + acc * dt * dt
    prevPos = tempPos

    vel += acc * dt

  (time, vel)
</code></pre>
<pre><code class="language-lisp">(defun stormer-verlet (pos acc dt)
  &quot;Integrates Newton's equation for motion while pos &gt; 0 using the Stormer-Verlet method.&quot;
  (loop
    with prev-pos = pos
    for time = 0 then (incf time dt)
    for vel = 0 then (incf vel (* acc dt))
    while (&gt; pos 0)
    ;; Variables are changed simultaneously by 'psetf', so there's no need for a temporary variable.
    do (psetf
         pos (+ (* pos 2) (- prev-pos) (* acc dt dt))
         prev-pos pos)
    finally (return (list time vel))))
</code></pre>
<p>Now, let's say we actually need the velocity to calculate out next timestep. Well, in this case, we simply cannot use the above approximation and instead need to use the <em>Velocity Verlet</em> algorithm.</p>
<h1 id="velocity-verlet"><a class="header" href="#velocity-verlet">Velocity Verlet</a></h1>
<p>In some ways, this algorithm is even simpler than above. We can calculate everything like</p>
<p>\[
\begin{align}
x(t+\Delta t) &amp;=x(t) + v(t)\Delta t + \frac{1}{2}a(t)\Delta t^2 \\
a(t+\Delta t) &amp;= f(x(t+\Delta t)) \\
v(t+\Delta t) &amp;= v(t) + \frac{1}{2}(a(t) + a(t+\Delta t))\Delta t
\end{align}
\]</p>
<p>which is literally the kinematic equation above, solving for \( x \), \( v \), and \( a \) every timestep. You can also split up the equations like so</p>
<p>\[
\begin{align}
v(t+\frac{1}{2}\Delta t) &amp;= v(t) + \frac{1}{2}a(t)\Delta t \\
x(t+\Delta t) &amp;=x(t) + v(t+\frac{1}{2}\Delta t)\Delta t \\
a(t+\Delta t) &amp;= f(x(t+\Delta t)) \\
v(t+\Delta t) &amp;= v(t+\frac{1}{2}\Delta t) + \frac{1}{2}a(t+\Delta t)\Delta t
\end{align}
\]</p>
<p>Here is the velocity Verlet method in code:</p>
<pre><code class="language-julia">function velocity_verlet(pos::Float64, acc::Float64, dt::Float64)
    prev_pos = pos
    time = 0.0
    vel = 0.0

    while (pos &gt; 0.0)
        time += dt
        pos += vel * dt + 0.5 * acc * dt * dt;
        vel += acc * dt;
    end

    return time, vel
end
</code></pre>
<pre><code class="language-cpp">timestep velocity_verlet(double pos, double acc, double dt) {

  double time = 0;
  double vel = 0;
  while (pos &gt; 0) {
    time += dt;
    pos += vel * dt + 0.5 * acc * dt * dt;
    vel += acc * dt;
  }

  return timestep { time, vel };
}
</code></pre>
<pre><code class="language-c">void velocity_verlet(double *time, double *vel,
                     double pos, double acc, double dt) {
    *vel = 0.0;
    *time = 0.0;

    while (pos &gt; 0) {
        *time += dt;
        pos += (*vel) * dt + 0.5 * acc * dt * dt;
        *vel += acc * dt;
    }
}
</code></pre>
<pre><code class="language-java">    static VerletValues velocity_verlet(double pos, double acc, double dt) {

        // Note that we are using a temp variable for the previous position
        double time, vel;
        vel = 0;
        time = 0;
        while (pos &gt; 0) {
            time += dt;
            pos += vel*dt + 0.5*acc * dt * dt;
            vel += acc*dt;
        }
        return new VerletValues(time, vel);
    }
</code></pre>
<pre><code class="language-python">def velocity_verlet(pos, acc, dt):
    time = 0
    vel = 0

    while pos &gt; 0:
        time += dt
        pos += vel * dt + 0.5 * acc * dt * dt
        vel += acc * dt

    return time, vel
</code></pre>
<pre><code class="language-haskell">velocityVerlet :: Method
velocityVerlet acc dt (xOld, _, aOld, _) (x, v, a, t) = (x', v', a', t + dt)
  where
    x' = 2 * x - xOld + a * dt ^ 2
    v' = v + 0.5 * (aOld + a) * dt
    a' = acc (x', v', a, t + dt)
</code></pre>
<pre><code class="language-javascript">function velocityVerlet(pos, acc, dt) {
  let time = 0;
  let vel = 0;

  while (pos &gt; 0) {
    time += dt;
    pos += vel * dt + 0.5 * acc * dt * dt;
    vel += acc * dt;
  }

  return { time, vel };
}
</code></pre>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn velocity_verlet(mut pos: f64, acc: f64, dt: f64) -&gt; (f64, f64) {
    let mut time = 0.0;
    let mut vel = 0.0;

    while pos &gt; 0.0 {
        time += dt;
        pos += vel * dt + 0.5 * acc * dt * dt;
        vel += acc * dt;
    }

    (time, vel)
}
<span class="boring">}
</span></code></pre></pre>
<pre><code class="language-swift">func velocityVerlet(pos: Double, acc: Double, dt: Double) -&gt; (time: Double, vel: Double) {
    var pos = pos
    var time, vel : Double
    vel = 0
    time = 0
    
    while (pos &gt; 0) {
        time += dt
        pos += vel*dt + 0.5*acc * dt * dt
        vel += acc*dt
    }
    
    return (time:time, vel:vel)
}
</code></pre>
<pre><code class="language-fortran">SUBROUTINE velocity_verlet(pos, acc, dt, time, vel) 
    IMPLICIT NONE
    REAL(8), INTENT(INOUT) :: pos, acc, dt, time, vel

    time     = 0d0
    vel      = 0d0

    DO
        IF (pos &gt; 0d0) THEN
            time = time + dt
            pos  = pos + vel * dt + 0.5d0 * acc * dt ** 2 
            vel  = vel + acc * dt
        ELSE
            EXIT
        END IF
    END DO
END SUBROUTINE velocity_verlet 
</code></pre>
<p>{% sample lang=&quot;ruby&quot; %}
<a href="code/ruby/verlet.rb">import:34-46, lang=&quot;ruby&quot;</a></p>
<pre><code class="language-go">func velocityVerlet(pos, acc, dt float64) (time, vel float64) {
	time, vel = 0, 0

	for pos &gt; 0 {
		time += dt
		pos += vel*dt + .5*acc*dt*dt
		vel += acc * dt
	}

	return
}
</code></pre>
<pre><code class="language-asm-x64"># xmm0 - pos
# xmm1 - acc
# xmm2 - dt
# RET xmm0 - time
# RET xmm1 - velocity
velocity_verlet:
  pxor   xmm7, xmm7                  # Holds 0 for comparisons
  pxor   xmm3, xmm3                  # Holds the velocity value
  pxor   xmm4, xmm4                  # Holds the time value
  comisd xmm0, xmm7                  # Check if pos is greater then 0.0
  jbe    velocity_verlet_return
  movsd  xmm5, half                  # xmm5 = 0.5 * dt * dt * acc
  mulsd  xmm5, xmm2
  mulsd  xmm5, xmm2
  mulsd  xmm5, xmm1
velocity_verlet_loop:
  movsd  xmm6, xmm3                  # Move velocity into register
  mulsd  xmm6, xmm2                  # Calculate new position
  addsd  xmm6, xmm5
  addsd  xmm0, xmm6
  addsd  xmm4, xmm2                  # Incrementing time
  movsd  xmm3, xmm4                  # Updating velocity
  mulsd  xmm3, xmm1
  comisd xmm0, xmm7
  ja     velocity_verlet_loop
velocity_verlet_return:
  movsd  xmm0, xmm4                  # Saving time and velocity
  movsd  xmm1, xmm3
  ret
</code></pre>
<pre><code class="language-kotlin">fun velocityVerlet(_pos: Double, acc: Double, dt: Double): VerletValues {
    var pos = _pos
    var time = 0.0
    var vel = 0.0
    while (pos &gt; 0) {
        time += dt
        pos += vel * dt + 0.5 * acc * dt * dt
        vel += acc * dt
    }
    return VerletValues(time, vel)
}
</code></pre>
<pre><code class="language-nim">func velocityVerlet(pos_in, acc, dt: float): (float, float) =
  var
    pos: float = pos_in
    time: float = 0.0
    vel: float = 0.0

  while pos &gt; 0.0:
    time += dt
    pos += vel * dt + 0.5 * acc * dt * dt
    vel += acc * dt

  (time, vel)
</code></pre>
<pre><code class="language-lisp">(defun velocity-verlet (pos acc dt)
  &quot;Integrates Newton's equation for motion while pos &gt; 0 using the velocity in calculations.&quot;
  (loop
    for time = 0 then (incf time dt)
    for vel = 0 then (incf vel (* acc dt))
    for p = pos then (incf p (+ (* vel dt) (* 0.5 acc dt dt)))
    while (&gt; p 0)
    finally (return (list time vel))))
</code></pre>
<p>Even though this method is more widely used than the simple Verlet method mentioned above, it unforunately has an error term of \( \mathcal{O}(\Delta t^2) \), which is two orders of magnitude worse. That said, if you want to have a simulaton with many objects that depend on one another --- like a gravity simulation --- the Velocity Verlet algorithm is a handy choice; however, you may have to play further tricks to allow everything to scale appropriately. These types of simulatons are sometimes called <em>n-body</em> simulations and one such trick is the Barnes-Hut algorithm, which cuts the complexity of n-body simulations from \( \sim \mathcal{O}(n^2) \) to \( \sim \mathcal{O}(n\log(n)) \).</p>
<h2 id="video-explanation"><a class="header" href="#video-explanation">Video Explanation</a></h2>
<p>Here is a video describing Verlet integration:</p>
<div style="text-align:center">
<iframe width="560" height="315" src="https://www.youtube.com/embed/g55QvpAev0I" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
</div>
<h2 id="example-code"><a class="header" href="#example-code">Example Code</a></h2>
<p>Both of these methods work simply by iterating timestep-by-timestep and can be written straightforwardly in any language. For reference, here are snippets of code that use both the classic and velocity Verlet methods to find the time it takes for a ball to hit the ground after being dropped from a given height.</p>
<pre><code class="language-julia">function verlet(pos::Float64, acc::Float64, dt::Float64)
    prev_pos = pos
    time = 0.0

    while (pos &gt; 0)
        time += dt
        temp_pos = pos
        pos = pos * 2 - prev_pos + acc * dt * dt
        prev_pos = temp_pos
    end

    return time
end

function stormer_verlet(pos::Float64, acc::Float64, dt::Float64)
    prev_pos = pos
    time = 0.0
    vel = 0.0

    while (pos &gt; 0.0)
        time += dt
        temp_pos = pos
        pos = pos * 2 - prev_pos + acc * dt * dt
        prev_pos = temp_pos

        # Because acceleration is constant, velocity is straightforward
        vel += acc * dt
    end

    return time, vel
end

function velocity_verlet(pos::Float64, acc::Float64, dt::Float64)
    prev_pos = pos
    time = 0.0
    vel = 0.0

    while (pos &gt; 0.0)
        time += dt
        pos += vel * dt + 0.5 * acc * dt * dt;
        vel += acc * dt;
    end

    return time, vel
end

function main()
    time = verlet(5.0, -10.0, 0.01);
    println(&quot;[#]\nTime for Verlet integration is:&quot;)
    println(&quot;$(time)&quot;)

    time, vel = stormer_verlet(5.0, -10.0, 0.01);
    println(&quot;[#]\nTime for Stormer Verlet integration is:&quot;)
    println(&quot;$(time)&quot;)
    println(&quot;[#]\nVelocity for Stormer Verlet integration is:&quot;)
    println(&quot;$(vel)&quot;)
    
    time, vel = velocity_verlet(5.0, -10.0, 0.01);
    println(&quot;[#]\nTime for velocity Verlet integration is:&quot;)
    println(&quot;$(time)&quot;)
    println(&quot;[#]\nVelocity for velocity Verlet integration is:&quot;)
    println(&quot;$(vel)&quot;)

end

main()
</code></pre>
<pre><code class="language-cpp">#include &lt;iomanip&gt;
#include &lt;iostream&gt;

struct timestep {
  double time;
  double vel;
};

double verlet(double pos, double acc, double dt) {

  double prev_pos = pos;
  double time = 0;

  while (pos &gt; 0) {
    time += dt;
    double next_pos = pos * 2 - prev_pos + acc * dt * dt;
    prev_pos = pos;
    pos = next_pos;
  }

  return time;
}

timestep stormer_verlet(double pos, double acc, double dt) {

  double prev_pos = pos;
  double time = 0;
  double vel = 0;
  while (pos &gt; 0) {
    time += dt;
    double next_pos = pos * 2 - prev_pos + acc * dt * dt;
    prev_pos = pos;
    pos = next_pos;

    // The acceleration is constant, so the velocity is
    // straightforward
    vel += acc * dt;
  }

  return timestep { time, vel };
}

timestep velocity_verlet(double pos, double acc, double dt) {

  double time = 0;
  double vel = 0;
  while (pos &gt; 0) {
    time += dt;
    pos += vel * dt + 0.5 * acc * dt * dt;
    vel += acc * dt;
  }

  return timestep { time, vel };
}

int main() {
  std::cout &lt;&lt; std::fixed &lt;&lt; std::setprecision(8);

  // Note that depending on the simulation, you might want to have the
  // Verlet loop outside.

  // For example, if your acceleration chages as a function of time,
  // you might need to also change the acceleration to be read into
  // each of these functions.

  double time = verlet(5.0, -10, 0.01);
  std::cout &lt;&lt; &quot;[#]\nTime for Verlet integration is:\n&quot; \
            &lt;&lt; time &lt;&lt; std::endl;

  timestep timestep_sv = stormer_verlet(5.0, -10, 0.01);
  std::cout &lt;&lt; &quot;[#]\nTime for Stormer Verlet integration is:\n&quot; \
            &lt;&lt; timestep_sv.time &lt;&lt; std::endl;
  std::cout &lt;&lt; &quot;[#]\nVelocity for Stormer Verlet integration is:\n&quot; \
            &lt;&lt; timestep_sv.vel &lt;&lt; std::endl;

  timestep timestep_vv = velocity_verlet(5.0, -10, 0.01);
  std::cout &lt;&lt; &quot;[#]\nTime for velocity Verlet integration is:\n&quot; \
            &lt;&lt; timestep_vv.time &lt;&lt; std::endl;
  std::cout &lt;&lt; &quot;[#]\nVelocity for velocity Verlet integration is:\n&quot; \
            &lt;&lt; timestep_vv.vel &lt;&lt; std::endl;

  return 0;

}
</code></pre>
<pre><code class="language-c">#include &lt;stdio.h&gt;

void verlet(double *time, double pos, double acc, double dt) {
    double prev_pos, temp_pos;
    prev_pos = pos;
    *time = 0.0;

    while (pos &gt; 0) {
        *time += dt;
        temp_pos = pos;
        pos = pos * 2 - prev_pos + acc * dt * dt;
        prev_pos = temp_pos;
    }
}

void stormer_verlet(double *time, double *vel,
                    double pos, double acc, double dt) {
    double prev_pos, temp_pos;
    prev_pos = pos;
    *vel = 0.0;
    *time = 0.0;

    while (pos &gt; 0) {
        *time += dt;
        temp_pos = pos;
        pos = pos * 2 - prev_pos + acc * dt * dt;
        prev_pos = temp_pos;

        *vel += acc * dt;
    }
}

void velocity_verlet(double *time, double *vel,
                     double pos, double acc, double dt) {
    *vel = 0.0;
    *time = 0.0;

    while (pos &gt; 0) {
        *time += dt;
        pos += (*vel) * dt + 0.5 * acc * dt * dt;
        *vel += acc * dt;
    }
}

int main() {
    double time, vel;

    verlet(&amp;time, 5.0, -10, 0.01);
    printf(&quot;[#]\nTime for Verlet integration is:\n&quot;);
    printf(&quot;%lf\n&quot;, time);

    stormer_verlet(&amp;time, &amp;vel, 5.0, -10, 0.01);
    printf(&quot;[#]\nTime for Stormer Verlet integration is:\n&quot;);
    printf(&quot;%lf\n&quot;, time);
    printf(&quot;[#]\nVelocity for Stormer Verlet integration is:\n&quot;);
    printf(&quot;%lf\n&quot;, vel);

    velocity_verlet(&amp;time, &amp;vel, 5.0, -10, 0.01);
    printf(&quot;[#]\nTime for velocity Verlet integration is:\n&quot;);
    printf(&quot;%lf\n&quot;, time);
    printf(&quot;[#]\nVelocity for Stormer Verlet integration is:\n&quot;);
    printf(&quot;%lf\n&quot;, vel);

    return 0;
}
</code></pre>
<pre><code class="language-java">public class Verlet {
    
    private static class VerletValues {
        public double time;
        public double vel;
    
        public VerletValues(double time, double vel) {
            this.time = time;
            this.vel = vel;
        }
    }
    

    static double verlet(double pos, double acc, double dt) {

      // Note that we are using a temp variable for the previous position
      double prev_pos, temp_pos, time;
      prev_pos = pos;
      time = 0;

      while (pos &gt; 0) {
            time += dt;
            temp_pos = pos;
            pos = pos*2 - prev_pos + acc * dt * dt;
            prev_pos = temp_pos;
        }

        return time;
    }
  
    static VerletValues stormer_verlet(double pos, double acc, double dt) {

        // Note that we are using a temp variable for the previous position
        double prev_pos, temp_pos, time, vel;
        prev_pos = pos;
        vel = 0;
        time = 0;
        while (pos &gt; 0) {
            time += dt;
            temp_pos = pos;
            pos = pos*2 - prev_pos + acc * dt * dt;
            prev_pos = temp_pos;

            // The acceleration is constant, so the velocity is straightforward
             vel += acc*dt;
        }
      
       return new VerletValues(time, vel);
    }

    static VerletValues velocity_verlet(double pos, double acc, double dt) {

        // Note that we are using a temp variable for the previous position
        double time, vel;
        vel = 0;
        time = 0;
        while (pos &gt; 0) {
            time += dt;
            pos += vel*dt + 0.5*acc * dt * dt;
            vel += acc*dt;
        }
        return new VerletValues(time, vel);
    }

    public static void main(String[] args) {

        double verletTime = verlet(5.0, -10, 0.01);
        System.out.println(&quot;[#]\nTime for Verlet integration is:&quot;);
        System.out.println(verletTime);
      
        VerletValues stormerVerlet = stormer_verlet(5.0, -10, 0.01);
        System.out.println(&quot;[#]\nTime for Stormer Verlet integration is:&quot;);
        System.out.println(stormerVerlet.time);
        System.out.println(&quot;[#]\nVelocity for Stormer Verlet integration is:&quot;);
        System.out.println(stormerVerlet.vel);
        
        VerletValues velocityVerlet = velocity_verlet(5.0, -10, 0.01);
        System.out.println(&quot;[#]\nTime for velocity Verlet integration is:&quot;);
        System.out.println(velocityVerlet.time);
        System.out.println(&quot;[#]\nVelocity for velocity Verlet integration is:&quot;);
        System.out.println(velocityVerlet.vel);
        
    }
}
</code></pre>
<pre><code class="language-python">def verlet(pos, acc, dt):
    prev_pos = pos
    time = 0

    while pos &gt; 0:
        time += dt
        next_pos = pos * 2 - prev_pos + acc * dt * dt
        prev_pos, pos = pos, next_pos

    return time

def stormer_verlet(pos, acc, dt):
    prev_pos = pos
    time = 0
    vel = 0

    while pos &gt; 0:
        time += dt
        next_pos = pos * 2 - prev_pos + acc * dt * dt
        prev_pos, pos = pos, next_pos
        vel += acc * dt

    return time, vel

def velocity_verlet(pos, acc, dt):
    time = 0
    vel = 0

    while pos &gt; 0:
        time += dt
        pos += vel * dt + 0.5 * acc * dt * dt
        vel += acc * dt

    return time, vel

def main():
    time = verlet(5, -10, 0.01)
    print(&quot;[#]\nTime for Verlet integration is:&quot;)
    print(&quot;{:.10f}&quot;.format(time))

    time, vel = stormer_verlet(5, -10, 0.01)
    print(&quot;[#]\nTime for Stormer Verlet integration is:&quot;)
    print(&quot;{:.10f}&quot;.format(time))
    print(&quot;[#]\nVelocity for Stormer Verlet integration is:&quot;)
    print(&quot;{:.10f}&quot;.format(vel))

    time, vel = velocity_verlet(5, -10, 0.01)
    print(&quot;[#]\nTime for velocity Verlet integration is:&quot;)
    print(&quot;{:.10f}&quot;.format(time))
    print(&quot;[#]\nVelocity for velocity Verlet integration is:&quot;)
    print(&quot;{:.10f}&quot;.format(vel))


if __name__ == '__main__':
    main()
</code></pre>
<pre><code class="language-haskell">-- submitted by Jie
type Time = Double

type Position = Double

type Speed = Double

type Acceleration = Double

type Particle = (Position, Speed, Acceleration, Time)

type Model = Particle -&gt; Acceleration

type Method = Model -&gt; Time -&gt; Particle -&gt; Particle -&gt; Particle

verlet :: Method
verlet acc dt (xOld, _, _, _) (x, _, a, t) = (x', v', a', t + dt)
  where
    x' = 2 * x - xOld + a * dt ^ 2
    v' = 0
    a' = acc (x', v', a, t + dt)

stormerVerlet :: Method
stormerVerlet acc dt (xOld, _, _, _) (x, _, a, t) = (x', v', a', t + dt)
  where
    x' = 2 * x - xOld + a * dt ^ 2
    v' = (x' - x) / dt
    a' = acc (x', v', a, t + dt)

velocityVerlet :: Method
velocityVerlet acc dt (xOld, _, aOld, _) (x, v, a, t) = (x', v', a', t + dt)
  where
    x' = 2 * x - xOld + a * dt ^ 2
    v' = v + 0.5 * (aOld + a) * dt
    a' = acc (x', v', a, t + dt)

trajectory :: Method -&gt; Model -&gt; Time -&gt; Particle -&gt; [Particle]
trajectory method acc dt p0@(x, v, a, t0) = traj
  where
    traj = p0 : p1 : zipWith (method acc dt) traj (tail traj)
    p1 = (x', v', acc (x', v', a, t0 + dt), t0 + dt)
    x' = x + v * dt + 0.5 * a * dt ^ 2
    v' = v + a * dt

main :: IO ()
main = do
  let p0 = (5, 0, -10, 0)
      dt = 0.001
      freefall _ = -10
      aboveGround (x, _, _, _) = x &gt; 0
      timeVelocity m =
        let (_, v, _, t) = last $ takeWhile aboveGround $ trajectory m freefall dt p0
         in (show t, show v)

  putStrLn &quot;[#]\nTime for Verlet integration is:&quot;
  putStrLn $ fst $ timeVelocity verlet
  putStrLn &quot;[#]\nTime for Stormer Verlet integration is:&quot;
  putStrLn $ fst $ timeVelocity stormerVerlet
  putStrLn &quot;[#]\nVelocity for Stormer Verlet integration is:&quot;
  putStrLn $ snd $ timeVelocity stormerVerlet
  putStrLn &quot;[#]\nTime for velocity Verlet integration is:&quot;
  putStrLn $ fst $ timeVelocity velocityVerlet
  putStrLn &quot;[#]\nVelocity for velocity Verlet integration is:&quot;
  putStrLn $ snd $ timeVelocity velocityVerlet
</code></pre>
<pre><code class="language-javascript">function verlet(pos, acc, dt) {
  let prevPos = pos;
  let time = 0;
  let tempPos;

  while (pos &gt; 0) {
    time += dt;
    tempPos = pos;
    pos = pos * 2 - prevPos + acc * dt * dt;
    prevPos = tempPos;
  }

  return time;
}

function stormerVerlet(pos, acc, dt) {
  let prevPos = pos;
  let time = 0;
  let vel = 0;
  let tempPos;

  while (pos &gt; 0) {
    time += dt;
    tempPos = pos;
    pos = pos * 2 - prevPos + acc * dt * dt;
    prevPos = tempPos;

    vel += acc * dt;
  }

  return { time, vel };
}

function velocityVerlet(pos, acc, dt) {
  let time = 0;
  let vel = 0;

  while (pos &gt; 0) {
    time += dt;
    pos += vel * dt + 0.5 * acc * dt * dt;
    vel += acc * dt;
  }

  return { time, vel };
}

const time = verlet(5, -10, 0.01);
console.log(`[#]\nTime for Verlet integration is:`);
console.log(`${time}`);

const stormer = stormerVerlet(5, -10, 0.01);
console.log(`[#]\nTime for Stormer Verlet integration is:`);
console.log(`${stormer.time}`);
console.log(`[#]\nVelocity for Stormer Verlet integration is:`);
console.log(`${stormer.vel}`);

const velocity = velocityVerlet(5, -10, 0.01);
console.log(`[#]\nTime for velocity Verlet integration is:`);
console.log(`${velocity.time}`);
console.log(`[#]\nVelocity for velocity Verlet integration is:`);
console.log(`${velocity.vel}`);
</code></pre>
<pre><pre class="playground"><code class="language-rust">fn verlet(mut pos: f64, acc: f64, dt: f64) -&gt; f64 {
    let mut prev_pos = pos;
    let mut time = 0.0;

    while pos &gt; 0.0 {
        time += dt;
        let temp_pos = pos;
        pos = pos * 2.0 - prev_pos + acc * dt * dt;
        prev_pos = temp_pos;
    }

    time
}

fn stormer_verlet(mut pos: f64, acc: f64, dt: f64) -&gt; (f64, f64) {
    let mut prev_pos = pos;
    let mut time = 0.0;
    let mut vel = 0.0;

    while pos &gt; 0.0 {
        time += dt;
        let temp_pos = pos;
        pos = pos * 2.0 - prev_pos + acc * dt * dt;
        prev_pos = temp_pos;

        // Because acceleration is constant, velocity is
        // straightforward
        vel += acc * dt;
    }

    (time, vel)
}

fn velocity_verlet(mut pos: f64, acc: f64, dt: f64) -&gt; (f64, f64) {
    let mut time = 0.0;
    let mut vel = 0.0;

    while pos &gt; 0.0 {
        time += dt;
        pos += vel * dt + 0.5 * acc * dt * dt;
        vel += acc * dt;
    }

    (time, vel)
}

fn main() {
    let time_v = verlet(5.0, -10.0, 0.01);
    let (time_sv, vel_sv) = stormer_verlet(5.0, -10.0, 0.01);
    let (time_vv, vel_vv) = velocity_verlet(5.0, -10.0, 0.01);

    println!(&quot;[#]\nTime for Verlet integration is:&quot;);
    println!(&quot;{}&quot;, time_v);
    
    println!(&quot;[#]\nTime for Stormer Verlet integration is:&quot;);
    println!(&quot;{}&quot;, time_sv);
    println!(&quot;[#]\nVelocity for Stormer Verlet integration is:&quot;);
    println!(&quot;{}&quot;, vel_sv);
    
    println!(&quot;[#]\nTime for velocity Verlet integration is:&quot;);
    println!(&quot;{}&quot;, time_vv);
    println!(&quot;[#]\nVelocity for velocity Verlet integration is:&quot;);
    println!(&quot;{}&quot;, vel_vv);
}
</code></pre></pre>
<pre><code class="language-swift">func verlet(pos: Double, acc: Double, dt: Double) -&gt; Double {
    var pos = pos
    var temp_pos, time: Double
    var prev_pos = pos
    time = 0.0
    
    while (pos &gt; 0) {
        time += dt
        temp_pos = pos
        pos = pos*2 - prev_pos + acc * dt * dt
        prev_pos = temp_pos
    }
    
    return time
}

func stormerVerlet(pos: Double, acc: Double, dt: Double) -&gt; (time: Double, vel: Double) {
    var pos = pos
    var temp_pos, time, vel: Double
    var prev_pos = pos
    vel = 0
    time = 0
    
    while (pos &gt; 0) {
        time += dt
        temp_pos = pos
        pos = pos*2 - prev_pos + acc * dt * dt
        prev_pos = temp_pos
        
        vel += acc*dt
    }
    
    return (time:time, vel:vel)
}

func velocityVerlet(pos: Double, acc: Double, dt: Double) -&gt; (time: Double, vel: Double) {
    var pos = pos
    var time, vel : Double
    vel = 0
    time = 0
    
    while (pos &gt; 0) {
        time += dt
        pos += vel*dt + 0.5*acc * dt * dt
        vel += acc*dt
    }
    
    return (time:time, vel:vel)
}

func main() {
    let verletTime = verlet(pos: 5.0, acc: -10.0, dt: 0.01)
    print(&quot;[#]\nTime for Verlet integration is:&quot;)
    print(&quot;\(verletTime)&quot;)
    
    let stormer = stormerVerlet(pos: 5.0, acc: -10.0, dt: 0.01);
    print(&quot;[#]\nTime for Stormer Verlet integration is:&quot;)
    print(&quot;\(stormer.time)&quot;)
    print(&quot;[#]\nVelocity for Stormer Verlet integration is:&quot;)
    print(&quot;\(stormer.vel)&quot;)
    
    let velVerlet = velocityVerlet(pos: 5.0, acc: -10, dt: 0.01)
    print(&quot;[#]\nTime for velocity Verlet integration is:&quot;)
    print(&quot;\(velVerlet.time)&quot;)
    print(&quot;[#]\nVelocity for velocity Verlet integration is:&quot;)
    print(&quot;\(velVerlet.vel)&quot;)
}

main()
</code></pre>
<pre><code class="language-fortran">SUBROUTINE verlet(pos, acc, dt, time) 
    IMPLICIT NONE
    REAL(8), INTENT(INOUT) :: pos, acc, dt, time
    REAL(8)                :: prev_pos, next_pos


    prev_pos = pos
    time     = 0d0

    DO
        IF (pos &gt; 0d0) THEN
            time     = time + dt
            next_pos = pos * 2d0 - prev_pos + acc * dt ** 2
            prev_pos = pos
            pos      = next_pos
        ELSE
            EXIT
        END IF
    END DO
END SUBROUTINE verlet

SUBROUTINE stormer_verlet(pos, acc, dt, time, vel) 
    IMPLICIT NONE
    REAL(8), INTENT(INOUT) :: pos, acc, dt, time, vel
    REAL(8)                :: prev_pos, next_pos

    prev_pos = pos 
    time     = 0d0
    vel      = 0d0

    DO
        IF (pos &gt; 0d0) THEN
            time     = time + dt
            next_pos = pos * 2 - prev_pos + acc * dt ** 2
            prev_pos = pos
            pos      = next_pos
            vel      = vel + acc * dt
        ELSE
            EXIT
        END IF
    END DO
END SUBROUTINE stormer_verlet 

SUBROUTINE velocity_verlet(pos, acc, dt, time, vel) 
    IMPLICIT NONE
    REAL(8), INTENT(INOUT) :: pos, acc, dt, time, vel

    time     = 0d0
    vel      = 0d0

    DO
        IF (pos &gt; 0d0) THEN
            time = time + dt
            pos  = pos + vel * dt + 0.5d0 * acc * dt ** 2 
            vel  = vel + acc * dt
        ELSE
            EXIT
        END IF
    END DO
END SUBROUTINE velocity_verlet 

PROGRAM verlet_integration

    IMPLICIT NONE 
    REAL(8) :: pos,acc, dt, time, vel
    
    INTERFACE
        SUBROUTINE verlet(pos, acc, dt, time)
        REAL(8), INTENT(INOUT) :: pos, acc, dt, time
        REAL(8)                :: prev_pos, next_pos
        END SUBROUTINE
    END INTERFACE 
    
    INTERFACE 
        SUBROUTINE stormer_verlet(pos, acc, dt, time, vel) 
            REAL(8), INTENT(INOUT) :: pos, acc, dt, time, vel
            REAL(8)                :: prev_pos, next_pos
        END SUBROUTINE 
    END INTERFACE 
    
    INTERFACE 
        SUBROUTINE velocity_verlet(pos, acc, dt, time, vel) 
            REAL(8), INTENT(INOUT) :: pos, acc, dt, time, vel
            REAL(8)                :: prev_pos, next_pos 
        END SUBROUTINE 
    END INTERFACE 
    
    pos = 5d0
    acc = -10d0
    dt  = 0.01d0
    ! Verlet 
    CALL verlet(pos, acc, dt, time)
    
    WRITE(*,*) '[#]'
    WRITE(*,*) 'Time for Verlet integration:'
    WRITE(*,*) time 
    
    ! stormer Verlet 
    pos = 5d0
    CALL stormer_verlet(pos, acc, dt, time, vel)
    
    WRITE(*,*) '[#]'
    WRITE(*,*) 'Time for Stormer Verlet integration:'
    WRITE(*,*) time
    WRITE(*,*) '[#]'
    WRITE(*,*) 'Velocity for Stormer Verlet integration:'
    WRITE(*,*) vel
    
    
    
    ! Velocity Verlet
    pos = 5d0
    CALL velocity_verlet(pos, acc, dt, time, vel)
    
    WRITE(*,*) '[#]'
    WRITE(*,*) 'Time for velocity Verlet integration:'
    WRITE(*,*) time
    WRITE(*,*) '[#]'
    WRITE(*,*) 'Velocity for velocity Verlet integration:'
    WRITE(*,*) vel

END PROGRAM verlet_integration
</code></pre>
<p>{% sample lang=&quot;ruby&quot; %}
<a href="code/ruby/verlet.rb">import, lang=&quot;ruby&quot;</a></p>
<pre><code class="language-go">package main

import &quot;fmt&quot;

func verlet(pos, acc, dt float64) (time float64) {
	prevPos := pos
	time = 0

	for pos &gt; 0 {
		time += dt
		nextPos := pos*2 - prevPos + acc*dt*dt
		prevPos, pos = pos, nextPos
	}

	return
}

func stormerVerlet(pos, acc, dt float64) (time, vel float64) {
	prevPos := pos
	time, vel = 0, 0

	for pos &gt; 0 {
		time += dt
		vel += acc * dt
		nextPos := pos*2 - prevPos + acc*dt*dt
		prevPos, pos = pos, nextPos
	}

	return
}

func velocityVerlet(pos, acc, dt float64) (time, vel float64) {
	time, vel = 0, 0

	for pos &gt; 0 {
		time += dt
		pos += vel*dt + .5*acc*dt*dt
		vel += acc * dt
	}

	return
}

func main() {
	time := verlet(5., -10., .01)
	fmt.Println(&quot;[#]\nTime for Verlet integration is:&quot;)
	fmt.Println(time)

	time, vel := stormerVerlet(5., -10., .01)
	fmt.Println(&quot;[#]\nTime for Stormer Verlet integration is:&quot;)
	fmt.Println(time)
	fmt.Println(&quot;[#]\nVelocity for Stormer Verlet integration is:&quot;)
	fmt.Println(vel)
	
	time, vel = velocityVerlet(5., -10., .01)
	fmt.Println(&quot;[#]\nTime for velocity Verlet integration is:&quot;)
	fmt.Println(time)
	fmt.Println(&quot;[#]\nVelocity for velocity Verlet integration is:&quot;)
	fmt.Println(vel)
}
</code></pre>
<pre><code class="language-asm-x64">.intel_syntax noprefix

.section .rodata
  zero:          .double 0.0
  two:           .double 2.0
  half:          .double 0.5
  verlet_fmt:    .string &quot;[#]\nTime for Verlet integration is:\n%lf\n&quot;
  stormer_fmt:   .string &quot;[#]\nTime for Stormer Verlet Integration is:\n%lf\n[#]\nVelocity for Stormer Verlet Integration is:\n%lf\n&quot;
  velocity_fmt:  .string &quot;[#]\nTime for Velocity Verlet Integration is:\n%lf\n[#]\nVelocity for Velocity Verlet Integration is:\n%lf\n&quot;
  pos:           .double 5.0
  acc:           .double -10.0
  dt:            .double 0.01

.section .text
  .global main
  .extern printf

# xmm0 - pos
# xmm1 - acc
# xmm2 - dt
# RET xmm0 - time
verlet:
  pxor   xmm7, xmm7                  # Holds 0 for comparisons
  pxor   xmm3, xmm3                  # Holds time value
  comisd xmm0, xmm7                  # Check if pos is greater then 0.0
  jbe    verlet_return
  movsd  xmm6, xmm1                  # xmm6 = acc * dt * dt
  mulsd  xmm6, xmm2
  mulsd  xmm6, xmm2
  movsd  xmm5, xmm0                  # Holds previous position
verlet_loop:
  addsd  xmm3, xmm2                  # Adding dt to time
  movsd  xmm4, xmm0                  # Hold old value of posistion
  addsd  xmm0, xmm0                  # Calculating new position
  subsd  xmm0, xmm5
  addsd  xmm0, xmm6
  movsd  xmm5, xmm4
  comisd xmm0, xmm7                  # Check if position is greater then 0.0
  ja     verlet_loop
verlet_return:
  movsd  xmm0, xmm3                  # Saving time value
  ret

# xmm0 - pos
# xmm1 - acc
# xmm2 - dt
# RET xmm0 - time
# RET xmm1 - velocity
stormer_verlet:
  pxor   xmm7, xmm7                  # Holds 0 for comparisons
  pxor   xmm3, xmm3                  # Holds time value
  comisd xmm0, xmm7                  # Check if pos is greater then 0.0
  jbe    stormer_verlet_return
  movsd  xmm6, xmm1                  # xmm6 = acc * dt * dt
  mulsd  xmm6, xmm2
  mulsd  xmm6, xmm2
  movsd  xmm5, xmm0                  # Holds previous position
stormer_verlet_loop:
  addsd  xmm3, xmm2                  # Adding dt to time
  movsd  xmm4, xmm0                  # Hold old value of posistion
  addsd  xmm0, xmm0                  # Calculating new position
  subsd  xmm0, xmm5
  addsd  xmm0, xmm6
  movsd  xmm5, xmm4
  comisd xmm0, xmm7                  # Check if position is greater then 0.0
  ja     stormer_verlet_loop
stormer_verlet_return:
  movsd  xmm0, xmm3                  # Saving time and velocity
  mulsd  xmm3, xmm1
  movsd  xmm1, xmm3
  ret

# xmm0 - pos
# xmm1 - acc
# xmm2 - dt
# RET xmm0 - time
# RET xmm1 - velocity
velocity_verlet:
  pxor   xmm7, xmm7                  # Holds 0 for comparisons
  pxor   xmm3, xmm3                  # Holds the velocity value
  pxor   xmm4, xmm4                  # Holds the time value
  comisd xmm0, xmm7                  # Check if pos is greater then 0.0
  jbe    velocity_verlet_return
  movsd  xmm5, half                  # xmm5 = 0.5 * dt * dt * acc
  mulsd  xmm5, xmm2
  mulsd  xmm5, xmm2
  mulsd  xmm5, xmm1
velocity_verlet_loop:
  movsd  xmm6, xmm3                  # Move velocity into register
  mulsd  xmm6, xmm2                  # Calculate new position
  addsd  xmm6, xmm5
  addsd  xmm0, xmm6
  addsd  xmm4, xmm2                  # Incrementing time
  movsd  xmm3, xmm4                  # Updating velocity
  mulsd  xmm3, xmm1
  comisd xmm0, xmm7
  ja     velocity_verlet_loop
velocity_verlet_return:
  movsd  xmm0, xmm4                  # Saving time and velocity
  movsd  xmm1, xmm3
  ret

main:
  push   rbp
  movsd  xmm0, pos                   # Calling verlet
  movsd  xmm1, acc
  movsd  xmm2, dt
  call   verlet
  mov    rdi, OFFSET verlet_fmt      # Print output
  mov    rax, 1
  call   printf
  movsd  xmm0, pos                   # Calling stormer_verlet
  movsd  xmm1, acc
  movsd  xmm2, dt
  call   stormer_verlet
  mov    rdi, OFFSET stormer_fmt     # Print output
  mov    rax, 1
  call   printf
  movsd  xmm0, pos                   # Calling velocity_verlet
  movsd  xmm1, acc
  movsd  xmm2, dt
  call   velocity_verlet
  mov    rdi, OFFSET velocity_fmt    # Print output
  mov    rax, 1
  call   printf
  pop    rbp
  xor    rax, rax                      # Set exit code to 0
  ret

</code></pre>
<pre><code class="language-kotlin">data class VerletValues(val time: Double, val vel: Double)

fun verlet(_pos: Double, acc: Double, dt: Double): Double {
    var pos = _pos  // Since function parameter are val and can't be modified
    var prevPos = pos
    var time = 0.0

    while (pos &gt; 0) {
        time += dt
        val nextPos = pos * 2 - prevPos + acc * dt * dt
        prevPos = pos
        pos = nextPos
    }
    return time
}

fun stormerVerlet(_pos: Double, acc: Double, dt: Double): VerletValues {
    var pos = _pos
    var prevPos = pos
    var time = 0.0
    var vel = 0.0
    while (pos &gt; 0) {
        time += dt
        val nextPos = pos * 2 - prevPos + acc * dt * dt
        prevPos = pos
        pos = nextPos
        vel += acc * dt
    }
    return VerletValues(time, vel)
}

fun velocityVerlet(_pos: Double, acc: Double, dt: Double): VerletValues {
    var pos = _pos
    var time = 0.0
    var vel = 0.0
    while (pos &gt; 0) {
        time += dt
        pos += vel * dt + 0.5 * acc * dt * dt
        vel += acc * dt
    }
    return VerletValues(time, vel)
}

fun main(args: Array&lt;String&gt;) {
    val verletTime = verlet(5.0, -10.0, 0.01)
    println(&quot;[#]\nTime for Verlet integration is:&quot;)
    println(&quot;$verletTime&quot;)

    val stormerVerlet = stormerVerlet(5.0, -10.0, 0.01)
    println(&quot;[#]\nTime for Stormer Verlet integration is:&quot;)
    println(&quot;${stormerVerlet.time}&quot;)
    println(&quot;[#]\nVelocity for Stormer Verlet integration is:&quot;)
    println(&quot;${stormerVerlet.vel}&quot;)

    val velocityVerlet = velocityVerlet(5.0, -10.0, 0.01)
    println(&quot;[#]\nTime for Velocity Verlet integration is:&quot;)
    println(&quot;${velocityVerlet.time}&quot;)
    println(&quot;[#]\nVelocity for Velocity Verlet integration is:&quot;)
    println(&quot;${velocityVerlet.vel}&quot;)
}
</code></pre>
<p>{% sample lang=&quot;nim&quot; %}
<a href="code/nim/verlet.nim">import, lang=&quot;nim&quot;</a></p>
<pre><code class="language-lisp">;;;; Verlet integration implementation in Common Lisp

(defun verlet (pos acc dt)
  &quot;Integrates Newton's equation for motion while pos &gt; 0 using Verlet integration.&quot;
  (loop
    with prev-pos = pos
    for time = 0 then (incf time dt)
    while (&gt; pos 0)
    ;; The starting speed is assumed to be zero.
    do (psetf
         pos (+ (* pos 2) (- prev-pos) (* acc dt dt))
         prev-pos pos)
    finally (return time)))

(defun stormer-verlet (pos acc dt)
  &quot;Integrates Newton's equation for motion while pos &gt; 0 using the Stormer-Verlet method.&quot;
  (loop
    with prev-pos = pos
    for time = 0 then (incf time dt)
    for vel = 0 then (incf vel (* acc dt))
    while (&gt; pos 0)
    ;; Variables are changed simultaneously by 'psetf', so there's no need for a temporary variable.
    do (psetf
         pos (+ (* pos 2) (- prev-pos) (* acc dt dt))
         prev-pos pos)
    finally (return (list time vel))))

(defun velocity-verlet (pos acc dt)
  &quot;Integrates Newton's equation for motion while pos &gt; 0 using the velocity in calculations.&quot;
  (loop
    for time = 0 then (incf time dt)
    for vel = 0 then (incf vel (* acc dt))
    for p = pos then (incf p (+ (* vel dt) (* 0.5 acc dt dt)))
    while (&gt; p 0)
    finally (return (list time vel))))

(format T &quot;[#]~%Time for Verlet integration:~%&quot;)
(format T &quot;~d~%&quot; (verlet 5 -10 0.01))

(defvar stormer-verlet-result (stormer-verlet 5 -10 0.01))
(format T &quot;[#]~%Time for Stormer Verlet integration is:~%&quot;)
(format T &quot;~d~%&quot; (first stormer-verlet-result))
(format T &quot;[#]~%Velocity for Stormer Verlet integration is:~%&quot;)
(format T &quot;~d~%&quot; (second stormer-verlet-result))

(defvar velocity-verlet-result (velocity-verlet 5 -10 0.01))
(format T &quot;[#]~%Time for velocity Verlet integration is:~%&quot;)
(format T &quot;~d~%&quot; (first velocity-verlet-result))
(format T &quot;[#]~%Velocity for velocity Verlet integration is:~%&quot;)
(format T &quot;~d~%&quot; (second velocity-verlet-result))
</code></pre>
<h2 id="license"><a class="header" href="#license">License</a></h2>
<h5 id="code-examples"><a class="header" href="#code-examples">Code Examples</a></h5>
<p>The code examples are licensed under the MIT license (found in <a href="https://github.com/algorithm-archivists/algorithm-archive/blob/master/LICENSE.md">LICENSE.md</a>).</p>
<h5 id="text"><a class="header" href="#text">Text</a></h5>
<p>The text of this chapter was written by <a href="https://github.com/leios">James Schloss</a> and is licensed under the <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</p>
<p><a href="https://creativecommons.org/licenses/by-sa/4.0/"><p><img  class="center" src="../cc/CC-BY-SA_icon.svg" /></p></a></p>
<h5 id="pull-requests"><a class="header" href="#pull-requests">Pull Requests</a></h5>
<p>After initial licensing (<a href="https://github.com/algorithm-archivists/algorithm-archive/pull/560">#560</a>), the following pull requests have modified the text or graphics of this chapter:</p>
<ul>
<li>none</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../physics_solvers/physics_solvers.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="../quantum_systems/quantum_systems.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../physics_solvers/physics_solvers.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="../quantum_systems/quantum_systems.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script type="text/javascript">
            var socket = new WebSocket("ws://0.0.0.0:3000/__livereload");
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->


    </body>
</html>
