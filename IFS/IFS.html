<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Iterated Function Systems - Arcane Algorithm Archive</title>


        <!-- Custom HTML head -->

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../index.html"><strong aria-hidden="true">1.</strong> Algorithm Archive</a></li><li class="chapter-item expanded "><a href="../introduction/introduction.html"><strong aria-hidden="true">2.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="../how_to_contribute/how_to_contribute.html"><strong aria-hidden="true">3.</strong> How To Contribute</a></li><li class="chapter-item expanded "><a href="../plotting/plotting.html"><strong aria-hidden="true">4.</strong> Plotting</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../domain_coloring/domain_coloring.html"><strong aria-hidden="true">4.1.</strong> Domain Coloring</a></li><li class="chapter-item expanded "><a href="../IFS/IFS.html" class="active"><strong aria-hidden="true">4.2.</strong> Iterated Function Systems</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../barnsley/barnsley.html"><strong aria-hidden="true">4.2.1.</strong> The Barnsley Fern</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="../data_structures/data_structures.html"><strong aria-hidden="true">5.</strong> Data Structures</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../stacks_and_queues/stacks_and_queues.html"><strong aria-hidden="true">5.1.</strong> Stacks and Queues</a></li></ol></li><li class="chapter-item expanded "><a href="../mathematical_background/mathematical_background.html"><strong aria-hidden="true">6.</strong> Mathematical Background</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../notation/notation.html"><strong aria-hidden="true">6.1.</strong> Complexity Notation</a></li><li class="chapter-item expanded "><a href="../affine_transformations/affine_transformations.html"><strong aria-hidden="true">6.2.</strong> Affine Transformations</a></li><li class="chapter-item expanded "><a href="../bitlogic/bitlogic.html"><strong aria-hidden="true">6.3.</strong> Bit Logic</a></li><li class="chapter-item expanded "><a href="../taylor_series_expansion/taylor_series_expansion.html"><strong aria-hidden="true">6.4.</strong> Taylor Series</a></li><li class="chapter-item expanded "><a href="../convolutions/convolutions.html"><strong aria-hidden="true">6.5.</strong> Convolutions</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../convolutions/1d/1d.html"><strong aria-hidden="true">6.5.1.</strong> Convolutions in 1D</a></li><li class="chapter-item expanded "><a href="../convolutions/multiplication/multiplication.html"><strong aria-hidden="true">6.5.2.</strong> Multiplication as a Convolution</a></li><li class="chapter-item expanded "><a href="../convolutions/2d/2d.html"><strong aria-hidden="true">6.5.3.</strong> Convolutions of Images (2D)</a></li><li class="chapter-item expanded "><a href="../convolutions/convolutional_theorem/convolutional_theorem.html"><strong aria-hidden="true">6.5.4.</strong> Convolutional Theorem</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="../tree_traversal/tree_traversal.html"><strong aria-hidden="true">7.</strong> Tree Traversal</a></li><li class="chapter-item expanded "><a href="../euclidean_algorithm/euclidean_algorithm.html"><strong aria-hidden="true">8.</strong> Euclidean Algorithm</a></li><li class="chapter-item expanded "><a href="../monte_carlo_integration/monte_carlo_integration.html"><strong aria-hidden="true">9.</strong> Monte Carlo</a></li><li class="chapter-item expanded "><a href="../matrix_methods/matrix_methods.html"><strong aria-hidden="true">10.</strong> Matrix Methods</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../gaussian_elimination/gaussian_elimination.html"><strong aria-hidden="true">10.1.</strong> Gaussian Elimination</a></li><li class="chapter-item expanded "><a href="../thomas_algorithm/thomas_algorithm.html"><strong aria-hidden="true">10.2.</strong> Thomas Algorithm</a></li></ol></li><li class="chapter-item expanded "><a href="../computational_geometry/computational_geometry.html"><strong aria-hidden="true">11.</strong> Computational Geometry</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../gift_wrapping/gift_wrapping.html"><strong aria-hidden="true">11.1.</strong> Gift Wrapping</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../jarvis_march/jarvis_march.html"><strong aria-hidden="true">11.1.1.</strong> Jarvis March</a></li><li class="chapter-item expanded "><a href="../graham_scan/graham_scan.html"><strong aria-hidden="true">11.1.2.</strong> Graham Scan</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="../cooley_tukey/cooley_tukey.html"><strong aria-hidden="true">12.</strong> FFT</a></li><li class="chapter-item expanded "><a href="../decision_problems/decision_problems.html"><strong aria-hidden="true">13.</strong> Decision Problems</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../stable_marriage_problem/stable_marriage_problem.html"><strong aria-hidden="true">13.1.</strong> Stable Marriage Problem</a></li></ol></li><li class="chapter-item expanded "><a href="../physics_solvers/physics_solvers.html"><strong aria-hidden="true">14.</strong> Physics Solvers</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../verlet_integration/verlet_integration.html"><strong aria-hidden="true">14.1.</strong> Verlet Integration</a></li><li class="chapter-item expanded "><a href="../quantum_systems/quantum_systems.html"><strong aria-hidden="true">14.2.</strong> Quantum Systems</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../split-operator_method/split-operator_method.html"><strong aria-hidden="true">14.2.1.</strong> Split-Operator Method</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="../data_compression/data_compression.html"><strong aria-hidden="true">15.</strong> Data Compression</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../huffman_encoding/huffman_encoding.html"><strong aria-hidden="true">15.1.</strong> Huffman Encoding</a></li></ol></li><li class="chapter-item expanded "><a href="../computer_graphics/computer_graphics.html"><strong aria-hidden="true">16.</strong> Computer Graphics</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../flood_fill/flood_fill.html"><strong aria-hidden="true">16.1.</strong> Flood Fill</a></li></ol></li><li class="chapter-item expanded "><a href="../quantum_information/quantum_information.html"><strong aria-hidden="true">17.</strong> Quantum Information</a></li><li class="chapter-item expanded "><a href="../computus/computus.html"><strong aria-hidden="true">18.</strong> Computus</a></li><li class="chapter-item expanded "><a href="../approximate_counting/approximate_counting.html"><strong aria-hidden="true">19.</strong> Approximate Counting Algorithm</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Arcane Algorithm Archive</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/algorithm-archivists/algorithm-archive/" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="iterated-function-systems"><a class="header" href="#iterated-function-systems">Iterated Function Systems</a></h1>
<p>A few quick notes before we start:</p>
<ol>
<li>
<p>For this chapter, we will be following the methodology set by the <a href="../plotting/plotting.html">plotting chapter</a>.
That is to say that the code presented in this chapter will output another file that can be easily plotted by an external plotter.
If you like to use a plotter provided by your language of choice, please modify the code provided to do so.</p>
</li>
<li>
<p>This chapter is currently a subsection to the plotting chapter, but we may extend the algorithm archive in the future with other fractal generation methods, which would require creating a new section on fractals, in particular.
This would include a chapter with more rigorous definitions on fractals, which is largely missing from the following discussion.
Please let us know if you are interested!</p>
</li>
</ol>
<p>In this chapter, we will show you how to make one of the most famous fractals, the Sierpinski triangle, via Iterated Function Systems (IFSs).
We will also introduce a number of interesting concepts for further exploration, such as chaos games, Hutchinson operators, and attractors.</p>
<h2 id="the-sierpinski-triangle"><a class="header" href="#the-sierpinski-triangle">The Sierpinski Triangle</a></h2>
<p>To begin the discussion of Iterated Function Systems (IFSs), we will first discuss what might be one of the most famous fractals currently known: the Sierpinski triangle (shown below):</p>
<img class="center" src="res/IFS_triangle_1.png" alt="Sierpinsky Triangle Chaos Game"  style="width:100%">
<p>This image is clearly a set of triangles embedded in a larger triangle in such a way that it can be continually cut into three identical pieces and still retain its internal structure.
This idea is known as self-similarity {{&quot;self-similar&quot; | cite }}, and it is usually the first aspect of fractals to catch an audience's attention.
In fact, there are plenty of uses of fractals and their mathematical underpinnings, such as estimating the coastline of Britain {{ &quot;mandelbrot1967long&quot; | cite}}, identifying fingerprints {{ &quot;jampour2010new&quot; | cite }}, and image compression {{ &quot;fractal-compression&quot; | cite }}{{ &quot;saupe1994review&quot; | cite }}.
In many more rigorous definitions, a fractal can be described as any system that has a non-integer Hausdorff dimension {{ &quot;3b1bfractal&quot; | cite }}{{ &quot;hausdorff&quot; | cite }}{{ &quot;gneiting2012estimators&quot; | cite }}.
Though this is an incredibly interesting concept, the discussion of this chapter will instead focus on methods to generate fractal patterns through iterated function systems.</p>
<p>To start, imagine creating a triangle from three points, \( A \), \( B \), and \( C \).
These points can be arbitrarily chosen, but for this conversation, we will constrict them to the vertices of an equilateral triangle, as shown below:</p>
<img class="center" src="res/IFS_triangle_2.png" alt="Triangle Vertices"  style="width:100%">
<p>Now let's create three separate functions that can act on a 2-dimensional space:</p>
<p>\[
\begin{align}
f_1(P) &amp;= \frac{P + A}{2}\\\\
f_2(P) &amp;= \frac{P + B}{2}\\\\
f_3(P) &amp;= \frac{P + C}{2}\\\\
\end{align}
\]</p>
<p>Each function will read in a particular location in space (here, \( P \in \mathbb{R}^2 \)) and output a new location that is the midpoint between the input location and \( A \), \( B \), or \( C \) for \( f_1 \), \( f_2 \), and \( f_3 \) respectively.
The union of all of these functions (the set of all possible functions available for use) is often notated as the <em>Hutchinson operator</em> {{ &quot;hutchinson-operator&quot; | cite }}{{ &quot;hutchinson1981fractals&quot; | cite}}, and for this case it would look like this:</p>
<p>\[ H(P) = \bigcup_{i=1}^3f_i(P) \]</p>
<p>By iteratively using this operator, we can traverse through all possible movements in the set.
For example, let's generate 3 new points that are halfway between \( A \) and \( B \), \( B \) and \( C \), and \( A \) and \( C \), which will be called \( D \), \( E \), and \( F \) respectively.
This is shown below:</p>
<img class="center" src="res/IFS_triangle_3.png" alt="Triangle Midpoints"  style="width:100%">
<p>From here, each new point (\( D \), \( E \), and \( F \)) will spawn 3 children, and each child will move according to one of the three possible functions in the Hutchinson operator, as shown below:</p>
<div style="text-align:center">
<video style="width:100%" controls>
  <source src="res/IFS_triangle_vid_1.mp4" type="video/mp4">
  <img class="center" src="res/IFS_triangle_4.png" alt="First Children"  style="width:100%">
</video>
</div>
<p>Here, all red children come from \( D \), green children come from \( E \) and blue children come from \( F \).
At this stage, the children will then spawn 3 more children, each of which will move according to a different function.
Those children will then spawn more children, who act accordingly.
As this process continues on and on, we begin to see an interesting pattern form:</p>
<div style="text-align:center">
<video style="width:100%" controls>
  <source src="res/IFS_triangle_vid_2.mp4" type="video/mp4">
  <img class="center" src="res/IFS_triangle_5.png" alt="Last children"  style="width:100%">
</video>
</div>
<p>This is the Sierpinski triangle.
At first, it might seem like mathematical magic that a simple set of 3 functions can create such a pattern.
After all, why aren't any of the children migrating to the empty spaces in the structure?
This will require some thought, but the simplest answer is that no function within the Hutchinson operator allows for children to enter those spaces; therefore, none of the children can enter them.</p>
<h2 id="what-about-a-square"><a class="header" href="#what-about-a-square">What about a square?</a></h2>
<p>When I learned about how the Sierpinski triangle could be generated from 3 simple functions, I began to wonder about other shapes.
Could we create fractal squares? Hexagons? Circles?
Such shapes <em>seem</em> like natural extensions to the triangular Hutchinson operator provided above, but there's a bit of a hitch...</p>
<p>First, let's take 4 points, \( A \), \( B \), \( C \), and \( D \), this time located at the four vertices of a square, like so:</p>
<img class="center" src="res/IFS_square_1.png" alt="Sierpinsky Triangle Chaos Game"  style="width:100%">
<p>In a similar fashion, we'll create 4 functions with \( H(P) = \bigcup_{i=1}^4f_i(P) \), and \( P \in \mathbb{R}^2 \) such that:</p>
<p>\[
\begin{align}
f_1(P) &amp;= \frac{P + A}{2}\\\\
f_2(P) &amp;= \frac{P + B}{2}\\\\
f_3(P) &amp;= \frac{P + C}{2}\\\\
f_4(P) &amp;= \frac{P + D}{2}\\\\
\end{align}
\]</p>
<p>If we then create 5 initial points located between all the vertices and allow these points to continually spawn children like before, something peculiar happens:</p>
<div style="text-align:center">
<video style="width:100%" controls>
  <source src="res/IFS_square_vid_1.mp4" type="video/mp4">
  <img class="center" src="res/IFS_square_2.png" alt="Hutchinson square"  style="width:100%">
</video>
</div>
<p>We essentially see a square of squares.
What happened to the self-similar structure we were getting before?
Why isn't this more interesting?</p>
<p>The best answer I have for now is that some Hutchinson operators are interesting and some are not.
Still, this square is a bit more interesting than it first appears, but to see why, we need to use the Hutchinson operator in a slightly different way.</p>
<h2 id="chaos-games-and-attractors"><a class="header" href="#chaos-games-and-attractors">Chaos games and attractors</a></h2>
<p>Until now, our visualizations for both the Sierpinski triangle and the square have been computationally costly.
Every iteration, we generate 3 or 4 new children per child per step of the simulation.
This scales exponentially and means that we will quickly have millions of children to keep track of!
In fact, to deal with this, we developed our own method of counting through the tree to more efficiently keep track of everything, but that is a story for another day.</p>
<p>The question for now is whether there is a more computationally feasible way of iterating through our Hutchinson operator.</p>
<p>As it turns out, there is!
Rather than keeping track of every possible movement within the Hutchinson operator to draw out a shape, it's actually possible to randomly sample the function set instead through a process known as a <em>chaos game</em> {{ &quot;chaos-game&quot; | cite }}{{ &quot;chaos-game-wolf&quot; | cite }}..
Here, instead of tracking children of children, we track a single individual that chooses randomly between the Hutchinson functions, as shown here:</p>
<pre><code class="language-julia">function chaos_game(n::Int, shape_points)

    # Initializing the output array and the initial point
    output_points = zeros(n,2)
    point = [rand(), rand()]

    for i = 1:n
        output_points[i,:] .= point
        point = 0.5*(rand(shape_points) .+ point)
    end

    return output_points

end
</code></pre>
<pre><code class="language-haskell">chaosGame :: RandomGen g =&gt; g -&gt; Int -&gt; Array Int (Point -&gt; Point) -&gt; [Point]
chaosGame g n hutchinson = take n points
  where
    (x, g') = random g
    (y, g'') = random g'
    choices = randomRs (bounds hutchinson) g''
    points = Point x y : zipWith (hutchinson !) choices points
</code></pre>
<pre><code class="language-cpp">// This is a function to simulate a &quot;chaos game&quot;
PointVector chaosGame(int numOutputPoints, const PointVector&amp; inputPoints) {
  // Choose first point randomly
  Point curPoint = {drand(), drand()};

  // For each output point, compute midpoint to random input point
  PointVector outputPoints(numOutputPoints);
  for (auto&amp; outPoint : outputPoints) {
    outPoint = curPoint;
    curPoint = 0.5 * (curPoint + choose(inputPoints));
  }

  return outputPoints;
}
</code></pre>
<pre><code class="language-python">def chaos_game(n, shape_points):
    # Initialize the starting point
    point = [random(), random()]

    for _ in range(n):
        # Update the point position and yield the result
        point = [(p + s) / 2 for p, s in zip(point, choice(shape_points))]
        yield point
</code></pre>
<pre><code class="language-c">void chaos_game(struct point *in, size_t in_n, struct point *out,
                size_t out_n) {

    struct point cur_point = {drand(), drand()};

    for (int i = 0; i &lt; out_n; ++i) {
        out[i] = cur_point;
        struct point tmp = random_element(in, in_n);
        cur_point.x = 0.5 * (cur_point.x + tmp.x);
        cur_point.y = 0.5 * (cur_point.y + tmp.y);
    }
}
</code></pre>
<pre><code class="language-lisp">(defun chaos-game (iterations shape-points)
  &quot;Plays a chaos game with a certain shape for a determined amount of iterations&quot;
  (loop
    repeat iterations
    for rand-point = (svref shape-points (random (length shape-points)))
    for point = (make-point (random 1.0) (random 1.0)) ; starting point
    then (make-point
           (* 0.5 (+ (point-x rand-point) (point-x point)))
           (* 0.5 (+ (point-y rand-point) (point-y point)))) ; every subsequent point
    collect point))
</code></pre>
<pre><code class="language-coconut">data point(x=0, y=0):
    def __add__(self, other):
        return point(self.x + other.x, self.y + other.y)

    def __rmul__(self, other):
        return point(self.x * other, self.y * other)

def chaos_game(n, shape_points):
    p = point(random(), random())

    for _ in range(n):
        p = (1/2) * (p + choice(shape_points))
        yield p
</code></pre>
<pre><code class="language-java">    public static Point[] chaosGame(int n, Point[] shapePoints) {
        Random rng = new Random();

        // Initialize output vector
        Point[] outputPoints = new Point[n];

        // Choose first point randomly
        Point point = new Point(rng.nextDouble(), rng.nextDouble());

        for (int i = 0; i &lt; n; i++) {
            outputPoints[i] = point;

            // Clone point to get a new reference
            point = new Point(point.x, point.y);

            // Retrieve random shape point
            Point temp = shapePoints[rng.nextInt(shapePoints.length)];
            // Calculate midpoint
            point.x = 0.5 * (point.x + temp.x);
            point.y = 0.5 * (point.y + temp.y);
        }

        return outputPoints;
    }
</code></pre>
<p>If we set the initial point to the on the equilateral triangle we saw before, we can see the Sierpinski triangle again after a few thousand iterations, as shown below:</p>
<div style="text-align:center">
<video style="width:100%" controls>
  <source src="res/chaos_vid_1.mp4" type="video/mp4">
  <img class="center" src="res/chaos_1.png" alt="Chaos game"  style="width:100%">
</video>
</div>
<p>Here, we are plotting 200,000 point locations in sets of 1000, and every set becomes successively more blue as the visualization continues.
At first glance, this visualization seems bewildering.
After all, it appears as if the entire triangle just magically comes into view in a few seconds.
The important thing to remember here is that each of these 200,000 dots is another location that our initial point decided to visit.</p>
<p>That said, there is something peculiar about the way the chaos game starts.
We are actually allowed to start the simulation <em>off</em> of the Sierpinski triangle.
As we mentioned earlier, none of the functions for the Sierpinski visualization allow children to enter the empty spaces of the triangle, so let's see what happens if we start the point off at the center of the triangle:</p>
<div style="text-align:center">
<video style="width:100%" controls>
  <source src="res/chaos_vid_2.mp4" type="video/mp4">
  <img class="center" src="reschaos_2.png" alt="Chaos game with initial points"  style="width:100%">
</video>
</div>
<p>Here, I have plotted the first 20 steps of the chaos game, and it is clear that the point gets closer and closer to the triangle each iteration.
Once it lands on the triangle, it can no longer escape and every movement from then on will be on the triangle.</p>
<p>In a sense, the wanderin point is <em>attracted</em> to the Sierpinski triangle with this set of functions, and that is actually the case!
The truth is that the word <em>attractor</em> is a very loaded term in the literature, but for the purposes of our discussion here, an <em>attractor</em> is any shape defined by the iteration through Hutchinson operator functions.</p>
<p>So let's go back to the example with the 4 points along the square and generate the attractor via a chaos game instead of going through every branch of the Hutchinson operator.
If we do this, we get what seems to be a random distribution of points:</p>
<img class="center" src="res/IFS_square_3.png" alt="Hutchinson square"  style="width:100%">
<p>This kinda boggled my mind a bit when I looked at it for the first time.
What does a random distribution of points mean in this context?</p>
<p>Well, firstly, it's only a random distribution between the square vertices of \( A \), \( B \), \( C \), and \( D \), but nothing exists outside of these points.
This means that it's not actually a random distribution of points, but instead an attractive plane that our lone wandering point can exist happily within.</p>
<p>This really helped me understand how attractors present themselves in different dimensions.
The Sierpinski triangle seems like a series of lines (one-dimensional objects) in two-dimensional space, but the square is a truly two-dimensional object.
In general, this means that an attractor embedded within \( \mathbb{R}^N \) can be any shape of dimension N or lower.</p>
<p>The next obvious question is whether a square can create any more interesting fractally patterns, and the answer is &quot;yes, but only if we restrict the movement a bit.&quot;
Which brings us to another topic entirely: restricted chaos games.
Discussing restricted chaos games in more detail is a chapter in its own right, so I will forego the discussion here.
If you are interested, please let me know and I will be more than willing to add the chapter in the future!</p>
<h2 id="video-explanation"><a class="header" href="#video-explanation">Video Explanation</a></h2>
<p>Here is a video describing iterated function systems:</p>
<div style="text-align:center">
<iframe width="560" height="315" src="https://www.youtube.com/embed/nIIp-vo8rHg"
 frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; pic
ture-in-picture" allowfullscreen></iframe>
</div>
<h2 id="example-code"><a class="header" href="#example-code">Example Code</a></h2>
<p>For the code in this chapter, we have decided to write it specifically for the Chaos game, not the hutchinson animations shown at the start of the chapter.
This is because that animation is slightly tricky to create and distracts from the overall purpose of this chapter.
In addition, we have written the chaos game code to take in a set of points so that it is not hard-coded for the Sierpinski triangle and can be easily extended to other shapes like the square or restricted chaos games, as we mentioned before!</p>
<pre><code class="language-julia">using DelimitedFiles

# This is a function to simulate a &quot;chaos game&quot;
function chaos_game(n::Int, shape_points)

    # Initializing the output array and the initial point
    output_points = zeros(n,2)
    point = [rand(), rand()]

    for i = 1:n
        output_points[i,:] .= point
        point = 0.5*(rand(shape_points) .+ point)
    end

    return output_points

end

# This will generate a Sierpinski triangle with a chaos game of n points for an 
# initial triangle with three points on the vertices of an equilateral triangle:
#     A = (0.0, 0.0)
#     B = (0.5, sqrt(0.75))
#     C = (1.0, 0.0)
# It will output the file sierpinski.dat, which can be plotted after
shape_points = [[0.0, 0.0],
                [0.5, sqrt(0.75)],
                [1.0, 0.0]]
output_points = chaos_game(10000, shape_points)
writedlm(&quot;sierpinski.dat&quot;, output_points)
</code></pre>
<pre><code class="language-haskell">import Data.Array ((!), Array, bounds, listArray)
import Data.List (intercalate)
import System.Random

data Point = Point Double Double

chaosGame :: RandomGen g =&gt; g -&gt; Int -&gt; Array Int (Point -&gt; Point) -&gt; [Point]
chaosGame g n hutchinson = take n points
  where
    (x, g') = random g
    (y, g'') = random g'
    choices = randomRs (bounds hutchinson) g''
    points = Point x y : zipWith (hutchinson !) choices points

main :: IO ()
main = do
  g &lt;- newStdGen

  let midPoint (Point a b) (Point x y) = Point ((a + x) / 2) ((b + y) / 2)
      sierpinski =
        listArray
          (1, 3)
          [ midPoint (Point 0 0),
            midPoint (Point 0.5 (sqrt 0.75)),
            midPoint (Point 1 0)
          ]
      points = chaosGame g 10000 sierpinski
      showPoint (Point x y) = show x ++ &quot;\t&quot; ++ show y

  writeFile &quot;out.dat&quot; $ intercalate &quot;\n&quot; $ map showPoint points
</code></pre>
<pre><code class="language-cpp">#include &lt;cmath&gt;
#include &lt;fstream&gt;
#include &lt;random&gt;
#include &lt;vector&gt;

// Simple X-Y point structure, along with some operators
struct Point {
  double x, y;
};

Point operator+(Point lhs, Point rhs) { return {lhs.x + rhs.x, lhs.y + rhs.y}; }
Point operator*(double k, Point pt) { return {k * pt.x, k * pt.y}; }
Point operator*(Point pt, double k) { return k * pt; }

using PointVector = std::vector&lt;Point&gt;;

// Returns a pseudo-random number generator
std::default_random_engine&amp; rng() {
  // Initialize static pseudo-random engine with non-deterministic random seed
  static std::default_random_engine randEngine(std::random_device{}());
  return randEngine;
}

// Returns a random double in [0, 1)
double drand() {
  return std::uniform_real_distribution&lt;double&gt;(0.0, 1.0)(rng());
}

// Returns a random integer in [0, numElems-1]
std::size_t randrange(std::size_t numElems) {
  return std::uniform_int_distribution&lt;std::size_t&gt;(0, numElems - 1)(rng());
}

// Return a random point from the non-empty PointVector
Point choose(const PointVector&amp; points) {
  return points[randrange(points.size())];
}

// This is a function to simulate a &quot;chaos game&quot;
PointVector chaosGame(int numOutputPoints, const PointVector&amp; inputPoints) {
  // Choose first point randomly
  Point curPoint = {drand(), drand()};

  // For each output point, compute midpoint to random input point
  PointVector outputPoints(numOutputPoints);
  for (auto&amp; outPoint : outputPoints) {
    outPoint = curPoint;
    curPoint = 0.5 * (curPoint + choose(inputPoints));
  }

  return outputPoints;
}

int main() {
  // This will generate a Sierpinski triangle with a chaos game of n points for
  // an initial triangle with three points on the vertices of an equilateral
  // triangle.
  PointVector inputPoints = {{0.0, 0.0}, {0.5, std::sqrt(0.75)}, {1.0, 0.0}};
  auto outputPoints = chaosGame(10000, inputPoints);

  // It will output the file sierpinski.dat, which can be plotted after
  std::ofstream ofs(&quot;sierpinski.dat&quot;);
  for (auto pt : outputPoints)
    ofs &lt;&lt; pt.x &lt;&lt; '\t' &lt;&lt; pt.y &lt;&lt; '\n';
}
</code></pre>
<pre><code class="language-python">from random import random, choice
from math import sqrt

# This generator simulates a &quot;chaos game&quot;
def chaos_game(n, shape_points):
    # Initialize the starting point
    point = [random(), random()]

    for _ in range(n):
        # Update the point position and yield the result
        point = [(p + s) / 2 for p, s in zip(point, choice(shape_points))]
        yield point

# This will generate a Sierpinski triangle with a chaos game of n points for an
# initial triangle with three points on the vertices of an equilateral triangle:
#     A = (0.0, 0.0)
#     B = (0.5, sqrt(0.75))
#     C = (1.0, 0.0)
# It will output the file sierpinski.dat, which can be plotted after
shape_points = [[0.0, 0.0],
                [0.5, sqrt(0.75)],
                [1.0, 0.0]]
with open(&quot;sierpinski.dat&quot;, &quot;w&quot;) as f:
    for point in chaos_game(10000, shape_points):
        f.write(&quot;{0}\t{1}\n&quot;.format(*point))
</code></pre>
<pre><code class="language-c">#include &lt;math.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;time.h&gt;

struct point {
    double x, y;
};

double drand() {
    return ((double) rand() / (RAND_MAX));
}

struct point random_element(struct point *array, size_t n) {
    return array[rand() % (int)n];
}

void chaos_game(struct point *in, size_t in_n, struct point *out,
                size_t out_n) {

    struct point cur_point = {drand(), drand()};

    for (int i = 0; i &lt; out_n; ++i) {
        out[i] = cur_point;
        struct point tmp = random_element(in, in_n);
        cur_point.x = 0.5 * (cur_point.x + tmp.x);
        cur_point.y = 0.5 * (cur_point.y + tmp.y);
    }
}

int main() {
    struct point shape_points [3] = {{0.0,0.0}, {0.5,sqrt(0.75)}, {1.0,0.0}};
    struct point out_points[1000];

    srand(time(NULL));

    chaos_game(shape_points, 3, out_points, 1000);

    FILE *fp = fopen(&quot;sierpinksi.dat&quot;, &quot;w+&quot;);

    for (int i = 0; i &lt; 1000; ++i) {
        fprintf(fp, &quot;%f\t%f\n&quot;, out_points[i].x, out_points[i].y);
    }

    fclose(fp);

    return 0;
}

</code></pre>
<pre><code class="language-lisp">;;;; Iterated Function System implementation

(defstruct (point (:constructor make-point (x y))) x y)

(defun chaos-game (iterations shape-points)
  &quot;Plays a chaos game with a certain shape for a determined amount of iterations&quot;
  (loop
    repeat iterations
    for rand-point = (svref shape-points (random (length shape-points)))
    for point = (make-point (random 1.0) (random 1.0)) ; starting point
    then (make-point
           (* 0.5 (+ (point-x rand-point) (point-x point)))
           (* 0.5 (+ (point-y rand-point) (point-y point)))) ; every subsequent point
    collect point))

(defparameter *shape-points*
  (map
    'vector
    (lambda (e) (apply #'make-point e))
    ;; the backquote allows us to selectively evaluate (sqrt 0.75) with the comma
    `((0 0) (0.5 ,(sqrt 0.75)) (1 0))))

;; output the data to the &quot;out.dat&quot; file
(with-open-file (out &quot;out.dat&quot; :direction :output :if-exists :supersede)
  (flet ((format-point (p)
           ;; this is not very clean, but it's the simplest way to insert a tab into a string.
           (format nil &quot;~f~c~f&quot; (point-x p) #\tab (point-y p))))
    (format out &quot;~{~a~%~}&quot; (map 'list #'format-point (chaos-game 10000 *shape-points*)))))
</code></pre>
<pre><code class="language-coconut">from math import sqrt
from random import random, choice

data point(x=0, y=0):
    def __add__(self, other):
        return point(self.x + other.x, self.y + other.y)

    def __rmul__(self, other):
        return point(self.x * other, self.y * other)

def chaos_game(n, shape_points):
    p = point(random(), random())

    for _ in range(n):
        p = (1/2) * (p + choice(shape_points))
        yield p


# This will generate a Sierpinski triangle with a chaos game of n points for an
# initial triangle with three points on the vertices of an equilateral triangle:
#     A = (0.0, 0.0)
#     B = (0.5, sqrt(0.75))
#     C = (1.0, 0.0)
# It will output the file sierpinski.dat, which can be plotted after
shape_points = [point(0.0, 0.0),
                point(0.5, sqrt(0.75)),
                point(1.0, 0.0)]
with open(&quot;sierpinski.dat&quot;, &quot;w&quot;) as f:
    for p in chaos_game(10000, shape_points):
        f.write(&quot;{0}\t{1}\n&quot;.format(p.x, p.y))
</code></pre>
<pre><code class="language-java">import java.io.FileWriter;
import java.util.Random;

public class IFS {

    private static class Point {
        double x, y;

        public Point(double x, double y) {
            this.x = x;
            this.y = y;
        }
    }
    
    // This is a function to simulate a &quot;chaos game&quot;
    public static Point[] chaosGame(int n, Point[] shapePoints) {
        Random rng = new Random();

        // Initialize output vector
        Point[] outputPoints = new Point[n];

        // Choose first point randomly
        Point point = new Point(rng.nextDouble(), rng.nextDouble());

        for (int i = 0; i &lt; n; i++) {
            outputPoints[i] = point;

            // Clone point to get a new reference
            point = new Point(point.x, point.y);

            // Retrieve random shape point
            Point temp = shapePoints[rng.nextInt(shapePoints.length)];
            // Calculate midpoint
            point.x = 0.5 * (point.x + temp.x);
            point.y = 0.5 * (point.y + temp.y);
        }

        return outputPoints;
    }

    public static void main(String[] args) throws Exception {
        // This will generate a Sierpinski triangle with a chaos game of n points for an
        // initial triangle with three points on the vertices of an equilateral triangle:
        //     A = (0.0, 0.0)
        //     B = (0.5, sqrt(0.75))
        //     C = (1.0, 0.0)
        // It will output the file sierpinski.dat, which can be plotted after
        Point[] shapePoints = new Point[]{
                new Point(0.0, 0.0),
                new Point(0.5, Math.sqrt(0.75)),
                new Point(1.0, 0.0)
        };
        Point[] outputPoints = chaosGame(10000, shapePoints);

        FileWriter fw = new FileWriter(&quot;sierpinski.dat&quot;);
        for (Point p : outputPoints)
            fw.write(p.x + &quot;\t&quot; + p.y + &quot;\n&quot;);
        fw.close();
    }

}
</code></pre>
<h3 id="bibliography"><a class="header" href="#bibliography">Bibliography</a></h3>
<p>{% references %} {% endreferences %}</p>
<h2 id="license"><a class="header" href="#license">License</a></h2>
<h5 id="code-examples"><a class="header" href="#code-examples">Code Examples</a></h5>
<p>The code examples are licensed under the MIT license (found in <a href="https://github.com/algorithm-archivists/algorithm-archive/blob/master/LICENSE.md">LICENSE.md</a>).</p>
<h5 id="text"><a class="header" href="#text">Text</a></h5>
<p>The text of this chapter was written by <a href="https://github.com/leios">James Schloss</a> and is licensed under the <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</p>
<p><a href="https://creativecommons.org/licenses/by-sa/4.0/"><p><img  class="center" src="../cc/CC-BY-SA_icon.svg" /></p></a></p>
<h4 id="imagesgraphics"><a class="header" href="#imagesgraphics">Images/Graphics</a></h4>
<ul>
<li>The image &quot;<a href="res/IFS_triangle_1.png">IFS triangle 1</a>&quot; was created by <a href="https://github.com/leios">James Schloss</a> and is licensed under the <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</li>
<li>The image &quot;<a href="res/IFS_triangle_2.png">IFS triangle 2</a>&quot; was created by <a href="https://github.com/leios">James Schloss</a> and is licensed under the <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</li>
<li>The image &quot;<a href="res/IFS_triangle_3.png">IFS triangle 3</a>&quot; was created by <a href="https://github.com/leios">James Schloss</a> and is licensed under the <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</li>
<li>The image &quot;<a href="res/IFS_triangle_4.png">IFS triangle 4</a>&quot; was created by <a href="https://github.com/leios">James Schloss</a> and is licensed under the <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</li>
<li>The image &quot;<a href="res/IFS_triangle_5.png">IFS triangle 5</a>&quot; was created by <a href="https://github.com/leios">James Schloss</a> and is licensed under the <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</li>
<li>The image &quot;<a href="res/IFS_square_1.png">IFS square 1</a>&quot; was created by <a href="https://github.com/leios">James Schloss</a> and is licensed under the <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</li>
<li>The image &quot;<a href="res/IFS_square_2.png">IFS square 2</a>&quot; was created by <a href="https://github.com/leios">James Schloss</a> and is licensed under the <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</li>
<li>The image &quot;<a href="res/IFS_square_3.png">IFS square 3</a>&quot; was created by <a href="https://github.com/leios">James Schloss</a> and is licensed under the <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</li>
<li>The image &quot;<a href="res/chaos_1.png">Chaos 1</a>&quot; was created by <a href="https://github.com/leios">James Schloss</a> and is licensed under the <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</li>
<li>The image &quot;<a href="res/chaos_2.png">Chaos 2</a>&quot; was created by <a href="https://github.com/leios">James Schloss</a> and is licensed under the <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</li>
<li>The video &quot;<a href="res/IFS_triangle_vid_1.mp4">IFS triangle video 1</a>&quot; was created by <a href="https://github.com/leios">James Schloss</a> and is licensed under the <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</li>
<li>The video &quot;<a href="res/IFS_triangle_vid_2.mp4">IFS triangle video 2</a>&quot; was created by <a href="https://github.com/leios">James Schloss</a> and is licensed under the <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</li>
<li>The video &quot;<a href="res/IFS_square_vid_1.mp4">IFS square video 1</a>&quot; was created by <a href="https://github.com/leios">James Schloss</a> and is licensed under the <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</li>
<li>The video &quot;<a href="res/chaos_vid_1.mp4">Chaos video 1</a>&quot; was created by <a href="https://github.com/leios">James Schloss</a> and is licensed under the <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</li>
<li>The video &quot;<a href="res/chaos_vid_2.mp4">Chaos video 2</a>&quot; was created by <a href="https://github.com/leios">James Schloss</a> and is licensed under the <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../domain_coloring/domain_coloring.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="../barnsley/barnsley.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../domain_coloring/domain_coloring.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="../barnsley/barnsley.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script type="text/javascript">
            var socket = new WebSocket("ws://0.0.0.0:3000/__livereload");
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->


    </body>
</html>
