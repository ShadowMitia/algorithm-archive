<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Euclidean Algorithm - Arcane Algorithm Archive</title>


        <!-- Custom HTML head -->

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../index.html"><strong aria-hidden="true">1.</strong> Algorithm Archive</a></li><li class="chapter-item expanded "><a href="../introduction/introduction.html"><strong aria-hidden="true">2.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="../how_to_contribute/how_to_contribute.html"><strong aria-hidden="true">3.</strong> How To Contribute</a></li><li class="chapter-item expanded "><a href="../plotting/plotting.html"><strong aria-hidden="true">4.</strong> Plotting</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../domain_coloring/domain_coloring.html"><strong aria-hidden="true">4.1.</strong> Domain Coloring</a></li><li class="chapter-item expanded "><a href="../IFS/IFS.html"><strong aria-hidden="true">4.2.</strong> Iterated Function Systems</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../barnsley/barnsley.html"><strong aria-hidden="true">4.2.1.</strong> The Barnsley Fern</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="../data_structures/data_structures.html"><strong aria-hidden="true">5.</strong> Data Structures</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../stacks_and_queues/stacks_and_queues.html"><strong aria-hidden="true">5.1.</strong> Stacks and Queues</a></li></ol></li><li class="chapter-item expanded "><a href="../mathematical_background/mathematical_background.html"><strong aria-hidden="true">6.</strong> Mathematical Background</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../notation/notation.html"><strong aria-hidden="true">6.1.</strong> Complexity Notation</a></li><li class="chapter-item expanded "><a href="../affine_transformations/affine_transformations.html"><strong aria-hidden="true">6.2.</strong> Affine Transformations</a></li><li class="chapter-item expanded "><a href="../bitlogic/bitlogic.html"><strong aria-hidden="true">6.3.</strong> Bit Logic</a></li><li class="chapter-item expanded "><a href="../taylor_series_expansion/taylor_series_expansion.html"><strong aria-hidden="true">6.4.</strong> Taylor Series</a></li><li class="chapter-item expanded "><a href="../convolutions/convolutions.html"><strong aria-hidden="true">6.5.</strong> Convolutions</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../convolutions/1d/1d.html"><strong aria-hidden="true">6.5.1.</strong> Convolutions in 1D</a></li><li class="chapter-item expanded "><a href="../convolutions/multiplication/multiplication.html"><strong aria-hidden="true">6.5.2.</strong> Multiplication as a Convolution</a></li><li class="chapter-item expanded "><a href="../convolutions/2d/2d.html"><strong aria-hidden="true">6.5.3.</strong> Convolutions of Images (2D)</a></li><li class="chapter-item expanded "><a href="../convolutions/convolutional_theorem/convolutional_theorem.html"><strong aria-hidden="true">6.5.4.</strong> Convolutional Theorem</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="../tree_traversal/tree_traversal.html"><strong aria-hidden="true">7.</strong> Tree Traversal</a></li><li class="chapter-item expanded "><a href="../euclidean_algorithm/euclidean_algorithm.html" class="active"><strong aria-hidden="true">8.</strong> Euclidean Algorithm</a></li><li class="chapter-item expanded "><a href="../monte_carlo_integration/monte_carlo_integration.html"><strong aria-hidden="true">9.</strong> Monte Carlo</a></li><li class="chapter-item expanded "><a href="../matrix_methods/matrix_methods.html"><strong aria-hidden="true">10.</strong> Matrix Methods</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../gaussian_elimination/gaussian_elimination.html"><strong aria-hidden="true">10.1.</strong> Gaussian Elimination</a></li><li class="chapter-item expanded "><a href="../thomas_algorithm/thomas_algorithm.html"><strong aria-hidden="true">10.2.</strong> Thomas Algorithm</a></li></ol></li><li class="chapter-item expanded "><a href="../computational_geometry/computational_geometry.html"><strong aria-hidden="true">11.</strong> Computational Geometry</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../gift_wrapping/gift_wrapping.html"><strong aria-hidden="true">11.1.</strong> Gift Wrapping</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../jarvis_march/jarvis_march.html"><strong aria-hidden="true">11.1.1.</strong> Jarvis March</a></li><li class="chapter-item expanded "><a href="../graham_scan/graham_scan.html"><strong aria-hidden="true">11.1.2.</strong> Graham Scan</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="../cooley_tukey/cooley_tukey.html"><strong aria-hidden="true">12.</strong> FFT</a></li><li class="chapter-item expanded "><a href="../decision_problems/decision_problems.html"><strong aria-hidden="true">13.</strong> Decision Problems</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../stable_marriage_problem/stable_marriage_problem.html"><strong aria-hidden="true">13.1.</strong> Stable Marriage Problem</a></li></ol></li><li class="chapter-item expanded "><a href="../physics_solvers/physics_solvers.html"><strong aria-hidden="true">14.</strong> Physics Solvers</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../verlet_integration/verlet_integration.html"><strong aria-hidden="true">14.1.</strong> Verlet Integration</a></li><li class="chapter-item expanded "><a href="../quantum_systems/quantum_systems.html"><strong aria-hidden="true">14.2.</strong> Quantum Systems</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../split-operator_method/split-operator_method.html"><strong aria-hidden="true">14.2.1.</strong> Split-Operator Method</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="../data_compression/data_compression.html"><strong aria-hidden="true">15.</strong> Data Compression</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../huffman_encoding/huffman_encoding.html"><strong aria-hidden="true">15.1.</strong> Huffman Encoding</a></li></ol></li><li class="chapter-item expanded "><a href="../computer_graphics/computer_graphics.html"><strong aria-hidden="true">16.</strong> Computer Graphics</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../flood_fill/flood_fill.html"><strong aria-hidden="true">16.1.</strong> Flood Fill</a></li></ol></li><li class="chapter-item expanded "><a href="../quantum_information/quantum_information.html"><strong aria-hidden="true">17.</strong> Quantum Information</a></li><li class="chapter-item expanded "><a href="../computus/computus.html"><strong aria-hidden="true">18.</strong> Computus</a></li><li class="chapter-item expanded "><a href="../approximate_counting/approximate_counting.html"><strong aria-hidden="true">19.</strong> Approximate Counting Algorithm</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Arcane Algorithm Archive</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/algorithm-archivists/algorithm-archive/" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="euclidean-algorithm"><a class="header" href="#euclidean-algorithm">Euclidean Algorithm</a></h1>
<p>Computer science is (almost by definition) a science about computers -- a device first conceptualized in the 1800's. Computers have become so revolutionary, that it is difficult to think of our lives today without them. That said, <em>algorithms</em> are much older and have existed in the world for millennia. Incredibly, a few of the algorithms created before the Common Era (AD) are still in use today. One such algorithm was first described in Euclid's <em>Elements</em> (~ 300 BC) and has come to be known as the <em>Euclidean Algorithm</em>.</p>
<p>The algorithm is a simple way to find the <em>greatest common divisor</em> (GCD) of two numbers, which is useful for a number of different applications (like reducing fractions). The first method (envisioned by Euclid) uses simple subtraction:</p>
<pre><code class="language-vim">function s:euclid_sub(a, b)
	let l:a = abs(a:a)
	let l:b = abs(a:b)

	while l:a != l:b
		if l:a &gt; l:b
			let l:a -= l:b
		else
			let l:b -= l:a
		endif
	endwhile

	return l:a
endfunction
</code></pre>
<pre><code class="language-c_cpp">int euclid_sub(int a, int b) {
    a = abs(a);
    b = abs(b);

    while (a != b) {
        if (a &gt; b) {
            a -= b;
        } else {
            b -= a;
        }
    }

    return a;
}
</code></pre>
<pre><code class="language-csharp">        public int EuclidSub(int a, int b)
        {
            // Math.Abs for negative number support
            a = Math.Abs(a);
            b = Math.Abs(b);

            while (a != b)
            {
                if (a &gt; b)
                    a = a - b;
                else
                    b = b - a;
            }

            return a;
        }
</code></pre>
<pre><code class="language-clojure">(defn euclid-sub [a b]
  (loop [i (Math/abs a) j (Math/abs b)]
    (if (= i j)
      i
      (if (&gt; i j)
        (recur (- i j) j)
        (recur i (- j i))))))
</code></pre>
<pre><code class="language-c_cpp">int euclid_sub(int a, int b) {
  a = std::abs(a);
  b = std::abs(b);

  while (a != b) {
    if (a &gt; b) {
      a -= b;
    } else {
      b -= a;
    }
  }

  return a;
}
</code></pre>
<pre><code class="language-java">    public static int euclidSub(int a, int b) {
        a = Math.abs(a);
        b = Math.abs(b);
        
        while (a != b) {
            if (a &gt; b) {
                a -= b;
            } else {
                b -= a;
            }
        }
        
        return a;
    }
</code></pre>
<pre><code class="language-kotlin">fun euclidSub(a: Int, b: Int): Int {
    var a = a.absoluteValue
    var b = b.absoluteValue

    while (a != b) {
        if (a &gt; b) a -= b
        else b -= a
    }

    return a
}
</code></pre>
<pre><code class="language-javascript">function euclidSub(a, b) {
  a = Math.abs(a);
  b = Math.abs(b);

  while (a !== b) {
    if (a &gt; b) {
      a -= a - b;
    } else {
      b = b - a;
    }
  }

  return a;
}

</code></pre>
<pre><code class="language-lisp">(defun euclid-sub (a b)
  &quot;Finds the greatest common divsor for any two integers&quot;
  (defun euclid-sub* (a b)
    &quot;Finds the greatest common divisor for any two positive integers&quot;
    (if (eql a b)
        a
        (if (&gt; a b)
            (euclid-sub* (- a b) b)
            (euclid-sub* a (- b a)))))
  (euclid-sub* (abs a) (abs b)))
</code></pre>
<pre><code class="language-python">def euclid_sub(a, b):

    a = abs(a)
    b = abs(b)

    if a == 0:
        return b
    elif b == 0:
        return a

    while a != b:
        if a &gt; b:
            a -= b
        else:
            b -= a

    return a
</code></pre>
<pre><code class="language-haskell">euclidSub :: Integer -&gt; Integer -&gt; Integer
euclidSub a b = inner (abs a) (abs b)
  where
    inner x y
      -- if a = b, then the gcd is a
      | x == y = x
      -- if a &lt; b: Recursively call euclidSub with the a and (b-a) as new inputs
      | x &lt; y = euclidSub x (y - x)
      -- otherwise: Recursively call euclidSub with the a and (b-a) as new inputs
      | otherwise = euclidSub (x - y) y

</code></pre>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn euclid_sub(mut a: i64, mut b: i64) -&gt; i64 {
    a = a.abs();
    b = b.abs();
    while a != b {
        if a &lt; b {
            b -= a;
        } else {
            a -= b;
        }
    }

    a
}
<span class="boring">}
</span></code></pre></pre>
<pre><code class="language-ocaml">let euclid_sub a b =
  let rec inner a b =
    if a = b then
      a
    else if a &lt; b then
      inner a (b - a)
    else
      inner (a - b) b
  in (inner (abs a) (abs b))
</code></pre>
<pre><code class="language-go">func euclidSub(a, b int) int {
	a = abs(a)
	b = abs(b)

	for a != b {
		if a &gt; b {
			a -= b
		} else {
			b -= a
		}
	}

	return a
}
</code></pre>
<pre><code class="language-swift">func euclidSub(a: Int, b: Int) -&gt; Int {
    var a = abs(a)
    var b = abs(b)
    
    while (a != b) {
        if (a &gt; b) {
            a -= b
        } else {
            b -= a
        }
    }
    
    return a
}
</code></pre>
<pre><code class="language-matlab">function gcd = euclidSub(a,b)
    
    a = abs(a);
    b = abs(b);
    
    while a ~= b
        if a &gt; b
            a = a - b;
        else
            b = b - a;
        end
    end
    
    gcd = a;
end
</code></pre>
<pre><code class="language-lua">local function euclid_sub(a, b)
  a = math.abs(a)
  b = math.abs(b)

  while a ~= b do
    if a &gt; b then
      a = a-b
    else
      b = b-a
    end
  end

  return a
end
</code></pre>
<pre><code class="language-julia">function euclid_sub(a::Int64, b::Int64)
    a = abs(a)
    b = abs(b)

    while (a != b)
        if (a &gt; b)
            a -= b
        else
            b -= a
        end
    end

    return a
end
</code></pre>
<pre><code class="language-nim">func euclid_sub(in1, in2: int): int =
  var
    a = abs(in1)
    b = abs(in2)

  while a != b:
    if a &gt; b:
      a -= b
    else:
      b -= a

  result = a
</code></pre>
<pre><code class="language-asm-x64">euclid_sub:
  mov    rax, rdi           # Get abs of a
  sar    rax, 31
  xor    rdi, rax
  sub    rdi, rax
  mov    rax, rsi           # Get abs of b
  sar    rax, 31
  xor    rsi, rax
  sub    rsi, rax
  jmp    check
loop:
  cmp    rdi, rsi           # Find which is bigger
  jle    if_true
  sub    rdi, rsi           # If a is bigger then a -= b
  jmp    check
if_true:
  sub    rsi, rdi           # Else b -= a
check:
  cmp    rsi, rdi           # Check if a and b are not equal
  jne    loop
  mov    rax, rdi           # Return results
  ret
</code></pre>
<pre><code class="language-fortran">INTEGER FUNCTION euclid_sub(a, b)
    IMPLICIT NONE
    INTEGER, INTENT(INOUT) :: a, b

    a = ABS(a)
    b = ABS(b)

    DO WHILE (a /= b)
    
        IF (a &gt; b) THEN
            a = a - b
        ELSE
            b = b - a
        END IF
    END DO

    euclid_sub = a

END FUNCTION euclid_sub 
</code></pre>
<pre><code class="language-php">function euclid_sub(int $a, int $b): int
{
    $a = abs($a);
    $b = abs($b);

    while ($a !== $b) {
        if ($a &gt; $b) {
            $a = $a - $b;
        } else {
            $b = $b - $a;
        }
    }

    return $a;
}
</code></pre>
<pre><code class="language-factor">: euclid- ( a b -- gcd )
  [ abs ] bi@
  [ 2dup = ]
  [
    ! make sure the lower number is deeper
    2dup &gt;= [ swap ] when
    over -
    ! leaves us with stack { &lt;lower&gt; &lt;greater - lower&gt; }
  ]
  until
  ! we have the GCD twice now, drop one
  drop
;
</code></pre>
<pre><code class="language-whitespace">Euclidian algorithm subtraction method.
Enter two positive integers.	
	
			
		
  			  	    
   
			   	
				  	 
 
	 			  	   	
 
 
					  	  	 
   
 
			 
 
			  	    

  			  	   	
   
				
 	



  			  	  	 
   
 
		  	   	
 
			 
 
The			  	    
end.
</code></pre>
<pre><code class="language-scala">  def euclid_sub(a: Int, b: Int): Int =
    (Math.abs(a), Math.abs(b)) match {
      case (0, _) | (_, 0) =&gt; 0
      case (x, y) if x &lt; y =&gt; euclid(x, y - x)
      case (x, y) if x &gt; y =&gt; euclid(x - y, y)
      case _ =&gt; a
</code></pre>
<pre><code class="language-racket">(define (euclid_sub a b)
  (local ((define (euclid_sub* x y)
          (if (= x y)
              x
              (if (&gt; x y)
                  (euclid_sub* (- x y) y)
                  (euclid_sub* x (- y x))
                  )
              )
          )) (euclid_sub* (abs a) (abs b))
    )
  )
</code></pre>
<pre><code class="language-ruby">def gcd_minus(a, b)
	a = a.abs
	b = b.abs
	until a == b
		if a &gt; b
			a -= b
		else
			b -= a
		end
	end
	a
end
</code></pre>
<pre><code class="language-smalltalk">Integer&gt;&gt;euclidSub: secondNumber
    &quot;Euclidean algorithm with subtraction&quot;
    | a b |
    a := self abs.
    b := secondNumber abs.
    [ a == b ] whileFalse: [ 
        a &gt; b ifTrue: [ 
            a := a - b.
        ] ifFalse: [ 
            b := b - a.
        ].
    ].
    ^a.
</code></pre>
<pre><code class="language-emojicode">  üêá ‚ùóÔ∏è üîº a üî¢ b üî¢ ‚û°Ô∏è üî¢ üçá
    üí≠ Use üèß (returns the absolute value) to support negative numbers.
    üèßa ‚ùóÔ∏è ‚û°Ô∏è üñçüÜïvar_a
    üèßb ‚ùóÔ∏è ‚û°Ô∏è üñçüÜïvar_b

    Ô∏èüîÅ ‚ùé var_a üôå var_b ‚ùóÔ∏è üçá
      ‚Ü™Ô∏è var_a ‚ñ∂Ô∏è var_b üçá
        var_a ‚¨ÖÔ∏è ‚ûñ var_b
      üçâ
      üôÖ üçá
        var_b ‚¨ÖÔ∏è ‚ûñ var_a
      üçâ
    üçâ

    ‚Ü©Ô∏è var_a
  üçâ
</code></pre>
<pre><code class="language-LOLCODE">    HOW IZ I UKLIDSUP YR NUM1 AN YR NUM2
        NUM1 R I IZ ABZ YR NUM1 MKAY
        NUM2 R I IZ ABZ YR NUM2 MKAY

        IM IN YR LOOP 
            BOTH SAEM NUM1 AN NUM2, O RLY?
                YA RLY, FOUND YR NUM1
            OIC        

            DIFFRINT NUM1 AN SMALLR OF NUM1 AN NUM2, O RLY?
                YA RLY, NUM1 R DIFF OF NUM1 AN NUM2
                NO WAI, NUM2 R DIFF OF NUM2 AN NUM1
            OIC
        IM OUTTA YR LOOP

    IF U SAY SO
</code></pre>
<pre><code class="language-bash">euclid_sub() {
    local a
    local b
    a=$(abs &quot;$1&quot;)
    b=$(abs &quot;$2&quot;)
    
    while (( a != b )); do
        if (( a &gt; b )); then
            ((a -= b))
        else
            ((b -= a))
        fi
    done
    printf &quot;%s&quot; &quot;$a&quot;
}
</code></pre>
<pre><code class="language-d">// Euclidean algorithm with subtraction
int euclid_sub(int a, int b) {
    a = abs(a);
    b = abs(b);

    while (a != b) {
        if (a &gt; b) {
            a -= b;
        } else {
            b -= a;
        }
    }

    return a;
}
</code></pre>
<blockquote>
<p><img src="code/piet/subtract/euclidian_algorithm_subtract_large.png" alt="" /> <img src="code/piet/subtract/euclidian_algorithm_subtract.png" alt="" /></p>
</blockquote>
<pre><code class="language-scheme">(define (euclid-sub a b)
    (cond                                                                                                                                                                                                                                                                         
        [(or (negative? a)(negative? b))(euclid-sub (abs a)(abs b))]                                                                                                                                                                                                              
        [(eq? a b) a]
        [(&gt; a b)(euclid-sub(- a b) b)]
        [else
            (euclid-sub a (- b a))]))
</code></pre>
<!-- {% sample lang="scratch" %} -->
<p>
  <img  class="center" src="code/scratch/euclid_sub.svg" style="width:30%" />
</p>
# leave one line empty:
<pre><code class="language-powershell">function Sub-Euclid($a, $b) {
    $a = [Math]::Abs($a)
    $b = [Math]::Abs($b)

    while ($a -ne $b) {
        if ($a -gt $b) {
            $a = $a - $b
        } else {
            $b = $b - $a
        }
    }
    
    return $a
}
</code></pre>
<pre><code class="language-coconut">def euclid_sub(a is int, 0) = a
addpattern def euclid_sub(0, b is int) = b

addpattern def euclid_sub(a is int, b is int):
    if a &lt; b:
        return euclid_sub(a, b - a)
    elif b &lt; a:
        return euclid_sub(a - b, b)
    return a
</code></pre>
<p>Here, we simply line the two numbers up every step and subtract the lower value from the higher one every timestep. Once the two values are equal, we call that value the greatest common divisor. A graph of <code>a</code> and <code>b</code> as they change every step would look something like this:</p>
<p>
    <img  class="center" src="res/subtraction.png" style="width:70%" />
</p>
<p>Modern implementations, though, often use the modulus operator (%) like so</p>
<pre><code class="language-vim">function s:euclid_mod(a, b)
	let l:a = abs(a:a)
	let l:b = abs(a:b)

	while l:b != 0
		let l:c = l:b
		let l:b = l:a % l:b
		let l:a = l:c
	endwhile

	return l:a
endfunction
</code></pre>
<pre><code class="language-c">int euclid_mod(int a, int b) {
    a = abs(a);
    b = abs(b);

    while (b != 0) {
        int temp = b;
        b = a % b;
        a = temp;
    }

    return a;
}

</code></pre>
<pre><code class="language-csharp">        public int EuclidMod(int a, int b)
        {
            // Math.Abs for negative number support
            a = Math.Abs(a);
            b = Math.Abs(b);

            while (b != 0)
            {
                var temp = b;
                b = a % b;
                a = temp;
            }

            return a;
        }
</code></pre>
<pre><code class="language-clojure">(defn euclid-mod [a b]
  (loop [i (Math/abs a) j (Math/abs b)]
    (if (zero? j)
      i
      (recur j (% i j)))))
</code></pre>
<pre><code class="language-c_cpp">// Euclidean algorithm using modulus
int euclid_mod(int a, int b) {
  a = std::abs(a);
  b = std::abs(b);

  while (b != 0) {
    a = std::exchange(b, a % b);
  }

  return a;
}
</code></pre>
<pre><code class="language-java">    public static int euclidMod(int a, int b) {
        while (b != 0) {
            int tmp = b;
            b = a % b;
            a = tmp;
        }

        return a;
    }
</code></pre>
<pre><code class="language-kotlin">fun euclidMod(a: Int, b: Int): Int {
    var a = a.absoluteValue
    var b = b.absoluteValue

    while (b != 0) {
        val tmp = b
        b = a % b
        a = tmp
    }

    return a
}
</code></pre>
<pre><code class="language-javascript">function euclidMod(a, b) {
  a = Math.abs(a);
  b = Math.abs(b);

  let temp;
  while (b !== 0) {
    temp = b;
    b = a % b;
    a = temp;
  }

  return a;
}
</code></pre>
<pre><code class="language-lisp">(defun euclid-mod (a b)
  &quot;Finds the greatest common divisor for any two integers&quot;
  (if (zerop b)
      (abs a)
      (euclid-mod b (mod a b))))
</code></pre>
<pre><code class="language-python">def euclid_mod(a, b):

    a = abs(a)
    b = abs(b)

    while b &gt; 0:
        a, b = b, a % b

    return a
</code></pre>
<pre><code class="language-haskell">euclidMod :: Integer -&gt; Integer -&gt; Integer
euclidMod a b = inner (abs a) (abs b)
  where
    -- if a divides b, then gcd is a
    inner x 0 = x
    -- otherwise, recursively call inner with b and (a mod b) as new inputs
    inner x y = inner y (x `mod` y)

</code></pre>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn euclid_rem(mut a: i64, mut b: i64) -&gt; i64 {
    a = a.abs();
    b = b.abs();
    while b != 0 {
        let tmp = b;
        b = a % b;
        a = tmp;
    }

    a
}
<span class="boring">}
</span></code></pre></pre>
<pre><code class="language-ocaml">let euclid_mod a b =
  let rec inner a = function
  | 0 -&gt; a
  | b -&gt; inner b (a mod b)
  in (inner (abs a) (abs b))
</code></pre>
<pre><code class="language-go">func euclidMod(a, b int) int {
	a = abs(a)
	b = abs(b)

	for b != 0 {
		a, b = b, a%b
	}

	return a
}
</code></pre>
<pre><code class="language-swift">func euclidMod(a: Int, b: Int) -&gt; Int {
    var a = abs(a);
    var b = abs(b);
    
    while (b != 0) {
        let temp = b
        b = a % b
        a = temp
    }
    
    return a
}
</code></pre>
<pre><code class="language-matlab">function gcd = euclidMod(a,b)
    
    a=abs(a);
    b=abs(b);
    
    while b &gt; 0
        temp = b;
        b = mod(a,b);
        a = temp;
    end
    
    gcd = a;
end
</code></pre>
<pre><code class="language-lua">local function euclid_mod(a, b)
  a = math.abs(a)
  b = math.abs(b)

  while b ~= 0 do
    a, b = b, a%b
  end

  return a
end
</code></pre>
<pre><code class="language-julia">function euclid_mod(a::Int64, b::Int64)
    a = abs(a)
    b = abs(b)

    while(b != 0)
        b,a = a%b,b
    end

    return a
end
</code></pre>
<pre><code class="language-nim">func euclid_mod(in1, in2: int): int =
  var
    a = abs(in1)
    b = abs(in2)

  while b != 0:
    let temp: int = b
    b = a mod b
    a = temp;

  result = a
</code></pre>
<pre><code class="language-asm-x64"># rdi - a
# rsi - b
# RET rax - gcd of a and b
euclid_mod:
  mov    rax, rdi           # Get abs of a
  sar    rax, 31
  xor    rdi, rax
  sub    rdi, rax
  mov    rax, rsi           # Get abs of b
  sar    rax, 31
  xor    rsi, rax
  sub    rsi, rax
  jmp    mod_check
mod_loop:
  xor    rdx, rdx           # Take the mod of a and b
  mov    rax, rdi
  div    rsi
  mov    rdi, rsi           # Set b to the mod of a and b
  mov    rsi, rdx           # Set a to b
mod_check:
  cmp    rsi, 0             # Check if b is non-zero
  jne    mod_loop
  mov    rax, rdi           # Return the result
  ret
</code></pre>
<pre><code class="language-fortran">INTEGER FUNCTION euclid_mod(a, b)
    IMPLICIT NONE
    INTEGER, INTENT(INOUT) :: a, b
    INTEGER                :: temp

    DO WHILE (b &gt; 0)
        temp = b
        b = MODULO(a,b)
        a = temp
    END DO

    euclid_mod = a

END FUNCTION euclid_mod
</code></pre>
<pre><code class="language-php">function euclid_mod(int $a, int $b): int
{
    $a = abs($a);
    $b = abs($b);

    while ($b !== 0) {
        list($b, $a) = [$a % $b, $b];
    }

    return $a;
}
</code></pre>
<pre><code class="language-factor">: euclid% ( a b -- gcd )
  [ abs ] bi@   ! take both absolute values
  [ dup zero? ] ! check if `b` (on top) is 0
  [
    ! a b -&gt; a b b -&gt; b a b -&gt; b a%b
    dup -rot mod
  ]
  until
  ! the zero is on top, so get rid of it
  drop
;
</code></pre>
<pre><code class="language-whitespace">Euclidian algorithm modulo method.
Enter two positive integers.	
	
			
		
  
   
			 
 
	 	
   	
			 
		 		   
			   	
 
			    
 
			 
 


  	
   	
				
 	

The
end.
</code></pre>
<pre><code class="language-scala">
  def euclid_mod(a: Int, b: Int): Int =
    (Math.abs(a), Math.abs(b)) match {
      case (_, 0) =&gt; a
      case (a, b) =&gt; euclid_mod(b, a % b)
</code></pre>
<pre><code class="language-racket">(define (euclid_mod a b)
  (local ((define (euclid_mod* a b)
           (if (= 0 b)
               (abs a)
               (euclid_mod* b (modulo a b))
               )
           )) (euclid_mod* a b)
    )
  )
</code></pre>
<pre><code class="language-ruby">def gcd_mod(a, b)
	a = a.abs
	b = b.abs
	a, b = b, a%b until b.zero?
	a
end
</code></pre>
<pre><code class="language-smalltalk">Integer&gt;&gt;euclidMod: secondNumber
    &quot;Euclidean algorithm with modulus.&quot;
    | a b oldB |
    a := self abs.
    b := secondNumber abs.
    [ b == 0 ] whileFalse: [ 
        oldB := b.
        b := a % b.
        a := oldB.
    ].
    ^a.
</code></pre>
<pre><code class="language-emojicode">  üêá ‚ùóÔ∏è ‚è´ a üî¢ b üî¢ ‚û°Ô∏è üî¢ üçá
    üí≠ Use üèß (returns the absolute value) to support negative numbers.
    üèßa ‚ùóÔ∏è ‚û°Ô∏è üñçüÜïvar_a
    üèßb ‚ùóÔ∏è ‚û°Ô∏è üñçüÜïvar_b

    Ô∏èüîÅ ‚ùé var_b üôå 0 ‚ùóÔ∏è üçá
      var_b ‚û°Ô∏è temp
      var_a üöÆ var_b ‚û°Ô∏è üñçvar_b
      temp ‚û°Ô∏è üñçvar_a
    üçâ

    ‚Ü©Ô∏è var_a
  üçâ
</code></pre>
<pre><code class="language-LOLCODE">    HOW IZ I UKLIDMOD YR NUM1 AN YR NUM2
        NUM1 R I IZ ABZ YR NUM1 MKAY
        NUM2 R I IZ ABZ YR NUM2 MKAY

        IM IN YR LOOP 
            BOTH SAEM NUM2 AN 0, O RLY?
                YA RLY, FOUND YR NUM1
            OIC

            I HAS A TMP ITZ NUM2
            NUM2 R MOD OF NUM1 AN NUM2
            NUM1 R TMP
        IM OUTTA YR LOOP

    IF U SAY SO
</code></pre>
<pre><code class="language-bash">euclid_mod() {
    local a
    local b
    a=$(abs &quot;$1&quot;)
    b=$(abs &quot;$2&quot;)
    
    while (( b != 0 )); do
        ((tmp = b))
        ((b = a % b))
        ((a = tmp))
    done
    printf &quot;%s&quot; &quot;$a&quot;
}
</code></pre>
<pre><code class="language-d">// Euclidean algorithm using modulus
int euclid_mod(int a, int b) {
    int tmp;
    a = abs(a);
    b = abs(b);

    while (b != 0) {
        tmp = a % b;
        a = b;
        b = tmp;
    }

    return a;
}
</code></pre>
<!-- {% sample lang="piet" %} -->
<blockquote>
<p><img src="code/piet/mod/euclidian_algorithm_mod_large.png" alt="" /> <img src="code/piet/mod/euclidian_algorithm_mod.png" alt="" /></p>
</blockquote>
<pre><code class="language-scheme">(define (euclid-mod a b)
    (if (zero? b)
        a
        (euclid-mod b (modulo a b))))
</code></pre>
<!-- {% sample lang="scratch" %} -->
<p>
  <img  class="center" src="code/scratch/euclid_mod.svg" style="width:30%" />
</p>
# leave one line empty:
<pre><code class="language-powershell">function Mod-Euclid($a, $b) {
    $a = [Math]::Abs($a)
    $b = [Math]::Abs($b)

    while ($b -ne 0) {
        $tmp = $b
        $b = $a % $b
        $a = $tmp
    }

    return $a
}
</code></pre>
<pre><code class="language-coconut">def euclid_mod(a is int, 0) = a
addpattern def euclid_mod(0, b is int) = b

addpattern def euclid_mod(a is int, b is int) = euclid_mod(b, a % b)
</code></pre>
<p>Here, we set <code>b</code> to be the remainder of <code>a%b</code> and <code>a</code> to be whatever <code>b</code> was last timestep. Because of how the modulus operator works, this will provide the same information as the subtraction-based implementation, but when we show <code>a</code> and <code>b</code> as they change with time, we can see that it might take many fewer steps:</p>
<p>
    <img  class="center" src="res/modulus.png" style="width:70%" />
</p>
<p>The Euclidean Algorithm is truly fundamental to many other algorithms throughout the history of computer science and will definitely be used again later. At least to me, it's amazing how such an ancient algorithm can still have modern use and appeal. That said, there are still other algorithms out there that can find the greatest common divisor of two numbers that are arguably better in certain cases than the Euclidean algorithm, but the fact that we are discussing Euclid two millennia after his death shows how timeless and universal mathematics truly is. I think that's pretty cool.</p>
<h2 id="video-explanation"><a class="header" href="#video-explanation">Video Explanation</a></h2>
<p>Here's a video on the Euclidean algorithm:</p>
<div style="text-align:center">
<iframe width="560" height="315" src="https://www.youtube.com/embed/h86RzlyHfUE" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
</div>
<h2 id="example-code"><a class="header" href="#example-code">Example Code</a></h2>
<pre><code class="language-vim">function s:euclid_mod(a, b)
	let l:a = abs(a:a)
	let l:b = abs(a:b)

	while l:b != 0
		let l:c = l:b
		let l:b = l:a % l:b
		let l:a = l:c
	endwhile

	return l:a
endfunction

function s:euclid_sub(a, b)
	let l:a = abs(a:a)
	let l:b = abs(a:b)

	while l:a != l:b
		if l:a &gt; l:b
			let l:a -= l:b
		else
			let l:b -= l:a
		endif
	endwhile

	return l:a
endfunction

let s:check_1 = s:euclid_mod(64 * 67, 64 * 71)
let s:check_2 = s:euclid_sub(128 * 12, 128 * 77)

echo 'Modulus-based euclidean algorithm result:' s:check_1
echo 'subtraction-based euclidean algorithm result:' s:check_2
</code></pre>
<pre><code class="language-c_cpp">#include &lt;stdio.h&gt;
#include &lt;math.h&gt;

int euclid_mod(int a, int b) {
    a = abs(a);
    b = abs(b);

    while (b != 0) {
        int temp = b;
        b = a % b;
        a = temp;
    }

    return a;
}

int euclid_sub(int a, int b) {
    a = abs(a);
    b = abs(b);

    while (a != b) {
        if (a &gt; b) {
            a -= b;
        } else {
            b -= a;
        }
    }

    return a;
}

int main() {
    int check1 = euclid_mod(64 * 67, 64 * 81);
    int check2 = euclid_sub(128 * 12, 128 * 77);

    printf(&quot;%d\n&quot;, check1);
    printf(&quot;%d\n&quot;, check2);

    return 0;
}
</code></pre>
<h5 id="euclideanalgorithmcs"><a class="header" href="#euclideanalgorithmcs">EuclideanAlgorithm.cs</a></h5>
<pre><code class="language-csharp">// submitted by Julian Schacher (jspp)
using System;

namespace EuclideanAlgorithm
{
    public class EuclideanAlgorithm
    {
        public int EuclidSub(int a, int b)
        {
            // Math.Abs for negative number support
            a = Math.Abs(a);
            b = Math.Abs(b);

            while (a != b)
            {
                if (a &gt; b)
                    a = a - b;
                else
                    b = b - a;
            }

            return a;
        }

        public int EuclidMod(int a, int b)
        {
            // Math.Abs for negative number support
            a = Math.Abs(a);
            b = Math.Abs(b);

            while (b != 0)
            {
                var temp = b;
                b = a % b;
                a = temp;
            }

            return a;
        }
    }
}
</code></pre>
<h5 id="programcs"><a class="header" href="#programcs">Program.cs</a></h5>
<pre><code class="language-csharp">// submitted by Julian Schacher (jspp)
using System;

namespace EuclideanAlgorithm
{
    class Program
    {
        static void Main(string[] args)
        {
            Console.WriteLine(&quot;EuclideanAlgorithm&quot;);
            var euclideanAlgorithm = new EuclideanAlgorithm();
            int check = euclideanAlgorithm.EuclidMod(64 * 67, 64 * 81);
            int check2 = euclideanAlgorithm.EuclidSub(128 * 12, 128 * 77);

            Console.WriteLine(check);
            Console.WriteLine(check2);
        }
    }
}
</code></pre>
<pre><code class="language-clojure">;; earthfail
(defn euclid-sub [a b]
  (loop [i (Math/abs a) j (Math/abs b)]
    (if (= i j)
      i
      (if (&gt; i j)
        (recur (- i j) j)
        (recur i (- j i))))))
(defn euclid-mod [a b]
  (loop [i (Math/abs a) j (Math/abs b)]
    (if (zero? j)
      i
      (recur j (% i j)))))

(print
 (euclid-sub (* 64 67)
             (* 64 81))
 (euclid-mod (* 128 12)
             (* 128 77)))
</code></pre>
<pre><code class="language-c_cpp">#include &lt;cmath&gt;
#include &lt;iostream&gt;
#include &lt;utility&gt;

// Euclidean algorithm using modulus
int euclid_mod(int a, int b) {
  a = std::abs(a);
  b = std::abs(b);

  while (b != 0) {
    a = std::exchange(b, a % b);
  }

  return a;
}

// Euclidean algorithm with subtraction
int euclid_sub(int a, int b) {
  a = std::abs(a);
  b = std::abs(b);

  while (a != b) {
    if (a &gt; b) {
      a -= b;
    } else {
      b -= a;
    }
  }

  return a;
}

int main() {
  auto check1 = euclid_mod(64 * 67, 64 * 81);
  auto check2 = euclid_sub(128 * 12, 128 * 77);

  std::cout &lt;&lt; check1 &lt;&lt; '\n';
  std::cout &lt;&lt; check2 &lt;&lt; '\n';
}
</code></pre>
<pre><code class="language-java">// submitted by lolatomroflsinnlos, modified by xam4lor
public class EuclideanAlgo {
    public static int euclidSub(int a, int b) {
        a = Math.abs(a);
        b = Math.abs(b);
        
        while (a != b) {
            if (a &gt; b) {
                a -= b;
            } else {
                b -= a;
            }
        }
        
        return a;
    }
    
    public static int euclidMod(int a, int b) {
        while (b != 0) {
            int tmp = b;
            b = a % b;
            a = tmp;
        }

        return a;
    }
    
    public static void main(String[] args) {
        System.out.println(euclidMod(64 * 67, 64 * 81));
        System.out.println(euclidSub(128 * 12, 128 * 77));
    }
}
</code></pre>
<pre><code class="language-kotlin">import kotlin.math.absoluteValue

fun euclidSub(a: Int, b: Int): Int {
    var a = a.absoluteValue
    var b = b.absoluteValue

    while (a != b) {
        if (a &gt; b) a -= b
        else b -= a
    }

    return a
}

fun euclidMod(a: Int, b: Int): Int {
    var a = a.absoluteValue
    var b = b.absoluteValue

    while (b != 0) {
        val tmp = b
        b = a % b
        a = tmp
    }

    return a
}

fun main(args: Array&lt;String&gt;) {
    println(euclidSub(128 * 12, 128 * 77))
    println(euclidMod(64 * 67, 64 * 81))
}
</code></pre>
<pre><code class="language-javascript">function euclidMod(a, b) {
  a = Math.abs(a);
  b = Math.abs(b);

  let temp;
  while (b !== 0) {
    temp = b;
    b = a % b;
    a = temp;
  }

  return a;
}

function euclidSub(a, b) {
  a = Math.abs(a);
  b = Math.abs(b);

  while (a !== b) {
    if (a &gt; b) {
      a -= a - b;
    } else {
      b = b - a;
    }
  }

  return a;
}

console.log(euclidMod(64 * 67, 64 * 81));
console.log(euclidSub(128 * 12, 128 * 77));
</code></pre>
<pre><code class="language-lisp">;;;; Euclidean algorithm implementation in Common Lisp

(defun euclid-sub (a b)
  &quot;Finds the greatest common divsor for any two integers&quot;
  (defun euclid-sub* (a b)
    &quot;Finds the greatest common divisor for any two positive integers&quot;
    (if (eql a b)
        a
        (if (&gt; a b)
            (euclid-sub* (- a b) b)
            (euclid-sub* a (- b a)))))
  (euclid-sub* (abs a) (abs b)))

(defun euclid-mod (a b)
  &quot;Finds the greatest common divisor for any two integers&quot;
  (if (zerop b)
      (abs a)
      (euclid-mod b (mod a b))))

(print (euclid-sub (* 64 67) (* 64 81)))
(print (euclid-mod (* 128 12) (* 128 77)))

;; Quick test
(assert
  (eql (euclid-sub (* 64 67) (* 64 81))
       (gcd (* 64 67) (* 64 81))))

(assert
  (eql (euclid-mod (* 64 67) (* 64 81))
       (gcd (* 64 67) (* 64 81))))
</code></pre>
<pre><code class="language-python">def euclid_mod(a, b):

    a = abs(a)
    b = abs(b)

    while b &gt; 0:
        a, b = b, a % b

    return a

def euclid_sub(a, b):

    a = abs(a)
    b = abs(b)

    if a == 0:
        return b
    elif b == 0:
        return a

    while a != b:
        if a &gt; b:
            a -= b
        else:
            b -= a

    return a

if __name__==&quot;__main__&quot;:
    print('Euclidean mod: ', euclid_mod(64 * 67, 64 * 81))
    print('Euclidean sub: ', euclid_sub(128 * 12, 128 * 77))
</code></pre>
<pre><code class="language-haskell">-- Method 1: Euclid's original subtraction algorithm

euclidSub :: Integer -&gt; Integer -&gt; Integer
euclidSub a b = inner (abs a) (abs b)
  where
    inner x y
      -- if a = b, then the gcd is a
      | x == y = x
      -- if a &lt; b: Recursively call euclidSub with the a and (b-a) as new inputs
      | x &lt; y = euclidSub x (y - x)
      -- otherwise: Recursively call euclidSub with the a and (b-a) as new inputs
      | otherwise = euclidSub (x - y) y

-- _______________________________________________________________________

-- Method 2: Modern implemetation - The modulus method.

euclidMod :: Integer -&gt; Integer -&gt; Integer
euclidMod a b = inner (abs a) (abs b)
  where
    -- if a divides b, then gcd is a
    inner x 0 = x
    -- otherwise, recursively call inner with b and (a mod b) as new inputs
    inner x y = inner y (x `mod` y)

-- _________________________________________________________________________

-- Examples

main :: IO ()
main = do
  let chk1 = euclidMod (64 * 67) (64 * 81)
      chk2 = euclidSub (128 * 12) (128 * 77)
  print chk1
  print chk2
</code></pre>
<pre><pre class="playground"><code class="language-rust">// contributed by Nicole Mazzuca (ubsan)

fn euclid_sub(mut a: i64, mut b: i64) -&gt; i64 {
    a = a.abs();
    b = b.abs();
    while a != b {
        if a &lt; b {
            b -= a;
        } else {
            a -= b;
        }
    }

    a
}

fn euclid_rem(mut a: i64, mut b: i64) -&gt; i64 {
    a = a.abs();
    b = b.abs();
    while b != 0 {
        let tmp = b;
        b = a % b;
        a = tmp;
    }

    a
}

fn main() {
    let chk1 = euclid_rem(64 * 67, 64 * 81);
    let chk2 = euclid_sub(128 * 12, 128 * 77);
    println!(&quot;{}&quot;, chk1);
    println!(&quot;{}&quot;, chk2);
}
</code></pre></pre>
<pre><code class="language-ocaml">(* contributed by Nicole Mazzuca (ubsan) *)

let euclid_mod a b =
  let rec inner a = function
  | 0 -&gt; a
  | b -&gt; inner b (a mod b)
  in (inner (abs a) (abs b))

let euclid_sub a b =
  let rec inner a b =
    if a = b then
      a
    else if a &lt; b then
      inner a (b - a)
    else
      inner (a - b) b
  in (inner (abs a) (abs b))

let chk1 = euclid_mod (64 * 67) (64 * 81)
let chk2 = euclid_sub (128 * 12) (128 * 77)
let () =
  chk1 |&gt; print_int |&gt; print_newline;
  chk2 |&gt; print_int |&gt; print_newline

</code></pre>
<pre><code class="language-go">// Submitted by Chinmaya Mahesh (chin123)

package main

import &quot;fmt&quot;

func abs(a int) int {
	if a &lt; 0 {
		a = -a
	}
	return a
}

func euclidMod(a, b int) int {
	a = abs(a)
	b = abs(b)

	for b != 0 {
		a, b = b, a%b
	}

	return a
}

func euclidSub(a, b int) int {
	a = abs(a)
	b = abs(b)

	for a != b {
		if a &gt; b {
			a -= b
		} else {
			b -= a
		}
	}

	return a
}

func main() {
	check1 := euclidMod(64*67, 64*81)
	check2 := euclidSub(128*12, 128*77)

	fmt.Println(check1)
	fmt.Println(check2)
}
</code></pre>
<pre><code class="language-swift">func euclidSub(a: Int, b: Int) -&gt; Int {
    var a = abs(a)
    var b = abs(b)
    
    while (a != b) {
        if (a &gt; b) {
            a -= b
        } else {
            b -= a
        }
    }
    
    return a
}

func euclidMod(a: Int, b: Int) -&gt; Int {
    var a = abs(a);
    var b = abs(b);
    
    while (b != 0) {
        let temp = b
        b = a % b
        a = temp
    }
    
    return a
}

func main() {
    print(euclidMod(a: 64 * 67, b: 64 * 81))
    print(euclidSub(a: 128 * 12, b: 128 * 77))
}

main()
</code></pre>
<pre><code class="language-matlab">// Submitted by Max Weinstein

function gcd = euclidSub(a,b)
    
    a = abs(a);
    b = abs(b);
    
    while a ~= b
        if a &gt; b
            a = a - b;
        else
            b = b - a;
        end
    end
    
    gcd = a;
end

function gcd = euclidMod(a,b)
    
    a=abs(a);
    b=abs(b);
    
    while b &gt; 0
        temp = b;
        b = mod(a,b);
        a = temp;
    end
    
    gcd = a;
end

function euclid()
    ['gcd(520,420) via euclidSub: ',num2str(euclidSub(520,420))]
    ['gcd(183,244) via euclidMod: ',num2str(euclidMod(183,244))]
end
</code></pre>
<pre><code class="language-lua">local function euclid_sub(a, b)
  a = math.abs(a)
  b = math.abs(b)

  while a ~= b do
    if a &gt; b then
      a = a-b
    else
      b = b-a
    end
  end

  return a
end

local function euclid_mod(a, b)
  a = math.abs(a)
  b = math.abs(b)

  while b ~= 0 do
    a, b = b, a%b
  end

  return a
end

local function main()
  print(euclid_sub(128 * 12, 128 * 77))
  print(euclid_mod(64 * 67, 64 * 81))
end

main()
</code></pre>
<pre><code class="language-julia">function euclid_mod(a::Int64, b::Int64)
    a = abs(a)
    b = abs(b)

    while(b != 0)
        b,a = a%b,b
    end

    return a
end

function euclid_sub(a::Int64, b::Int64)
    a = abs(a)
    b = abs(b)

    while (a != b)
        if (a &gt; b)
            a -= b
        else
            b -= a
        end
    end

    return a
end

function main()
    check1 = euclid_mod(64 * 67, 64 * 81);
    check2 = euclid_sub(128 * 12, 128 * 77);

    println(&quot;Modulus-based euclidean algorithm result: $(check1)&quot;)
    println(&quot;subtraction-based euclidean algorithm result: $(check2)&quot;)

end

main()
</code></pre>
<p>{% sample lang=&quot;nim&quot; %}
<a href="code/nim/euclid_algorithm.nim">import, lang=&quot;nim&quot; %</a></p>
<pre><code class="language-asm-x64">.intel_syntax noprefix

.section .rodata
  fmt:  .string &quot;%d\n&quot;

.section .text
  .global main
  .extern printf

# rdi - a
# rsi - b
# RET rax - gcd of a and b
euclid_mod:
  mov    rax, rdi           # Get abs of a
  sar    rax, 31
  xor    rdi, rax
  sub    rdi, rax
  mov    rax, rsi           # Get abs of b
  sar    rax, 31
  xor    rsi, rax
  sub    rsi, rax
  jmp    mod_check
mod_loop:
  xor    rdx, rdx           # Take the mod of a and b
  mov    rax, rdi
  div    rsi
  mov    rdi, rsi           # Set b to the mod of a and b
  mov    rsi, rdx           # Set a to b
mod_check:
  cmp    rsi, 0             # Check if b is non-zero
  jne    mod_loop
  mov    rax, rdi           # Return the result
  ret

euclid_sub:
  mov    rax, rdi           # Get abs of a
  sar    rax, 31
  xor    rdi, rax
  sub    rdi, rax
  mov    rax, rsi           # Get abs of b
  sar    rax, 31
  xor    rsi, rax
  sub    rsi, rax
  jmp    check
loop:
  cmp    rdi, rsi           # Find which is bigger
  jle    if_true
  sub    rdi, rsi           # If a is bigger then a -= b
  jmp    check
if_true:
  sub    rsi, rdi           # Else b -= a
check:
  cmp    rsi, rdi           # Check if a and b are not equal
  jne    loop
  mov    rax, rdi           # Return results
  ret

main:
  mov    rdi, 4288          # Call euclid_mod
  mov    rsi, 5184
  call   euclid_mod
  mov    rdi, OFFSET fmt    # Print output
  mov    rsi, rax
  xor    rax, rax
  call   printf
  mov    rdi, 1536          # Call euclid_sub
  mov    rsi, 9856
  call   euclid_sub
  mov    rdi, OFFSET fmt    # Print output
  mov    rsi, rax
  xor    rax, rax
  call   printf
  xor    rax, rax           # Return 0
  ret
</code></pre>
<pre><code class="language-fortran">INTEGER FUNCTION euclid_sub(a, b)
    IMPLICIT NONE
    INTEGER, INTENT(INOUT) :: a, b

    a = ABS(a)
    b = ABS(b)

    DO WHILE (a /= b)
    
        IF (a &gt; b) THEN
            a = a - b
        ELSE
            b = b - a
        END IF
    END DO

    euclid_sub = a

END FUNCTION euclid_sub 

INTEGER FUNCTION euclid_mod(a, b)
    IMPLICIT NONE
    INTEGER, INTENT(INOUT) :: a, b
    INTEGER                :: temp

    DO WHILE (b &gt; 0)
        temp = b
        b = MODULO(a,b)
        a = temp
    END DO

    euclid_mod = a

END FUNCTION euclid_mod

PROGRAM euclidean

    IMPLICIT NONE
    INTEGER :: a, b, euclid_sub, euclid_mod
    
    a = 24
    b = 27
    WRITE(*,*) 'Subtraction method: GCD is: ', euclid_sub(a, b)
    
    a = 24
    b = 27
    WRITE(*,*) 'Modulus method:     GCD is: ', euclid_mod(a, b)

END PROGRAM euclidean 
</code></pre>
<pre><code class="language-php">&lt;?php
declare(strict_types=1);

function euclid_sub(int $a, int $b): int
{
    $a = abs($a);
    $b = abs($b);

    while ($a !== $b) {
        if ($a &gt; $b) {
            $a = $a - $b;
        } else {
            $b = $b - $a;
        }
    }

    return $a;
}

function euclid_mod(int $a, int $b): int
{
    $a = abs($a);
    $b = abs($b);

    while ($b !== 0) {
        list($b, $a) = [$a % $b, $b];
    }

    return $a;
}

printf('Euclidean mod: %s', euclid_mod(64 * 67, 64 * 81));
echo PHP_EOL;
printf('Euclidean sub: %s', euclid_sub(128 * 12, 128 * 77));
echo PHP_EOL;
</code></pre>
<pre><code class="language-factor">: euclid- ( a b -- gcd )
  [ abs ] bi@
  [ 2dup = ]
  [
    ! make sure the lower number is deeper
    2dup &gt;= [ swap ] when
    over -
    ! leaves us with stack { &lt;lower&gt; &lt;greater - lower&gt; }
  ]
  until
  ! we have the GCD twice now, drop one
  drop
;

: euclid% ( a b -- gcd )
  [ abs ] bi@   ! take both absolute values
  [ dup zero? ] ! check if `b` (on top) is 0
  [
    ! a b -&gt; a b b -&gt; b a b -&gt; b a%b
    dup -rot mod
  ]
  until
  ! the zero is on top, so get rid of it
  drop
;

42 56 euclid% .  ! 14
48 180 euclid% . ! 12

42 56 euclid- .  ! 14
48 180 euclid- . ! 12

</code></pre>
<pre><code class="language-whitespace">Reading the input: a, b
[SPACE][SPACE][SPACE][LF]            push 0
[SPACE][SPACE][SPACE][TAB][LF]       push 1
[TAB][LF][TAB][TAB]                  readi
[TAB][LF][TAB][TAB]                  readi

Loop: a, b =&gt; a, b-a
[LF][SPACE][SPACE][LF]               label_0:
[SPACE][SPACE][SPACE][LF]              push 0
[TAB][TAB][TAB]                        retrieve
[SPACE][SPACE][SPACE][TAB][LF]         push 1
[TAB][TAB][TAB]                        retrieve
[TAB][SPACE][SPACE][TAB]               sub
[SPACE][LF][SPACE]                     dup
[LF][TAB][SPACE][TAB][LF]              jmp zero label_1
[SPACE][LF][SPACE]                     dup
[LF][TAB][TAB][TAB][SPACE][LF]         jmp neg label_2
[SPACE][SPACE][SPACE][LF]              push 0
[SPACE][LF][TAB]                       swap
[TAB][TAB][SPACE]                      store
[LF][SPACE][LF][LF]                    jmp label_0

Exit when a=b
[LF][SPACE][SPACE][TAB][LF]          label_1:
[SPACE][SPACE][SPACE][LF]              push 0
[TAB][TAB][TAB]                        retrieve
[TAB][LF][SPACE][TAB]                  printi
[LF][LF][LF]                           end

If a&gt;b: a, b =&gt; a-b, b
[LF][SPACE][SPACE][TAB][SPACE][LF]   label_2:
[SPACE][SPACE][SPACE][LF]              push 0
[SPACE][LF][TAB]                       swap
[TAB][SPACE][SPACE][TAB]               sub
[SPACE][SPACE][SPACE][TAB][LF]         push 1
[SPACE][LF][TAB]                       swap
[TAB][TAB][SPACE]                      store
[LF][SPACE][LF][LF]                    jmp label_0
</code></pre>
<pre><code class="language-whitespace">Reading the input: a, b
[SPACE][SPACE][SPACE][LF]       push 0
[SPACE][SPACE][SPACE][TAB][LF]  push 1
[TAB][LF][TAB][TAB]             readi
[TAB][LF][TAB][TAB]             readi

Loop: a, b =&gt; b, a%b
[LF][SPACE][SPACE][LF]          label_0:
[SPACE][SPACE][SPACE][LF]         push 0
[TAB][TAB][TAB]                   retrieve
[SPACE][LF][SPACE]                dup
[LF][TAB][SPACE][TAB][LF]         jmp zero label_1
[SPACE][SPACE][SPACE][TAB][LF]    push 1
[TAB][TAB][TAB]                   retrieve
[SPACE][LF][TAB]                  swap
[TAB][SPACE][TAB][TAB]            mod
[SPACE][SPACE][SPACE][LF]         push 0
[TAB][TAB][TAB]                   retrieve
[SPACE][SPACE][SPACE][TAB][LF]    push 1
[SPACE][LF][TAB]                  swap
[TAB][TAB][SPACE]                 store
[SPACE][SPACE][SPACE][LF]         push 0
[SPACE][LF][TAB]                  swap
[TAB][TAB][SPACE]                 store
[LF][SPACE][LF][LF]               jmp label_0

Exit when b=0
[LF][SPACE][SPACE][TAB][LF]     label_1:
[SPACE][SPACE][SPACE][TAB][LF]    push 1
[TAB][TAB][TAB]                   retrieve
[TAB][LF][SPACE][TAB]             printi
[LF][LF][LF][LF]                  end
</code></pre>
<pre><code class="language-scala">object Euclid {

  def euclid_sub(a: Int, b: Int): Int =
    (Math.abs(a), Math.abs(b)) match {
      case (0, _) | (_, 0) =&gt; 0
      case (x, y) if x &lt; y =&gt; euclid(x, y - x)
      case (x, y) if x &gt; y =&gt; euclid(x - y, y)
      case _ =&gt; a
    }

  def euclid_mod(a: Int, b: Int): Int =
    (Math.abs(a), Math.abs(b)) match {
      case (_, 0) =&gt; a
      case (a, b) =&gt; euclid_mod(b, a % b)
    }

  def main(args: Array[String]): Unit = {
    println(euclid_sub(151 * 899, 151 * 182))
    println(euclid_mod(151 * 899, 151 * 182))
  }

}
</code></pre>
<pre><code class="language-racket">#lang racket

(define (euclid_sub a b)
  (local ((define (euclid_sub* x y)
          (if (= x y)
              x
              (if (&gt; x y)
                  (euclid_sub* (- x y) y)
                  (euclid_sub* x (- y x))
                  )
              )
          )) (euclid_sub* (abs a) (abs b))
    )
  )

(define (euclid_mod a b)
  (local ((define (euclid_mod* a b)
           (if (= 0 b)
               (abs a)
               (euclid_mod* b (modulo a b))
               )
           )) (euclid_mod* a b)
    )
  )

(displayln (euclid_sub (* 64 67) (* 64 81)))
(displayln (euclid_mod (* 128 12) (* 128 77)))
</code></pre>
<pre><code class="language-ruby">def gcd_mod(a, b)
	a = a.abs
	b = b.abs
	a, b = b, a%b until b.zero?
	a
end
 
def gcd_minus(a, b)
	a = a.abs
	b = b.abs
	until a == b
		if a &gt; b
			a -= b
		else
			b -= a
		end
	end
	a
end
 
p gcd_mod(12 * 6, 12 * 4) #=&gt; 12
p gcd_mod(9 * 667, 9 * 104) #=&gt; 9

p gcd_minus(12 * 6, 12 * 4) #=&gt; 12
p gcd_minus(9 * 667, 9 * 104) #=&gt; 9
</code></pre>
<pre><code class="language-smalltalk">Integer&gt;&gt;euclidSub: secondNumber
    &quot;Euclidean algorithm with subtraction&quot;
    | a b |
    a := self abs.
    b := secondNumber abs.
    [ a == b ] whileFalse: [ 
        a &gt; b ifTrue: [ 
            a := a - b.
        ] ifFalse: [ 
            b := b - a.
        ].
    ].
    ^a.

Integer&gt;&gt;euclidMod: secondNumber
    &quot;Euclidean algorithm with modulus.&quot;
    | a b oldB |
    a := self abs.
    b := secondNumber abs.
    [ b == 0 ] whileFalse: [ 
        oldB := b.
        b := a % b.
        a := oldB.
    ].
    ^a.

Transcript show: ((64 * 67) euclidSub: (64 * 81)).
Transcript cr.
Transcript show: ((128 * 12) euclidMod: (128 * 77)).
</code></pre>
<pre><code class="language-emojicode">üêá ‚¨ÜÔ∏è üçá
  üêá ‚ùóÔ∏è üîº a üî¢ b üî¢ ‚û°Ô∏è üî¢ üçá
    üí≠ Use üèß (returns the absolute value) to support negative numbers.
    üèßa ‚ùóÔ∏è ‚û°Ô∏è üñçüÜïvar_a
    üèßb ‚ùóÔ∏è ‚û°Ô∏è üñçüÜïvar_b

    Ô∏èüîÅ ‚ùé var_a üôå var_b ‚ùóÔ∏è üçá
      ‚Ü™Ô∏è var_a ‚ñ∂Ô∏è var_b üçá
        var_a ‚¨ÖÔ∏è ‚ûñ var_b
      üçâ
      üôÖ üçá
        var_b ‚¨ÖÔ∏è ‚ûñ var_a
      üçâ
    üçâ

    ‚Ü©Ô∏è var_a
  üçâ

  üêá ‚ùóÔ∏è ‚è´ a üî¢ b üî¢ ‚û°Ô∏è üî¢ üçá
    üí≠ Use üèß (returns the absolute value) to support negative numbers.
    üèßa ‚ùóÔ∏è ‚û°Ô∏è üñçüÜïvar_a
    üèßb ‚ùóÔ∏è ‚û°Ô∏è üñçüÜïvar_b

    Ô∏èüîÅ ‚ùé var_b üôå 0 ‚ùóÔ∏è üçá
      var_b ‚û°Ô∏è temp
      var_a üöÆ var_b ‚û°Ô∏è üñçvar_b
      temp ‚û°Ô∏è üñçvar_a
    üçâ

    ‚Ü©Ô∏è var_a
  üçâ
üçâ

üèÅ üçá
  üòÄ üî° Ô∏èüîºüêá‚¨ÜÔ∏è ü§ú64 ‚úñÔ∏è 67ü§õ ü§ú64 ‚úñÔ∏è 81ü§õ ‚ùóÔ∏è 10 ‚ùóÔ∏è‚ùóÔ∏è
  üòÄ üî° Ô∏è‚è´üêá‚¨ÜÔ∏è ü§ú128 ‚úñÔ∏è 12ü§õ ü§ú128 ‚úñÔ∏è 77ü§õ ‚ùóÔ∏è 10 ‚ùóÔ∏è‚ùóÔ∏è
üçâ
</code></pre>
<pre><code class="language-LOLCODE">HAI 1.2
    HOW IZ I ABZ YR NUM
        DIFFRINT NUM AN BIGGR OF NUM AN 0, O RLY?
            YA RLY, FOUND YR DIFF OF 0 AN NUM
            NO WAI, FOUND YR NUM
        OIC
    IF U SAY SO

    HOW IZ I UKLIDMOD YR NUM1 AN YR NUM2
        NUM1 R I IZ ABZ YR NUM1 MKAY
        NUM2 R I IZ ABZ YR NUM2 MKAY

        IM IN YR LOOP 
            BOTH SAEM NUM2 AN 0, O RLY?
                YA RLY, FOUND YR NUM1
            OIC

            I HAS A TMP ITZ NUM2
            NUM2 R MOD OF NUM1 AN NUM2
            NUM1 R TMP
        IM OUTTA YR LOOP

    IF U SAY SO

    HOW IZ I UKLIDSUP YR NUM1 AN YR NUM2
        NUM1 R I IZ ABZ YR NUM1 MKAY
        NUM2 R I IZ ABZ YR NUM2 MKAY

        IM IN YR LOOP 
            BOTH SAEM NUM1 AN NUM2, O RLY?
                YA RLY, FOUND YR NUM1
            OIC        

            DIFFRINT NUM1 AN SMALLR OF NUM1 AN NUM2, O RLY?
                YA RLY, NUM1 R DIFF OF NUM1 AN NUM2
                NO WAI, NUM2 R DIFF OF NUM2 AN NUM1
            OIC
        IM OUTTA YR LOOP

    IF U SAY SO

    I HAS A CHECK1 ITZ I IZ UKLIDMOD YR PRODUKT OF 64 AN 67 AN YR PRODUKT OF 64 AN 81 MKAY
    I HAS A CHECK2 ITZ I IZ UKLIDSUP YR PRODUKT OF 128 AN 12  AN YR PRODUKT OF 128 AN 77 MKAY

    VISIBLE CHECK1
    VISIBLE CHECK2
KTHXBYE
</code></pre>
<pre><code class="language-bash">#!/usr/bin/env bash
abs() {
    local ret=$1
    if (( ret &lt; 0 )); then
        ((ret *= -1))
    fi
    printf &quot;%s&quot; &quot;$ret&quot;
} 

euclid_mod() {
    local a
    local b
    a=$(abs &quot;$1&quot;)
    b=$(abs &quot;$2&quot;)
    
    while (( b != 0 )); do
        ((tmp = b))
        ((b = a % b))
        ((a = tmp))
    done
    printf &quot;%s&quot; &quot;$a&quot;
}

euclid_sub() {
    local a
    local b
    a=$(abs &quot;$1&quot;)
    b=$(abs &quot;$2&quot;)
    
    while (( a != b )); do
        if (( a &gt; b )); then
            ((a -= b))
        else
            ((b -= a))
        fi
    done
    printf &quot;%s&quot; &quot;$a&quot;
}

result=$(euclid_mod $((64 * 67)) $((64 * 81)))
echo &quot;$result&quot;
result=$(euclid_sub $((128 * 12)) $((128 * 77)))
echo &quot;$result&quot;
</code></pre>
<pre><code class="language-d">import std.stdio;
import std.math;

// Euclidean algorithm using modulus
int euclid_mod(int a, int b) {
    int tmp;
    a = abs(a);
    b = abs(b);

    while (b != 0) {
        tmp = a % b;
        a = b;
        b = tmp;
    }

    return a;
}

// Euclidean algorithm with subtraction
int euclid_sub(int a, int b) {
    a = abs(a);
    b = abs(b);

    while (a != b) {
        if (a &gt; b) {
            a -= b;
        } else {
            b -= a;
        }
    }

    return a;
}

void main()
{
    auto check1 = euclid_mod(64 * 67, 64 * 81);
    auto check2 = euclid_sub(128 * 12, 128 * 77);

    writeln(&quot;Modulus-based euclidean algorithm result: &quot;, check1);
    writeln(&quot;Subtraction-based euclidean algorithm result: &quot;, check2);
}
</code></pre>
<p>A text version of the program is provided for both versions.</p>
<h4 id="subtraction"><a class="header" href="#subtraction">Subtraction</a></h4>
<blockquote>
<p><img src="code/piet/subtract/euclidian_algorithm_subtract_large.png" alt="" /> <img src="code/piet/subtract/euclidian_algorithm_subtract.png" alt="" /></p>
</blockquote>
<pre><code class="language-piet">COMMAND                 STATE OF STACK
in(number)              A           // Take A as an input
duplicate               AA          // Start to take the absolute value of A
push 1                  1AA
duplicate               11AA
subtract                0AA
greater                 0/1A        // 1 if A &gt; 0, 0 if A &lt;= 0
not                     1/0A        // 0 if A &gt; 0, 1 if A &lt;= 0
push 1                  1 1/0 A
push 3                  31 1/0 A
subtract                -2 1/0 A
multiply                -2/0 A
push 1                  1 -2/0 A
add                     -1/1 A
multiply                A           // A should now be an absolute value

in(number)              BA          // Take B as an input
duplicate               BBA         // Start to take the absolute value of B
push 1                  1BBA
duplicate               11BBA
subtract                0BBA
greater                 0/1BA        // 1 if B &gt; 0, 0 if B &lt;= 0
not                     1/0BA        // 0 if B &gt; 0, 1 if B &lt;= 0
push 1                  1 1/0 BA
push 3                  31 1/0 BA
subtract                -2 1/0 BA
multiply                -2/0 BA
push 1                  1 -2/0 BA
add                     -1/1 BA
multiply                BA          // B should now be an absolute value

// Start of the main loop while a ‚â† b 
duplicate               BBA
push 3                  3BBA
push 2                  23BBA
roll                    ABB
duplicate               AABB
push 4                  4AABB
push 1                  14AABB
roll                    ABBA
subtract                0/x BA
not                     1/0 BA      // 1 if a = b and 0 if a ‚â† b
not                     0/1 BA      // 1 if a ‚â† b and 0 if a = b
pointer                 BA          // If a ‚â† b, the DP should change one clockwise, otherwise, go straight ahead.

    // Go left if a ‚â† b (DP changed one clockwise)
    duplicate               BBA
    push 3                  3BBA
    push 2                  23BBA
    roll                    ABB
    duplicate               AABB
    push 4                  4AABB
    push 1                  14AABB
    roll                    ABBA
    push 2                  2ABBA
    push 1                  12ABBA
    roll                    BABA
    greater                 0/1 BA          // A &gt; B; 1 if true; 0 if false
    pointer                 BA              // If A &gt; B, DP goes one clockwise, otherwise, DP stays the same. 

        // If A &gt; B (DP has changed 1 clockwise)
        duplicate               BBA
        push 3                  3BBA
        push 1                  13BBA
        roll                    BAB
        subtract                AB              // A = A - B
        push 2                  2AB
        push 1                  12AB
        roll                    BA
        // Go back to start of loop

        // If B &gt; A (DP stayed the same)
        push 2                  2BA
        push 1                  12BA
        roll                    AB
        duplicate               AAB
        push 3                  3AAB
        push 1                  13AAB
        roll                    ABA
        subtract                BA              // B = B - A
        // Go back to start of loop

// Go down if a = b (end of while loop)
pop                     A
out(number)             -               // Print out A when done.
</code></pre>
<h4 id="modulo"><a class="header" href="#modulo">Modulo</a></h4>
<blockquote>
<p><img src="code/piet/mod/euclidian_algorithm_mod_large.png" alt="" /> <img src="code/piet/mod/euclidian_algorithm_mod.png" alt="" /></p>
</blockquote>
<pre><code class="language-piet">COMMAND                 STATE OF STACK
in(number)              A
in(number)              BA

//  Start of loop
duplicate               BBA
not                     0/1 BA
not                     1/0 BA
pointer                 BA

    // Go down if b ‚â† 0
    duplicate               TBA
    push 3                  3TBA                  
    push 1                  13TBA
    roll                    BAT
    mod                     BA          // b = a mod b; a = t
    // Go back to the start of the loop

// Go right if b = 0
pop                     A
out(number)             -               // Print out A when done.
</code></pre>
<pre><code class="language-scheme">(define (euclid-sub a b)
    (cond                                                                                                                                                                                                                                                                         
        [(or (negative? a)(negative? b))(euclid-sub (abs a)(abs b))]                                                                                                                                                                                                              
        [(eq? a b) a]
        [(&gt; a b)(euclid-sub(- a b) b)]
        [else
            (euclid-sub a (- b a))]))

(define (euclid-mod a b)
    (if (zero? b)
        a
        (euclid-mod b (modulo a b))))

(display (euclid-mod (* 64 67) (* 64 81))) (newline)
(display (euclid-sub (* 128 12) (* 128 77))) (newline)

</code></pre>
<p>
The code snippets were taken from this [Scratch project](https://scratch.mit.edu/projects/278727055/)
</p>
<p>
  <img  class="center" src="code/scratch/main.svg" style="width:30%" />
</p>
<pre><code class="language-powershell">function Sub-Euclid($a, $b) {
    $a = [Math]::Abs($a)
    $b = [Math]::Abs($b)

    while ($a -ne $b) {
        if ($a -gt $b) {
            $a = $a - $b
        } else {
            $b = $b - $a
        }
    }
    
    return $a
}

function Mod-Euclid($a, $b) {
    $a = [Math]::Abs($a)
    $b = [Math]::Abs($b)

    while ($b -ne 0) {
        $tmp = $b
        $b = $a % $b
        $a = $tmp
    }

    return $a
}

Write-Host &quot;Subtraction-based euclidean algorithm result: $(Mod-Euclid $(64 * 67) $(64 * 81))&quot;
Write-Host &quot;Modulus-based euclidean algorithm result: $(Sub-Euclid $(128 * 12) $(128 * 77))&quot;
</code></pre>
<pre><code class="language-coconut">def euclid_sub(a is int, 0) = a
addpattern def euclid_sub(0, b is int) = b

addpattern def euclid_sub(a is int, b is int):
    if a &lt; b:
        return euclid_sub(a, b - a)
    elif b &lt; a:
        return euclid_sub(a - b, b)
    return a


def euclid_mod(a is int, 0) = a
addpattern def euclid_mod(0, b is int) = b

addpattern def euclid_mod(a is int, b is int) = euclid_mod(b, a % b)

if __name__ == '__main__':
    print('Euclidean mod:', euclid_mod(64 * 67, 64 * 81))
    print('Euclidean sub:', euclid_sub(128 * 12, 128 * 77))
</code></pre>
<h2 id="license"><a class="header" href="#license">License</a></h2>
<h5 id="code-examples"><a class="header" href="#code-examples">Code Examples</a></h5>
<p>The code examples are licensed under the MIT license (found in <a href="https://github.com/algorithm-archivists/algorithm-archive/blob/master/LICENSE.md">LICENSE.md</a>).</p>
<h5 id="text"><a class="header" href="#text">Text</a></h5>
<p>The text of this chapter was written by <a href="https://github.com/leios">James Schloss</a> and is licensed under the <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</p>
<p><a href="https://creativecommons.org/licenses/by-sa/4.0/"><p><img  class="center" src="../cc/CC-BY-SA_icon.svg" /></p></a></p>
<h5 id="imagesgraphics"><a class="header" href="#imagesgraphics">Images/Graphics</a></h5>
<ul>
<li>The image &quot;<a href="res/subtraction.png">Euclidsub</a>&quot; was created by <a href="https://github.com/leios">James Schloss</a> and is licensed under the <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</li>
<li>The image &quot;<a href="res/modulus.png">Euclidmod</a>&quot; was created by <a href="https://github.com/leios">James Schloss</a> and is licensed under the <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</li>
</ul>
<h5 id="pull-requests"><a class="header" href="#pull-requests">Pull Requests</a></h5>
<p>After initial licensing (<a href="https://github.com/algorithm-archivists/algorithm-archive/pull/560">#560</a>), the following pull requests have modified the text or graphics of this chapter:</p>
<ul>
<li>none</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../tree_traversal/tree_traversal.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="../monte_carlo_integration/monte_carlo_integration.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../tree_traversal/tree_traversal.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="../monte_carlo_integration/monte_carlo_integration.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script type="text/javascript">
            var socket = new WebSocket("ws://0.0.0.0:3000/__livereload");
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->


    </body>
</html>
