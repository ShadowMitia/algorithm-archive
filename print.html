<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Arcane Algorithm Archive</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="index.html"><strong aria-hidden="true">1.</strong> Algorithm Archive</a></li><li class="chapter-item expanded "><a href="introduction/introduction.html"><strong aria-hidden="true">2.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="how_to_contribute/how_to_contribute.html"><strong aria-hidden="true">3.</strong> How To Contribute</a></li><li class="chapter-item expanded "><a href="plotting/plotting.html"><strong aria-hidden="true">4.</strong> Plotting</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="domain_coloring/domain_coloring.html"><strong aria-hidden="true">4.1.</strong> Domain Coloring</a></li><li class="chapter-item expanded "><a href="IFS/IFS.html"><strong aria-hidden="true">4.2.</strong> Iterated Function Systems</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="barnsley/barnsley.html"><strong aria-hidden="true">4.2.1.</strong> The Barnsley Fern</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="data_structures/data_structures.html"><strong aria-hidden="true">5.</strong> Data Structures</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="stacks_and_queues/stacks_and_queues.html"><strong aria-hidden="true">5.1.</strong> Stacks and Queues</a></li></ol></li><li class="chapter-item expanded "><a href="mathematical_background/mathematical_background.html"><strong aria-hidden="true">6.</strong> Mathematical Background</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="notation/notation.html"><strong aria-hidden="true">6.1.</strong> Complexity Notation</a></li><li class="chapter-item expanded "><a href="affine_transformations/affine_transformations.html"><strong aria-hidden="true">6.2.</strong> Affine Transformations</a></li><li class="chapter-item expanded "><a href="bitlogic/bitlogic.html"><strong aria-hidden="true">6.3.</strong> Bit Logic</a></li><li class="chapter-item expanded "><a href="taylor_series_expansion/taylor_series_expansion.html"><strong aria-hidden="true">6.4.</strong> Taylor Series</a></li><li class="chapter-item expanded "><a href="convolutions/convolutions.html"><strong aria-hidden="true">6.5.</strong> Convolutions</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="convolutions/1d/1d.html"><strong aria-hidden="true">6.5.1.</strong> Convolutions in 1D</a></li><li class="chapter-item expanded "><a href="convolutions/multiplication/multiplication.html"><strong aria-hidden="true">6.5.2.</strong> Multiplication as a Convolution</a></li><li class="chapter-item expanded "><a href="convolutions/2d/2d.html"><strong aria-hidden="true">6.5.3.</strong> Convolutions of Images (2D)</a></li><li class="chapter-item expanded "><a href="convolutions/convolutional_theorem/convolutional_theorem.html"><strong aria-hidden="true">6.5.4.</strong> Convolutional Theorem</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="tree_traversal/tree_traversal.html"><strong aria-hidden="true">7.</strong> Tree Traversal</a></li><li class="chapter-item expanded "><a href="euclidean_algorithm/euclidean_algorithm.html"><strong aria-hidden="true">8.</strong> Euclidean Algorithm</a></li><li class="chapter-item expanded "><a href="monte_carlo_integration/monte_carlo_integration.html"><strong aria-hidden="true">9.</strong> Monte Carlo</a></li><li class="chapter-item expanded "><a href="matrix_methods/matrix_methods.html"><strong aria-hidden="true">10.</strong> Matrix Methods</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="gaussian_elimination/gaussian_elimination.html"><strong aria-hidden="true">10.1.</strong> Gaussian Elimination</a></li><li class="chapter-item expanded "><a href="thomas_algorithm/thomas_algorithm.html"><strong aria-hidden="true">10.2.</strong> Thomas Algorithm</a></li></ol></li><li class="chapter-item expanded "><a href="computational_geometry/computational_geometry.html"><strong aria-hidden="true">11.</strong> Computational Geometry</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="gift_wrapping/gift_wrapping.html"><strong aria-hidden="true">11.1.</strong> Gift Wrapping</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="jarvis_march/jarvis_march.html"><strong aria-hidden="true">11.1.1.</strong> Jarvis March</a></li><li class="chapter-item expanded "><a href="graham_scan/graham_scan.html"><strong aria-hidden="true">11.1.2.</strong> Graham Scan</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="cooley_tukey/cooley_tukey.html"><strong aria-hidden="true">12.</strong> FFT</a></li><li class="chapter-item expanded "><a href="decision_problems/decision_problems.html"><strong aria-hidden="true">13.</strong> Decision Problems</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="stable_marriage_problem/stable_marriage_problem.html"><strong aria-hidden="true">13.1.</strong> Stable Marriage Problem</a></li></ol></li><li class="chapter-item expanded "><a href="physics_solvers/physics_solvers.html"><strong aria-hidden="true">14.</strong> Physics Solvers</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="verlet_integration/verlet_integration.html"><strong aria-hidden="true">14.1.</strong> Verlet Integration</a></li><li class="chapter-item expanded "><a href="quantum_systems/quantum_systems.html"><strong aria-hidden="true">14.2.</strong> Quantum Systems</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="split-operator_method/split-operator_method.html"><strong aria-hidden="true">14.2.1.</strong> Split-Operator Method</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="data_compression/data_compression.html"><strong aria-hidden="true">15.</strong> Data Compression</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="huffman_encoding/huffman_encoding.html"><strong aria-hidden="true">15.1.</strong> Huffman Encoding</a></li></ol></li><li class="chapter-item expanded "><a href="computer_graphics/computer_graphics.html"><strong aria-hidden="true">16.</strong> Computer Graphics</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="flood_fill/flood_fill.html"><strong aria-hidden="true">16.1.</strong> Flood Fill</a></li></ol></li><li class="chapter-item expanded "><a href="quantum_information/quantum_information.html"><strong aria-hidden="true">17.</strong> Quantum Information</a></li><li class="chapter-item expanded "><a href="computus/computus.html"><strong aria-hidden="true">18.</strong> Computus</a></li><li class="chapter-item expanded "><a href="approximate_counting/approximate_counting.html"><strong aria-hidden="true">19.</strong> Approximate Counting Algorithm</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Arcane Algorithm Archive</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/algorithm-archivists/algorithm-archive/" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="the-arcane-algorithm-archive"><a class="header" href="#the-arcane-algorithm-archive">The Arcane Algorithm Archive</a></h1>
<p>The Arcane Algorithm Archive is a collaborative effort to create a guide for all important algorithms in all languages.
This goal is obviously too ambitious for a book of any size, but it is a great project to learn from and work on and will hopefully become an incredible resource for programmers in the future.</p>
<p>To change the language, please use the UI at the top of the site:</p>
<p>
  <img  class="center" src="languages.gif" style="width:50%" />
</p>
<p>Here are some essential links:</p>
<ul>
<li>Book / website: <a href="https://www.algorithm-archive.org/">https://www.algorithm-archive.org/</a></li>
<li>GitHub repository: <a href="https://github.com/algorithm-archivists/algorithm-archive">https://github.com/algorithm-archivists/algorithm-archive</a></li>
<li>YouTube channel (LeiosOS): <a href="https://www.youtube.com/user/LeiosOS">https://www.youtube.com/user/LeiosOS</a></li>
<li>Twitch livestream: <a href="https://www.twitch.tv/leioslabs">https://www.twitch.tv/leioslabs</a></li>
<li>Discord server: <a href="https://discord.gg/Pr2E9S6">https://discord.gg/Pr2E9S6</a></li>
</ul>
<p>Note that this project is essentially a book about algorithms collaboratively written by an online community.
Fortunately, there are a lot of algorithms out there, which means that there is a lot of content material available.
Unfortunately, this means that we will probably never cover every algorithm ever created and instead need to focus on what the community sees as useful and necessary.
That said, we'll still cover a few algorithms for fun that have very little, if any practical purpose.</p>
<p>If you would like to contribute, feel free to go to any chapter with code associated with it and implement that algorithm in your favorite language, and then submit the code via pull request.
You can find help and instructions regarding the contribution process in our <a href="https://github.com/algorithm-archivists/algorithm-archive/wiki/How-to-Contribute">How to Contribute</a> wiki entry.</p>
<p>Hopefully, this project will grow and allow individuals to learn about and try their hand at implementing different algorithms for fun and (potentially) useful projects.
If nothing else, it will be an enjoyable adventure for our community.</p>
<p>Thanks for reading and let me know if there's anything wrong or if you want to see something implemented in the future!</p>
<hr />
<h2 id="license"><a class="header" href="#license">License</a></h2>
<p>The code examples for this project are licensed under the MIT license (found in <a href="https://github.com/algorithm-archivists/algorithm-archive/blob/master/LICENSE.md">LICENSE.md</a>).
All text content is licensed under the <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">Creative Commons Attribution-ShareAlike 4.0 International License</a> with attribution specified at the end of every chapter.
All graphics are licensed under the license stated at the end of every chapter.
If no attribution is specified, please attribute James Schloss.</p>
<p><a href="https://creativecommons.org/licenses/by-sa/4.0/"><p><img  class="center" src="contents/cc/CC-BY-SA_icon.svg" /></p></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>People learn differently, there's no doubt about that. I for one, have never been able to follow a lecture. No matter how interesting the subject might be, the teacher or professor either moves too slowly or too quickly, and in both cases I lose the motivation to study and learn outside of class. Looking back at all my past lectures, this is a bit of a shame. I genuinely love learning! In fact, nowadays there's nothing I enjoy more than poring through the <a href="https://arxiv.org/">ArXiv</a>, looking for the latest and greatest algorithms in physics and computer science. Sure, I cannot <em>understand</em> them all, but sometimes it's nice to be completely overwhelmed and chip away at problems one piece at a time. In the end, modern research is a conglomeration of fun little (or big) puzzles to solve; however, I find that many papers are too harsh for most people to tackle without a significant background in computer science or physics. For this reason, they are ignored by the public. We live in an era where nearly the entire sum of human knowledge is available at our fingertips, and yet people are blissfully unaware of the unique ideas and challenges that are pushing our understanding forward.</p>
<p>I guess that is the point of this work. Throughout the past few years, I have been collecting small morsels of knowledge that are hard to express in any meaningful way through blog posts, YouTube, or twitch streaming. YouTube, for example, is a great place to introduce the general idea of an algorithm; however, I personally find it a poor choice to show a worked example. Twitch is great to show everything, but spending 5 hours programming up an algorithm for the first time is generally not everyone's idea of fun. Blog posts work well for this type of material; however, they lack a comprehensive nature that I tend to enjoy. So what's left? Well, I suppose that would be a book, which is an incredibly exciting prospect!</p>
<p>See, when I was younger, maybe around Jr. High School age, I really wanted to become an author. I spent as much free time as I could manage writing fantastical stories about heroes and villains creating their own worlds and redefining reality. It was (and still is) an enjoyable hobby of mine. In many ways, my love of storytelling is echoed in my love of science and mathematics. In my mind, every discovery is its own story -- an adventure just waiting to be understood! It seems incredible to me that I now have the chance to combine my two favorite hobbies: writing and learning.</p>
<p>Now, to be clear, I am not a master computer scientist. In fact, my degree is in physics and at the time of writing, I am in a PhD program studying quantum systems; however, I really, really love learning algorithms. About a year or two ago, I started a Twitch stream focused on computational physics. Almost every day, I would get up at 5:00AM and livecode something I had never coded before. It was incredibly fun and through working with the community, we learned a lot. In addition, I found my programming abilities improving significantly, and I learned to see the power in a community of hobby programmers.</p>
<p>This text is a natural extension of that idea -- a community effort to learn as much as possible about as many algorithms as we can. Because of this, I feel like I should be as honest as possible about the nature of this book. As mentioned, I am not classically trained in computer science, so for the most part, I will be learning right along with you, the reader. My hope is to advance my own understanding of computer science while also providing a comprehensive guide for those wishing to improve their own understanding as well.</p>
<p>For this reason, I hesitate to call this a work a &quot;textbook&quot; and would prefer to think of it as a lab notebook of sorts. It will be an archive filled with cool ideas in computer science and physics that I hope will be interesting in their own right. My hope is that this book perfectly straddles the line between comprehensiveness and pleasure and will be an enjoyable read for anyone at any stage on their hobby programming journey.</p>
<p>Keeping with the community theme, this book is freely available on <a href="https://github.com/algorithm-archivists/algorithm-archive">GitHub</a> and <a href="https://www.algorithm-archive.org">GitHub pages</a>. Please feel free to read / browse the content available there. If you have any questions / comments / concerns, please let me know. This book is a community project and will only work if there is a community that works on it!</p>
<p>As a final note before beginning the bulk text, I would like for this book to be &quot;language agnostic.&quot; This basically means that I would like to use pseudocode in the main text, but provide source code in any language you could want in the appendix. Though this may seem a little counter-intuitive, I think it offers the greatest flexibility for myself as the author and for the community to develop their own code in any way they please. In fact, if you feel inclined, please feel free to implement your own version of any algorithm mentioned in this text. If you submit it and it passes all my <em>ahem</em> rigorous tests, then I can throw it at the end of each chapter with attribution to you!</p>
<p>So I guess that's all for now. Because this book is freely available online, I may be heavily modifying the content as we delve deeper into the archive of arcane algorithms.</p>
<h2 id="license-1"><a class="header" href="#license-1">License</a></h2>
<h5 id="code-examples"><a class="header" href="#code-examples">Code Examples</a></h5>
<p>The code examples are licensed under the MIT license (found in <a href="https://github.com/algorithm-archivists/algorithm-archive/blob/master/LICENSE.md">LICENSE.md</a>).</p>
<h5 id="text"><a class="header" href="#text">Text</a></h5>
<p>The text of this chapter was written by <a href="https://github.com/leios">James Schloss</a> and is licensed under the <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</p>
<p><a href="https://creativecommons.org/licenses/by-sa/4.0/"><p><img  class="center" src="introduction/../cc/CC-BY-SA_icon.svg" /></p></a></p>
<h5 id="pull-requests"><a class="header" href="#pull-requests">Pull Requests</a></h5>
<p>After initial licensing (<a href="https://github.com/algorithm-archivists/algorithm-archive/pull/560">#560</a>), the following pull requests have modified the text or graphics of this chapter:</p>
<ul>
<li>none</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="how-to-contribute-to-the-algorithm-archive"><a class="header" href="#how-to-contribute-to-the-algorithm-archive">How to Contribute to the Algorithm Archive</a></h1>
<p>The <em>Algorithm Archive</em> is an effort to learn about and teach algorithms as a community.
As such, it requires a certain level of trust between community members.
For specific details on how to contribute, please consult the <a href="https://github.com/algorithm-archivists/algorithm-archive/wiki/How-to-Contribute">How to Contribute guide</a>.
If you are having trouble with git and version control, please also check out <a href="https://www.youtube.com/playlist?list=PL5NSPcN6fRq2vwgdb9noJacF945CeBk8x">this video series</a> with more details.</p>
<p>In addition, we also have an <a href="https://github.com/algorithm-archivists/algorithm-archive/wiki/FAQ">FAQ</a> and a <a href="https://github.com/algorithm-archivists/algorithm-archive/wiki/Code-style-guide">code style guide</a>, which is currently being written for all languages submitted to the Algorithm Archive so far.</p>
<p>Currently, we are not accepting chapter submissions; however, we will allow for this in the near future.
For now, here are the basics for submitting code to the Algorithm Archive:</p>
<ol>
<li><strong>Style</strong>: We are developing a <a href="https://github.com/algorithm-archivists/algorithm-archive/wiki/Code-style-guide">code style guide</a> for all the languages in the Algorithm Archive. For the most part, follow standard style guidelines associated with your language of choice. Your code should be readable and understandable to anyone -- especially those who are new to the language. In addition, remember that your code will be displayed in this book, so try to keep to around 80 columns, try to remove any visual clutter, and keep variable names clean and understandable.</li>
<li><strong>Licensing</strong>: All the code from this project will be under the MIT license found in <code>LICENSE.md</code>; however, the text will be under a Creative Commons Attribution-NonCommercial 4.0 International License.</li>
<li><strong>CONTRIBUTORS.md</strong>: After contributing code, please echo your name to the end of <code>CONTRIBUTORS.md</code> with <code>echo &quot;- name&quot; &gt;&gt; CONTRIBUTORS.md</code>.</li>
<li><strong>Building the Algorithm Archive</strong>: Before every submission, you should build the Algorithm Archive on your own machine. To do this, install <a href="https://nodejs.org/">Node</a> and use <code>npm install</code> and then <code>npm run serve</code> in the main directory (where <code>README.md</code> is). This will provide a local URL to go to to view the archive in your browser of choice. Use this server to make sure your version of the Algorithm Archive works cleanly for the chapter you are updating!</li>
</ol>
<p>To submit code, simply go to the <code>code/</code> directory of whatever chapter you want and add another directory for your language of choice.</p>
<p>We use two GitBook plugins to allow users to flip between languages on different algorithms.
One is the theme-api, and the other is the include-codeblock api.
We need the following statements in the markdown file for these to work together:</p>
<p><a href="how_to_contribute/res/codeblock.txt">import</a></p>
<p>For this example, we are starting the theme-api <code>method</code> and importing lines 1-17 from a sample Julia snippet from the code directory.
Note that to standardize the language capitalization schemes, we ask that each language's <code>sample lang</code> is the file extension for their code, <code>cpp</code> for C++, <code>hs</code> for Haskell, etc.
This keeps the title in the theme-api consistent across different languages.
Also note that depending on the algorithm, there might be in-text code snippets that also need to be written.</p>
<p>I'll update this page as the project grows.
If you would like to be a part of the ongoing discussion, please feel free to join our discord server: https://discord.gg/pb976sY.
Thanks for all the support and considering contributing to the Algorithm Archive!</p>
<h2 id="license-2"><a class="header" href="#license-2">License</a></h2>
<h5 id="code-examples-1"><a class="header" href="#code-examples-1">Code Examples</a></h5>
<p>The code examples are licensed under the MIT license (found in <a href="https://github.com/algorithm-archivists/algorithm-archive/blob/master/LICENSE.md">LICENSE.md</a>).</p>
<h5 id="text-1"><a class="header" href="#text-1">Text</a></h5>
<p>The text of this chapter was written by <a href="https://github.com/leios">James Schloss</a> and is licensed under the <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</p>
<p><a href="https://creativecommons.org/licenses/by-sa/4.0/"><p><img  class="center" src="how_to_contribute/../cc/CC-BY-SA_icon.svg" /></p></a></p>
<h5 id="pull-requests-1"><a class="header" href="#pull-requests-1">Pull Requests</a></h5>
<p>After initial licensing (<a href="https://github.com/algorithm-archivists/algorithm-archive/pull/560">#560</a>), the following pull requests have modified the text or graphics of this chapter:</p>
<ul>
<li>none</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="plotting"><a class="header" href="#plotting">Plotting</a></h1>
<p>Plotting is an essential tool for visualizing and understanding important details of several algorithms and methods and is necessary for studies in various areas of computational science.
For many languages, such as python, julia, and matlab, it is relatively straightforward to create simple plots for various types of data; however, for several other languages, like fortran, C/C++, and java, plotting can be a chore.
Because the Algorithm Archive strives to be language agnostic, we do not want to favor any particular set of languages and have decided instead to output all data that needs plotting into a file format that can easily be read in by various plotting scripts separate from the algorithm implementations.</p>
<p>If you are implementing any algorithm in a language found on this page, you should be able to modify your existing code to allow for on-the-fly plotting.
Otherwise, please use the language of your choice to write the initial implementation and output the data to a file before using one of the scripts available here for plotting.</p>
<p>This chapter aims to explain how to plot several different types of data and will be updated as more algorithms require more complex plotting schemes.
Though many complex file formats exist, we will be mainly storing data for plotting in simple ASCII text.
If you wish to use these plotting scripts for other file formats or projects unrelated to the Algorithm Archive, some modification will be necessary.
In addition, each plotting language used in this chapter will likely have many features we are not currently using, so there may be methods to create stunning visualizations that we are ignoring here.</p>
<h2 id="plotting-a-series-of-functions"><a class="header" href="#plotting-a-series-of-functions">Plotting a series of functions</a></h2>
<p>To begin, let's write a simple script that allows for plotting a sine wave</p>
<pre><code class="language-gnuplot">plot sin(x) with lines
</code></pre>
<p>Where <code>x</code> is a range from negative to positive 10.
To plot from the terminal, you can either:</p>
<ul>
<li>enter the gnuplot REPL (Read, Evaluate, Print, Loop -- the gnuplot shell) by using the <code>gnuplot</code> command and type the above command manually.</li>
<li>write the command in an external script (let's call it <code>script.gp</code>) and run it with <code>gnuplot script.gp -</code>. The <code>-</code> will keep the terminal open in the background so the image stays up. If your plotting script outputs a <code>.png</code> file, the <code>-</code> is unnecessary.</li>
</ul>
<p>This command will create a plot that looks like this:</p>
<p>
    <img  class="center" src="plotting/res/gnuplot/sine.png" style="width:70%" />
</p>
<p>For most gnuplot scripts, this command is written in short-hand.
The phrase <code>with lines</code> is abbreviated to simply <code>w l</code> and <code>plot</code> is sometimes written as simply <code>p</code>, so the following command would also work:</p>
<pre><code>p sin(x) w l
</code></pre>
<p>From here, it is rather straightforward to add more plots.
For example, let's add in a cosine function.</p>
<p>{% sample lang=&quot;gnuplot&quot; %}
In this case, we need to add the following line to our script:
<a href="plotting/code/gnuplot/sine.gp">import:2, lang:&quot;gnuplot&quot;</a></p>
<p>Which will create an image that looks like this:</p>
<p>
    <img  class="center" src="plotting/res/gnuplot/sincos.png" style="width:70%" />
</p>
<p>If you would prefer to plot everything on a single line (which will become more relevant when plotting directly to an image file), then you can use the following command:</p>
<pre><code>p sin(x) w l, cos(x) w l
</code></pre>
<p>In some sense, this chapter is meant as a guide so users can better understand plotting in their language of choice.
As such, it is important to first understand how to perform a few basic tasks:</p>
<ol>
<li>Changing auxiliary features of the plot such as: title, axis, labels, x/ytic values, and plot dimensions</li>
<li>Plotting multiple functions at the same time</li>
<li>Outputting the plot to file</li>
</ol>
<p>At the end of this chapter, we will discuss the scatter plot; however, additional plotting techniques may be covered in the near future for specific algorithms and methods.</p>
<h3 id="changing-auxiliary-features"><a class="header" href="#changing-auxiliary-features">Changing auxiliary features</a></h3>
<p>Beauty is in the eye of the beholder, but it is rare for people to call plots &quot;beautiful.&quot;
That said, there are plenty of things you can do to more clearly represent your data, and if your data is beautiful, so be it!
In this section, we'll show you some small-scale modifications you can make to the plot we have already generated to make it little cleaner, but there are plenty of other ways to spruce up your plot that we are not covering here.
Be sure to look at the documentation {{ &quot;gnuplot&quot; | cite }}  for plotting in your language of choice if you want to do anything more complicated.</p>
<h4 id="x-and-y-range"><a class="header" href="#x-and-y-range">x and y range</a></h4>
<p>All data that can be plotted has a scope at which the important features are more clear.
It is sometimes important to zoom in or zoom out to highlight particular facets of the data available.
This can be simply done by modifying the \( x \) and \( y \) ranges in your plotter of choice, like so:</p>
<p>{% sample lang=&quot;gnuplot&quot; %}</p>
<pre><code>set xrange [0:10]
set yrange [0:1]
plot sin(x) w l, cos(x) w l
</code></pre>
<p>Here, the keywords <code>xrange</code> and <code>yrange</code> are known by gnuplot and take a range from <code>[n:m]</code>, where <code>n</code> and <code>m</code> are real units in the plot, itself.
For this script, we generate a plot that looks like this:</p>
<p>
    <img  class="center" src="plotting/res/gnuplot/sincos_range.png" style="width:70%" />
</p>
<h4 id="x-and-y-tics"><a class="header" href="#x-and-y-tics">x and y tics</a></h4>
<p>In addition to changing the plot scales, it is also important to notify your audience of what these scales actually mean.
To help guide the reader's eye and better understand what the plot represents, plotters provide <em>tics</em> (little notches) on the \( x \) and \( y \) axes.
As such, it is important to update the \( x \) and \( y \) tics with appropriate scales and labels.</p>
<p>{% sample lang=&quot;gnuplot&quot; %}</p>
<p>Firstly, to remove x and y tics, use</p>
<pre><code>unset xtics
unset ytics
</code></pre>
<p>This will create a plot that looks like this:</p>
<p>
    <img  class="center" src="plotting/res/gnuplot/sincos_notics.png" style="width:70%" />
</p>
<p>If you want to set particular x or y tic values, use</p>
<pre><code>set xtics 0, 5, 10
set ytics (&quot;bottom&quot; 0 , &quot;top&quot; 1)
</code></pre>
<p>which creates a plot that looks like this:</p>
<p>
    <img  class="center" src="plotting/res/gnuplot/sincos_customtics.png" style="width:70%" />
</p>
<p>Here, we are selecting 3 values to use for the x-axis and using words or phrases for the &quot;bottom&quot; and &quot;top&quot; of the y-axis.
To be clear: we are not condoning the behavior of having mismatched x and y tic values by using words or phrases along the y axis and numbers along the x axis.
This is simply meant as a showcase for using gnuplot in this way.</p>
<p>As a note: there is a lot of information here we missed, specifically format specifiers, which allow users to modify the format of the numbers in their plots (to be in floating point, scientific notation, or something else).
This can be found in <a href="http://gnuplot.sourceforge.net/docs_4.2/node184.html">the documentation</a>, along with anything else that is missed here.</p>
<h4 id="logscale"><a class="header" href="#logscale">logscale</a></h4>
<p>In addition to changing the values of the x and y tics, we can also change the axes to plot in log-scale by using the following command:</p>
<p>{% sample lang=&quot;gnuplot&quot; %}</p>
<pre><code>set logscale x
set logscale y
</code></pre>
<p>As a simple example, let's take the <code>exp(x)</code> function.</p>
<p>{% sample lang=&quot;gnuplot&quot; %}</p>
<p>In gnuplot, we can plot this by using <code>p exp(x) w l</code>, which will create the following:</p>
<p>
    <img  class="center" src="plotting/res/gnuplot/exp.png" style="width:70%" />
</p>
<p>Now let's plot the same function with log-scale along the \( y \) axis:</p>
<p>{% sample lang=&quot;gnuplot&quot; %}</p>
<p>
    <img  class="center" src="plotting/res/gnuplot/explog.png" style="width:70%" />
</p>
<p>Here, we see what we expect: <code>exp(x)</code> is a straight line when the \( y \) axis is in log-scale.
When we use log-scale on the sine and cosine waves from before, we get the following:</p>
<p>{% sample lang=&quot;gnuplot&quot; %}</p>
<p>
    <img  class="center" src="plotting/res/gnuplot/sincos_log.png" style="width:70%" />
</p>
<p>This is an awful plot, so it is only fitting that we use it as out example for the a few more plots in this chapter.</p>
<h4 id="labels-titles-and-legends"><a class="header" href="#labels-titles-and-legends">labels, titles, and legends</a></h4>
<p>Many researchers are very particular about labels.
Labels need to be in the right spot, say the right stuff, and be interpreted in the right way.
As such, most plotters have a lot of options for labels, including LaTeX-like formatting for academic journals and such.</p>
<p>There are also multiple labels associated with each plot.
Every line has a label, often held in a box called a <em>legend</em>, and the plot, itself, has a title.</p>
<h5 id="labels"><a class="header" href="#labels">labels</a></h5>
<p>First, let's change the labels associated with each data set or function.</p>
<p>{% sample lang=&quot;gnuplot&quot; %}</p>
<pre><code>p sin(x) w l title &quot;sine wave&quot;, cos(x) w l title &quot;cos(x)&quot;
</code></pre>
<p>
    <img  class="center" src="plotting/res/gnuplot/sincos_label.png" style="width:70%" />
</p>
<p>Here, we show that we can modify the data labels to be whatever we want.
Note that for LaTeX-like math in the label, we might need to change the output to TeX, which will be shown later.</p>
<p>For now, let's move on to discuss what we can to with all of the labels in the legend</p>
<h4 id="legend"><a class="header" href="#legend">legend</a></h4>
<p>First things first, you should probably use a legend, unless you are a legend yourself and don't need one... In which case you can use the following:</p>
<p>{% sample lang=&quot;gnuplot&quot; %}</p>
<pre><code>set nokey
</code></pre>
<p>which will produce a plot that looks like this:</p>
<p>
    <img  class="center" src="plotting/res/gnuplot/sincos_nokey.png" style="width:70%" />
</p>
<p>Admittedly, you are probably not important enough to remove the legend and doing so will prevent readers from understanding the data you are plotting, so this should be used sparingly.
Instead, you should probably try to move the legend out of the way of the data, which can be done in a number of ways.</p>
<p>{% sample lang=&quot;gnuplot&quot; %}</p>
<p>In gnuplot, it is possible to specify where we place the legend by using certain keywords, like <code>top</code>, <code>bottom</code>, <code>left</code>, <code>right</code>, and <code>center</code>, like so:</p>
<pre><code>set key top left
</code></pre>
<p>which will produce a plot that looks like this:</p>
<p>
    <img  class="center" src="plotting/res/gnuplot/sincos_movekey.png" style="width:70%" />
</p>
<p>In addition, we can specify exact coordinates in the plot to place the legend.
For example, if we wanted the legend to be at the position (1,0.5), then we would use the following command:</p>
<pre><code>set key at 1, 0.5
</code></pre>
<p>which will produce a plot that looks like this:</p>
<p>
    <img  class="center" src="plotting/res/gnuplot/sincos_movekey2.png" style="width:70%" />
</p>
<p>This is certainly an awful place to put a legend for this plot, but this command could be useful for other plots.</p>
<h5 id="titles"><a class="header" href="#titles">titles</a></h5>
<p>Obviously, in addition to labels, we can also provide a title for the entire plot, like so:</p>
<p>{% sample lang=&quot;gnuplot&quot; %}</p>
<pre><code>set title &quot;Gnuplot Test&quot;
</code></pre>
<p>
    <img  class="center" src="plotting/res/gnuplot/sincos_title.png" style="width:70%" />
</p>
<h4 id="square-output"><a class="header" href="#square-output">square output</a></h4>
<p>Many times, plotting data in a 6:9 (or worse, 16:9) aspect ratio can feel like a misrepresentation of the data.
For whatever reason, I was told time and time again as a fledgling researcher that there is no need for widescreen plots and that I should set the output to square whenever possible.</p>
<p>That can be done by using</p>
<p>{% sample lang=&quot;gnuplot&quot; %}</p>
<pre><code>set size square
</code></pre>
<p>which will output the following plot:</p>
<p>
    <img  class="center" src="plotting/res/gnuplot/sincos_square.png" style="width:70%" />
</p>
<h4 id="line-and-point-types"><a class="header" href="#line-and-point-types">line and point types</a></h4>
<p>Finally, it's important to show your individuality by choosing your own point and line types.</p>
<p>{% sample lang=&quot;gnuplot&quot; %}
To find all the point or line types available in gnuplot, simply open the REPL and run the <code>test</code> command, which outputs something that looks like this:</p>
<p>
    <img  class="center" src="plotting/res/gnuplot/test.png" style="width:70%" />
</p>
<p>As a note, changing the line color is not mentioned in the test image above, this can be done with the <code>linecolor</code> command, which takes an argument in a color space like <code>rgb</code>.</p>
<p>If we would like to use a dashed black line for the sine function and purple crosses for cosine, we would use something like this:</p>
<pre><code>p sin(x) with lines dashtype 2 linecolor rgb &quot;black&quot; title &quot;sin(x)&quot;
rep cos(x) w p pt 17 lc rgb &quot;purple&quot; t &quot;cos(x)&quot;
</code></pre>
<p>This will create a plot that looks like this:</p>
<p>
    <img  class="center" src="plotting/res/gnuplot/sincos_lt.png" style="width:70%" />
</p>
<p>With this script, we are using a bunch of aliases, which can be found in the following section.
For now, it is clear that you can make your plot look however you like without too much trouble.
There are also a bunch of cool features that you can learn by looking up examples on the <a href="http://gnuplot.sourceforge.net/">gnuplot site</a>.</p>
<p>{% sample lang=&quot;gnuplot&quot; %}</p>
<h4 id="gnuplot-aliases"><a class="header" href="#gnuplot-aliases">gnuplot aliases</a></h4>
<p>As we have seen in this chapter, it is common to use several aliases with gnuplot, and I have tried to introduce these slowly in the above text.
Here are all the aliases stated explicitly:</p>
<table><thead><tr><th align="center">command</th><th align="center">alias</th></tr></thead><tbody>
<tr><td align="center"><code>plot</code></td><td align="center"><code>p</code></td></tr>
<tr><td align="center"><code>replot</code></td><td align="center"><code>rep</code></td></tr>
<tr><td align="center"><code>with lines</code></td><td align="center"><code>w l</code></td></tr>
<tr><td align="center"><code>with points</code></td><td align="center"><code>w p</code></td></tr>
<tr><td align="center"><code>linecolor</code></td><td align="center"><code>lc</code></td></tr>
<tr><td align="center"><code>pointtype</code></td><td align="center"><code>pt</code></td></tr>
<tr><td align="center"><code>title</code></td><td align="center"><code>t</code></td></tr>
</tbody></table>
<p>We will add more aliases to this table as they are used in the Algorithm Archive.</p>
<h3 id="outputting-the-plot-to-file"><a class="header" href="#outputting-the-plot-to-file">Outputting the plot to file</a></h3>
<p>At this point, all the scripts have shown so far will output an image directly to your computer screen; however, it is important to note that you can use any of the above methods when outputting to a file as well.</p>
<p>{% sample lang=&quot;gnuplot&quot; %}</p>
<p>For the most part, if you want to output any of the above scripts to a file, you simply need to run the following commands:</p>
<pre><code>set terminal pngcairo
set output &quot;check.png&quot;
</code></pre>
<p>In this case, we are changing the REPL type to work with png images with the Cairo back-end, which is a vector drawing library in C.
We are also setting the output to &quot;check.png&quot;.</p>
<p>If we would like to set the resolution of the output image, we could do the following:</p>
<pre><code>set terminal pngcairo size 640, 480
</code></pre>
<p>As an example, here is the script for the image we generated above:</p>
<p><a href="plotting/code/gnuplot/sine_to_file.gp">import, lang:&quot;gnuplot&quot;</a></p>
<p>As mentioned above, for a lot of scientific papers and articles, it is worth outputting images into a format that is used commonly for typesetting, such as LaTeX.
There are multiple ways to create TeX output with gnuplot by using different REPL modes like <code>epslatex</code>.</p>
<p>The easiest method to generate a pdf output with gnuplot that uses LaTeX would be to create a <code>standalone</code> TeX file, like so</p>
<pre><code>set terminal epslatex standalone size 10cm, 10cm
set output &quot;check.tex&quot;
</code></pre>
<p>This can be quickly turned into a pdf with the <code>pdflatex check.tex</code> command.</p>
<p>For example, if we run the following script:</p>
<p><a href="plotting/code/gnuplot/example_tex.gp">import, lang:&quot;gnuplot&quot;</a></p>
<p>and then run</p>
<pre><code>gnuplot file.gp
pdflatex out.tex
</code></pre>
<p>We will have a standalone pdf that uses LaTeX features in the file <code>out.pdf</code>.
This file should look like this:</p>
<p>
    <img  class="center" src="plotting/res/gnuplot/exponential_tex.png" style="width:70%" />
</p>
<p>Note that in this process, we create auxiliary files like <code>*.eps</code> and <code>*.aux</code>, which are expected with LaTeX.</p>
<p>If you would like to directly read the output <code>.tex</code> file from gnuplot into another LaTeX document, you can use the same command as above without the <code>standalone</code> option, like so:</p>
<pre><code>set terminal epslatex size 10cm, 10cm
set output &quot;check.tex&quot;
</code></pre>
<p>This will output another &quot;check.tex&quot; file that can be used by other LaTeX documents, and here is an example tex file to do that:</p>
<p><a href="plotting/code/gnuplot/latex_import.tex">import, lang:&quot;gnuplot&quot;</a></p>
<p>As a note, the units for the <code>epslatex</code> terminal are real units in terms of cm, inches, or whatever other measurement LaTeX takes.
As such, you will probably want to make sure the size of the output image from gnuplot actually fits in the document you want to create.</p>
<h2 id="plotting-data-from-a-file"><a class="header" href="#plotting-data-from-a-file">Plotting data from a file</a></h2>
<p>Each algorithm in the Algorithm Archive that requires plotting will also output a data file to use for this purpose.
Even though there are plenty of complex data formats to write to and read from, for the purposes of this text, we will focus on simple ASCII data.
This is not preferred for any data-intensive task and there are a large number of different storage formats and file types available to choose from for your specific purposes; however, the Algorithm Archive intends to provide the simplest explanation of algorithms and methods and we do not want to over-complicate the process with file input and output.</p>
<p>If multiple data sets are required to be plotted, they will also be provided a new file, usually with a zero-padded name such as <code>file_0000.dat</code>, <code>file_0001.dat</code>, <code>file_0002.dat</code>, and so on.
We will assume that your plotter of choice has limited  three dimensional capabilities and will instead focus on the data format for one and two-dimensional data here</p>
<h3 id="one-dimensional-output"><a class="header" href="#one-dimensional-output">One-dimensional output</a></h3>
<p>In the case of one-dimensional output, the data file will have all numbers separated by a newline, such as in this case:</p>
<p><a href="plotting/data/1d_sample_low_res.dat">import</a></p>
<p>For the purposes of the Algorithm Archive, we will call these data files <code>.dat</code> files; however, the file extension does not matter and you can just as well name the files <code>.tsv</code> or <code>.csv</code> depending on your tastes.</p>
<p>{% sample lang=&quot;gnuplot&quot; %}</p>
<p>Gnuplot can read in this file in the same way it can plot functions above.
So we can use the following command:</p>
<pre><code>plot &quot;sample_data.dat&quot; with lines
</code></pre>
<p>Which will provide the following output:</p>
<p>
    <img  class="center" src="plotting/res/gnuplot/1d_sample.png" style="width:70%" />
</p>
<h3 id="two-dimensional-image-output"><a class="header" href="#two-dimensional-image-output">Two-dimensional image output</a></h3>
<p>In the case of two-dimensional image output, the data file be similar, but this time, each number will be separated by a tab for different column entries and a newline for rows, as shown here:</p>
<p><a href="plotting/data/2d_sample_low_res.dat">import</a></p>
<p>It is expected that the number of columns does not vary in each row and that we are working with an \( n \times m \) matrix which can be simply plotted as a series of pixels that scale in color according to some defined colorbar.</p>
<p>{% sample lang=&quot;gnuplot&quot; %}</p>
<p>To create 2 dimensional plots in Gnuplot, we need to set the view to 2 dimensional and then do a 3 dimensional plot with the <code>splot</code> function that we set to a matrix image, like so:</p>
<pre><code>set view map
splot &quot;sample_data.dat&quot; matrix with image
</code></pre>
<p>
    <img  class="center" src="plotting/res/gnuplot/2d_sample.png" style="width:70%" />
</p>
<h4 id="changing-the-colorbar"><a class="header" href="#changing-the-colorbar">changing the colorbar</a></h4>
<p>For plotting images from data files, we will often need to specify how we color the image by setting a custom color bar</p>
<p>{% sample lang=&quot;gnuplot&quot; %}</p>
<p>In Gnuplot, there are not many predefined themes, but it is fairly easy to set your own theme for coloring a 2 dimensional image.
This is done by setting a <code>palette</code> and there are <a href="https://github.com/Gnuplotting/gnuplot-palettes">repositories online</a> that have a number of palettes to choose from.
Simply put, a palette is a number line where you can set a color to be associated with whatever value you like, like in this example:</p>
<pre><code>set view map
set palette defined (0 0 0 1, 1 'red', 2 '#00FF00')
splot &quot;2d_sample_low_res.dat&quot; matrix with image
</code></pre>
<p>The integer value corresponds to the location of the color on the color bar and the color can be set as either a recognized word (<code>blue</code>, <code>red</code>, <code>green</code>, etc.), HTML notation (<code>'#FF0000'</code>, <code>'#00FF00'</code>, <code>'#0000FF'</code>, etc.), or RGB colors (<code>1 0 0</code>, <code>0 1 0</code>, <code>0 0 1</code>, etc.).
This example will output the following plot:</p>
<p>
    <img  class="center" src="plotting/res/gnuplot/2d_sample_cb.png" style="width:70%" />
</p>
<h3 id="scatter-plots"><a class="header" href="#scatter-plots">Scatter Plots</a></h3>
<p>The scatter plot is another useful method for visualizing data that plots each point in an \( n \) -dimensional space.
For the purposes of the Algorithm Archive, this space is mainly two-dimensional; however, scatter plots in three-dimensions may also be used for visualizing three-dimensional datasets.
We will update this section if three-dimensional scatter plots are required.</p>
<p>For the purposes of the Algorithm Archive, scatter plot data will be output as a series of \( x \) and \( y \) pairs, where each row has an \( x \) and a \( y \) value, separated by a tab character.
For example, a datafile might look like this:</p>
<p><a href="plotting/data/scatterplot_data.dat">import:1-10</a></p>
<p>For three-dimensional scatter plots, there might be a third, \( z \) dimension.</p>
<p>{% sample lang=&quot;gnuplot&quot; %}</p>
<p>In gnuplot, scatter plots are easy to generate with the provided data format, for example, you could use the following command:</p>
<pre><code>p &quot;scatterplot_data.dat&quot; pt 7
</code></pre>
<p>Which will create the following image</p>
<p>
    <img  class="center" src="plotting/res/gnuplot/scatterplot.png" style="width:70%" />
</p>
<p>Here, we have chosen <code>pointtype 7</code>, simply because it is easier to see when compared to the default crosses.</p>
<p>If you are interested in seeing this type of plot generate fractal patterns, please look at the chapter on <a href="plotting/../IFS/IFS.html">iterated function systems</a>.</p>
<h2 id="conclusions"><a class="header" href="#conclusions">Conclusions</a></h2>
<p>Plotting is a powerful tool that is essential for most of computational science.
Here, we have provided all of the essential skills to plot any data that comes from the Algorithm Archive, and we will strive to provide the plotting scripts we used whenever possible.</p>
<h3 id="bibliography"><a class="header" href="#bibliography">Bibliography</a></h3>
<p>{% references %} {% endreferences %}</p>
<h5 id="code-examples-2"><a class="header" href="#code-examples-2">Code Examples</a></h5>
<p>The code examples are licensed under the MIT license (found in <a href="https://github.com/algorithm-archivists/algorithm-archive/blob/master/LICENSE.md">LICENSE.md</a>).</p>
<h5 id="text-2"><a class="header" href="#text-2">Text</a></h5>
<p>The text of this chapter was written by <a href="https://github.com/leios">James Schloss</a> and is licensed under the <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</p>
<p><a href="https://creativecommons.org/licenses/by-sa/4.0/"><p><img  class="center" src="plotting/../cc/CC-BY-SA_icon.svg" /></p></a></p>
<h5 id="imagesgraphics"><a class="header" href="#imagesgraphics">Images/Graphics</a></h5>
<p>{% sample lang=&quot;gnuplot&quot; %}</p>
<ul>
<li>The image &quot;<a href="plotting/res/gnuplot/sine.png">gnuplot_sine_wave</a>&quot; was created by <a href="https://github.com/leios">James Schloss</a> and is licensed under the <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</li>
<li>The image &quot;<a href="plotting/res/gnuplot/sincos.png">gnuplot_sine_cosine_wave</a>&quot; was created by <a href="https://github.com/leios">James Schloss</a> and is licensed under the <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</li>
<li>The image &quot;<a href="plotting/res/gnuplot/sincos_range.png">gnuplot_sine_cosine_wave_range</a>&quot; was created by <a href="https://github.com/leios">James Schloss</a> and is licensed under the <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</li>
<li>The image &quot;<a href="plotting/res/gnuplot/sincos_notics.png">gnuplot_sine_cosine_notics</a>&quot; was created by <a href="https://github.com/leios">James Schloss</a> and is licensed under the <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</li>
<li>The image &quot;<a href="plotting/res/gnuplot/sincos_customtics.png">gnuplot_sine_cosine_customtics</a>&quot; was created by <a href="https://github.com/leios">James Schloss</a> and is licensed under the <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</li>
<li>The image &quot;<a href="plotting/res/gnuplot/exp.png">exp_fn</a>&quot; was created by <a href="https://github.com/leios">James Schloss</a> and is licensed under the <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</li>
<li>The image &quot;<a href="plotting/res/gnuplot/explog.png">exp_fn_log</a>&quot; was created by <a href="https://github.com/leios">James Schloss</a> and is licensed under the <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</li>
<li>The image &quot;<a href="plotting/res/gnuplot/sincos_log.png">gnuplot_sine_cosine_log</a>&quot; was created by <a href="https://github.com/leios">James Schloss</a> and is licensed under the <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</li>
<li>The image &quot;<a href="plotting/res/gnuplot/sincos_label.png">gnuplot_sine_cosine_label</a>&quot; was created by <a href="https://github.com/leios">James Schloss</a> and is licensed under the <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</li>
<li>The image &quot;<a href="plotting/res/gnuplot/sincos_nokey.png">gnuplot_sine_cosine_nokey</a>&quot; was created by <a href="https://github.com/leios">James Schloss</a> and is licensed under the <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</li>
<li>The image &quot;<a href="plotting/res/gnuplot/sincos_movekey.png">gnuplot_sine_cosine_movekey</a>&quot; was created by <a href="https://github.com/leios">James Schloss</a> and is licensed under the <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</li>
<li>The image &quot;<a href="plotting/res/gnuplot/sincos_movekey2.png">gnuplot_sine_cosine_movekey2</a>&quot; was created by <a href="https://github.com/leios">James Schloss</a> and is licensed under the <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</li>
<li>The image &quot;<a href="plotting/res/gnuplot/sincos_title.png">gnuplot_sine_cosine_title</a>&quot; was created by <a href="https://github.com/leios">James Schloss</a> and is licensed under the <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</li>
<li>The image &quot;<a href="plotting/res/gnuplot/sincos_square.png">gnuplot_sine_cosine_square</a>&quot; was created by <a href="https://github.com/leios">James Schloss</a> and is licensed under the <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</li>
<li>The image &quot;<a href="plotting/res/gnuplot/test.png">gnuplot_test</a>&quot; was created by the <code>gnuplot test</code> command, and gnuplot has <a href="https://sourceforge.net/p/gnuplot/gnuplot-main/ci/master/tree/Copyright">this copyright</a>.</li>
<li>The image &quot;<a href="plotting/res/gnuplot/sincos_lt.png">gnuplot_sine_cosine_linetype</a>&quot; was created by <a href="https://github.com/leios">James Schloss</a> and is licensed under the <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</li>
<li>The image &quot;<a href="plotting/res/gnuplot/exponential_tex.png">gnuplot_exp_tex</a>&quot; was created by <a href="https://github.com/leios">James Schloss</a> and is licensed under the <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</li>
<li>The image &quot;<a href="plotting/res/gnuplot/1d_sample.png">gnuplot_1d_sample</a>&quot; was created by <a href="https://github.com/leios">James Schloss</a> and is licensed under the <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</li>
<li>The image &quot;<a href="plotting/res/gnuplot/2d_sample.png">gnuplot_2d_sample</a>&quot; was created by <a href="https://github.com/leios">James Schloss</a> and is licensed under the <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</li>
<li>The image &quot;<a href="plotting/res/gnuplot/2d_sample_cb.png">gnuplot_2d_sample_colorbar</a>&quot; was created by <a href="https://github.com/leios">James Schloss</a> and is licensed under the <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</li>
<li>The image &quot;<a href="plotting/res/gnuplot/scatterplot.png">gnuplot_scatterplot</a>&quot; was created by <a href="https://github.com/leios">James Schloss</a> and is licensed under the <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</li>
</ul>
<h5 id="pull-requests-2"><a class="header" href="#pull-requests-2">Pull Requests</a></h5>
<p>The following pull requests have modified the text or graphics of this chapter:</p>
<ul>
<li>622: Initial PR for chapter</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="domain-coloring"><a class="header" href="#domain-coloring">Domain coloring</a></h1>
<p>Domain coloring is a much more complicated plotting technique than those outlined in the <a href="domain_coloring/../plotting/plotting.html">plotting chapter</a> and is used to plot complex functions where both the input and output have imaginary and real components.
For the code in this chapter, we will focus on languages that are easily able to plot two-dimensional images or heat maps, instead of languages meant for number-crunching.
That is to say that this chapter will certainly have a code implementation in gnuplot, but it will not likely have an implementation in C, Fortran, or Java because these languages do not have plotting capabilities in-built.</p>
<p>To start, imagine the following function: \( f(z) = z^2 \).
In this case, we could create a plot that looks like this:</p>
<p>
    <img  class="center" src="domain_coloring/res/z2.png" style="width:70%" />
</p>
<p>This indicates that for various input values along \( z \), we have different function outputs from \( f(z) \).
For this function, \( z\in\mathbb{R} \) is purely in real space and because of this, the output is also in real space.
Now let's imagine another function with complex input \( (z \in \mathbb{C}) \), but a purely real output \( (f(z) \in \mathbb{R}) \):</p>
<p>\[ f(z) = |z| \]</p>
<p>In this case, this can be plotted as a two-dimensional dataset like so:</p>
<p>
    <img  class="center" src="domain_coloring/res/absz.png" style="width:84%" />
</p>
<p>Here, the \( x \)-axis and \( y \)-axis represent the imaginary and real components of the input variable, respectively.
The color bar represents the output of \( f(z) \).</p>
<p>At this point, we can start to see the problem.
If the output of \( f(z) \) also requires plotting of real and imaginary components, then we would need four dimensions to appropriately represent the full function space, one axis for the real component and another for the imaginary component of both the input (\( z \)) and the output of \( f(z) \)!
Unfortunately, feeble human minds are incapable of understanding four spatial dimensions without projecting onto lower dimensionality, so we need to improvise.</p>
<p>We do this by assuming the complex output can be represented in the following form:</p>
<p>\[ z = re^{i \theta} = r(\cos(\theta) + i\sin(\theta)) \]</p>
<p>where, \( r \) is a complex magnitude and \( \theta \) is a complex phase.
This is the formula for a circle in the complex plane and we can easily find \( r \) and \( \theta \) like so:</p>
<p>\[
\begin{align}
r &amp;= \sqrt{\text{Re}(z)^2 + \text{Im}(z)^2} \\ 
\theta &amp;= \text{atan}\left(\frac{\text{Im}(z)}{\text{Re}(z)}\right)
\end{align}
\]</p>
<p>Once we have our complex function output in this form, we then color the output domain according to a color space with at least 2 independent dimensions, like RGB (Red, Green, Blue), or HSV (Hue, Saturation, Value) {{ &quot;hsv&quot; | cite }}.
The choice of color space is completely dependent on what the users feel is most visually intuitive.
In any case, one dimension of the color system will be used to represent the complex magnitude and another dimension of the color system will be used to represent the complex phase of the output.
The \( xy \) grid will be representing the real and imaginary inputs to these functions.
That is to say, we plug every value in the 2D complex plane into the function and then color each pixel based on the function output.</p>
<p>As an example, let's look at the simplest function we can \( f(z) = z \), but in this case \( z \in \mathbb{C} \).
If we use an RGB color scheme, where red represents \( \theta \) and blue represents \( r \), we can generate the following image:</p>
<p>
    <img  class="center" src="domain_coloring/res/rgb1.png" style="width:84%" />
</p>
<p>As a note here, there is a clear phase discontinuity along the horizontal axis, which is a consequence of the fact that
the complex phase wraps around the origin, ranging from 0 (clear) to \( 2\pi \) (red).
In addition, the edges of the plot are blue because the function's magnitude increases linearly as we move from the origin.</p>
<p>If we instead look at the function \( f(z) = z^2 \), we can generate a similar plot:</p>
<p>
    <img  class="center" src="domain_coloring/res/rgb2.png" style="width:84%" />
</p>
<p>Here, it is clear that the complex phase wraps around the origin twice, creating two separate phase discontinuities on top of each other.
This indicates a \( 4\pi \) phase winding.
For some purposes, such as vortex tracking for inviscid fluids, this visualization is ideal, because a vortex is located precisely at the center of the phase discontinuity {{ &quot;schloss2019&quot; | cite }} {{ &quot;pethick2008&quot; | cite }}.
For other purposes, the discontinuity is visually distracting, and for this reason, many people use an HSV scheme for plotting complex functions {{ &quot;wegert2012&quot; | cite }} {{ &quot;poelkedomain&quot; | cite }} {{ &quot;lundmark2004&quot; | cite }}.
So here is the same function \( \left(f(z)=z^2\right) \), but using hue to represent the complex phase and saturation to represent the magnitude:</p>
<p>
    <img  class="center" src="domain_coloring/res/hsv.png" style="width:84%" />
</p>
<p>In this plot, the Value for HSV was always set to 1.
When looking at the edges of the plot, the hue changes rapidly, but each color is mirrored on the opposite edge.
This indicates the \( 4\pi \) phase winding we saw in the RGB plot.
Also, because the complex magnitude increases as we move further from the center of the plot, the saturation also increases.
Thus the center of the plot is completely washed out!
We need to fix this in subsequent plots to make them more representative of the actual data.</p>
<p>One easy way to show the increasing complex magnitude without sacrificing phase information is by using contours.
Essentially, at ever integer value of the magnitude, we want to draw some kind of line.
There are a number of ways to generate these lines, and one simple way is by using an alternative shading function like so:</p>
<p>\[ g(r) = r-\lfloor r \rfloor. \]</p>
<p>This will create the following image:</p>
<p>
    <img  class="center" src="domain_coloring/res/hsv2.png" style="width:84%" />
</p>
<p>This function will essentially create a smooth gradient, but because of the floor operation \( \left(\lfloor \cdot \rfloor \right) \), the saturation will go from 0 to 1 between each integer value of the magnitude.
Here, it is clear that the magnitude is increasing as \( z^2 \) from the origin; however, because the saturation is fluctuating so much, it is difficult to see the phase pattern next to each contour.
This can be fixed simply by adding an offset to the shading function such that,</p>
<p>\[ g(r) = \frac{1}{2} + \frac{1}{2}\left(r-\lfloor r \rfloor \right). \]</p>
<p>Which will produce the following image:</p>
<p>
    <img  class="center" src="domain_coloring/res/hsv3.png" style="width:84%" />
</p>
<p>This means that the saturation will fluctuate from \( \frac12 \) to 1 instead of from 0 to 1, which makes it way easier to see phase information next to contours.
Again, there are a lot of different ways to play with these equations, so feel free to use whatever function you want!
As long as some sort of rounding operation is used to establish some form of integer value for the magnitude, it should be possible to create contours of various types.</p>
<p>At this point, changing the saturation shows changes in the complex magnitude, and changing the hue shows changes in the complex phase.
Unfortunately, neither the magnitude nor the phase directly show what is happening in real or imaginary space with the output.
To show this, we might want to draw grid lines that color our pixels black whenever the imaginary or real components of the output function are integer values.</p>
<p>For example, let's go back to a simpler function \( f(z) = z \).
If we draw lines on this plot, corresponding to integer values in the output, we get a simple grid</p>
<p>
    <img  class="center" src="domain_coloring/res/hsv4.png" style="width:84%" />
</p>
<p>Like before, the choice of which function to use in order to create the grid lines is somewhat arbitrary.
It is important to choose a function that sharply drops to 0 or peaks at 1 for all integer values, and then we simply plug values of \( f(z) \) into this function.
For the purposes of this chapter, we chose the following function</p>
<p>\[ h(z) = |\sin(\pi\times\text{Re}(f(z)))^t|\times|\sin(\pi\times\text{Im}(f(z)))^t|, \]</p>
<p>where \( t \) is some threshold value, and was set to be 0.1 in our plot.
A plot of \( h(z) \) for \( f(z) = z \) where \( z\in\mathbb{R} \) is shown below:</p>
<p>
    <img  class="center" src="domain_coloring/res/shade.png" style="width:84%" />
</p>
<p>So, putting it all together and returning to the function of \( f(z) = z^2 \), we find the following image.</p>
<p>
    <img  class="center" src="domain_coloring/res/hsv5.png" style="width:84%" />
</p>
<p>Here, the diagonal lines through the center represent integer values along the imaginary axis for \( f(z) \) and the vertical and horizontal lines represent integer values of the real axis for \( f(z) \).
An easy way to determine which lines correspond to which integer values is by plugging in certain values for \( z \) into \( f(z) \).
For example, there is a black line at \( z = 1 + 1i \) where \( f(z) = 2i \), this means that all values along that contour correspond to values that are constrained to having an imaginary component of precisely 2.</p>
<p>Overall, there are plenty of interesting ways to plot complex functions and make really compelling and beautiful images!
We will be using domain coloring in other contexts throughout this text when describing methods that heavily use complex space.</p>
<h2 id="video-explanation"><a class="header" href="#video-explanation">Video Explanation</a></h2>
<p>Here is a video describing domain coloring:</p>
<div style="text-align:center">
<iframe width="560" height="315" src="https://www.youtube.com/embed/EbanExb75mc" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
</div>
<h2 id="example-code"><a class="header" href="#example-code">Example Code</a></h2>
<p>Here is the full script to generate a domain colored output of \( f(z)=z^2 \).</p>
<pre><code class="language-gnuplot"># setting output to file of size 800 x 800
set terminal pngcairo size 1000, 1000 
set output 'domain.png'

# sets title for full plot
set title 'f(z)=z^2'

# removes legend
unset key

# projects image onto 2D plane
set view map

# sets aspect ratio of plot to be square 
set size square

# sets x and y range and labels
set xrange[-2:2]
set yrange[-2:2]

set xlabel &quot;Re(z)&quot;
set ylabel &quot;Im(z)&quot;

# scaling the x, y, and colorbar tics to zero so they are not seen in the plot
set xtics border scale 0,0
set ytics border scale 0,0
set cbtics border scale 0,0

# sets tics in color bar at 0 and 2pi
set cbtics (&quot;0&quot; -3.14159, '2pi' 3.14159)

set cblabel &quot;Phase Angle&quot; 
set cbrange [ -3.14159 : 3.14159 ]

# use hsv for colorbar and set palette to use full hsv space
set palette model HSV
set palette defined ( 0 0 1 1, 1 1 1 1 )

# setting isosamples for output grid and samples for input grid
set isosamples 2000, 2000
set samples 2000, 2000

# setting functions necessary for domain coloring
# setting threshold for gridlines. Smaller threshold will make smaller lines
thresh = 0.1
f(z) = z**2

# atan2 returns a range from -pi to pi, so we need to add pi, but this offsets
# the value by 180 degrees, so we also imput (-y, -x) for another 180 degrees
# to invert rotation
angle(x,y) = (pi + atan2(-y,-x)) / (2*pi)

# complex magnitude
r(x,y) = sqrt(x*x + y*y)

# complex phase and magnitude
theta(x,y) = atan2(y,x)
z(x,y) = r(x,y)*exp(theta(x,y)*sqrt(-1))

# imaginary and real output functions
imaginary_f(z) = imag(f(z))
real_f(z) = real(f(z))

# magnitude contours
magnitude_shading(x,y) = 0.5 + 0.5*(abs(f(z(x,y)))-floor(abs(f(z(x,y)))))

# gridlines
gridlines(x,y) = (abs(sin(real_f(z(x,y))*pi)**thresh) \
                  * abs(sin(imaginary_f(z(x,y))*pi))**thresh)

# overall coloring function
color(x,y) = hsv2rgb(angle(real_f(z(x,y)), imaginary_f(z(x,y))), \
                     magnitude_shading(x,y), \
                     gridlines(x,y))

save_encoding = &quot;utf8&quot;

# Last datafile plotted: &quot;++&quot;
# In this case, it means, &quot;plot the data file created with the
#                          samples and isosamples&quot;
splot '++' using 1:2:(color($1,$2)) with pm3d lc rgb variable nocontour
</code></pre>
<pre><code class="language-python">
import numpy as np
import matplotlib.pyplot as plt
import matplotlib.colors
from matplotlib.cm import ScalarMappable


def f(z):
    return z**2


def magnitude_shading(f_val):
    f_val_abs = np.abs(f_val)
    return 0.5 + 0.5 * (f_val_abs - np.floor(f_val_abs))


def gridlines(f_val, threshold):
    return (np.abs(np.sin(np.pi * np.real(f_val))) ** threshold
            * np.abs(np.sin(np.pi * np.imag(f_val))) ** threshold)


def color(f_val, threshold):
    hue = (np.pi - np.angle(f_val)) / (2.0 * np.pi)
    saturation = magnitude_shading(f_val)
    value = gridlines(f_val, threshold)

    # Currently we have a tuple of 2D-arrays (hue, saturation, value).
    # This makes it a 2D-array of tuples, which the conversion function requires.
    hsv = np.moveaxis((hue, saturation, value), 0, -1)
    return matplotlib.colors.hsv_to_rgb(hsv)


if __name__ == &quot;__main__&quot;:
    # Create a new figure containing a single plot
    fig, axes = plt.subplots(1, 1)

    # Set the title for the plot
    axes.set_title(&quot;$f(x)=z^2$&quot;)

    # Create color bar
    cbar = fig.colorbar(
        ScalarMappable(matplotlib.colors.Normalize(0.0, 2.0 * np.pi), &quot;hsv&quot;),
        ax=axes,
        label=&quot;Phase Angle&quot;)

    # Set x and y labels
    axes.set_xlabel(&quot;$Re(z)$&quot;)
    axes.set_ylabel(&quot;$Im(z)$&quot;)
    
    # Set color bar tick locations and labels
    cbar.set_ticks([0.0, np.pi, 2.0 * np.pi])
    cbar.set_ticklabels([&quot;$0.0$&quot;, &quot;$\pi$&quot;, &quot;$2\pi$&quot;])

    # Hide x and y ticks
    for tick in axes.get_xticklines():
        tick.set_visible(False)

    for tick in axes.get_yticklines():
        tick.set_visible(False)

    # Create a 500x500 input grid
    coords = np.linspace(-2.0, 2.0, 500)
    z_real, z_imag = np.meshgrid(coords, coords)
    z = z_real + 1j * z_imag

    # Calculate function values
    f_val = f(z)

    # Map function values to colors
    colors = color(f_val, 0.1)

    # Plot the colors
    #   extent=(-2.0, 2.0, -2.0, 2.0) sets the x and y ranges
    #   origin=&quot;lower&quot; places index (0,0) of the color array in the lower-left corner
    #   aspect=&quot;equal&quot; ensures that the plot is square
    axes.imshow(
        colors,
        extent=(-2.0, 2.0, -2.0, 2.0),
        origin=&quot;lower&quot;,
        aspect=&quot;equal&quot;)

    # Save output
    fig.savefig(&quot;domain.png&quot;)
</code></pre>
<h3 id="bibliography-1"><a class="header" href="#bibliography-1">Bibliography</a></h3>
<p>{% references %} {% endreferences %}</p>
<h2 id="license-3"><a class="header" href="#license-3">License</a></h2>
<h5 id="code-examples-3"><a class="header" href="#code-examples-3">Code Examples</a></h5>
<p>The code examples are licensed under the MIT license (found in <a href="https://github.com/algorithm-archivists/algorithm-archive/blob/master/LICENSE.md">LICENSE.md</a>).</p>
<h5 id="text-3"><a class="header" href="#text-3">Text</a></h5>
<p>The text of this chapter was written by <a href="https://github.com/leios">James Schloss</a> and is licensed under the <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</p>
<p><a href="https://creativecommons.org/licenses/by-sa/4.0/"><p><img  class="center" src="domain_coloring/../cc/CC-BY-SA_icon.svg" /></p></a></p>
<h5 id="imagesgraphics-1"><a class="header" href="#imagesgraphics-1">Images/Graphics</a></h5>
<ul>
<li>The image &quot;<a href="domain_coloring/res/z2.png">z2</a>&quot; was created by <a href="https://github.com/leios">James Schloss</a> and is licensed under the <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</li>
<li>The image &quot;<a href="domain_coloring/res/absz.png">absz</a>&quot; was created by <a href="https://github.com/leios">James Schloss</a> and is licensed under the <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</li>
<li>The image &quot;<a href="domain_coloring/res/rgb1.png">rgb1</a>&quot; was created by <a href="https://github.com/leios">James Schloss</a> and is licensed under the <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</li>
<li>The image &quot;<a href="domain_coloring/res/rgb2.png">rgb2</a>&quot; was created by <a href="https://github.com/leios">James Schloss</a> and is licensed under the <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</li>
<li>The image &quot;<a href="domain_coloring/res/hsv.png">hsv1</a>&quot; was created by <a href="https://github.com/leios">James Schloss</a> and is licensed under the <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</li>
<li>The image &quot;<a href="domain_coloring/res/hsv2.png">hsv2</a>&quot; was created by <a href="https://github.com/leios">James Schloss</a> and is licensed under the <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</li>
<li>The image &quot;<a href="domain_coloring/res/hsv3.png">hsv3</a>&quot; was created by <a href="https://github.com/leios">James Schloss</a> and is licensed under the <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</li>
<li>The image &quot;<a href="domain_coloring/res/hsv4.png">hsv4</a>&quot; was created by <a href="https://github.com/leios">James Schloss</a> and is licensed under the <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</li>
<li>The image &quot;<a href="domain_coloring/res/shade.png">shade</a>&quot; was created by <a href="https://github.com/leios">James Schloss</a> and is licensed under the <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</li>
<li>The image &quot;<a href="domain_coloring/res/hsv5.png">hsv5</a>&quot; was created by <a href="https://github.com/leios">James Schloss</a> and is licensed under the <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</li>
</ul>
<h5 id="pull-requests-3"><a class="header" href="#pull-requests-3">Pull Requests</a></h5>
<p>The following pull requests have modified the text or graphics of this chapter:</p>
<ul>
<li>none</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="iterated-function-systems"><a class="header" href="#iterated-function-systems">Iterated Function Systems</a></h1>
<p>A few quick notes before we start:</p>
<ol>
<li>
<p>For this chapter, we will be following the methodology set by the <a href="IFS/../plotting/plotting.html">plotting chapter</a>.
That is to say that the code presented in this chapter will output another file that can be easily plotted by an external plotter.
If you like to use a plotter provided by your language of choice, please modify the code provided to do so.</p>
</li>
<li>
<p>This chapter is currently a subsection to the plotting chapter, but we may extend the algorithm archive in the future with other fractal generation methods, which would require creating a new section on fractals, in particular.
This would include a chapter with more rigorous definitions on fractals, which is largely missing from the following discussion.
Please let us know if you are interested!</p>
</li>
</ol>
<p>In this chapter, we will show you how to make one of the most famous fractals, the Sierpinski triangle, via Iterated Function Systems (IFSs).
We will also introduce a number of interesting concepts for further exploration, such as chaos games, Hutchinson operators, and attractors.</p>
<h2 id="the-sierpinski-triangle"><a class="header" href="#the-sierpinski-triangle">The Sierpinski Triangle</a></h2>
<p>To begin the discussion of Iterated Function Systems (IFSs), we will first discuss what might be one of the most famous fractals currently known: the Sierpinski triangle (shown below):</p>
<img class="center" src="IFS/res/IFS_triangle_1.png" alt="Sierpinsky Triangle Chaos Game"  style="width:100%">
<p>This image is clearly a set of triangles embedded in a larger triangle in such a way that it can be continually cut into three identical pieces and still retain its internal structure.
This idea is known as self-similarity {{&quot;self-similar&quot; | cite }}, and it is usually the first aspect of fractals to catch an audience's attention.
In fact, there are plenty of uses of fractals and their mathematical underpinnings, such as estimating the coastline of Britain {{ &quot;mandelbrot1967long&quot; | cite}}, identifying fingerprints {{ &quot;jampour2010new&quot; | cite }}, and image compression {{ &quot;fractal-compression&quot; | cite }}{{ &quot;saupe1994review&quot; | cite }}.
In many more rigorous definitions, a fractal can be described as any system that has a non-integer Hausdorff dimension {{ &quot;3b1bfractal&quot; | cite }}{{ &quot;hausdorff&quot; | cite }}{{ &quot;gneiting2012estimators&quot; | cite }}.
Though this is an incredibly interesting concept, the discussion of this chapter will instead focus on methods to generate fractal patterns through iterated function systems.</p>
<p>To start, imagine creating a triangle from three points, \( A \), \( B \), and \( C \).
These points can be arbitrarily chosen, but for this conversation, we will constrict them to the vertices of an equilateral triangle, as shown below:</p>
<img class="center" src="IFS/res/IFS_triangle_2.png" alt="Triangle Vertices"  style="width:100%">
<p>Now let's create three separate functions that can act on a 2-dimensional space:</p>
<p>\[
\begin{align}
f_1(P) &amp;= \frac{P + A}{2}\\\\
f_2(P) &amp;= \frac{P + B}{2}\\\\
f_3(P) &amp;= \frac{P + C}{2}\\\\
\end{align}
\]</p>
<p>Each function will read in a particular location in space (here, \( P \in \mathbb{R}^2 \)) and output a new location that is the midpoint between the input location and \( A \), \( B \), or \( C \) for \( f_1 \), \( f_2 \), and \( f_3 \) respectively.
The union of all of these functions (the set of all possible functions available for use) is often notated as the <em>Hutchinson operator</em> {{ &quot;hutchinson-operator&quot; | cite }}{{ &quot;hutchinson1981fractals&quot; | cite}}, and for this case it would look like this:</p>
<p>\[ H(P) = \bigcup_{i=1}^3f_i(P) \]</p>
<p>By iteratively using this operator, we can traverse through all possible movements in the set.
For example, let's generate 3 new points that are halfway between \( A \) and \( B \), \( B \) and \( C \), and \( A \) and \( C \), which will be called \( D \), \( E \), and \( F \) respectively.
This is shown below:</p>
<img class="center" src="IFS/res/IFS_triangle_3.png" alt="Triangle Midpoints"  style="width:100%">
<p>From here, each new point (\( D \), \( E \), and \( F \)) will spawn 3 children, and each child will move according to one of the three possible functions in the Hutchinson operator, as shown below:</p>
<div style="text-align:center">
<video style="width:100%" controls>
  <source src="res/IFS_triangle_vid_1.mp4" type="video/mp4">
  <img class="center" src="IFS/res/IFS_triangle_4.png" alt="First Children"  style="width:100%">
</video>
</div>
<p>Here, all red children come from \( D \), green children come from \( E \) and blue children come from \( F \).
At this stage, the children will then spawn 3 more children, each of which will move according to a different function.
Those children will then spawn more children, who act accordingly.
As this process continues on and on, we begin to see an interesting pattern form:</p>
<div style="text-align:center">
<video style="width:100%" controls>
  <source src="res/IFS_triangle_vid_2.mp4" type="video/mp4">
  <img class="center" src="IFS/res/IFS_triangle_5.png" alt="Last children"  style="width:100%">
</video>
</div>
<p>This is the Sierpinski triangle.
At first, it might seem like mathematical magic that a simple set of 3 functions can create such a pattern.
After all, why aren't any of the children migrating to the empty spaces in the structure?
This will require some thought, but the simplest answer is that no function within the Hutchinson operator allows for children to enter those spaces; therefore, none of the children can enter them.</p>
<h2 id="what-about-a-square"><a class="header" href="#what-about-a-square">What about a square?</a></h2>
<p>When I learned about how the Sierpinski triangle could be generated from 3 simple functions, I began to wonder about other shapes.
Could we create fractal squares? Hexagons? Circles?
Such shapes <em>seem</em> like natural extensions to the triangular Hutchinson operator provided above, but there's a bit of a hitch...</p>
<p>First, let's take 4 points, \( A \), \( B \), \( C \), and \( D \), this time located at the four vertices of a square, like so:</p>
<img class="center" src="IFS/res/IFS_square_1.png" alt="Sierpinsky Triangle Chaos Game"  style="width:100%">
<p>In a similar fashion, we'll create 4 functions with \( H(P) = \bigcup_{i=1}^4f_i(P) \), and \( P \in \mathbb{R}^2 \) such that:</p>
<p>\[
\begin{align}
f_1(P) &amp;= \frac{P + A}{2}\\\\
f_2(P) &amp;= \frac{P + B}{2}\\\\
f_3(P) &amp;= \frac{P + C}{2}\\\\
f_4(P) &amp;= \frac{P + D}{2}\\\\
\end{align}
\]</p>
<p>If we then create 5 initial points located between all the vertices and allow these points to continually spawn children like before, something peculiar happens:</p>
<div style="text-align:center">
<video style="width:100%" controls>
  <source src="res/IFS_square_vid_1.mp4" type="video/mp4">
  <img class="center" src="IFS/res/IFS_square_2.png" alt="Hutchinson square"  style="width:100%">
</video>
</div>
<p>We essentially see a square of squares.
What happened to the self-similar structure we were getting before?
Why isn't this more interesting?</p>
<p>The best answer I have for now is that some Hutchinson operators are interesting and some are not.
Still, this square is a bit more interesting than it first appears, but to see why, we need to use the Hutchinson operator in a slightly different way.</p>
<h2 id="chaos-games-and-attractors"><a class="header" href="#chaos-games-and-attractors">Chaos games and attractors</a></h2>
<p>Until now, our visualizations for both the Sierpinski triangle and the square have been computationally costly.
Every iteration, we generate 3 or 4 new children per child per step of the simulation.
This scales exponentially and means that we will quickly have millions of children to keep track of!
In fact, to deal with this, we developed our own method of counting through the tree to more efficiently keep track of everything, but that is a story for another day.</p>
<p>The question for now is whether there is a more computationally feasible way of iterating through our Hutchinson operator.</p>
<p>As it turns out, there is!
Rather than keeping track of every possible movement within the Hutchinson operator to draw out a shape, it's actually possible to randomly sample the function set instead through a process known as a <em>chaos game</em> {{ &quot;chaos-game&quot; | cite }}{{ &quot;chaos-game-wolf&quot; | cite }}..
Here, instead of tracking children of children, we track a single individual that chooses randomly between the Hutchinson functions, as shown here:</p>
<pre><code class="language-julia">function chaos_game(n::Int, shape_points)

    # Initializing the output array and the initial point
    output_points = zeros(n,2)
    point = [rand(), rand()]

    for i = 1:n
        output_points[i,:] .= point
        point = 0.5*(rand(shape_points) .+ point)
    end

    return output_points

end
</code></pre>
<pre><code class="language-haskell">chaosGame :: RandomGen g =&gt; g -&gt; Int -&gt; Array Int (Point -&gt; Point) -&gt; [Point]
chaosGame g n hutchinson = take n points
  where
    (x, g') = random g
    (y, g'') = random g'
    choices = randomRs (bounds hutchinson) g''
    points = Point x y : zipWith (hutchinson !) choices points
</code></pre>
<pre><code class="language-cpp">// This is a function to simulate a &quot;chaos game&quot;
PointVector chaosGame(int numOutputPoints, const PointVector&amp; inputPoints) {
  // Choose first point randomly
  Point curPoint = {drand(), drand()};

  // For each output point, compute midpoint to random input point
  PointVector outputPoints(numOutputPoints);
  for (auto&amp; outPoint : outputPoints) {
    outPoint = curPoint;
    curPoint = 0.5 * (curPoint + choose(inputPoints));
  }

  return outputPoints;
}
</code></pre>
<pre><code class="language-python">def chaos_game(n, shape_points):
    # Initialize the starting point
    point = [random(), random()]

    for _ in range(n):
        # Update the point position and yield the result
        point = [(p + s) / 2 for p, s in zip(point, choice(shape_points))]
        yield point
</code></pre>
<pre><code class="language-c">void chaos_game(struct point *in, size_t in_n, struct point *out,
                size_t out_n) {

    struct point cur_point = {drand(), drand()};

    for (int i = 0; i &lt; out_n; ++i) {
        out[i] = cur_point;
        struct point tmp = random_element(in, in_n);
        cur_point.x = 0.5 * (cur_point.x + tmp.x);
        cur_point.y = 0.5 * (cur_point.y + tmp.y);
    }
}
</code></pre>
<pre><code class="language-lisp">(defun chaos-game (iterations shape-points)
  &quot;Plays a chaos game with a certain shape for a determined amount of iterations&quot;
  (loop
    repeat iterations
    for rand-point = (svref shape-points (random (length shape-points)))
    for point = (make-point (random 1.0) (random 1.0)) ; starting point
    then (make-point
           (* 0.5 (+ (point-x rand-point) (point-x point)))
           (* 0.5 (+ (point-y rand-point) (point-y point)))) ; every subsequent point
    collect point))
</code></pre>
<pre><code class="language-coconut">data point(x=0, y=0):
    def __add__(self, other):
        return point(self.x + other.x, self.y + other.y)

    def __rmul__(self, other):
        return point(self.x * other, self.y * other)

def chaos_game(n, shape_points):
    p = point(random(), random())

    for _ in range(n):
        p = (1/2) * (p + choice(shape_points))
        yield p
</code></pre>
<pre><code class="language-java">    public static Point[] chaosGame(int n, Point[] shapePoints) {
        Random rng = new Random();

        // Initialize output vector
        Point[] outputPoints = new Point[n];

        // Choose first point randomly
        Point point = new Point(rng.nextDouble(), rng.nextDouble());

        for (int i = 0; i &lt; n; i++) {
            outputPoints[i] = point;

            // Clone point to get a new reference
            point = new Point(point.x, point.y);

            // Retrieve random shape point
            Point temp = shapePoints[rng.nextInt(shapePoints.length)];
            // Calculate midpoint
            point.x = 0.5 * (point.x + temp.x);
            point.y = 0.5 * (point.y + temp.y);
        }

        return outputPoints;
    }
</code></pre>
<p>If we set the initial point to the on the equilateral triangle we saw before, we can see the Sierpinski triangle again after a few thousand iterations, as shown below:</p>
<div style="text-align:center">
<video style="width:100%" controls>
  <source src="res/chaos_vid_1.mp4" type="video/mp4">
  <img class="center" src="IFS/res/chaos_1.png" alt="Chaos game"  style="width:100%">
</video>
</div>
<p>Here, we are plotting 200,000 point locations in sets of 1000, and every set becomes successively more blue as the visualization continues.
At first glance, this visualization seems bewildering.
After all, it appears as if the entire triangle just magically comes into view in a few seconds.
The important thing to remember here is that each of these 200,000 dots is another location that our initial point decided to visit.</p>
<p>That said, there is something peculiar about the way the chaos game starts.
We are actually allowed to start the simulation <em>off</em> of the Sierpinski triangle.
As we mentioned earlier, none of the functions for the Sierpinski visualization allow children to enter the empty spaces of the triangle, so let's see what happens if we start the point off at the center of the triangle:</p>
<div style="text-align:center">
<video style="width:100%" controls>
  <source src="res/chaos_vid_2.mp4" type="video/mp4">
  <img class="center" src="IFS/reschaos_2.png" alt="Chaos game with initial points"  style="width:100%">
</video>
</div>
<p>Here, I have plotted the first 20 steps of the chaos game, and it is clear that the point gets closer and closer to the triangle each iteration.
Once it lands on the triangle, it can no longer escape and every movement from then on will be on the triangle.</p>
<p>In a sense, the wanderin point is <em>attracted</em> to the Sierpinski triangle with this set of functions, and that is actually the case!
The truth is that the word <em>attractor</em> is a very loaded term in the literature, but for the purposes of our discussion here, an <em>attractor</em> is any shape defined by the iteration through Hutchinson operator functions.</p>
<p>So let's go back to the example with the 4 points along the square and generate the attractor via a chaos game instead of going through every branch of the Hutchinson operator.
If we do this, we get what seems to be a random distribution of points:</p>
<img class="center" src="IFS/res/IFS_square_3.png" alt="Hutchinson square"  style="width:100%">
<p>This kinda boggled my mind a bit when I looked at it for the first time.
What does a random distribution of points mean in this context?</p>
<p>Well, firstly, it's only a random distribution between the square vertices of \( A \), \( B \), \( C \), and \( D \), but nothing exists outside of these points.
This means that it's not actually a random distribution of points, but instead an attractive plane that our lone wandering point can exist happily within.</p>
<p>This really helped me understand how attractors present themselves in different dimensions.
The Sierpinski triangle seems like a series of lines (one-dimensional objects) in two-dimensional space, but the square is a truly two-dimensional object.
In general, this means that an attractor embedded within \( \mathbb{R}^N \) can be any shape of dimension N or lower.</p>
<p>The next obvious question is whether a square can create any more interesting fractally patterns, and the answer is &quot;yes, but only if we restrict the movement a bit.&quot;
Which brings us to another topic entirely: restricted chaos games.
Discussing restricted chaos games in more detail is a chapter in its own right, so I will forego the discussion here.
If you are interested, please let me know and I will be more than willing to add the chapter in the future!</p>
<h2 id="video-explanation-1"><a class="header" href="#video-explanation-1">Video Explanation</a></h2>
<p>Here is a video describing iterated function systems:</p>
<div style="text-align:center">
<iframe width="560" height="315" src="https://www.youtube.com/embed/nIIp-vo8rHg"
 frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; pic
ture-in-picture" allowfullscreen></iframe>
</div>
<h2 id="example-code-1"><a class="header" href="#example-code-1">Example Code</a></h2>
<p>For the code in this chapter, we have decided to write it specifically for the Chaos game, not the hutchinson animations shown at the start of the chapter.
This is because that animation is slightly tricky to create and distracts from the overall purpose of this chapter.
In addition, we have written the chaos game code to take in a set of points so that it is not hard-coded for the Sierpinski triangle and can be easily extended to other shapes like the square or restricted chaos games, as we mentioned before!</p>
<pre><code class="language-julia">using DelimitedFiles

# This is a function to simulate a &quot;chaos game&quot;
function chaos_game(n::Int, shape_points)

    # Initializing the output array and the initial point
    output_points = zeros(n,2)
    point = [rand(), rand()]

    for i = 1:n
        output_points[i,:] .= point
        point = 0.5*(rand(shape_points) .+ point)
    end

    return output_points

end

# This will generate a Sierpinski triangle with a chaos game of n points for an 
# initial triangle with three points on the vertices of an equilateral triangle:
#     A = (0.0, 0.0)
#     B = (0.5, sqrt(0.75))
#     C = (1.0, 0.0)
# It will output the file sierpinski.dat, which can be plotted after
shape_points = [[0.0, 0.0],
                [0.5, sqrt(0.75)],
                [1.0, 0.0]]
output_points = chaos_game(10000, shape_points)
writedlm(&quot;sierpinski.dat&quot;, output_points)
</code></pre>
<pre><code class="language-haskell">import Data.Array ((!), Array, bounds, listArray)
import Data.List (intercalate)
import System.Random

data Point = Point Double Double

chaosGame :: RandomGen g =&gt; g -&gt; Int -&gt; Array Int (Point -&gt; Point) -&gt; [Point]
chaosGame g n hutchinson = take n points
  where
    (x, g') = random g
    (y, g'') = random g'
    choices = randomRs (bounds hutchinson) g''
    points = Point x y : zipWith (hutchinson !) choices points

main :: IO ()
main = do
  g &lt;- newStdGen

  let midPoint (Point a b) (Point x y) = Point ((a + x) / 2) ((b + y) / 2)
      sierpinski =
        listArray
          (1, 3)
          [ midPoint (Point 0 0),
            midPoint (Point 0.5 (sqrt 0.75)),
            midPoint (Point 1 0)
          ]
      points = chaosGame g 10000 sierpinski
      showPoint (Point x y) = show x ++ &quot;\t&quot; ++ show y

  writeFile &quot;out.dat&quot; $ intercalate &quot;\n&quot; $ map showPoint points
</code></pre>
<pre><code class="language-cpp">#include &lt;cmath&gt;
#include &lt;fstream&gt;
#include &lt;random&gt;
#include &lt;vector&gt;

// Simple X-Y point structure, along with some operators
struct Point {
  double x, y;
};

Point operator+(Point lhs, Point rhs) { return {lhs.x + rhs.x, lhs.y + rhs.y}; }
Point operator*(double k, Point pt) { return {k * pt.x, k * pt.y}; }
Point operator*(Point pt, double k) { return k * pt; }

using PointVector = std::vector&lt;Point&gt;;

// Returns a pseudo-random number generator
std::default_random_engine&amp; rng() {
  // Initialize static pseudo-random engine with non-deterministic random seed
  static std::default_random_engine randEngine(std::random_device{}());
  return randEngine;
}

// Returns a random double in [0, 1)
double drand() {
  return std::uniform_real_distribution&lt;double&gt;(0.0, 1.0)(rng());
}

// Returns a random integer in [0, numElems-1]
std::size_t randrange(std::size_t numElems) {
  return std::uniform_int_distribution&lt;std::size_t&gt;(0, numElems - 1)(rng());
}

// Return a random point from the non-empty PointVector
Point choose(const PointVector&amp; points) {
  return points[randrange(points.size())];
}

// This is a function to simulate a &quot;chaos game&quot;
PointVector chaosGame(int numOutputPoints, const PointVector&amp; inputPoints) {
  // Choose first point randomly
  Point curPoint = {drand(), drand()};

  // For each output point, compute midpoint to random input point
  PointVector outputPoints(numOutputPoints);
  for (auto&amp; outPoint : outputPoints) {
    outPoint = curPoint;
    curPoint = 0.5 * (curPoint + choose(inputPoints));
  }

  return outputPoints;
}

int main() {
  // This will generate a Sierpinski triangle with a chaos game of n points for
  // an initial triangle with three points on the vertices of an equilateral
  // triangle.
  PointVector inputPoints = {{0.0, 0.0}, {0.5, std::sqrt(0.75)}, {1.0, 0.0}};
  auto outputPoints = chaosGame(10000, inputPoints);

  // It will output the file sierpinski.dat, which can be plotted after
  std::ofstream ofs(&quot;sierpinski.dat&quot;);
  for (auto pt : outputPoints)
    ofs &lt;&lt; pt.x &lt;&lt; '\t' &lt;&lt; pt.y &lt;&lt; '\n';
}
</code></pre>
<pre><code class="language-python">from random import random, choice
from math import sqrt

# This generator simulates a &quot;chaos game&quot;
def chaos_game(n, shape_points):
    # Initialize the starting point
    point = [random(), random()]

    for _ in range(n):
        # Update the point position and yield the result
        point = [(p + s) / 2 for p, s in zip(point, choice(shape_points))]
        yield point

# This will generate a Sierpinski triangle with a chaos game of n points for an
# initial triangle with three points on the vertices of an equilateral triangle:
#     A = (0.0, 0.0)
#     B = (0.5, sqrt(0.75))
#     C = (1.0, 0.0)
# It will output the file sierpinski.dat, which can be plotted after
shape_points = [[0.0, 0.0],
                [0.5, sqrt(0.75)],
                [1.0, 0.0]]
with open(&quot;sierpinski.dat&quot;, &quot;w&quot;) as f:
    for point in chaos_game(10000, shape_points):
        f.write(&quot;{0}\t{1}\n&quot;.format(*point))
</code></pre>
<pre><code class="language-c">#include &lt;math.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;time.h&gt;

struct point {
    double x, y;
};

double drand() {
    return ((double) rand() / (RAND_MAX));
}

struct point random_element(struct point *array, size_t n) {
    return array[rand() % (int)n];
}

void chaos_game(struct point *in, size_t in_n, struct point *out,
                size_t out_n) {

    struct point cur_point = {drand(), drand()};

    for (int i = 0; i &lt; out_n; ++i) {
        out[i] = cur_point;
        struct point tmp = random_element(in, in_n);
        cur_point.x = 0.5 * (cur_point.x + tmp.x);
        cur_point.y = 0.5 * (cur_point.y + tmp.y);
    }
}

int main() {
    struct point shape_points [3] = {{0.0,0.0}, {0.5,sqrt(0.75)}, {1.0,0.0}};
    struct point out_points[1000];

    srand(time(NULL));

    chaos_game(shape_points, 3, out_points, 1000);

    FILE *fp = fopen(&quot;sierpinksi.dat&quot;, &quot;w+&quot;);

    for (int i = 0; i &lt; 1000; ++i) {
        fprintf(fp, &quot;%f\t%f\n&quot;, out_points[i].x, out_points[i].y);
    }

    fclose(fp);

    return 0;
}

</code></pre>
<pre><code class="language-lisp">;;;; Iterated Function System implementation

(defstruct (point (:constructor make-point (x y))) x y)

(defun chaos-game (iterations shape-points)
  &quot;Plays a chaos game with a certain shape for a determined amount of iterations&quot;
  (loop
    repeat iterations
    for rand-point = (svref shape-points (random (length shape-points)))
    for point = (make-point (random 1.0) (random 1.0)) ; starting point
    then (make-point
           (* 0.5 (+ (point-x rand-point) (point-x point)))
           (* 0.5 (+ (point-y rand-point) (point-y point)))) ; every subsequent point
    collect point))

(defparameter *shape-points*
  (map
    'vector
    (lambda (e) (apply #'make-point e))
    ;; the backquote allows us to selectively evaluate (sqrt 0.75) with the comma
    `((0 0) (0.5 ,(sqrt 0.75)) (1 0))))

;; output the data to the &quot;out.dat&quot; file
(with-open-file (out &quot;out.dat&quot; :direction :output :if-exists :supersede)
  (flet ((format-point (p)
           ;; this is not very clean, but it's the simplest way to insert a tab into a string.
           (format nil &quot;~f~c~f&quot; (point-x p) #\tab (point-y p))))
    (format out &quot;~{~a~%~}&quot; (map 'list #'format-point (chaos-game 10000 *shape-points*)))))
</code></pre>
<pre><code class="language-coconut">from math import sqrt
from random import random, choice

data point(x=0, y=0):
    def __add__(self, other):
        return point(self.x + other.x, self.y + other.y)

    def __rmul__(self, other):
        return point(self.x * other, self.y * other)

def chaos_game(n, shape_points):
    p = point(random(), random())

    for _ in range(n):
        p = (1/2) * (p + choice(shape_points))
        yield p


# This will generate a Sierpinski triangle with a chaos game of n points for an
# initial triangle with three points on the vertices of an equilateral triangle:
#     A = (0.0, 0.0)
#     B = (0.5, sqrt(0.75))
#     C = (1.0, 0.0)
# It will output the file sierpinski.dat, which can be plotted after
shape_points = [point(0.0, 0.0),
                point(0.5, sqrt(0.75)),
                point(1.0, 0.0)]
with open(&quot;sierpinski.dat&quot;, &quot;w&quot;) as f:
    for p in chaos_game(10000, shape_points):
        f.write(&quot;{0}\t{1}\n&quot;.format(p.x, p.y))
</code></pre>
<pre><code class="language-java">import java.io.FileWriter;
import java.util.Random;

public class IFS {

    private static class Point {
        double x, y;

        public Point(double x, double y) {
            this.x = x;
            this.y = y;
        }
    }
    
    // This is a function to simulate a &quot;chaos game&quot;
    public static Point[] chaosGame(int n, Point[] shapePoints) {
        Random rng = new Random();

        // Initialize output vector
        Point[] outputPoints = new Point[n];

        // Choose first point randomly
        Point point = new Point(rng.nextDouble(), rng.nextDouble());

        for (int i = 0; i &lt; n; i++) {
            outputPoints[i] = point;

            // Clone point to get a new reference
            point = new Point(point.x, point.y);

            // Retrieve random shape point
            Point temp = shapePoints[rng.nextInt(shapePoints.length)];
            // Calculate midpoint
            point.x = 0.5 * (point.x + temp.x);
            point.y = 0.5 * (point.y + temp.y);
        }

        return outputPoints;
    }

    public static void main(String[] args) throws Exception {
        // This will generate a Sierpinski triangle with a chaos game of n points for an
        // initial triangle with three points on the vertices of an equilateral triangle:
        //     A = (0.0, 0.0)
        //     B = (0.5, sqrt(0.75))
        //     C = (1.0, 0.0)
        // It will output the file sierpinski.dat, which can be plotted after
        Point[] shapePoints = new Point[]{
                new Point(0.0, 0.0),
                new Point(0.5, Math.sqrt(0.75)),
                new Point(1.0, 0.0)
        };
        Point[] outputPoints = chaosGame(10000, shapePoints);

        FileWriter fw = new FileWriter(&quot;sierpinski.dat&quot;);
        for (Point p : outputPoints)
            fw.write(p.x + &quot;\t&quot; + p.y + &quot;\n&quot;);
        fw.close();
    }

}
</code></pre>
<h3 id="bibliography-2"><a class="header" href="#bibliography-2">Bibliography</a></h3>
<p>{% references %} {% endreferences %}</p>
<h2 id="license-4"><a class="header" href="#license-4">License</a></h2>
<h5 id="code-examples-4"><a class="header" href="#code-examples-4">Code Examples</a></h5>
<p>The code examples are licensed under the MIT license (found in <a href="https://github.com/algorithm-archivists/algorithm-archive/blob/master/LICENSE.md">LICENSE.md</a>).</p>
<h5 id="text-4"><a class="header" href="#text-4">Text</a></h5>
<p>The text of this chapter was written by <a href="https://github.com/leios">James Schloss</a> and is licensed under the <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</p>
<p><a href="https://creativecommons.org/licenses/by-sa/4.0/"><p><img  class="center" src="IFS/../cc/CC-BY-SA_icon.svg" /></p></a></p>
<h4 id="imagesgraphics-2"><a class="header" href="#imagesgraphics-2">Images/Graphics</a></h4>
<ul>
<li>The image &quot;<a href="IFS/res/IFS_triangle_1.png">IFS triangle 1</a>&quot; was created by <a href="https://github.com/leios">James Schloss</a> and is licensed under the <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</li>
<li>The image &quot;<a href="IFS/res/IFS_triangle_2.png">IFS triangle 2</a>&quot; was created by <a href="https://github.com/leios">James Schloss</a> and is licensed under the <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</li>
<li>The image &quot;<a href="IFS/res/IFS_triangle_3.png">IFS triangle 3</a>&quot; was created by <a href="https://github.com/leios">James Schloss</a> and is licensed under the <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</li>
<li>The image &quot;<a href="IFS/res/IFS_triangle_4.png">IFS triangle 4</a>&quot; was created by <a href="https://github.com/leios">James Schloss</a> and is licensed under the <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</li>
<li>The image &quot;<a href="IFS/res/IFS_triangle_5.png">IFS triangle 5</a>&quot; was created by <a href="https://github.com/leios">James Schloss</a> and is licensed under the <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</li>
<li>The image &quot;<a href="IFS/res/IFS_square_1.png">IFS square 1</a>&quot; was created by <a href="https://github.com/leios">James Schloss</a> and is licensed under the <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</li>
<li>The image &quot;<a href="IFS/res/IFS_square_2.png">IFS square 2</a>&quot; was created by <a href="https://github.com/leios">James Schloss</a> and is licensed under the <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</li>
<li>The image &quot;<a href="IFS/res/IFS_square_3.png">IFS square 3</a>&quot; was created by <a href="https://github.com/leios">James Schloss</a> and is licensed under the <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</li>
<li>The image &quot;<a href="IFS/res/chaos_1.png">Chaos 1</a>&quot; was created by <a href="https://github.com/leios">James Schloss</a> and is licensed under the <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</li>
<li>The image &quot;<a href="IFS/res/chaos_2.png">Chaos 2</a>&quot; was created by <a href="https://github.com/leios">James Schloss</a> and is licensed under the <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</li>
<li>The video &quot;<a href="IFS/res/IFS_triangle_vid_1.mp4">IFS triangle video 1</a>&quot; was created by <a href="https://github.com/leios">James Schloss</a> and is licensed under the <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</li>
<li>The video &quot;<a href="IFS/res/IFS_triangle_vid_2.mp4">IFS triangle video 2</a>&quot; was created by <a href="https://github.com/leios">James Schloss</a> and is licensed under the <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</li>
<li>The video &quot;<a href="IFS/res/IFS_square_vid_1.mp4">IFS square video 1</a>&quot; was created by <a href="https://github.com/leios">James Schloss</a> and is licensed under the <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</li>
<li>The video &quot;<a href="IFS/res/chaos_vid_1.mp4">Chaos video 1</a>&quot; was created by <a href="https://github.com/leios">James Schloss</a> and is licensed under the <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</li>
<li>The video &quot;<a href="IFS/res/chaos_vid_2.mp4">Chaos video 2</a>&quot; was created by <a href="https://github.com/leios">James Schloss</a> and is licensed under the <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-barnsley-fern"><a class="header" href="#the-barnsley-fern">The Barnsley Fern</a></h1>
<p>At the end of the chapter on <a href="barnsley/../IFS/IFS.html">Iterated Function Systems</a>, we introduced two separate attractors: the Sierpinski triangle, and a uniform two-dimensional square, shown below with their corresponding Hutchinson operator.</p>
<table><thead><tr><th>Hutchinson Operator</th><th>Attractor</th></tr></thead><tbody>
<tr><td>\( \begin{align} f_1(P) &amp;= \frac{P+A}{2} \\  f_2(P) &amp;= \frac{P+B}{2} \\  f_3(P) &amp;= \frac{P+C}{2} \end{align} \)</td><td><img class="center" src="barnsley/../IFS/res/IFS_triangle_1.png" alt="Sierpinsky Triangle Chaos Game"  style="width:100%"></td></tr>
<tr><td>\( \begin{align} f_1(P) &amp;= \frac{P+A}{2} \\  f_2(P) &amp;= \frac{P+B}{2} \\  f_3(P) &amp;= \frac{P+C}{2} \\ f_4(P) &amp;= \frac{P+D}{2} \end{align} \)</td><td><img class="center" src="barnsley/../IFS/res/IFS_square_3.png" alt="Square Chaos Game"  style="width:100%"></td></tr>
</tbody></table>
<p>As a reminder, the Hutchinson operator is a set of functions that act on a point in space, \( P \), and return another another point at a new location.
These functions are meant to be used over and over again in some fashion, and as you continually iterate through them, some shape will eventually be drawn.
This shape is known as an attractor, and the entire system is called an <em>iterated function system</em> due to the iterative nature of drawing the attractor.</p>
<p>In these cases, each function will move the point to be halfway between its original position and the position of \( A \), \( B \), \( C \), and \( D \) for \( f_1 \), \( f_2 \), \( f_3 \), and \( f_4 \), respectively.
Even though \( f_1 \), \( f_2 \), and \( f_3 \) are the same for both attractors, the addition of \( f_4 \) drastically changes the final result!
It is surprising that two seemingly identical sets of functions can look so different in the end, and this leads us to a somewhat challenging question: given a set of functions, is there any way to predict what the attractor will be without iterating through the functions?</p>
<p>In general, the answer is no.
You <em>must</em> sample the function set in some fashion to get find the resulting attractor.</p>
<p>This feels somewhat unsettling to me.
After all, each individual function is simple, so why is the result so difficult to predict?
In this chapter, I hope to provide a slightly more satisfying answer by introducing another iterated function system with beautiful attractor, known as the Barnsley fern {{ &quot;barnsley2014fractals&quot; | cite }}:</p>
<table><thead><tr><th>Hutchinson Operator</th><th>Attractor</th></tr></thead><tbody>
<tr><td>\( \begin{align} f_1(P) &amp;= \begin{bmatrix} 0 &amp;0 \\ 0 &amp;0.16 \end{bmatrix}P + \begin{bmatrix} 0 \\ 0 \end{bmatrix} \\ f_2(P) &amp;= \begin{bmatrix} 0.85 &amp;0.04 \\ -0.04 &amp;0.85 \end{bmatrix}P + \begin{bmatrix} 0 \\ 1.6 \end{bmatrix} \\ f_3(P) &amp;= \begin{bmatrix} 0.2 &amp;-0.26 \\ 0.23 &amp;0.22 \end{bmatrix}P + \begin{bmatrix} 0 \\ 1.6 \end{bmatrix} \\ f_4(P) &amp;= \begin{bmatrix} -0.15 &amp;0.28 \\ 0.26 &amp;0.24 \end{bmatrix}P + \begin{bmatrix} 0 \\ 0.44 \end{bmatrix} \end{align} \)</td><td><img class="center" src="barnsley/res/full_fern.png" alt="Barnsley Chaos Game"  style="width:100%"></td></tr>
</tbody></table>
<p>At first glance, this set of functions looks like an incomprehensible mess of magic numbers to create a specific result, and in a sense, that is precisely correct.
That said, we will go through each function and explain how it works, while also providing a simple chaos game implementation in code.
By the end of this chapter, we do not hope to provide a general strategy for understanding all iterated function systems, but we hope to at least make this one set of functions a bit more understandable.</p>
<h2 id="individual-affine-transforms"><a class="header" href="#individual-affine-transforms">Individual affine transforms</a></h2>
<p>The first thing to note about the Barnsley set of functions is that each one is an <a href="barnsley/../affine_transformations/affine_transformations.html">affine transformation</a>.
Though it is not a hard rule, most iterated function systems use affine transforms, so this notation is common.
In fact, the Sierpinski operators can also be written in an affine form:</p>
<table><thead><tr><th>Non-affine</th><th>Affine</th></tr></thead><tbody>
<tr><td>\( \begin{align} f_1(P) &amp;= \frac{P+A}{2} \\  f_2(P) &amp;= \frac{P+B}{2} \\  f_3(P) &amp;= \frac{P+C}{2} \end{align} \)</td><td>\( \begin{align} f_1(P) &amp;= \begin{bmatrix} 0.5 &amp;0 \\ 0 &amp;0.5 \end{bmatrix}P + \frac{A}{2} \\ f_2(P) &amp;= \begin{bmatrix} 0.5 &amp;0 \\ 0 &amp;0.5 \end{bmatrix}P + \frac{B}{2} \\ f_3(P) &amp;= \begin{bmatrix} 0.5 &amp;0 \\ 0 &amp;0.5 \end{bmatrix}P + \frac{C}{2} \end{align} \)</td></tr>
</tbody></table>
<p>The affine variant performs the same operation by scaling the \( x \) and \( y \) component of \( P \) by \( 0.5 \) and then adding half of either \( A \), \( B \), or \( C \) for \( f_1 \), \( f_2 \), or \( f_3 \), respectively.
Each of these transforms involves some linear component (scaling or shearing) with an additional translation.</p>
<p>As an important side-note: in both the Barnsley and Sierpinski function systems, the coefficients of the transformation matrix are all less than 1.
This property is known as <em>contractivity</em>, and an iterated function system can only have an attractor if the system is contractive.
Upon reflection, this makes sense.
If the matrix elements were greater than 1, the point could tend towards infinity after successive iterations of the function.</p>
<p>Now let's hop into disecting the Barnsley fern by seeing how each transform affects a random distribution of points:</p>
<table><thead><tr><th>Function</th><th>Operation</th></tr></thead><tbody>
<tr><td>\( f_1(P) = \begin{bmatrix} 0 &amp;0 \\ 0 &amp;0.16 \end{bmatrix}P + \begin{bmatrix} 0 \\ 0 \end{bmatrix} \) <p> This operation moves every point to a single line.</td><td><div style="text-align:center"> <video style="width:100%" controls loop> <source src="res/affine_rnd_0.mp4" type="video/mp4"> Your browser does not support the video tag. </video> </div></td></tr>
<tr><td>\( f_2(P) = \begin{bmatrix} 0.85 &amp;0.04 \\ -0.04 &amp;0.85 \end{bmatrix}P + \begin{bmatrix} 0 \\ 1.6 \end{bmatrix} \) <p> This operation moves every point up and to the right.</td><td><div style="text-align:center"> <video style="width:100%" controls loop> <source src="res/affine_rnd_1.mp4" type="video/mp4"> Your browser does not support the video tag. </video> </div></td></tr>
<tr><td>\( f_3(P) = \begin{bmatrix} 0.2 &amp;-0.26 \\ 0.23 &amp;0.22 \end{bmatrix}P + \begin{bmatrix} 0 \\ 1.6 \end{bmatrix} \) <p> This operation rotates every point to the left.</td><td><div style="text-align:center"> <video style="width:100%" controls loop> <source src="res/affine_rnd_2.mp4" type="video/mp4"> Your browser does not support the video tag. </video> </div></td></tr>
<tr><td>\( f_4(P) = \begin{bmatrix} -0.15 &amp;0.28 \\ 0.26 &amp;0.24 \end{bmatrix}P + \begin{bmatrix} 0 \\ 0.44 \end{bmatrix} \) <p> This operation flips every point and rotates to the right.</td><td><div style="text-align:center"> <video style="width:100%" controls loop> <source src="res/affine_rnd_3.mp4" type="video/mp4"> Your browser does not support the video tag. </video> </div></td></tr>
</tbody></table>
<p>At this stage, it <em>might</em> be clear what is going on, but it's not exactly obvious.
Essentially, each operation corresponds to another part of the fern:</p>
<ul>
<li>\( f_1 \) creates the stem.</li>
<li>\( f_2 \) creates successively smaller ferns moving up and to the right.</li>
<li>\( f_3 \) creates the leaves on the right.</li>
<li>\( f_4 \) creates the leaves on the left.</li>
</ul>
<p>The easiest way to make sense of this is to show the operations on the Barnsley fern, itself, instead of a random distribution of points.</p>
<table><thead><tr><th>Function</th><th>Operation</th></tr></thead><tbody>
<tr><td>\( f_1(P) = \begin{bmatrix} 0 &amp;0 \\ 0 &amp;0.16 \end{bmatrix}P + \begin{bmatrix} 0 \\ 0 \end{bmatrix} \)</td><td><div style="text-align:center"> <video style="width:100%" controls loop> <source src="res/affine_fern_0.mp4" type="video/mp4"> Your browser does not support the video tag. </video> </div></td></tr>
<tr><td>\( f_2(P) = \begin{bmatrix} 0.85 &amp;0.04 \\ -0.04 &amp;0.85 \end{bmatrix}P + \begin{bmatrix} 0 \\ 1.6 \end{bmatrix} \)</td><td><div style="text-align:center"> <video style="width:100%" controls loop> <source src="res/affine_fern_1.mp4" type="video/mp4"> Your browser does not support the video tag. </video> </div></td></tr>
<tr><td>\( f_3(P) = \begin{bmatrix} 0.2 &amp;-0.26 \\ 0.23 &amp;0.22 \end{bmatrix}P + \begin{bmatrix} 0 \\ 1.6 \end{bmatrix} \)</td><td><div style="text-align:center"> <video style="width:100%" controls loop> <source src="res/affine_fern_2.mp4" type="video/mp4"> Your browser does not support the video tag. </video> </div></td></tr>
<tr><td>\( f_4(P) = \begin{bmatrix} -0.15 &amp;0.28 \\ 0.26 &amp;0.24 \end{bmatrix}P + \begin{bmatrix} 0 \\ 0.44 \end{bmatrix} \)</td><td><div style="text-align:center"> <video style="width:100%" controls loop> <source src="res/affine_fern_3.mp4" type="video/mp4"> Your browser does not support the video tag. </video> </div></td></tr>
</tbody></table>
<p>Here, the self-similar nature of the fern becomes apparent.
Each operation is effectively moving a point on one part of the fern to a point on another part of the fern.</p>
<p>In the final construction, it is clear that fewer points are necessary on some parts than others.
The stem, for example, does not need many points at all.
Meanwhile, the bulk of the fern seems to be generated by \( f_2 \), so we probably want the majority of the points to choose that function when iterating through he set.
To account for this, each function is also given a probability of being chosen:</p>
<table><thead><tr><th>Function</th><th>Probability</th></tr></thead><tbody>
<tr><td>\( f_1(P) = \begin{bmatrix} 0 &amp;0 \\ 0 &amp;0.16 \end{bmatrix}P + \begin{bmatrix} 0 \\ 0 \end{bmatrix} \)</td><td>0.01</td></tr>
<tr><td>\( f_2(P) = \begin{bmatrix} 0.85 &amp;0.04 \\ -0.04 &amp;0.85 \end{bmatrix}P + \begin{bmatrix} 0 \\ 1.6 \end{bmatrix} \)</td><td>0.85</td></tr>
<tr><td>\( f_3(P) = \begin{bmatrix} 0.2 &amp;-0.26 \\ 0.23 &amp;0.22 \end{bmatrix}P + \begin{bmatrix} 0 \\ 1.6 \end{bmatrix} \)</td><td>0.07</td></tr>
<tr><td>\( f_4(P) = \begin{bmatrix} -0.15 &amp;0.28 \\ 0.26 &amp;0.24 \end{bmatrix}P + \begin{bmatrix} 0 \\ 0.44 \end{bmatrix} \)</td><td>0.07</td></tr>
</tbody></table>
<h2 id="playing-around-a-bit"><a class="header" href="#playing-around-a-bit">Playing around a bit...</a></h2>
<p>One big advantage of using affine transformations to construct an attractor is that mathematicians and programmers can leverage their knowledge of how these transformations work to also modify the resulting image.
Here are a few examples of ferns that can be generated by modifying constituent functions:</p>
<table><thead><tr><th>Function</th><th>Operation</th></tr></thead><tbody>
<tr><td>\( f_1(P) = \begin{bmatrix} \tau &amp;0 \\ 0 &amp;0.16 \end{bmatrix}P + \begin{bmatrix} 0 \\ 0 \end{bmatrix} \) <p> where \( -0.5 &lt; \tau &lt; 0.5  \) <p> Turning stems to leaves</td><td><div style="text-align:center"> <video style="width:100%" controls loop> <source src="res/fern_twiddle_0.mp4" type="video/mp4"> Your browser does not support the video tag. </video> </div></td></tr>
<tr><td>\( f_2(P) = \begin{bmatrix} 0.85 &amp; \tau \\ -0.04 &amp;0.85 \end{bmatrix}P + \begin{bmatrix} 0 \\ 1.6 \end{bmatrix} \) <p> where \(  -0.01 &lt; \tau &lt; 0.09  \) <p> Changing fern tilt</td><td><div style="text-align:center"> <video style="width:100%" controls loop> <source src="res/fern_twiddle_1.mp4" type="video/mp4"> Your browser does not support the video tag. </video> </div></td></tr>
<tr><td>\( f_3(P) = \begin{bmatrix} 0.2 &amp;-0.26 \\ 0.23 &amp;0.22 \end{bmatrix}P + \begin{bmatrix} \tau \\ 1.6 \end{bmatrix} \) <p> where \( -0.5 &lt; \tau &lt; 0.5 \) <p> Plucking left leaves</td><td><div style="text-align:center"> <video style="width:100%" controls loop> <source src="res/fern_twiddle_2.mp4" type="video/mp4"> Your browser does not support the video tag. </video> </div></td></tr>
<tr><td>\( f_4(P) = \begin{bmatrix} -0.15 &amp;0.28 \\ 0.26 &amp;0.24 \end{bmatrix}P + \begin{bmatrix} \tau \\ 0.44 \end{bmatrix} \) <p> where \( -0.5 &lt; \tau &lt; 0.5 \) <p> Plucking right leaves</td><td><div style="text-align:center"> <video style="width:100%" controls loop> <source src="res/fern_twiddle_3.mp4" type="video/mp4"> Your browser does not support the video tag. </video> </div></td></tr>
</tbody></table>
<p>As an important note: the idea of modifying a resulting image by twiddling the knobs of an affine transform is the heart of many interesting methods, including fractal image compression where a low resolution version of an image is stored along with a reconstructing function set to generate high-quality images on-the-fly {{ &quot;fractal-compression&quot; | cite }}{{ &quot;saupe1994review&quot; | cite }}.
If this seems mystifying, don't worry!
We'll definitely come back to this soon, I just wanted to briefly mention it now so it's on everyone's mind as we move forward.</p>
<h2 id="video-explanation-2"><a class="header" href="#video-explanation-2">Video Explanation</a></h2>
<p>Here is a video describing the Barnsley fern:</p>
<div style="text-align:center">
<iframe width="560" height="315" src="https://www.youtube.com/embed/xoXe0AljUMA"
 frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; pic
ture-in-picture" allowfullscreen></iframe>
</div>
<h2 id="example-code-2"><a class="header" href="#example-code-2">Example Code</a></h2>
<p>Similar to the chapter on <a href="barnsley/../IFS/IFS.html">iterated function systems</a>, the example code here will show a chaos game for the construction of an attractor;
however, in this case the attractor will be the Barnsley fern instead of the Sierpinski triangle.
The biggest differences between the two code implementations is that the Barnsley implementation must take into account the varying probabilities for choosing each function path and that we will be choosing an initial point that is <em>on</em> the attractor this time (namely \( (0,0) \)).</p>
<pre><code class="language-julia">using DelimitedFiles

# This is a function that reads in the Hutchinson operator and corresponding
#     probabilities and outputs a randomly selected transform
# This works by choosing a random number and then iterating through all 
#     probabilities until it finds an appropriate bin
function select_array(hutchinson_op, probabilities)

    # random number to be binned
    rnd = rand()

    # This checks to see if a random number is in a bin, if not, that 
    #     probability is subtracted from the random number and we check the
    #     next bin in the list
    for i = 1:length(probabilities)
        if (rnd &lt; probabilities[i])
            return hutchinson_op[i]
        end
        rnd -= probabilities[i]
    end
end

# This is a general function to simulate a chaos game
# n is the number of iterations
# initial_location is the starting point of the chaos game
# hutchinson_op is the set of functions to iterate through
# probabilities is the set of probabilities corresponding to the likelihood
#     of choosing their corresponding function in hutchinson_op
function chaos_game(n::Int, initial_location, hutchinson_op, probabilities)

    # Initializing the output array and the initial point
    output_points = zeros(n,2)

    # extending point to 3D for affine transform
    point = [initial_location[1], initial_location[2], 1]

    for i = 1:n
        output_points[i,:] .= point[1:2]
        point = select_array(hutchinson_op, probabilities)*point
    end

    return output_points

end

barnsley_hutchinson = [[0.0 0.0 0.0;
                        0.0 0.16 0.0;
                        0.0 0.0 1.0],
                       [0.85 0.04 0.0;
                        -0.04 0.85 1.60;
                        0.0 0.0 1.0],
                       [0.20 -0.26 0.0;
                        0.23 0.22 1.60;
                        0.0 0.0 1.0],
                       [-0.15 0.28 0.0;
                        0.26 0.24 0.44;
                        0.0 0.0 1.0]]

barnsley_probabilities = [0.01, 0.85, 0.07, 0.07]
output_points = chaos_game(10000, [0,0],
                           barnsley_hutchinson, barnsley_probabilities)
writedlm(&quot;out.dat&quot;, output_points)
</code></pre>
<pre><pre class="playground"><code class="language-rust">use rand::prelude::*;
#[derive(Clone, Copy)]
struct Point2 {
    x: f64,
    y: f64,
}

#[derive(Clone, Copy)]
struct Point3 {
    x: f64,
    y: f64,
    z: f64,
}

impl Point3 {
    fn new(x: f64, y: f64, z: f64) -&gt; Self {
        Self { x, y, z }
    }

    fn matrix_mul(self, rhs: Vec&lt;Point3&gt;) -&gt; Self {
        let x = rhs[0].x * self.x + rhs[0].y * self.y + rhs[0].z * self.z;
        let y = rhs[1].x * self.x + rhs[1].y * self.y + rhs[1].z * self.z;
        let z = rhs[2].x * self.x + rhs[2].y * self.y + rhs[2].z * self.z;
        Self::new(x, y, z)
    }
}

fn select_array(hutchinson_op: &amp;[Vec&lt;Point3&gt;], probabilities: &amp;[f64]) -&gt; Vec&lt;Point3&gt; {
    let mut rng = rand::thread_rng();
    let mut rnd = rng.gen::&lt;f64&gt;();

    for (i, probability) in probabilities.iter().enumerate() {
        if rnd &lt; *probability {
            return hutchinson_op[i].clone();
        }
        rnd -= probability;
    }

    return vec![];
}

fn chaos_game(
    iters: usize,
    initial_location: Point2,
    hutchinson_op: &amp;[Vec&lt;Point3&gt;],
    probabilities: &amp;[f64],
) -&gt; Vec&lt;Point2&gt; {
    let mut point = Point3 {
        x: initial_location.x,
        y: initial_location.y,
        z: 1.0,
    };
    (0..iters)
        .into_iter()
        .map(|_| {
            let old_point = point;
            let operation = select_array(hutchinson_op, probabilities);
            point = point.matrix_mul(operation);
            Point2 {
                x: old_point.x,
                y: old_point.y,
            }
        })
        .collect()
}

fn main() {
    let barnsley_hutchinson = vec![
        vec![
            Point3::new(0.0, 0.0, 0.0),
            Point3::new(0.0, 0.16, 0.0),
            Point3::new(0.0, 0.0, 1.0),
        ],
        vec![
            Point3::new(0.85, 0.04, 0.0),
            Point3::new(-0.04, 0.85, 1.60),
            Point3::new(0.0, 0.0, 1.0),
        ],
        vec![
            Point3::new(0.20, -0.26, 0.0),
            Point3::new(0.23, 0.22, 1.60),
            Point3::new(0.0, 0.0, 1.0),
        ],
        vec![
            Point3::new(-0.15, 0.28, 0.0),
            Point3::new(0.26, 0.24, 0.44),
            Point3::new(0.0, 0.0, 1.0),
        ],
    ];

    let barnsley_probabilities = vec![0.01, 0.85, 0.07, 0.07];

    let mut out = String::new();

    for point in chaos_game(
        10_000,
        Point2 { x: 0.0, y: 0.0 },
        &amp;barnsley_hutchinson,
        &amp;barnsley_probabilities,
    ) {
        out += format!(&quot;{}\t{}\n&quot;, point.x, point.y).as_str();
    }

    std::fs::write(&quot;./out.dat&quot;, out).unwrap();
}
</code></pre></pre>
<pre><code class="language-cpp">// The code bellow uses C++-17 features, compile it with C++-17 flags, e.g.:
// clang++ -Wall -Wextra -Wshadow -Wnon-virtual-dtor -Wold-style-cast -Wcast-align -Wunused -Woverloaded-virtual -Wpedantic -Wconversion -Wsign-conversion -Wnull-dereference -Wdouble-promotion -Wformat=2 -gdwarf-3 -D_GLIBCXX_DEBUG -std=c++17 -O3 -c ./barnsley.cpp barnsley

#include &lt;array&gt;
#include &lt;cassert&gt;
#include &lt;fstream&gt;
#include &lt;random&gt;

using Vec2 = std::array&lt;double, 2&gt;;
using Vec3 = std::array&lt;double, 3&gt;;
using Row = std::array&lt;double, 3&gt;;
using Op = std::array&lt;Row, 3&gt;;

constexpr auto OpN = 4U;

template &lt;size_t N&gt;
auto operator+(std::array&lt;double, N&gt; x, std::array&lt;double, N&gt; y) {
  for (auto i = 0U; i &lt; N; ++i)
    x[i] += y[i];
  return x;
}

template &lt;size_t N&gt;
auto operator*(double k, std::array&lt;double, N&gt; v) {
  for (auto i = 0U; i &lt; N; ++i)
    v[i] *= k;
  return v;
}

template &lt;size_t N&gt;
auto operator*(std::array&lt;double, N&gt; v, double k) {
  return k * v;
}

auto operator*(const Op&amp; x, const Vec3&amp; y) {
  auto ret = Vec3{};
  for (auto i = 0U; i &lt; 3U; ++i) {
    ret[i] = 0;
    for (auto j = 0U; j &lt; 3U; ++j)
      ret[i] += y[j] * x[i][j];
  }
  return ret;
}

// Returns a pseudo-random number generator
std::default_random_engine&amp; rng() {
  // Initialize static pseudo-random engine with non-deterministic random seed
  static std::default_random_engine randEngine(std::random_device{}());
  return randEngine;
}

// Returns a random double in [0, 1)
double drand() {
  return std::uniform_real_distribution&lt;double&gt;(0.0, 1.0)(rng());
}

// This is a function that reads in the Hutchinson operator and
// corresponding
//     probabilities and outputs a randomly selected transform
// This works by choosing a random number and then iterating through all
//     probabilities until it finds an appropriate bin
auto select_array(
    const std::array&lt;Op, OpN&gt;&amp; hutchinson_op,
    const std::array&lt;double, OpN&gt;&amp; probabilities) {

  // random number to be binned
  auto rnd = drand();

  // This checks to see if a random number is in a bin, if not, that
  //     probability is subtracted from the random number and we check the
  //     next bin in the list
  for (auto i = 0U; i &lt; probabilities.size(); ++i) {
    if (rnd &lt; probabilities[i])
      return hutchinson_op[i];
    rnd -= probabilities[i];
  }
  assert(!static_cast&lt;bool&gt;(&quot;check if probabilities adding up to 1&quot;));
}

// This is a general function to simulate a chaos game
// n is the number of iterations
// initial_location is the the starting point of the chaos game
// hutchinson_op is the set of functions to iterate through
// probabilities is the set of probabilities corresponding to the likelihood
//     of choosing their corresponding function in hutchinson_op
auto chaos_game(
    size_t n,
    Vec2 initial_location,
    const std::array&lt;Op, OpN&gt;&amp; hutchinson_op,
    const std::array&lt;double, OpN&gt;&amp; probabilities) {

  // Initializing the output array and the initial point
  auto output_points = std::vector&lt;Vec2&gt;{};

  // extending point to 3D for affine transform
  auto point = Vec3{initial_location[0], initial_location[1], 1};

  for (auto i = 0U; i &lt; n; ++i) {
    output_points.push_back(Vec2{point[0], point[1]});
    point = select_array(hutchinson_op, probabilities) * point;
  }

  return output_points;
}

int main() {

  const std::array barnsley_hutchinson = {
      Op{Row{0.0, 0.0, 0.0}, Row{0.0, 0.16, 0.0}, Row{0.0, 0.0, 1.0}},
      Op{Row{0.85, 0.04, 0.0}, Row{-0.04, 0.85, 1.60}, Row{0.0, 0.0, 1.0}},
      Op{Row{0.20, -0.26, 0.0}, Row{0.23, 0.22, 1.60}, Row{0.0, 0.0, 1.0}},
      Op{Row{-0.15, 0.28, 0.0}, Row{0.26, 0.24, 0.44}, Row{0.0, 0.0, 1.0}}};

  const std::array barnsley_probabilities = {0.01, 0.85, 0.07, 0.07};
  auto output_points = chaos_game(
      10'000, Vec2{0, 0}, barnsley_hutchinson, barnsley_probabilities);

  std::ofstream ofs(&quot;out.dat&quot;);
  for (auto pt : output_points)
    ofs &lt;&lt; pt[0] &lt;&lt; '\t' &lt;&lt; pt[1] &lt;&lt; '\n';
}
</code></pre>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

struct matrix {
    double xx, xy, xz,
           yx, yy, yz,
           zx, zy, zz;
};

struct point2d {
    double x, y;
};

struct point3d {
    double x, y, z;
};

struct point3d matmul(struct matrix mat, struct point3d point)
{
    struct point3d out = {
        mat.xx * point.x + mat.xy * point.y + mat.xz * point.z,
        mat.yx * point.x + mat.yy * point.y + mat.yz * point.z,
        mat.zx * point.x + mat.zy * point.y + mat.zz * point.z
    };
    return out;
}

// This function reads in the Hutchinson operator and corresponding
// probabilities and returns a randomly selected transform
// This works by choosing a random number and then iterating through all
// probabilities until it finds an appropriate bin
struct matrix select_array(struct matrix *hutchinson_op, double *probabilities,
                           size_t num_op)
{
    // random number to be binned
    double rnd = (double)rand() / RAND_MAX;

    // This checks to see if a random number is in a bin, if not, that
    // probability is subtracted from the random number and we check the next
    // bin in the list
    for (size_t i = 0; i &lt; num_op; ++i) {
        if (rnd &lt; probabilities[i]) {
            return hutchinson_op[i];
        }
        rnd -= probabilities[i];
    }
}

// This is a general function to simulate a chaos game
//  - output_points: pointer to an initialized output array
//  - num: the number of iterations
//  - initial_point: the starting point of the chaos game
//  - hutchinson_op: the set of functions to iterate through
//  - probabilities: the set of probabilities corresponding to the likelihood
//      of choosing their corresponding function in hutchingson_op
//  - nop: the number of functions in hutchinson_op
void chaos_game(struct point2d *output_points, size_t num,
                struct point2d initial_point, struct matrix *hutchinson_op,
                double *probabilities, size_t nop)
{
    // extending point to 3D for affine transform
    struct point3d point = {initial_point.x, initial_point.y, 1.0};

    for (size_t i = 0; i &lt; num; ++i) {
        point = matmul(select_array(hutchinson_op, probabilities, nop), point);
        output_points[i].x = point.x;
        output_points[i].y = point.y;
    }
}

int main()
{
    struct matrix barnsley_hutchinson[4] = {
        {
            0.0, 0.0, 0.0,
            0.0, 0.16, 0.0,
            0.0, 0.0, 1.0
        },
        {
            0.85, 0.04, 0.0,
            -0.04, 0.85, 1.60,
            0.0, 0.0, 1.0
        },
        {
            0.2, -0.26, 0.0,
            0.23, 0.22, 1.60,
            0.0, 0.0, 1.0
        },
        {
            -0.15, 0.28, 0.0,
            0.26, 0.24, 0.44,
            0.0, 0.0, 1.0
        }
    };

    double barnsley_probabilities[4] = {0.01, 0.85, 0.07, 0.07};
    struct point2d output_points[10000];
    struct point2d initial_point = {0.0, 0.0};
    chaos_game(output_points, 10000, initial_point, barnsley_hutchinson,
               barnsley_probabilities, 4);
    FILE *f = fopen(&quot;barnsley.dat&quot;, &quot;w&quot;);
    for (size_t i = 0; i &lt; 10000; ++i) {
        fprintf(f, &quot;%f\t%f\n&quot;, output_points[i].x, output_points[i].y);
    }
    fclose(f);

    return 0;
}
</code></pre>
<pre><code class="language-java">import java.io.FileWriter;
import java.io.IOException;
import java.util.Random;

public class Barnsley {

    private static class Point {
        public double x, y, z;

        public Point(double x, double y, double z) {
            this.x = x;
            this.y = y;
            this.z = z;
        }

        public Point(double[] coordinates) {
            this.x = coordinates[0];
            this.y = coordinates[1];
            this.z = coordinates[2];
        }

        public Point matrixMultiplication(double[][] matrix) {
            double[] results = new double[3];
            for (int i = 0; i &lt; 3; i++) {
                results[i] = matrix[i][0] * x + matrix[i][1] * y + matrix[i][2] * z;
            }
            return new Point(results);
        }
    }

    // This is a function that reads in the Hutchinson operator and corresponding
    //   probabilities and outputs a randomly selected transform
    // This works by choosing a random number and then iterating through all
    //   probabilities until it finds an appropriate bin
    public static double[][] selectArray(double[][][] hutchinsonOp, double[] probabilities) {
        Random rng = new Random();
        // Random number to be binned
        double rand = rng.nextDouble();

        // This checks to see if a random number is in a bin, if not, that
        // probability is subtracted from the random number and we check the
        // next bin in the list
        for (int i = 0; i &lt; probabilities.length; i++) {
            if (rand &lt; probabilities[i])
                return hutchinsonOp[i];
            rand -= probabilities[i];
        }
        // This return will never be reached, as the loop above ensures that at some point rand will be smaller
        // than a probability. However, Java does not know this and thus this return is needed for compilation.
        return null;
    }

    // This is a general function to simulate a chaos game
    // n is the number of iterations
    // initialLocation is the starting point of the chaos game
    // hutchinsonOp is the set of functions to iterate through
    // probabilities is the set of probabilities corresponding to the likelihood
    //   of choosing their corresponding function in hutchinsonOp
    public static Point[] chaosGame(int n, Point initialLocation, double[][][] hutchinsonOp, double[] probabilities) {
        // Initializing output points
        Point[] outputPoints = new Point[n];
        Point point = initialLocation;

        for (int i = 0; i &lt; n; i++) {
            outputPoints[i] = point;
            point = point.matrixMultiplication(selectArray(hutchinsonOp, probabilities));
        }

        return outputPoints;
    }

    public static void main(String[] args) {
        double[][][] barnsleyHutchinson = {
                {{0.0, 0.0, 0.0},
                 {0.0, 0.16, 0.0},
                 {0.0, 0.0, 1.0}},
                {{0.85, 0.04, 0.0},
                 {-0.04, 0.85, 1.60},
                 {0.0, 0.0, 1.0}},
                {{0.20, -0.26, 0.0},
                 {0.23, 0.22, 1.60},
                 {0.0, 0.0, 1.0}},
                {{-0.15, 0.28, 0.0},
                 {0.26, 0.24, 0.44},
                 {0.0, 0.0, 1.0}}
        };
        double[] barnsleyProbabilities = new double[]{0.01, 0.85, 0.07, 0.07};
        Point[] outputPoints = chaosGame(10000, new Point(0.0, 0.0, 1.0), barnsleyHutchinson, barnsleyProbabilities);
        try (FileWriter fw = new FileWriter(&quot;barnsley.dat&quot;)) {
            for (Point p : outputPoints) {
                fw.write(p.x + &quot;\t&quot; + p.y + &quot;\n&quot;);
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

}
</code></pre>
<pre><code class="language-coconut">from random import choices
import numpy as np

data Point(x=0, y=0):
    def __rmatmul__(self, mat: np.array):
        point_array = np.array([self.x, self.y, 1])
        x, y, *_ = tuple(*(mat @ point_array))
        return Point(x, y)


def chaos_game(initial_location is Point, hutchinson_op, probabilities):
    point = initial_location
    while True:
        yield (point := choices(hutchinson_op, probabilities) @ point)

barnsley_hutchinson = [
    np.array([
        [0., 0., 0.],
        [0., 0.16, 0.],
        [0., 0., 1.],
    ]),
    np.array([
        [0.85, 0.04, 0.],
        [-0.04, 0.85, 1.6],
        [0., 0., 1.],
    ]),
    np.array([
        [0.2, -0.26, 0.],
        [0.23, 0.22, 1.6],
        [0., 0., 1.],
    ]),
    np.array([
        [-0.15, 0.28, 0.],
        [0.26, 0.24, 0.44],
        [0., 0., 1.],
    ]),
]

barnsley_probabilities = [0.01, 0.85, 0.07, 0.07]

if __name__ == '__main__':
    output_gen = chaos_game(Point(0, 0), barnsley_hutchinson, barnsley_probabilities)
    output_points = np.array([*output_gen$[:10000]])
    np.savetxt(&quot;out.dat&quot;, output_points)
</code></pre>
<pre><code class="language-haskell">import Data.Array (Array, bounds, elems, listArray, (!))
import Data.List (intercalate)
import System.Random

data Point = Point Double Double

chaosGame :: RandomGen g =&gt; g -&gt; Int -&gt; Array Int (Double, (Point -&gt; Point)) -&gt; [Point]
chaosGame g n hutchinson = take n points
  where
    (x, g') = random g
    (y, g'') = random g'

    cumulProbabilities = scanl1 (+) $ map fst $ elems hutchinson
    to_choice x = length $ takeWhile (x &gt;) cumulProbabilities

    picks = map to_choice $ randomRs (0, 1) g''
    step = fmap snd hutchinson

    points = Point x y : zipWith (step !) picks points

affine :: (Double, Double, Double, Double) -&gt; (Double, Double) -&gt; Point -&gt; Point
affine (xx, xy, yx, yy) (a, b) (Point x y) = Point (a + xx * x + xy * y) (b + yx * x + yy * y)

showPoint :: Point -&gt; String
showPoint (Point x y) = show x ++ &quot;\t&quot; ++ show y

main :: IO ()
main = do
  g &lt;- newStdGen
  let barnsley =
        listArray
          (0, 3)
          [ (0.01, affine (0, 0, 0, 0.16) (0, 0)),
            (0.85, affine (0.85, 0.04, -0.04, 0.85) (0, 1.6)),
            (0.07, affine (0.2, -0.26, 0.23, 0.22) (0, 1.6)),
            (0.07, affine (-0.15, 0.28, 0.26, 0.24) (0, 0.44))
          ]
      points = chaosGame g 100000 barnsley

  writeFile &quot;out.dat&quot; $ intercalate &quot;\n&quot; $ map showPoint points
</code></pre>
<h3 id="bibliography-3"><a class="header" href="#bibliography-3">Bibliography</a></h3>
<p>{% references %} {% endreferences %}</p>
<h2 id="license-5"><a class="header" href="#license-5">License</a></h2>
<h5 id="code-examples-5"><a class="header" href="#code-examples-5">Code Examples</a></h5>
<p>The code examples are licensed under the MIT license (found in <a href="https://github.com/algorithm-archivists/algorithm-archive/blob/master/LICENSE.md">LICENSE.md</a>).</p>
<h5 id="text-5"><a class="header" href="#text-5">Text</a></h5>
<p>The text of this chapter was written by <a href="https://github.com/leios">James Schloss</a> and is licensed under the <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</p>
<p><a href="https://creativecommons.org/licenses/by-sa/4.0/"><p><img  class="center" src="barnsley/../cc/CC-BY-SA_icon.svg" /></p></a></p>
<h4 id="imagesgraphics-3"><a class="header" href="#imagesgraphics-3">Images/Graphics</a></h4>
<ul>
<li>The image &quot;<a href="barnsley/../IFS/res/IFS_triangle_1.png">IFS triangle 1</a>&quot; was created by <a href="https://github.com/leios">James Schloss</a> and is licensed under the <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</li>
<li>The image &quot;<a href="barnsley/../IFS/res/IFS_square_3.png">IFS square 3</a>&quot; was created by <a href="https://github.com/leios">James Schloss</a> and is licensed under the <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</li>
<li>The image &quot;<a href="barnsley/res/full_fern.png">Simple Barnsley fern</a>&quot; was created by <a href="https://github.com/leios">James Schloss</a> and is licensed under the <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</li>
<li>The video &quot;<a href="barnsley/res/affine_rnd_0.mp4">Affine random transform 0</a>&quot; was created by <a href="https://github.com/leios">James Schloss</a> and is licensed under the <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</li>
<li>The video &quot;<a href="barnsley/res/affine_rnd_1.mp4">Affine random transform 1</a>&quot; was created by <a href="https://github.com/leios">James Schloss</a> and is licensed under the <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</li>
<li>The video &quot;<a href="barnsley/res/affine_rnd_2.mp4">Affine random transform 2</a>&quot; was created by <a href="https://github.com/leios">James Schloss</a> and is licensed under the <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</li>
<li>The video &quot;<a href="barnsley/res/affine_rnd_3.mp4">Affine random transform 3</a>&quot; was created by <a href="https://github.com/leios">James Schloss</a> and is licensed under the <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</li>
<li>The video &quot;<a href="barnsley/res/affine_fern_0.mp4">Affine fern transform 0</a>&quot; was created by <a href="https://github.com/leios">James Schloss</a> and is licensed under the <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</li>
<li>The video &quot;<a href="barnsley/res/affine_fern_1.mp4">Affine fern transform 1</a>&quot; was created by <a href="https://github.com/leios">James Schloss</a> and is licensed under the <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</li>
<li>The video &quot;<a href="barnsley/res/affine_fern_2.mp4">Affine fern transform 2</a>&quot; was created by <a href="https://github.com/leios">James Schloss</a> and is licensed under the <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</li>
<li>The video &quot;<a href="barnsley/res/affine_fern_3.mp4">Affine fern transform 3</a>&quot; was created by <a href="https://github.com/leios">James Schloss</a> and is licensed under the <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</li>
<li>The video &quot;<a href="barnsley/res/fern_twiddle_0.mp4">Fern twiddle 0</a>&quot; was created by <a href="https://github.com/leios">James Schloss</a> and is licensed under the <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</li>
<li>The video &quot;<a href="barnsley/res/fern_twiddle_1.mp4">Fern twiddle 1</a>&quot; was created by <a href="https://github.com/leios">James Schloss</a> and is licensed under the <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</li>
<li>The video &quot;<a href="barnsley/res/fern_twiddle_2.mp4">Fern twiddle 2</a>&quot; was created by <a href="https://github.com/leios">James Schloss</a> and is licensed under the <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</li>
<li>The video &quot;<a href="barnsley/res/fern_twiddle_3.mp4">Fern twiddle 3</a>&quot; was created by <a href="https://github.com/leios">James Schloss</a> and is licensed under the <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="data-structures"><a class="header" href="#data-structures">Data Structures</a></h1>
<p>This is a book about algorithms.
The fundamental building blocks of algorithms are data structures, and thus as more algorithms are added to the Archive, more data structures will be added to this section.</p>
<h2 id="license-6"><a class="header" href="#license-6">License</a></h2>
<h5 id="code-examples-6"><a class="header" href="#code-examples-6">Code Examples</a></h5>
<p>The code examples are licensed under the MIT license (found in <a href="https://github.com/algorithm-archivists/algorithm-archive/blob/master/LICENSE.md">LICENSE.md</a>).</p>
<h5 id="text-6"><a class="header" href="#text-6">Text</a></h5>
<p>The text of this chapter was written by <a href="https://github.com/leios">James Schloss</a> and is licensed under the <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</p>
<p><a href="https://creativecommons.org/licenses/by-sa/4.0/"><p><img  class="center" src="data_structures/../cc/CC-BY-SA_icon.svg" /></p></a></p>
<h5 id="pull-requests-4"><a class="header" href="#pull-requests-4">Pull Requests</a></h5>
<p>After initial licensing (<a href="https://github.com/algorithm-archivists/algorithm-archive/pull/560">#560</a>), the following pull requests have modified the text or graphics of this chapter:</p>
<ul>
<li>none</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="stacks-and-queues"><a class="header" href="#stacks-and-queues">Stacks and Queues</a></h1>
<p>Stacks and Queues are two sides of the same coin in computer science. They are both simple data structures that hold multiple elements, but allow you to use a single element at a time. The biggest difference between the two structures is the order in which you can access the elements in the data structure.</p>
<p>In <em>stacks</em>, data follows <em>Last In, First Out</em> (LIFO), which basically means that whichever element you put in last will be the first element you take out. It acts exactly like a stack in real life. If you put a book on a stack of other books, the first book you will look at when sifting through the stack will be the book you just put on the stack.</p>
<p>In <em>Queues</em>, data follows <em>First In, First Out</em> (FIFO), which means that whichever element you put in first will be the first element you take out. Imagine a queue of people. It would be unfair if the first person in line for groceries were not the first person to receive attention once the attendant finally shows up.</p>
<p>For the most part, though, queues and stacks are treated the same way. There must be a way to:</p>
<ol>
<li>look at the first element (<code>top()</code>)</li>
<li>to remove the first element (<code>pop()</code>)</li>
<li>to push elements onto the data structure (<code>push()</code>)</li>
</ol>
<p>The notation for this depends on the language you are using. Queues, for example, will often use <code>dequeue()</code> instead of <code>pop()</code> and <code>front()</code> instead of <code>top()</code>. You will see the language-specific details in the source code under the algorithms in this book, so for now it's simply important to know what stacks and queues are and how to access elements held within them.</p>
<h2 id="example-code-3"><a class="header" href="#example-code-3">Example Code</a></h2>
<p>Here is a simple implementation of a stack:</p>
<pre><code class="language-typescript">interface IStack&lt;T&gt; {
  /**
   * `pop` removes last element from the stack and returns the same
   */
  pop(): T;
  /**
   * `push` adds element to last of the stack and returns the size
   */
  push(data: T): number;
  /**
   * `size` return size or length of the stack
   */
  size(): number;
  /**
   * `top` returns last element of the stack
   */
  top(): T;
}

class Stack&lt;T&gt; implements IStack&lt;T&gt; {
  private readonly list: Array&lt;T&gt; = [];

  public push(data: T) {
    return this.list.push(data);
  }

  public pop() {
    return this.list.pop();
  }

  public size() {
    return this.list.length;
  }

  public top() {
    return this.list[this.list.length - 1];
  }
}

function exampleStack() {
  const numberStack = new Stack&lt;number&gt;();

  numberStack.push(4);
  numberStack.push(5);
  numberStack.push(9);

  console.log(numberStack.pop());
  console.log(numberStack.size());
  console.log(numberStack.top());
}

exampleStack();
``````typescript
interface IStack&lt;T&gt; {
  /**
   * `pop` removes last element from the stack and returns the same
   */
  pop(): T;
  /**
   * `push` adds element to last of the stack and returns the size
   */
  push(data: T): number;
  /**
   * `size` return size or length of the stack
   */
  size(): number;
  /**
   * `top` returns last element of the stack
   */
  top(): T;
}

class Stack&lt;T&gt; implements IStack&lt;T&gt; {
  private readonly list: Array&lt;T&gt; = [];

  public push(data: T) {
    return this.list.push(data);
  }

  public pop() {
    return this.list.pop();
  }

  public size() {
    return this.list.length;
  }

  public top() {
    return this.list[this.list.length - 1];
  }
}

function exampleStack() {
  const numberStack = new Stack&lt;number&gt;();

  numberStack.push(4);
  numberStack.push(5);
  numberStack.push(9);

  console.log(numberStack.pop());
  console.log(numberStack.size());
  console.log(numberStack.top());
}

exampleStack();
</code></pre>
<p><a href="stacks_and_queues/code/java/Stack.java">import, lang:&quot;java&quot;</a></p>
<p>Here is a simple implementation of a queue:</p>
<pre><code class="language-typescript">interface IQueue&lt;T&gt; {
  /**
   * `dequeue` removes first element from the queue and returns the same
   */
  dequeue(): T;
  /**
   * `enqueue` adds element to last of the queue and returns the size
   */
  enqueue(data: T): number;
  /**
   * `size` return size or length of the queue
   */
  size(): number;
  /**
   * `front` returns first element of the queue
   */
  front(): T;
}

class Queue&lt;T&gt; implements IQueue&lt;T&gt; {
  private readonly list: Array&lt;T&gt; = [];

  public enqueue(data: T) {
    return this.list.push(data);
  }

  public dequeue() {
    return this.list.shift();
  }

  public size() {
    return this.list.length;
  }

  public front() {
    return this.list[0];
  }
}

function exampleQueue() {
  const numberQueue = new Queue&lt;number&gt;();

  numberQueue.enqueue(4);
  numberQueue.enqueue(5);
  numberQueue.enqueue(9);

  console.log(numberQueue.dequeue());
  console.log(numberQueue.size());
  console.log(numberQueue.front());
}

exampleQueue();
</code></pre>
<p>{% sample lang=&quot;java&quot; %}
<a href="stacks_and_queues/code/java/Queue.java">import, lang:&quot;java&quot; </a></p>
<h2 id="license-7"><a class="header" href="#license-7">License</a></h2>
<h5 id="code-examples-7"><a class="header" href="#code-examples-7">Code Examples</a></h5>
<p>The code examples are licensed under the MIT license (found in <a href="https://github.com/algorithm-archivists/algorithm-archive/blob/master/LICENSE.md">LICENSE.md</a>).</p>
<h5 id="text-7"><a class="header" href="#text-7">Text</a></h5>
<p>The text of this chapter was written by <a href="https://github.com/leios">James Schloss</a> and is licensed under the <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</p>
<p><a href="https://creativecommons.org/licenses/by-sa/4.0/"><p><img  class="center" src="stacks_and_queues/../cc/CC-BY-SA_icon.svg" /></p></a></p>
<h5 id="pull-requests-5"><a class="header" href="#pull-requests-5">Pull Requests</a></h5>
<p>After initial licensing (<a href="https://github.com/algorithm-archivists/algorithm-archive/pull/560">#560</a>), the following pull requests have modified the text or graphics of this chapter:</p>
<ul>
<li>none</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mathematical-background"><a class="header" href="#mathematical-background">Mathematical Background</a></h1>
<p>No matter who you ask, programming requires at least a little math.
That said, for most programmers, it doesn't require <em>too</em> much.
For the most part, depending on your specialty, you will probably not see too much calculus or differential equations.
Honestly, you could probably get away with what you learned in high school.</p>
<p>However, this is a book about algorithms, and algorithms sometimes require a deeper understanding of mathematics.
This section attempts to provide the mathematical foundations that you will need to understand certain algorithms.
As we add new algorithms and need new mathematical tools, we will add them to this section.</p>
<p>A notable exception to this rule will be in the case of classes of algorithms that require domain-specific knowledge, like quantum simulations or bioinformatics.
In those cases, we will place the mathematical methods in more relevant sections.</p>
<h2 id="license-8"><a class="header" href="#license-8">License</a></h2>
<h5 id="code-examples-8"><a class="header" href="#code-examples-8">Code Examples</a></h5>
<p>The code examples are licensed under the MIT license (found in <a href="https://github.com/algorithm-archivists/algorithm-archive/blob/master/LICENSE.md">LICENSE.md</a>).</p>
<h5 id="text-8"><a class="header" href="#text-8">Text</a></h5>
<p>The text of this chapter was written by <a href="https://github.com/leios">James Schloss</a> and is licensed under the <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</p>
<p><a href="https://creativecommons.org/licenses/by-sa/4.0/"><p><img  class="center" src="mathematical_background/../cc/CC-BY-SA_icon.svg" /></p></a></p>
<h5 id="pull-requests-6"><a class="header" href="#pull-requests-6">Pull Requests</a></h5>
<p>After initial licensing (<a href="https://github.com/algorithm-archivists/algorithm-archive/pull/560">#560</a>), the following pull requests have modified the text or graphics of this chapter:</p>
<ul>
<li>none</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="complexity-notation"><a class="header" href="#complexity-notation">Complexity Notation</a></h1>
<p>Algorithms are designed to solve problems.
Over time, new algorithms are created to solve problems that old algorithms have already solved.
In some cases, the new algorithms are not intrinsically <em>better</em> than the older ones.
In other cases, these new algorithms breathe life into areas of research and engineering that could not exist without them.
The question is: what makes an algorithm &quot;better&quot; than another one?</p>
<p>Obviously, there is no good answer to this question.
If you write an algorithm to solve a problem, whatever you come up with will probably work just fine for small problems.
That said, if you need to use the algorithm for a larger system, you might find yourself waiting for longer and longer on your code to run.
In these cases, it's obvious that <em>if you are working on a large system, you need an algorithm that scales well with a large size</em>.
Ideally, an algorithm that works well for a large system will also work with a smaller one; however, this is not always the case.</p>
<p>In order to determine the best algorithm for your system, it's often best to consult a tool computer scientists use to describe how algorithms scale with system size: <em>complexity theory</em>.
Here's the idea: algorithms operate on data.
Complexity theory uses different notations to describe how many operations an algorithm will need.
In this way, computational complexity measures runtime in terms of the number of operations an algorithm takes to complete its task.
To be clear, the notations used are not at all exact, but they roughly describe the run-time of code and can be used to estimate how long an algorithm should take to run.
In addition, there are many different notations depending on who you ask, but for now we'll focus on the big 3: \( O \), \( \Omega \), and \( \Theta \).
Big \( O \) assumes the worst, which is the often the most useful description of an algorithm.
On the other hand, \( \Omega \) assumes the best and \( \Theta \) is used when the best and worst cases are the same.</p>
<p>Of the three Big \( O \) is used the most, and is used in conversation to mean that the algorithm will take &quot;on the order of&quot; \( n \) operations.
Unfortunately, at this point, these notations might be a little vague.
In fact, it was incredibly vague for me for a long time, and it wasn't until I saw the notations in action that it all started to make sense, so that's what this section is about: providing concrete examples to better understand computational complexity notation.</p>
<h2 id="constant-time"><a class="header" href="#constant-time">Constant Time</a></h2>
<p>Let's write some code that reads in an array of length <code>n</code> and runs with constant time:</p>
<pre><code class="language-julia">function constant(a::Array{Float64})
    println(a[1])
end
</code></pre>
<p>Obviously, no matter how large <code>a</code> is, this function will not take any longer to run.
Because of this, we say it has a constant runtime and notate it with \( O(1) = \Omega(1) = \Theta(1) \).
Basically, we are saying that this function will run with 1 operation total (a single print).
The best-case runtime will be 1 operation, the worst-case runtime will be 1 operation, and because they are both the same, we can use \( \Theta \) to notate that.
Now imagine the following function:</p>
<pre><code class="language-julia">function constant(a::Array{Float64})
    if (length(a) &gt;= 3)
        println(a[1])
        println(a[2])
        println(a[3])
    end
end
</code></pre>
<p>This function has 3 print statements, so it has 3 operations total.
Because of this, it's tempting to say that the runtime would be \( O(3) = \Omega(3) = \Theta(3) \), and you would not be wrong; however, complexity notations often make a big assumption: <strong>we don't care about constants!</strong>
What does this mean? Well, it means that we get rid of all constants that are not 1!
In this case, that means we set \( O(3) = O(1) \).</p>
<p>Now, I know what you are thinking, <em>That's stupid! It's clear that the second function will take 3 times as long to run, shouldn't we notate that?</em>
You're not wrong; however, complexity notation is mostly interested in how algorithms scale with larger and larger inputs.
Because we are talking about constant run-time, there is no scaling with larger inputs. No matter what array you read in to the above functions, they will always take a constant number of operations to finish.
Whether that constant time is 1 operation or 3 operations doesn't really matter because different machines will have different runtimes anyway.</p>
<p>Now, here's the thing: as we move on to more complicated examples, we will continue to ignore constants and extra terms to make the notation easier to understand.
Just because this is common practice does not mean it's the <em>best</em> practice.
I have run into several situation where knowing the constants has saved me hours of run-time, so keep in mind that all of these notations are somewhat vague and dependent on a number of auxiliary factors.
Still, that doesn't mean the notation is completely useless. For now, let's keep moving forward with some more complicated (and useful) examples!</p>
<h2 id="linear-time"><a class="header" href="#linear-time">Linear Time</a></h2>
<p>Now we are moving into interesting territory!
Let's consider the following function:</p>
<pre><code class="language-julia">function linear(a::Array{Float64})
    for i = 1:length(a)
        println(a[i])
    end
end
</code></pre>
<p>Here, it's clear that if we increase <code>a</code> by one element, we will need to do another operation.
That is, with an array of size \( n \), we will need to do \( n \) operations, which means that our complexity is \( O(n) = \Omega(n) = \Theta(n) \).
As before, adding more operations into the <code>for</code> loop will change the constant in front of \( n \) in our complexity notation, but we'll continue to ignore those constants.
For example:</p>
<pre><code class="language-julia">function linear(a::Array{Float64})
    println(&quot;The first element in our array is: &quot;, a[1])

    println(&quot;The sum of all pairs of elements in our array are...&quot;)
    for i = 1:length(a)/2
        println(&quot;a is: &quot;, a[2*i])
        println(&quot;b is: &quot;, a[2*i+1])
        println(&quot;The sum of a and b is: &quot;, a[2*i] + a[2*i+1])
    end

    println(&quot;The last element in our array is: &quot;, a[end])
end
</code></pre>
<p>Technically has a complexity of \( \Theta(\frac{3n}{2} + 2) \), but we'll just call it \( \Theta(n) \).
Regardless of the notation, if you see something that is \( O(n) \), you know that <em>at worst</em> it will run at the speed of a <code>for</code> loop, which is pretty good!</p>
<h3 id="polynomial-time"><a class="header" href="#polynomial-time">Polynomial Time</a></h3>
<p>A promise of \( O(n) \) is not bad in terms of run-time; however, it is unlikely that you will run into too many straightforward algorithms that are \( O(n) \).
For example, let's say you have a square, 2D image and want to iterate through all of its points.
Well, to do this, we might write code that looks something like:</p>
<pre><code class="language-julia"># Here, size is the length of a single side of the image
function access_image(img::Array{Float64}, size::Int64)
    for i = 1:size
        for j = 1:size
            index = j + i*size
            println(img[index])
        end
    end
end
</code></pre>
<p>This is a simple case where a nested <code>for</code> loop is perfectly acceptable, and it's obvious geometrically that we need to access \( \mathrm{size}\times\mathrm{size} \) number of elements (because we are working with a square).
This means that this example has \( \Theta(n^2) \) complexity. This is not great.
If you have to access 3D space, this might require \( \Theta(n^3) \), which is even worse! Don't even get me started on 4D!
Intuitively, if you see anything that has a polynomial runtime, it's easy to think of it as a bunch of nested <code>for</code> loops.
That said, there have been several cases throughout the history of algorithms where polynomial runtimes have inhibited certain algorithms from being used entirely, simply because it takes too long to run!</p>
<p>For this reason, if you can avoid writing nested <code>for</code> loops, you certainly should!
However, there are several cases where this cannot be avoided, so don't spend too much time worrying about it unless runtime becomes an issue!</p>
<h2 id="exponential-and-logarithmic-time"><a class="header" href="#exponential-and-logarithmic-time">Exponential and Logarithmic Time</a></h2>
<p>These are two more cases that come up all the time and often require a common theme: <em>recursion</em>.
Generally speaking, logarithmic algorithms are some of the fastest algorithms out there, while exponential algorithms are some of the slowest.
Unfortunately, this means that recursion can be either the most useful tool in existence for realizing certain algorithms or the most harmful one, depending on your problem.</p>
<p>Here is a simple example of a function with exponential runtime:</p>
<pre><code class="language-julia"># Here, n is the number of iterations
function exponential(value::Int64, n::Int64)
    println(value)
    value += 1
    exponential(value, n-1)
    exponential(value, n-1)
end
</code></pre>
<p>Here, we read in the maximum number <code>n</code> we are iterating through and recursively call the <code>exponential</code> function, decrementing the number of iterations left each time.
Because we are calling the <code>exponential</code> function twice, this has a complexity of \( \Theta(2^n) \), which is not great, but if it's the only way to get a job done, it's the only way to get a job done.</p>
<p>Logarithmic algorithms can be thought of as the opposite of exponential ones.
Instead of taking a value and computing more and more values each time, a good example of a logarithmic algorithm is one that takes an array and recursively divides it up, like so:</p>
<pre><code class="language-julia"># Here, cutoff is an arbitrary variable to know when to stop recursing
function logarithmic(a::Array{Float64}, cutoff::Int64)
    if (length(a) &gt; cutoff)
        logarithmic(a[1:length(a)/2], cutoff)
        logarithmic(a[length(a)/2+1:end], cutoff)
    end
    println(length(a))
end
</code></pre>
<p>To be honest, it is not obvious that the provided <code>logarithmic</code> function should operate in \( \Theta(\log(n)) \) time, where \( n \) is the size of <code>a</code>.
That said, I encourage you to think about an array of size 8.
First, we split it in half, creating 2 arrays of 4 elements each.
If we split these new arrays, we have 4 arrays of 2, and if we split these by two we have 8 arrays of 1 element each.
This is as far as we can go, and we ended up dividing the array 3 times to get to this point.
\( 3 = \log_2(8) \), so this function runs with a logarithmic number of operations.</p>
<h2 id="putting-it-all-together"><a class="header" href="#putting-it-all-together">Putting it all together</a></h2>
<p>We've outlined the most common complexity cases of different algorithms here, but at this point things might still be unclear.
Which is better: \( O(n^2) \) or \( O(log(n)) \)?
Well, let's plot all the different cases out, and the answer should become obvious.</p>
<p>
    <img  class="center" src="notation/res/cplot.png" />
</p>
<p>Here, we see each of the complexity cases as \( n \) increases.
Clearly, linear time is not bad when compared to polynomial or exponential time; however, if you can manage something in logarithmic or constant time, do it!</p>
<p>Now, there is a lot more to say about computational complexity and we'll definitely cover it at some point, but I can only move so fast!
In particular, I would love to have a discussion on the \( P=NP \) issue that has been rustling the jimmies of a few computer scientists for a while, but we'll get to that in due time.</p>
<h3 id="final-warning"><a class="header" href="#final-warning">Final Warning</a></h3>
<p>This is a book about algorithms.
It would be nearly impossible to talk about most algorithms without touching on complexity theory and explaining why certain algorithms are faster than others.
That said, just because an algorithm runs in \( O(\log n) \) does not mean it will always be faster than one that runs in \( O(n^2) \).
Because complexity notation often ignores constants, there could be a crazy constant that we are missing that actually makes a huge difference in runtime.
In addition, in order to use an algorithm that seems faster based on complexity notation, you may need to use a library that massively increases runtime due to a plethora of other reasons.</p>
<p>Basically, take complexity notation with a grain of salt.
It is a useful descriptor of how fast algorithms should run in an ideal world; however, ideal worlds do not exist.
When it comes to programming, there may be hundreds of other factors that need to be considered before implementing anything.
That said, complexity notation should not be ignored.
If you can easily implement an algorithm that is notationally faster with no repercussions, go for it!
Just be sure you do not waste time trying to optimize code you haven't written yet.</p>
<p>In general, my advice would be the following:
write code first and optimize what you can on the first run-through without going too far out of your way.
If the runtime is awful, go back and see about implementing algorithms that are faster based on complexity notation.</p>
<h2 id="license-9"><a class="header" href="#license-9">License</a></h2>
<h5 id="code-examples-9"><a class="header" href="#code-examples-9">Code Examples</a></h5>
<p>The code examples are licensed under the MIT license (found in <a href="https://github.com/algorithm-archivists/algorithm-archive/blob/master/LICENSE.md">LICENSE.md</a>).</p>
<h5 id="text-9"><a class="header" href="#text-9">Text</a></h5>
<p>The text of this chapter was written by <a href="https://github.com/leios">James Schloss</a> and is licensed under the <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</p>
<p><a href="https://creativecommons.org/licenses/by-sa/4.0/"><p><img  class="center" src="notation/../cc/CC-BY-SA_icon.svg" /></p></a></p>
<h5 id="imagesgraphics-4"><a class="header" href="#imagesgraphics-4">Images/Graphics</a></h5>
<ul>
<li>The image &quot;<a href="notation/res/cplot.png">Complexity Scaling</a>&quot; was created by <a href="https://github.com/leios">James Schloss</a> and is licensed under the <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</li>
</ul>
<h5 id="pull-requests-7"><a class="header" href="#pull-requests-7">Pull Requests</a></h5>
<p>After initial licensing (<a href="https://github.com/algorithm-archivists/algorithm-archive/pull/560">#560</a>), the following pull requests have modified the text or graphics of this chapter:</p>
<ul>
<li>none</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="affine-transformations"><a class="header" href="#affine-transformations">Affine Transformations</a></h1>
<p>Affine transformations are a class of mathematical operations that encompass rotation, scaling, translation, shearing, and several similar transformations that are regularly used for various applications in mathematics and computer graphics.
To start, we will draw a distinct (yet thin) line between affine and linear transformations before discussing the augmented matrix formalism typically used in practice.</p>
<h2 id="a-quick-intro-to-affine-and-linear-transforms"><a class="header" href="#a-quick-intro-to-affine-and-linear-transforms">A quick intro to affine (and linear) transforms</a></h2>
<p>Let us start with a provided point, \( (x,y) \), on a two-dimensional plane.
If we treat this point as a \( 1 \times 2 \) vector, we can transform it into another \( 1 \times 2 \) vector by multiplying it with a \( 2 \times 2 \) transformation matrix.
Similarly, a three-dimensional point could be seen as a \( 1\times 3 \) vector and would need a \( 3 \times 3  \) transformation matrix.
These types of operations are known as linear transformations and are often notated as,</p>
<p>\[ \mathbf{v} = \mathbf{A}\mathbf{v}_0. \]</p>
<p>Here, \( \mathbf{A} \) is an \( n\times n \) transformation matrix, where \( n \) is the length of the input and output vectors, \( \mathbf{v_0} \) and \( \mathbf{v} \), respectively.
Though these transformations are powerful, all of them are centered about the origin.
Affine transformations extend linear transformations beyond this limitation and allow us to also translate our initial vector locations such that</p>
<p>\[ \textbf{v} = \mathbf{A}\mathbf{v}_0 + \ell. \]</p>
<p>Here, \( \ell \) is an \( n\times 1 \) translation vector.
To understand the power of these transformations, it is important to see them in practice:</p>
<table><thead><tr><th>Description</th><th>Transform</th></tr></thead><tbody>
<tr><td>Scaling along \( x \)</td><td><div style="text-align:center"> <video style="width:100%" controls loop> <source src="res/a11_square_white.mp4" type="video/mp4"> Your browser does not support the video tag. </video> </div></td></tr>
<tr><td>Scaling along \( y \)</td><td><div style="text-align:center"> <video style="width:100%" controls loop> <source src="res/a22_square_white.mp4" type="video/mp4"> Your browser does not support the video tag. </video> </div></td></tr>
<tr><td>Shearing along \( x \)</td><td><div style="text-align:center"> <video style="width:100%" controls loop> <source src="res/a12_square_white.mp4" type="video/mp4"> Your browser does not support the video tag. </video> </div></td></tr>
<tr><td>Shearing along \( y \)</td><td><div style="text-align:center"> <video style="width:100%" controls loop> <source src="res/a21_square_white.mp4" type="video/mp4"> Your browser does not support the video tag. </video> </div></td></tr>
<tr><td>Translation along \( x \)</td><td><div style="text-align:center"> <video style="width:100%" controls loop> <source src="res/a13_square_white.mp4" type="video/mp4"> Your browser does not support the video tag. </video> </div></td></tr>
<tr><td>Translation along \( y \)</td><td><div style="text-align:center"> <video style="width:100%" controls loop> <source src="res/a23_square_white.mp4" type="video/mp4"> Your browser does not support the video tag. </video> </div></td></tr>
</tbody></table>
<p>For all of these visualizations, we show a set of 4 points that are assigned to the vertices of a square.
Initially, \( \mathbf{A} \) is set to be the identity matrix and \( \ell = [0,0] \), such that there is no transformation or translation to the input vectors.
From there, each element of \( \mathbf{A} \) and \( \ell \) are modified individually and the resulting transformation can be seen on the left.
The amount by which each element has been modified is shown numerically in the matrix representation and also as small dials underneath.</p>
<p>The hope is that these visualizations show that each element within \( \mathbf{A} \) and \( \ell \) are simply dials that can be manipulated to perform a specified transformation on the set of input vectors.
Of course, it is entirely possible to move more than one dial at a time, which is why it is worth diving into an example that everyone loves: rotation.</p>
<h3 id="rotation-a-special-side-note"><a class="header" href="#rotation-a-special-side-note">Rotation: a special side-note</a></h3>
<p>I will be honest, when I initially learned how to perform rotation with a linear transformation, I did not really understand how it worked.
For this reason, I think it is important to delve a bit deeper into this topic, hopefully providing an intuitive explanation for those who are new (and potentially those who already use the rotation matrix regularly, but do not fully understand it).</p>
<p>If someone were to take the set of dials shown above and mix them to create a rotational effect, they might start by shearing in one direction along \( x \) and then another direction along \( y \) which will create a &quot;pseudo-rotation&quot; effect.
This is definitely a step in the right direction, but if the shearing components are modified while the other components remain 1, the points will also move further away from the origin.
For this reason, an additional scaling along \( x \) and \( y \) is necessary.
This is shown in the following animation:</p>
<div style="text-align:center">
<video style="width:100%" controls loop>
  <source src="res/semi_rotate_white.mp4" type="video/mp4">
Your browser does not support the video tag.
</video>
</div>
<p>Here, we see that (at least for angles less than \( \pi/2 \)), rotation is simply a matter of shearing in opposite directions and scaling accordingly.
Now the only question is, <em>&quot;How do we know the amount we need to shear and scale?&quot;</em></p>
<p>Well, the answer is not particularly surprising.
If we want to rotate our points, we probably are already imagining this rotation along a circle with some angle \( \theta \).
We know that the identity matrix should correspond to a non-rotated object with \( \theta = 0 \).
For this reason, we know that two elements should start at 1 (note: \( \cos(0) = 1 \)) and the other two should start at 0 (note: \( \sin(0) = 0 \)).
We also know that the shearing should happen in opposite directions, so we might guess that the rotation matrix would be:</p>
<p>\[
\mathbf{A}_{\text{rot}} = \begin{bmatrix}
\cos(\theta) &amp; -\sin(\theta) \\
\sin(\theta) &amp; \cos(\theta) \\
\end{bmatrix}
\]</p>
<p>In this case, the amount we want to shear should start at 0 when \( \theta = 0 \) and then go to \( \pm 1 \) when \( \theta = \pm \pi/2 \).
Meanwhile, the scale factor should start at 1 when \( \theta = 0 \) and go to \( 0 \) when \( \theta = \pi/2 \).</p>
<p>This <em>seems</em> right, but it is worth dwelling on this a bit more.
If the scale factor is 0 at \( \pi/2 \), surely this means that all points on the square are also at 0, right?
After all, anything scaled by 0 should be 0!
Well, not exactly.
In this case,</p>
<p>\[
\mathbf{A} = \begin{bmatrix}
1 &amp; 0 \\
0 &amp; 1 \\
\end{bmatrix}
\rightarrow
\begin{bmatrix}
0 &amp; -1 \\
1 &amp; 0 \\
\end{bmatrix}
\]</p>
<p>This means that even though the scaling components are 0, the shear components are \( \pm 1 \).
This might still be a little confusing so let us multiply the vector \( [1,2] \) with both of these matrices:</p>
<p>\[
\begin{align}
\begin{bmatrix}
1 &amp; 0 \\
0 &amp; 1 \\
\end{bmatrix}
\begin{bmatrix}
1 \\
2 \\
\end{bmatrix}
&amp;=
\begin{bmatrix}
1 \\
2 \\
\end{bmatrix},\\</p>
<p>\begin{bmatrix}
0 &amp; -1 \\
1 &amp; 0 \\
\end{bmatrix}
\begin{bmatrix}
1 \\
2 \\
\end{bmatrix}
&amp;=
\begin{bmatrix}
-2 \\ 
1 \\
\end{bmatrix}.</p>
<p>\end{align}
\]</p>
<p>Here, we see that when multiplying by the identity matrix, the vector remains the same, but when multiplying by the second matrix, the x and y components flip.
Essentially, all of the vector magnitude moved into the &quot;shear&quot; component, while none of it remains in the &quot;scale&quot; component.</p>
<p>My point is that even though it is useful to think of two of our dials as scale factors along \( x \) and \( y \), it does not necessarily paint the whole picture and it is important to consider how these different components work together.</p>
<p>Before continuing to show what the \( \mathbf{A}_{\text{rot}} \) matrix does when applied to a square, it is worth considering two somewhat related matrices where the identity matrix is modified with only the \( \sin(\theta) \) or \( \cos(\theta) \) components.</p>
<table><thead><tr><th>Description</th><th>Transform</th></tr></thead><tbody>
<tr><td>Just sines</td><td><div style="text-align:center"> <video style="width:100%" controls loop> <source src="res/sines_white.mp4" type="video/mp4"> Your browser does not support the video tag. </video> </div></td></tr>
<tr><td>Just cosines</td><td><div style="text-align:center"> <video style="width:100%" controls loop> <source src="res/cosines_white.mp4" type="video/mp4"> Your browser does not support the video tag. </video> </div></td></tr>
</tbody></table>
<p>Here, we see two completely different behaviors:</p>
<ol>
<li>In the sine-only case, we see that as \( \theta \) wraps around from \( 0 \rightarrow 2\pi \), the square seems to grow and rotate like expected, but at \( \pi/2 \), it somewhat abruptly decides to move in the other direction.</li>
<li>In cosine-only case, we see the square flip around entirely at \( \pi/2 \).</li>
</ol>
<p>Before watching the next video, it is important to think for a little bit about how these two different interactions will work together in practice.
When you are ready, go ahead and click the play button:</p>
<div style="text-align:center">
<video style="width:100%" controls loop>
  <source src="res/rotation_square_white.mp4" type="video/mp4">
Your browser does not support the video tag.
</video>
</div>
<p>At least for me, it took some thinking to figure out why the two animations above create rotation when put together.
When thinking about it, it makes sense that at \( \pi/2 \), the sine component will start to encourage the square to slowly oscillate back towards the original position, but will be tugged in the opposite direction by the cosine component that has turned negative at the same time.
This &quot;coincidence&quot; is what creates a rotational effect.</p>
<p>Overall, the rotation matrix is a fun and interesting application to linear transformations that really helped me understand how the entire class of operations can be used to create more complicated movements.</p>
<h3 id="guarantees-of-affine-transformations"><a class="header" href="#guarantees-of-affine-transformations">Guarantees of affine transformations</a></h3>
<p>At this stage, we have discussed what affine transforms are from a functional perspective; however, (as always) there is a lot more to discuss.
This particular chapter is meant to provide an intuitive feel for the transformations for those who might need to use them for whatever application they need, so I am hesitant to dive too deeply into more rigorous definitions; however, it is important to talk about certain properties of affine transforms that make them suitable for a wide variety of applications.
Namely, affine transformations preserve the following:</p>
<ol>
<li><strong>collinearity between points</strong>. This means that any points that are on the same line before an affine transform must be on that same line after the transformation. The line can still change in slope or position.</li>
<li><strong>parallelism between lines</strong>. Any lines parallel before the transform must also be parallel after.</li>
<li><strong>ratios of the lengths of parallel line segments</strong>. This means if you have two different line segments, one of which is parameterized by \( p_1 \) and \( p_2 \), while the other is parameterized by \( p_3 \) and \( p_4 \), then \( \frac{\vec{p_1 p_2}}{\vec{p_3 p_4}} \) must be the same before and after transformation.</li>
<li><strong>convexity of any transformed shape</strong>. If a shape does not have any concave component (a point that points in towards its center), then it cannot have a concave component after the transformation.</li>
<li><strong>barycenters of the collection of points</strong>. The barycenter is the collective center of mass of the system, like the balancing point for a plate. Essentially, there is an equal amount of &quot;stuff&quot; on either side of the barycenter. This location must remain at the same location relative to each point after transformation.</li>
</ol>
<p>Again, there is a lot more we could talk about, but I feel we will leave more rigorous discussions for later if we need them for subsequent algorithms.
Instead, I believe it is useful to move on to a relatively common implementation of affine transformations: the augmented matrix formalism.</p>
<h2 id="augmented-matrix-implementation"><a class="header" href="#augmented-matrix-implementation">Augmented matrix implementation</a></h2>
<p>As stated before, affine transformations are basically a mix of a transformation matrix and translation.
For two-dimensional input vectors, the augmented matrix formalism combines both of these into a large \( 3 \times 3 \) transformation matrix.
If you are like me, this might be a bit confusing.
After all, if the two-dimensional vector is described by a \( 1 \times 2 \) array, then how do you do a matrix multiplication with a \( 3 \times 3 \) array?</p>
<p>To be honest, the answer <em>feels</em> like a bit of a hack: we simply append a 1 to the end of the input, output, and translation vectors, such that:</p>
<h1>\[
\begin{bmatrix}
\mathbf{v} \\
1 \\
\end{bmatrix}</h1>
<p>\left[\begin{array}{@{}ccc|c@{}}
&amp; \mathbf{A} &amp;  &amp; \ell \\
0 &amp; \cdots &amp; 0 &amp; 1 \\
\end{array}\right]
\begin{bmatrix}
\mathbf{v}_0 \\
1
\end{bmatrix}
\]</p>
<p>So, using </p>
<p>\[
\begin{align}
\mathbf{v}_0 &amp;= \begin{bmatrix}
1 \\ 
2 \\
\end{bmatrix} \\
\mathbf{A} &amp;= \begin{bmatrix}
0 &amp; -1 \\
1 &amp; 0 \\
\end{bmatrix} \\
\ell &amp;= \begin{bmatrix}
0 \\ 
0 \\
\end{bmatrix}
\end{align},
\]</p>
<p>we would perform the following computation:</p>
<h1>\[
\begin{bmatrix}
\mathbf{v} \\
1 \\
\end{bmatrix}</h1>
<p>\left[\begin{array}{@{}cc|c@{}}
0 &amp; -1 &amp; 0 \\
1 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 1 \\
\end{array}\right]
\begin{bmatrix}
1 \\
2 \\
1
\end{bmatrix}
\]</p>
<p>Doing this, we find that \( \mathbf{v} = [-2,1] \), just as we found in the previous example.
Ok, now we need to talk about why this works.</p>
<p>Appending the 1 to the end of the two-dimensional vectors essentially turn them into three-dimensional vectors, with the \( z \) dimension simply set to be 1.
The easiest way to visualize this is by thinking of the top plane on a larger cube, so here are the same vector operations as before on that cube:</p>
<table><thead><tr><th>Description</th><th>Transform</th></tr></thead><tbody>
<tr><td>Scaling along \( x \)</td><td><div style="text-align:center"> <video style="width:100%" controls loop> <source src="res/a11_cube_white.mp4" type="video/mp4"> Your browser does not support the video tag. </video> </div></td></tr>
<tr><td>Scaling along \( y \)</td><td><div style="text-align:center"> <video style="width:100%" controls loop> <source src="res/a22_cube_white.mp4" type="video/mp4"> Your browser does not support the video tag. </video> </div></td></tr>
<tr><td>Shearing along \( x \)</td><td><div style="text-align:center"> <video style="width:100%" controls loop> <source src="res/a12_cube_white.mp4" type="video/mp4"> Your browser does not support the video tag. </video> </div></td></tr>
<tr><td>Shearing along \( y \)</td><td><div style="text-align:center"> <video style="width:100%" controls loop> <source src="res/a21_cube_white.mp4" type="video/mp4"> Your browser does not support the video tag. </video> </div></td></tr>
<tr><td>Translation along \( x \)</td><td><div style="text-align:center"> <video style="width:100%" controls loop> <source src="res/a13_cube_white.mp4" type="video/mp4"> Your browser does not support the video tag. </video> </div></td></tr>
<tr><td>Translation along \( y \)</td><td><div style="text-align:center"> <video style="width:100%" controls loop> <source src="res/a23_cube_white.mp4" type="video/mp4"> Your browser does not support the video tag. </video> </div></td></tr>
</tbody></table>
<p>The shear and scaling operations seem about the same as before; however, the translation operations are now clearly a shear along the entire cube!
The only reason this acts as translation for two dimensions is because we only care about the slice through the cube at \( z=1 \).</p>
<p>Now, the reason I always feel this implementation is a bit hacky is because there is a little magic that everyone keeps quiet about: the last row in the matrix.
With all of the operations shown above, it was simply set to \( [0,0,1] \) and never touched again...
But that is terribly unsatisfying!</p>
<p>What would happen if we actually moved those dials and modified the bottom row?
Well...</p>
<table><thead><tr><th>Description</th><th>Transform</th></tr></thead><tbody>
<tr><td>Shearing along \( z \) and \( x \)</td><td><div style="text-align:center"> <video style="width:100%" controls loop> <source src="res/a31_cube_white.mp4" type="video/mp4"> Your browser does not support the video tag. </video> </div></td></tr>
<tr><td>Shearing along \( z \) and \( y \)</td><td><div style="text-align:center"> <video style="width:100%" controls loop> <source src="res/a32_cube_white.mp4" type="video/mp4"> Your browser does not support the video tag. </video> </div></td></tr>
<tr><td>Scaling along \( z \)</td><td><div style="text-align:center"> <video style="width:100%" controls loop> <source src="res/a33_cube_white.mp4" type="video/mp4"> Your browser does not support the video tag. </video> </div></td></tr>
</tbody></table>
<p>In this case, the first two components are shearing along \( z \) and \( x \) and \( z \) and \( y \), while the last component is a scale along \( z \).
If someone was taking a picture from above, none of these transformations would be visible.
Because we are hyper-focused on the top-down view for affine transformations, none of these operations are technically affine; however, they are still linear, and it is still nice to show all possible linear transforms for the cube as well.</p>
<p>Finally, let us go back to the rotation example:</p>
<div style="text-align:center">
<video style="width:100%" controls loop>
  <source src="res/rotation_cube_white.mp4" type="video/mp4">
Your browser does not support the video tag.
</video>
</div>
<p>Here, we see that we can embed just about any affine transformation into three dimensional space and still see the same results as in the two dimensional case.
I think that is a nice note to end on: affine transformations are linear transformations in an \( n+1 \) dimensional space.</p>
<h2 id="video-explanation-3"><a class="header" href="#video-explanation-3">Video Explanation</a></h2>
<p>Here is a video describing affine transformations:</p>
<div style="text-align:center">
<iframe width="560" height="315" src="https://www.youtube.com/embed/E3Phj6J287o" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
</div>
<h2 id="license-10"><a class="header" href="#license-10">License</a></h2>
<h5 id="code-examples-10"><a class="header" href="#code-examples-10">Code Examples</a></h5>
<p>The code examples are licensed under the MIT license (found in <a href="https://github.com/algorithm-archivists/algorithm-archive/blob/master/LICENSE.md">LICENSE.md</a>).</p>
<h5 id="text-10"><a class="header" href="#text-10">Text</a></h5>
<p>The text of this chapter was written by <a href="https://github.com/leios">James Schloss</a> and is licensed under the <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</p>
<p><a href="https://creativecommons.org/licenses/by-sa/4.0/"><p><img  class="center" src="affine_transformations/../cc/CC-BY-SA_icon.svg" /></p></a></p>
<h5 id="imagesgraphics-5"><a class="header" href="#imagesgraphics-5">Images/Graphics</a></h5>
<ul>
<li>The video &quot;<a href="affine_transformations/res/a11_square_white.mp4">A11 square</a>&quot; was created by <a href="https://github.com/leios">James Schloss</a> and is licensed under the <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</li>
<li>The video &quot;<a href="affine_transformations/res/a22_square_white.mp4">A22 square</a>&quot; was created by <a href="https://github.com/leios">James Schloss</a> and is licensed under the <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</li>
<li>The video &quot;<a href="affine_transformations/res/a12_square_white.mp4">A12 square</a>&quot; was created by <a href="https://github.com/leios">James Schloss</a> and is licensed under the <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</li>
<li>The video &quot;<a href="affine_transformations/res/a21_square_white.mp4">A21 square</a>&quot; was created by <a href="https://github.com/leios">James Schloss</a> and is licensed under the <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</li>
<li>The video &quot;<a href="affine_transformations/res/a13_square_white.mp4">A13 square</a>&quot; was created by <a href="https://github.com/leios">James Schloss</a> and is licensed under the <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</li>
<li>The video &quot;<a href="affine_transformations/res/a23_square_white.mp4">A23 square</a>&quot; was created by <a href="https://github.com/leios">James Schloss</a> and is licensed under the <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</li>
<li>The video &quot;<a href="affine_transformations/res/semi_rotate_white.mp4">Semi Rotate</a>&quot; was created by <a href="https://github.com/leios">James Schloss</a> and is licensed under the <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</li>
<li>The video &quot;<a href="affine_transformations/res/sines_white.mp4">Sines</a>&quot; was created by <a href="https://github.com/leios">James Schloss</a> and is licensed under the <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</li>
<li>The video &quot;<a href="affine_transformations/res/cosines_white.mp4">Cosines</a>&quot; was created by <a href="https://github.com/leios">James Schloss</a> and is licensed under the <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</li>
<li>The video &quot;<a href="affine_transformations/res/rotation_square_white.mp4">Rotate Square</a>&quot; was created by <a href="https://github.com/leios">James Schloss</a> and is licensed under the <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</li>
<li>The video &quot;<a href="affine_transformations/res/a11_cube_white.mp4">A11 cube</a>&quot; was created by <a href="https://github.com/leios">James Schloss</a> and is licensed under the <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</li>
<li>The video &quot;<a href="affine_transformations/res/a22_cube_white.mp4">A22 cube</a>&quot; was created by <a href="https://github.com/leios">James Schloss</a> and is licensed under the <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</li>
<li>The video &quot;<a href="affine_transformations/res/a12_cube_white.mp4">A12 cube</a>&quot; was created by <a href="https://github.com/leios">James Schloss</a> and is licensed under the <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</li>
<li>The video &quot;<a href="affine_transformations/res/a21_cube_white.mp4">A21 cube</a>&quot; was created by <a href="https://github.com/leios">James Schloss</a> and is licensed under the <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</li>
<li>The video &quot;<a href="affine_transformations/res/a13_cube_white.mp4">A13 cube</a>&quot; was created by <a href="https://github.com/leios">James Schloss</a> and is licensed under the <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</li>
<li>The video &quot;<a href="affine_transformations/res/a23_cube_white.mp4">A23 cube</a>&quot; was created by <a href="https://github.com/leios">James Schloss</a> and is licensed under the <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</li>
<li>The video &quot;<a href="affine_transformations/res/a31_cube_white.mp4">A31 cube</a>&quot; was created by <a href="https://github.com/leios">James Schloss</a> and is licensed under the <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</li>
<li>The video &quot;<a href="affine_transformations/res/a32_cube_white.mp4">A32 cube</a>&quot; was created by <a href="https://github.com/leios">James Schloss</a> and is licensed under the <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</li>
<li>The video &quot;<a href="affine_transformations/res/a33_cube_white.mp4">A33 cube</a>&quot; was created by <a href="https://github.com/leios">James Schloss</a> and is licensed under the <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</li>
<li>The video &quot;<a href="affine_transformations/res/rotation_cube_white.mp4">Rotation cube</a>&quot; was created by <a href="https://github.com/leios">James Schloss</a> and is licensed under the <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bit-logic"><a class="header" href="#bit-logic">Bit Logic</a></h1>
<p>We write code in a language that makes a little sense to us, but does not make sense at all to our computer without a compiler to transform the code we write into a language the computer can understand.
In the end, whenever we write code, all of the data structures we write are transformed into binary strings of 1's and 0's to be interpreted by our computer.
That said, it's not always obvious how this happens, so let's start the simple case of integer numbers.</p>
<h2 id="integers"><a class="header" href="#integers">Integers</a></h2>
<p>For integer numbers, 0 is still 0 and 1 is still 1; however, for 2, we need to use 2 digits because binary only has 0's and 1's. When we get to 4, we'll need 3 digits and when we get to 8, we'll need 4. Every time we cross a power of 2, we'll need to add a new digit. Here's a table of the first 10 integers in binary:</p>
<table><thead><tr><th>Integer Number</th><th>Binary Number</th></tr></thead><tbody>
<tr><td>0</td><td><code>0000</code></td></tr>
<tr><td>1</td><td><code>0001</code></td></tr>
<tr><td>2</td><td><code>0010</code></td></tr>
<tr><td>3</td><td><code>0011</code></td></tr>
<tr><td>4</td><td><code>0100</code></td></tr>
<tr><td>5</td><td><code>0101</code></td></tr>
<tr><td>6</td><td><code>0110</code></td></tr>
<tr><td>7</td><td><code>0111</code></td></tr>
<tr><td>8</td><td><code>1000</code></td></tr>
<tr><td>9</td><td><code>1001</code></td></tr>
</tbody></table>
<p>The easiest way to interpret a binary string is to imagine that each digit is a power of 2 and add them together. For example, take the number 13, with a bitstring 1101:</p>
<table><thead><tr><th>1</th><th>1</th><th>0</th><th>1</th></tr></thead><tbody>
<tr><td>\( 2^3 \)</td><td>\( 2^2 \)</td><td>\( 2^1 \)</td><td>\( 2^0 \)</td></tr>
<tr><td>8</td><td>4</td><td>2</td><td>1</td></tr>
</tbody></table>
<p>We have 1 \( 2^3 = 8 \), 1 \( 2^2 = 4 \), 0 \( 2^1 = 2 \) and 1 \( 2^0 = 1 \), adding together to 13.
Though this might seem straightforward, it is essential to understanding several operations that will be done on bits later.
For now, let's talk about the only trick to integer values: <em>negative numbers!</em></p>
<p>There are a few ways to represent negative numbers.
For example, if we are using 8 bits, we might use the first of the 8 bits to be a <strong>sign</strong> bit, whose only purpose is telling the computer whether the number is positive or negative.</p>
<p>Another method is to &quot;roll over&quot; to negative numbers when the bit count gets too high, for example:</p>
<table><thead><tr><th>Integer Number</th><th>Binary Number</th></tr></thead><tbody>
<tr><td>126</td><td><code>01111110</code></td></tr>
<tr><td>127</td><td><code>01111111</code></td></tr>
<tr><td>-128</td><td><code>10000000</code></td></tr>
<tr><td>-127</td><td><code>10000001</code></td></tr>
</tbody></table>
<p>Ultimately, integer numbers are not that difficult to deal with in binary, so let's move onto something more complicated: <em>floating-point numbers!</em></p>
<h2 id="floating-point-numbers"><a class="header" href="#floating-point-numbers">Floating-point Numbers</a></h2>
<p>Floats are numbers with a decimal point.
9.125 is a float. 9.000 is a float. 9 is an integer.
Here are a few floats and their integer representations:</p>
<table><thead><tr><th>Floating-point Number</th><th>Binary Number</th></tr></thead><tbody>
<tr><td>9.125</td><td><code>1001.001</code></td></tr>
<tr><td>10.25</td><td><code>1010.01</code></td></tr>
<tr><td>1.00</td><td><code>1</code></td></tr>
</tbody></table>
<p>The idea is similar to before: Each digit represents a power of 2; however, this time any digit after the decimal point counts negative.
So for 9.125, we have 1 \( 2^3 = 8 \), 1 \( 2^0 = 1 \), and 1 \( 2^{-3} = \frac{1}{8} \).</p>
<p>Now, how is this actually implemented on your computer?
Well, one way is with the IEEE 754 Floating-point Arithmetic Standard.
For 32 bits, the first bit is the <em>sign bit</em>, the next 8 bits tell us about the number's exponent, and the next 23 are called the <em>mantissa</em> and hold the binary string, itself. Now, there are a few points to keep in mind:</p>
<ol>
<li>
<p>Because the exponent is being represented in 8 bits, we only have 256 values to play with. This means that the largest exponent we can represent (in single precision) is 128 and the smallest is -127. For this reason, we will add 127 to the power of every floating-point number. So, \( 1 = 1 \times 2^{0} \). The exponent stored is \( 0+127 = 127 \).</p>
</li>
<li>
<p>We normalize every bitstring to the first 1 available. For example: \( 9.125 = 1.001001 \times 2^{3} \) and the biased exponent is \( 3+127=130 \), \( 8.25 = 1.00001 \times 2^{130} \), \( 0.5 = 1 \times 2^{126} \) \( \ldots \) This means that <em>there will always be a leading 1 in our bitstring</em>. This means that the first 1 is redundant and can be removed from the mantissa.</p>
</li>
</ol>
<p>So here are a few floating-point numbers and their corresponding bitstrings:</p>
<table><thead><tr><th>Float</th><th>Sign</th><th>Exponent</th><th>Mantissa</th></tr></thead><tbody>
<tr><td>9.125</td><td><code>0</code></td><td><code>10000010</code></td><td><code>00100100000000000000000</code></td></tr>
<tr><td>- 5.25</td><td><code>1</code></td><td><code>10000001</code></td><td><code>01010000000000000000000</code></td></tr>
<tr><td>- 4096.625</td><td><code>1</code></td><td><code>10001011</code></td><td><code>00000000000010100000000</code></td></tr>
</tbody></table>
<p>Now that we know how to represent integers and floating-point numbers, let's move on to operations, starting with <em>bitshift operators</em></p>
<h4 id="bitshift-operators-"><a class="header" href="#bitshift-operators-">Bitshift Operators: &lt;&lt;,&gt;&gt;</a></h4>
<p>Bitshift operators do what their name implies: they shift a string of bits one digit to the left (&lt;&lt;) or right (&gt;&gt;).
This has the somewhat profound effect of multiplying or dividing the value by 2, which makes sense when you consider that each digit represents a power of 2.
Because of the somewhat complicated nature of floating-point numbers, bitshift operators usually only work on integer numbers, like so:</p>
<table><thead><tr><th>Operation</th><th>Integer</th><th>Bitstring</th></tr></thead><tbody>
<tr><td>None</td><td>10</td><td><code>00001010</code></td></tr>
<tr><td>Bitshift left, &lt;&lt;</td><td>20</td><td><code>00010100</code></td></tr>
<tr><td>Bitshift right, &gt;&gt;</td><td>5</td><td><code>00000101</code></td></tr>
</tbody></table>
<p>There are more complicated things that can be done with the bitshift operators; however, we'll leave that discussion for another day!</p>
<h4 id="logic-gates"><a class="header" href="#logic-gates">Logic gates</a></h4>
<p>In addition to the bitshift operations, there are a number of logical operations that can be performed on one or two bits together.
These operations are called <em>gates</em>, and follow somewhat straightforward logic.
The <em>AND</em> gate, for example, reads in 2 bits and will only output a 1 value if both inputs are 1. This can be seen in the corresponding truth table:</p>
<p>
    <img  class="center" src="bitlogic/res/and.jpg" style="width:50%" />
</p>
<p>The <em>OR</em> gate will output 1 if either input bits are 1:</p>
<p>
    <img  class="center" src="bitlogic/res/or.jpg" style="width:50%" />
</p>
<p>The <em>exclusive OR</em> or <em>XOR</em> gate is the same as the <em>OR</em> gate, but will not output 1 if both bits are 1:</p>
<p>
    <img  class="center" src="bitlogic/res/xor.jpg" style="width:50%" />
</p>
<p>The <em>NOT</em> gate simply flips the input bit:</p>
<p>
    <img  class="center" src="bitlogic/res/not.jpg" style="width:50%" />
</p>
<p>By combining the NOT and AND gates, we get the <em>NAND</em> gate:</p>
<p>
    <img  class="center" src="bitlogic/res/nand.jpg" style="width:50%" />
</p>
<p>And NOT and OR create <em>NOR</em>:</p>
<p>
    <img  class="center" src="bitlogic/res/nor.jpg" style="width:50%" />
</p>
<p>There are a few other gates, but this is enough for most things. We'll add more as the need arises!</p>
<p>That's about it for bitlogic. I realize it was a bit long, but this is absolutely essential to understanding how computers think and how to use programming as an effective tool!</p>
<h2 id="video-explanation-4"><a class="header" href="#video-explanation-4">Video Explanation</a></h2>
<p>Here is a video describing the contents of this chapter:</p>
<div style="text-align:center">
<iframe width="560" height="315" src="https://www.youtube.com/embed/zMuEk44Ufkw" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
</div>
<h2 id="license-11"><a class="header" href="#license-11">License</a></h2>
<h5 id="code-examples-11"><a class="header" href="#code-examples-11">Code Examples</a></h5>
<p>The code examples are licensed under the MIT license (found in <a href="https://github.com/algorithm-archivists/algorithm-archive/blob/master/LICENSE.md">LICENSE.md</a>).</p>
<h5 id="text-11"><a class="header" href="#text-11">Text</a></h5>
<p>The text of this chapter was written by <a href="https://github.com/leios">James Schloss</a> and is licensed under the <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</p>
<p><a href="https://creativecommons.org/licenses/by-sa/4.0/"><p><img  class="center" src="bitlogic/../cc/CC-BY-SA_icon.svg" /></p></a></p>
<h5 id="imagesgraphics-6"><a class="header" href="#imagesgraphics-6">Images/Graphics</a></h5>
<ul>
<li>The image &quot;<a href="bitlogic/res/and.jpg">ANDgate</a>&quot; was created by <a href="https://github.com/leios">James Schloss</a> and is licensed under the <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</li>
<li>The image &quot;<a href="bitlogic/res/or.jpg">ORgate</a>&quot; was created by <a href="https://github.com/leios">James Schloss</a> and is licensed under the <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</li>
<li>The image &quot;<a href="bitlogic/res/xor.jpg">XORgate</a>&quot; was created by <a href="https://github.com/leios">James Schloss</a> and is licensed under the <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</li>
<li>The image &quot;<a href="bitlogic/res/not.jpg">NOTgate</a>&quot; was created by <a href="https://github.com/leios">James Schloss</a> and is licensed under the <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</li>
<li>The image &quot;<a href="bitlogic/res/nand.jpg">NANDgate</a>&quot; was created by <a href="https://github.com/leios">James Schloss</a> and is licensed under the <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</li>
<li>The image &quot;<a href="bitlogic/res/nor.jpg">NORgate</a>&quot; was created by <a href="https://github.com/leios">James Schloss</a> and is licensed under the <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</li>
</ul>
<h5 id="pull-requests-8"><a class="header" href="#pull-requests-8">Pull Requests</a></h5>
<p>After initial licensing (<a href="https://github.com/algorithm-archivists/algorithm-archive/pull/560">#560</a>), the following pull requests have modified the text or graphics of this chapter:</p>
<ul>
<li>none</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><p>NOTE: Incomplete!</p>
<h1 id="taylor-series-expansion"><a class="header" href="#taylor-series-expansion">Taylor Series Expansion</a></h1>
<p>I have been formally trained as a physicist. In my mind, there are several mathematical topics that blur the boundary between mathematics and physics. Taylor Series Expansions are one of those topics.</p>
<p>On the one hand, I can see how the expansion could be considered purely mathematical. I mean, here is the definition:
\[ f(x) \simeq \sum_{n=0}^{\infty} \frac{f^{(n)}(a)}{n!}(x-a)^n \]</p>
<p>where \( f(x) \) is some function along real or complex space, \( a \) is the point that we are expanding from, and \( f^{(n)}(x) \) denotes the \( n^{\text{th}} \) derivative of \( f(x) \).
From this perspective, the expansion just looks like a bunch of derivatives strung together! Where's the physics? Well, let's expand this series for the first few derivatives:</p>
<p>\[
f(x) \simeq f(a) + \frac{df(a)}{dx}(x-a)
+ \frac{1}{2}\frac{d^2f(a)}{dx^2}(x-a)^2
\]</p>
<p>If we substitute the derivatives for their physical quantities with \( f(x) \rightarrow x(t) \), expanding from 0, and set</p>
<p>\[
\begin{align}
\frac{dx(t)}{dt} &amp;= \text{velocity} = v(t) \\
\frac{d^2x(t)}{dt^2} &amp;= \text{acceleration} = a \\
\end{align}
\]</p>
<p>The Taylor series expansion turns into one of the most common formulas in classical physics, the <em>kinematic equation</em>!</p>
<p>\[
x(t) \simeq x_0 + v_0t
+ \frac{1}{2}at^2
\]</p>
<p>Note that here, we assume the acceleration to be constant, but it could technically have higher order terms.</p>
<p>Truth be told, the Taylor Series Expansion can be found in the most unusual places and is used as the foundation of many different algorithms throughout this book. At first, it might not seem obvious why, but we can approximate almost any smooth function with a Taylor Series Expansion, and the more terms we include, the better our approximation becomes! For example, take Figure 1. Any function can be approximated as a sum of all the derivatives for that function. If we evaluate these derivatives at any point, we closely approximate the actual function.</p>
<p>
    <img  class="center" src="taylor_series_expansion/res/function_sum.png" />
</p>
<p>This shows the true power of the Taylor Series Expansion. It allows us to more easily tackle complicated functions by approximating them as functions we can actually use and imagine!</p>
<h2 id="license-12"><a class="header" href="#license-12">License</a></h2>
<h5 id="code-examples-12"><a class="header" href="#code-examples-12">Code Examples</a></h5>
<p>The code examples are licensed under the MIT license (found in <a href="https://github.com/algorithm-archivists/algorithm-archive/blob/master/LICENSE.md">LICENSE.md</a>).</p>
<h5 id="text-12"><a class="header" href="#text-12">Text</a></h5>
<p>The text of this chapter was written by <a href="https://github.com/leios">James Schloss</a> and is licensed under the <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</p>
<p><a href="https://creativecommons.org/licenses/by-sa/4.0/"><p><img  class="center" src="taylor_series_expansion/../cc/CC-BY-SA_icon.svg" /></p></a></p>
<h5 id="imagesgraphics-7"><a class="header" href="#imagesgraphics-7">Images/Graphics</a></h5>
<ul>
<li>The image &quot;<a href="taylor_series_expansion/res/function_sum.png">Taylor Approximation</a>&quot; was created by <a href="https://github.com/leios">James Schloss</a> and is licensed under the <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</li>
</ul>
<h5 id="pull-requests-9"><a class="header" href="#pull-requests-9">Pull Requests</a></h5>
<p>After initial licensing (<a href="https://github.com/algorithm-archivists/algorithm-archive/pull/560">#560</a>), the following pull requests have modified the text or graphics of this chapter:</p>
<ul>
<li>none</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="convolutions"><a class="header" href="#convolutions">Convolutions</a></h1>
<p>To put it bluntly, convolutions can be confusing.
Some might even call them <em>convoluted</em>!
(Get it? Because we are talking about <em>convolutions</em>? A wise man once told me that all good jokes need additional clarification.)</p>
<p>Not only are convolutions hard to describe, but if they are not used in practice, it is hard to understand why they would ever be needed.
I am going to do what I can to describe them in an intuitive way; however, I may need to come back to this in the future.
Let me know if there is anything here that is unclear, and I will do what I can to clear it up.</p>
<p>As always, we should start at the start.
If you take two functions \( f \) and \( g \), there are a number of ways you can combine them.
All basic operations can do this (addition, subtraction, multiplication, and division), but there are also special operations that only work with functions and do not work on standard variables or numbers.
For example, \( f \circ g \) is a <em>composition</em> of the two functions, where you plug \( g(x) \) into \( f \).
A convolution is another function-related operation, and is often notated with a star \( (*) \) operator, where</p>
<p>\[ f*g=c \]</p>
<p>provides a third function, \( c \), that is a blended version of \( f \) and \( g \).
As a rather important side-note: there is an incredibly similar operation known as a <em>correlation</em> which will be discussed in the near future.
Now we are left with a rather vague question: how do we <em>blend</em> functions?</p>
<p>To answer this question, we will need to show off a few simple graphics and animations in the <a href="convolutions/1d/1d.html">Convolutions in 1D</a> section while also discussing the mathematical definition of convolutions.
After, there will be a brief discussion on an interesting application of one dimensional convolutions in integer multiplication in the <a href="convolutions/multiplication/multiplication.html">Multiplication as a Convolution</a> section.
We will then move on to the most stereotypical application of convolutions in the <a href="convolutions/2d/2d.html">Convolutions of Images</a> section, where we will also discuss two important filters: the Gaussian kernel and the Sobel operator.
As a note: convolutions can be extended to \( n \)-dimensions, but after seeing how they are extended to two dimensions, it should be possible for the reader to extend it to three dimensions and beyond if that is needed, so we will not cover that in great detail here unless is is useful for another algorithm.
In addition, we will be touching on a rather difficult but powerful topic with the <a href="convolutions/convolutional_theorem/convolutional_theorem.html">Convolutional Theorem</a> section where convolutions can be computed by using <a href="convolutions/../Cooley_tukey/cooley_tukey.html">Fourier transforms</a>.</p>
<h2 id="license-13"><a class="header" href="#license-13">License</a></h2>
<h5 id="text-13"><a class="header" href="#text-13">Text</a></h5>
<p>The text of this chapter was written by <a href="https://github.com/leios">James Schloss</a> and is licensed under the <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</p>
<p><a href="https://creativecommons.org/licenses/by-sa/4.0/"><p><img  class="center" src="convolutions/../cc/CC-BY-SA_icon.svg" /></p></a></p>
<h5 id="pull-requests-10"><a class="header" href="#pull-requests-10">Pull Requests</a></h5>
<p>After initial licensing (<a href="https://github.com/algorithm-archivists/algorithm-archive/pull/560">#560</a>), the following pull requests have modified the text or graphics of this chapter:</p>
<ul>
<li>none</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="convolutions-in-1d"><a class="header" href="#convolutions-in-1d">Convolutions in 1D</a></h1>
<p>As mentioned in the <a href="convolutions/1d/../convolutions.html">introductory section for convolutions</a>, convolutions allow mathematicians to &quot;blend&quot; two seemingly unrelated functions; however, this definition is not very rigorous, so it might be better to think of a convolution as a method to apply a filter to a signal or image.
This, of course, brings up more questions: what is a filter? What is a signal? How is this all related to images?</p>
<p>For this, we will start with some predefined signal.
It does not matter too much what it is, so we will pick a square wave where everything is set to zero except for a few elements at the center, which will be set to one.
This signal can be treated as an array, or a black and white, one-dimensional image where everything is black except for a white strip at the center.
We will also introduce a filter, which will be a simple triangle wave that goes to 1.
Both of these are shown below:</p>
<p float="center">
    <img src="convolutions/1d/../res/square_wave.png" style="width:49%">
    <img src="convolutions/1d/../res/triangle_wave.png" style="width:49%">
</p>
<p>So now we have a signal and a filter.
How do we apply the filter to the signal?
The easiest way to do this is to iterate through every point in the signal and blend it with neighboring elements, where each neighboring element is weighted based on the filter value.
So in the case where the triangle wave is only 3 elements (<code>[0.5, 1, 0.5]</code>), the output at each point would be</p>
<p>\[ C_n = \frac{A_{n-1}}{2} + A_{n} + \frac{A_{n+1}}{2}, \]</p>
<p>where \( C \) is the output value, \( A \) is the input array (a signal or image), and \( n \) is an iterable element through that signal.
In this way, the &quot;application of a filter,&quot; is simply a multiplication of the triangle wave centered around each point of the input array, followed by in integral or sum of the output.
In some sense, this means we will shift the filter, then multiply and sum every step.
This can be seen in the following animation:</p>
<div style="text-align:center">
<video style="width:90%" controls loop>
  <source src="../res/triangle_square_conv.mp4" type="video/mp4">
Your browser does not support the video tag.
</video>
</div>
<p>Here, the purple, dashed line is the output convolution \( C \), the vertical line is the iteration \( n \), the blue line is the original signal, the red line is the filter, and the green area is the signal multiplied by the filter at that location.
The convolution at each point is the integral (sum) of the green area for each point.</p>
<p>If we extend this concept into the entirety of discrete space, it might look like this:</p>
<p>\( (f*g)[n] = \sum_{m = -\infty}^{\infty}f[m]g[n-m] = \sum_{m = -\infty}^{\infty}f[n-m]g[m] \)</p>
<p>Where <code>f[n]</code> and <code>g[n]</code> are arrays of some form.
This means that the convolution can calculated by shifting either the filter along the signal or the signal along the filter.
This can be read as we said before: every step, we shift the filter, multiply, and sum.
There is, of course, a small caveat here.
Why are we subtracting \( m \)?
Certainly, if we wanted to &quot;shift the filter along the signal,&quot; we could also do so by <em>adding</em> \( m \) instead, but that is actually an entirely separate operation known as a <em>correlation</em>, which will be discussed at a later time.</p>
<p>The simplest interpretation for this equation is the same as the animation: we reverse the second array, and move it through the first array one step at a time, performing a simple element-wise multiplication and summation at each step.
With this in mind, we can almost directly transcribe the discrete equation into code like so:</p>
<pre><code class="language-julia">function convolve_linear(signal::Array{T, 1}, filter::Array{T, 1},
                         output_size) where {T &lt;: Number}

    # convolutional output
    out = Array{Float64,1}(undef, output_size)
    sum = 0

    for i = 1:output_size
        for j = max(1, i-length(filter)):i
            if j &lt;= length(signal) &amp;&amp; i-j+1 &lt;= length(filter)
                sum += signal[j] * filter[i-j+1]
            end
        end

        out[i] = sum
        sum = 0
    end

    return out
end
</code></pre>
<pre><code class="language-csharp">        static double[] ConvolveLinear(double[] signal, double[] filter, int outputSize)
        {
            // Convolutional output.
            var output = new double[outputSize];
            var sum = 0.0;

            for (var i = 0; i &lt; outputSize; i++)
            {
                for (var j = Math.Max(0, i - filter.Length); j &lt;= i; j++)
                {
                    if (j &lt; signal.Length &amp;&amp; (i - j) &lt; filter.Length)
                    {
                        sum += signal[j] * filter[i - j];
                    }
                }

                output[i] = sum;
                sum = 0.0;
            }

            return output;
        }
</code></pre>
<pre><code class="language-python">def convolve_linear(signal, filter_array, output_size):
    out = np.zeros(output_size)
    s = 0

    for i in range(output_size):
        for j in range(max(0, i - len(filter_array)), i + 1):
            if j &lt; len(signal) and (i - j) &lt; len(filter_array):
                s += signal[j] * filter_array[i - j]
        out[i] = s
        s = 0

    return out
</code></pre>
<p>The easiest way to reason about this code is to read it as you might read a textbook.
For each element in the output domain, we are summing a certain subsets of elements from <code>i-length(filter)</code> to <code>i</code> after multiplying it by the reversed filter (<code>filter[i-j]</code>).
In this way, it is precisely the same as the mathematical notation mentioned before.</p>
<p>In contrast to the animation, where the filter continuously reappears on the left edge of the screen, the code we have written for this part of the chapter requires the user to specify what they expect the output array length to be.
Determining what should happen at the edges of the convolution is a somewhat hotly debated topic and differs depending on what the user actually wants, so we will be discussing this in greater detail later in this chapter.</p>
<p>As an important note, if we were to extend the convolution into continuous space, we might write something like:</p>
<p>\( (f*g)(x) = \int_{-\infty}^{\infty}f(\xi)g(x-\xi)d\xi = \int_{-\infty}^{\infty}f(x-\xi)g(\xi)d\xi \)</p>
<p>Note that in this case, \( x \) and \( \xi \) are not necessarily spatial elements, but the interpretation is otherwise the same as before.</p>
<p>At this stage, the mathematics and code might still be a little opaque, so it is a good idea to play around a bit and think about how this operation might be used in practice with a few different filters.</p>
<h2 id="playing-with-filters"><a class="header" href="#playing-with-filters">Playing with filters</a></h2>
<p>Honestly, the best way to learn how convolutions work is by using them for a number of different signals and filters, so
let us extend the previous triangle filter a bit further by convolving a square wave with a relatively sharp Gaussian, which can be seen in the following animation:</p>
<div style="text-align:center">
<video style="width:90%" controls loop>
  <source src="../res/1d_gaussian.mp4" type="video/mp4">
Your browser does not support the video tag.
</video>
</div>
<p>In practice, the convolutional output here is very similar to the triangle wave we showed before.
The final convolved image looks a lot like the square, except that its boundaries have been smoothed out or &quot;blurred.&quot;
In practice whenever a Gaussian filter is used, it will always blur the other convolved signal, which is why a convolution with a Gaussian is also called a <em>blurring operation</em>.
This operation is used very often when dealing with two-dimensional images, and we will discuss common kernels found in the wild in <a href="convolutions/1d/../2d/2d.html">the next section</a>.
Still, it is interesting to see the blurring operation in action by convolving a random distribution with a larger Gaussian filter:</p>
<div style="text-align:center">
<video style="width:90%" controls loop>
  <source src="../res/1d_rand_gaussian_cyclic.mp4" type="video/mp4">
Your browser does not support the video tag.
</video>
</div>
<p>In this animation, the final convolution is so blurred that it does not seem related to the random input signal at all!
In fact, this animation seems to blend much more when compared to the previous Gaussian and the triangle wave animations.
This is because the Gaussian is wider than the previous to filters.
In general, the wider the filter, the stronger the blurring effect.</p>
<p>So what happens if we convolve a Gaussian with another Gaussian?
Well, that is shown below:</p>
<div style="text-align:center">
<video style="width:90%" controls loop>
  <source src="../res/double_gaussian.mp4" type="video/mp4">
Your browser does not support the video tag.
</video>
</div>
<p>As one might expect, the output is a blurrier Gaussian, which is essentially just wider.
If you were paying particularly close attention to the visualization, you might have noticed that the green area inside this visualization does not properly line up with the overlap of the two arrays.
Don't worry!
This is exactly what should happen!
Remember that the convolution requires a <em>multiplication</em> of the signal and filter, which was the same as the overlap when the signal was a square wave; however, in the case of two distinct signals, we should expect the multiplied output to look somewhat distinct.</p>
<p>Let us extend this concept to one final example of a square wave convolved with a triangular, sawtooth function that looks like this:</p>
<p>
  <img  class="center" src="convolutions/1d/../res/sawtooth.png" style="width:60%" />
</p>
<p>This is the first non-symmetric filter of this chapter, and its convolution would look like this:</p>
<div style="text-align:center">
<video style="width:90%" controls loop>
  <source src="../res/1d_sawtooth.mp4" type="video/mp4">
Your browser does not support the video tag.
</video>
</div>
<p>Non-symmetric filters are useful for testing convolutions to ensure that the output is correct, so it might be worthwhile to linger on this animation for a bit longer.
Notice how the convolution has an accelerating, positive slope when the reversed sawtooth function interacts with the square.
This makes sense as the smallest part of the triangle interacts first.
Similarly, there is a negatively accelerating slope when the sawtooth function leaves the square.</p>
<h2 id="dealing-with-boundaries"><a class="header" href="#dealing-with-boundaries">Dealing with boundaries</a></h2>
<p>In all of the animations, we have shown the filter constantly reappearing on the left edge of the screen, which is not always the best thing to do at the boundaries.
In fact, these boundary conditions are somewhat non-trivial to code, so for this section, we will start with relatively simple boundary conditions that were introduced in the previous code example.</p>
<h3 id="simple-boundaries"><a class="header" href="#simple-boundaries">Simple boundaries</a></h3>
<p>In general, if a user wants to see a full convolution between two signals, the output size must be the size of the two signals put together, otherwise, we cannot iterate through the entire convolutional output domain.
For example, here is random noise again convolved with a Gaussian function, but with non-periodic boundaries:</p>
<div style="text-align:center">
<video style="width:90%" controls>
  <source src="../res/1d_rand_gaussian_full.mp4" type="video/mp4">
Your browser does not support the video tag.
</video>
</div>
<p>This shows the full, unbounded convolution of the two signals, where
we clearly see a &quot;ramp up&quot; and &quot;ramp down&quot; phase at the start and end of the animation.
That said, there are many applications where the user actually needs to specify the output domain to be another length, such as the size of one of the input signals.</p>
<p>In this case, the simplest boundary would be to assume that whenever the filter hits the end of the image, it simply disappears.
Another way to think about this is that the signal only exists for the domain we specify it over, and is all 0s outside of this domain; therefore, the filter does not sum any signal from elements beyond its scope.
As an example, let's take the same example as before:</p>
<div style="text-align:center">
<video style="width:90%" controls>
  <source src="../res/1d_rand_gaussian_simple.mp4" type="video/mp4">
Your browser does not support the video tag.
</video>
</div>
<p>Similar to the case without boundary conditions, this convolution needs to &quot;ramp up,&quot; but it does not need to &quot;ramp down.&quot;
This is because the convolution output no longer extends past the bounds of the original signal so the bounded convolution is a subset of the full convolution.
More than that, the convolution does not go all the way to 0 on the right side.
This means that we are actually ignoring a rather important part of the convolution!</p>
<p>This is 100% true; however, if the signal is large and the filter is small (as is the case with most of image processing), we do not really care that much about the bits of the convolution we missed.
In addition, there is a way to center the convolution by modifying the location where the filter starts.
For example, we could have half of the filter already existing and overlapping with the signal for the very first computed point of the convolution.
For this reason, simple bounds are used frequently when performing convolutions on an image.</p>
<p>In the previous code snippet, we were able to perform both a bounded and unbounded convolution.
Here it is again for clarity:</p>
<pre><code class="language-julia">function convolve_linear(signal::Array{T, 1}, filter::Array{T, 1},
                         output_size) where {T &lt;: Number}

    # convolutional output
    out = Array{Float64,1}(undef, output_size)
    sum = 0

    for i = 1:output_size
        for j = max(1, i-length(filter)):i
            if j &lt;= length(signal) &amp;&amp; i-j+1 &lt;= length(filter)
                sum += signal[j] * filter[i-j+1]
            end
        end

        out[i] = sum
        sum = 0
    end

    return out
end
</code></pre>
<pre><code class="language-csharp">        static double[] ConvolveLinear(double[] signal, double[] filter, int outputSize)
        {
            // Convolutional output.
            var output = new double[outputSize];
            var sum = 0.0;

            for (var i = 0; i &lt; outputSize; i++)
            {
                for (var j = Math.Max(0, i - filter.Length); j &lt;= i; j++)
                {
                    if (j &lt; signal.Length &amp;&amp; (i - j) &lt; filter.Length)
                    {
                        sum += signal[j] * filter[i - j];
                    }
                }

                output[i] = sum;
                sum = 0.0;
            }

            return output;
        }
</code></pre>
<pre><code class="language-python">def convolve_linear(signal, filter_array, output_size):
    out = np.zeros(output_size)
    s = 0

    for i in range(output_size):
        for j in range(max(0, i - len(filter_array)), i + 1):
            if j &lt; len(signal) and (i - j) &lt; len(filter_array):
                s += signal[j] * filter_array[i - j]
        out[i] = s
        s = 0

    return out
</code></pre>
<p>Here, the main difference between the bounded and unbounded versions is that the output array size is smaller in the bounded case.
For an unbounded convolution, the function would be called with a the output array size specified to be the size of both signals put together:</p>
<pre><code class="language-julia">    # full convolution, output will be the size of x + y - 1
    full_linear_output = convolve_linear(x, y, length(x) + length(y) - 1)
</code></pre>
<pre><code class="language-csharp">            // Full convolution, output will be the size of x + y - 1.
            var fullLinearOutput = ConvolveLinear(x, y, x.Length + y.Length - 1);
</code></pre>
<pre><code class="language-python"># full convolution, output will be the size of x + y - 1
full_linear_output = convolve_linear(x, y, len(x) + len(y) - 1)
</code></pre>
<p>On the other hand, the bounded call would set the output array size to simply be the length of the signal</p>
<pre><code class="language-julia">    # simple boundaries
    simple_linear_output = convolve_linear(x, y, length(x))
</code></pre>
<pre><code class="language-csharp">            // Simple boundaries.
            var simpleLinearOutput = ConvolveLinear(x, y, x.Length);
</code></pre>
<pre><code class="language-python"># simple boundaries
simple_linear_output = convolve_linear(x, y, len(x))
</code></pre>
<p>Finally, as we mentioned before, it is possible to center bounded convolutions by changing the location where we calculate the each point along the filter.
This can be done by modifying the following line:</p>
<pre><code class="language-julia">        for j = max(1, i-length(filter)):i
</code></pre>
<pre><code class="language-csharp">                for (var j = Math.Max(0, i - filter.Length); j &lt;= i; j++)
</code></pre>
<pre><code class="language-python">        for j in range(max(0, i - len(filter_array)), i + 1):
</code></pre>
<p>Here, <code>j</code> counts from <code>i-length(filter)</code> to <code>i</code>.
To center the convolution, it would need to count from <code>i-(length(filter)/2)</code> to <code>i+(length(filter)/2)</code> instead.</p>
<p>I think this is a good place to stop discussions on simple boundary conditions.
Now let us talk a bit more in detail about the case where we want the filter to continuously reappear every loop.
This case is known as the &quot;periodic boundary condition&quot; and was used for the visualizations at the start of this chapter.</p>
<h3 id="periodic-boundary-conditions"><a class="header" href="#periodic-boundary-conditions">Periodic boundary conditions</a></h3>
<p>Though periodic boundary conditions are more complicated that those mentioned in the previous section, they are still <em>relatively</em> straightforward to implement.
With these conditions, the filter will wrap itself around to the other end of the signal whenever it hits a boundary.
In this way, the signal is periodic, with an identical copy of itself acting as left and right neighbors.
Those neighbors then have other neighbors, and those then have more neighbors, creating a sea of signals extending to infinity and beyond in both directions.
For us, this means that when the filter leaves one edge of the domain, it simply appears on the other, opposite edge.</p>
<p>This particular convolution is known as a <em>cyclic</em> convolution and is also the most common output of convolutions that work via the <a href="convolutions/1d/../convolutional_theorem/convolutional_theorem.html">convolutional theorem</a>, which will be discussed in another section.
For clarity: here is the same cyclic visualization we showed above with a random distribution and a Gaussian signal.</p>
<div style="text-align:center">
<video style="width:90%" controls loop>
  <source src="../res/1d_rand_gaussian_cyclic.mp4" type="video/mp4">
Your browser does not support the video tag.
</video>
</div>
<p>In code, this typically amounts to using some form of modulus operation, as shown here:</p>
<pre><code class="language-julia">function convolve_cyclic(signal::Array{T, 1},
                         filter::Array{T, 1}) where {T &lt;: Number}

    # output size will be the size of sign
    output_size = max(length(signal), length(filter))

    # convolutional output
    out = Array{Float64,1}(undef,output_size)
    sum = 0

    for i = 1:output_size
        for j = 1:output_size
            sum += get(signal, mod1(j, output_size), 0) * get(filter, mod1(i-j, output_size), 0)
        end

        out[i] = sum
        sum = 0

    end

    return out
end
</code></pre>
<pre><code class="language-csharp">        static double[] ConvolveCyclic(double[] signal, double[] filter)
        {
            var outputSize = Math.Max(signal.Length, filter.Length);

            // Convolutional output.
            var output = new double[outputSize];
            var sum = 0.0;

            for (var i = 0; i &lt; outputSize; i++)
            {
                for (var j = 0; j &lt; outputSize; j++)
                {
                    if (Mod(i - j, outputSize) &lt; filter.Length)
                    {
                        sum += signal[Mod(j - 1, outputSize)] * filter[Mod(i - j, outputSize)];
                    }
                }

                output[i] = sum;
                sum = 0.0;
            }

            return output;
        }
</code></pre>
<pre><code class="language-python">def convolve_cyclic(signal, filter_array):
    output_size = max(len(signal), len(filter_array))
    out = np.zeros(output_size)
    s = 0

    for i in range(output_size):
        for j in range(output_size):
            if(mod1(i - j, output_size) &lt; len(filter_array)):
                s += signal[mod1(j - 1, output_size)] * filter_array[mod1(i - j, output_size)]
        out[i] = s
        s = 0

    return out
</code></pre>
<p>This is essentially the same as before, except for the modulus operations, which allow us to work on a periodic domain.</p>
<p>As a final note before continuing: dealing with boundaries is tricky business and can dramatically change the behavior of the output convolution.
For this reason, it is important to think about what types of boundaries will work best for what you, the programmer, actually need.
The selection of boundary conditions will be a common trope for a large portion of computer graphics and physics algorithms where researchers often need to present and simulate data on an array of some sort.</p>
<h2 id="example-code-4"><a class="header" href="#example-code-4">Example Code</a></h2>
<p>For the code associated with this chapter, we have used the convolution to generate a few files for the full convolution, along with the periodic and simple boundary conditions discussed in this chapter.</p>
<pre><code class="language-julia">using DelimitedFiles
using LinearAlgebra

function convolve_cyclic(signal::Array{T, 1},
                         filter::Array{T, 1}) where {T &lt;: Number}

    # output size will be the size of sign
    output_size = max(length(signal), length(filter))

    # convolutional output
    out = Array{Float64,1}(undef,output_size)
    sum = 0

    for i = 1:output_size
        for j = 1:output_size
            sum += get(signal, mod1(j, output_size), 0) * get(filter, mod1(i-j, output_size), 0)
        end

        out[i] = sum
        sum = 0

    end

    return out
end

function convolve_linear(signal::Array{T, 1}, filter::Array{T, 1},
                         output_size) where {T &lt;: Number}

    # convolutional output
    out = Array{Float64,1}(undef, output_size)
    sum = 0

    for i = 1:output_size
        for j = max(1, i-length(filter)):i
            if j &lt;= length(signal) &amp;&amp; i-j+1 &lt;= length(filter)
                sum += signal[j] * filter[i-j+1]
            end
        end

        out[i] = sum
        sum = 0
    end

    return out
end

function main()

    # sawtooth functions for x and y
    x = [float(i)/200 for i = 1:200]
    y = [float(i)/200 for i = 1:200]

    # Normalization is not strictly necessary, but good practice
    normalize!(x)
    normalize!(y)

    # full convolution, output will be the size of x + y - 1
    full_linear_output = convolve_linear(x, y, length(x) + length(y) - 1)

    # simple boundaries
    simple_linear_output = convolve_linear(x, y, length(x))

    # cyclic convolution
    cyclic_output = convolve_cyclic(x, y)

    # outputting convolutions to different files for plotting in external code
    writedlm(&quot;full_linear.dat&quot;, full_linear_output)
    writedlm(&quot;simple_linear.dat&quot;, simple_linear_output)
    writedlm(&quot;cyclic.dat&quot;, cyclic_output)

end
</code></pre>
<pre><code class="language-csharp">using System;
using System.IO;

namespace Convolution1D
{
    public class Convolution1D
    {
        // Creates a sawtooth function with the given length.
        static double[] CreateSawtooth(int length)
        {
            var array = new double[length];
            for (var i = 0; i &lt; length; i++)
                array[i] = (i + 1) / 200f;
            return array;
        }

        // Normalizes the given array.
        static void Normalize(double[] array)
        {
            var norm = Norm(array);
            for (var i = 0; i &lt; array.Length; i++)
                array[i] /= norm;
        }

        // Calculates the norm of the array.
        static double Norm(double[] array)
        {
            var sum = 0.0;
            for (var i = 0; i &lt; array.Length; i++)
                sum += Math.Pow(array[i], 2);
            return Math.Sqrt(sum);
        }

        // Modulus function which handles negative values properly.
        // Assumes that y &gt;= 0.
        static int Mod(int x, int y) =&gt; ((x % y) + y) % y;

        static double[] ConvolveCyclic(double[] signal, double[] filter)
        {
            var outputSize = Math.Max(signal.Length, filter.Length);

            // Convolutional output.
            var output = new double[outputSize];
            var sum = 0.0;

            for (var i = 0; i &lt; outputSize; i++)
            {
                for (var j = 0; j &lt; outputSize; j++)
                {
                    if (Mod(i - j, outputSize) &lt; filter.Length)
                    {
                        sum += signal[Mod(j - 1, outputSize)] * filter[Mod(i - j, outputSize)];
                    }
                }

                output[i] = sum;
                sum = 0.0;
            }

            return output;
        }

        static double[] ConvolveLinear(double[] signal, double[] filter, int outputSize)
        {
            // Convolutional output.
            var output = new double[outputSize];
            var sum = 0.0;

            for (var i = 0; i &lt; outputSize; i++)
            {
                for (var j = Math.Max(0, i - filter.Length); j &lt;= i; j++)
                {
                    if (j &lt; signal.Length &amp;&amp; (i - j) &lt; filter.Length)
                    {
                        sum += signal[j] * filter[i - j];
                    }
                }

                output[i] = sum;
                sum = 0.0;
            }

            return output;
        }

        static void Main()
        {
            // Create sawtooth functions for x and y.
            var x = CreateSawtooth(200);
            var y = CreateSawtooth(200);

            // Normalization is not strictly necessary, but good practice.
            Normalize(x);
            Normalize(y);

            // Full convolution, output will be the size of x + y - 1.
            var fullLinearOutput = ConvolveLinear(x, y, x.Length + y.Length - 1);
            // Simple boundaries.
            var simpleLinearOutput = ConvolveLinear(x, y, x.Length);
            // Cyclic convolution.
            var cyclicOutput = ConvolveCyclic(x, y);

            // Output convolutions to different files for plotting.
            File.WriteAllText(&quot;full_linear.dat&quot;, String.Join(Environment.NewLine, fullLinearOutput));
            File.WriteAllText(&quot;simple_linear.dat&quot;, String.Join(Environment.NewLine, simpleLinearOutput));
            File.WriteAllText(&quot;cyclic.dat&quot;, String.Join(Environment.NewLine, cyclicOutput));
        }
    }
}

</code></pre>
<pre><code class="language-python">import numpy as np

def mod1(x, y): return ((x % y) + y) % y

def convolve_cyclic(signal, filter_array):
    output_size = max(len(signal), len(filter_array))
    out = np.zeros(output_size)
    s = 0

    for i in range(output_size):
        for j in range(output_size):
            if(mod1(i - j, output_size) &lt; len(filter_array)):
                s += signal[mod1(j - 1, output_size)] * filter_array[mod1(i - j, output_size)]
        out[i] = s
        s = 0

    return out


def convolve_linear(signal, filter_array, output_size):
    out = np.zeros(output_size)
    s = 0

    for i in range(output_size):
        for j in range(max(0, i - len(filter_array)), i + 1):
            if j &lt; len(signal) and (i - j) &lt; len(filter_array):
                s += signal[j] * filter_array[i - j]
        out[i] = s
        s = 0

    return out

# sawtooth functions for x and y
x = [float(i + 1)/200 for i in range(200)]
y = [float(i + 1)/200 for i in range(200)]

# Normalization is not strictly necessary, but good practice
x /= np.linalg.norm(x)
y /= np.linalg.norm(y)

# full convolution, output will be the size of x + y - 1
full_linear_output = convolve_linear(x, y, len(x) + len(y) - 1)

# simple boundaries
simple_linear_output = convolve_linear(x, y, len(x))

# cyclic convolution
cyclic_output = convolve_cyclic(x, y)

# outputting convolutions to different files for plotting in external code
np.savetxt('full_linear.dat', full_linear_output)
np.savetxt('simple_linear.dat', simple_linear_output)
np.savetxt('cyclic.dat', cyclic_output)
</code></pre>
<p>At a test case, we have chosen to use two sawtooth functions, which should produce the following images:</p>
<table><thead><tr><th>Description</th><th>Image</th></tr></thead><tbody>
<tr><td>Simple Boundaries</td><td><img  class="center" src="convolutions/1d/../res/simple_linear.png" style="width:100%" /></td></tr>
<tr><td>Full</td><td><img  class="center" src="convolutions/1d/../res/full_linear.png" style="width:100%" /></td></tr>
<tr><td>Cyclic</td><td><img  class="center" src="convolutions/1d/../res/cyclic.png" style="width:100%" /></td></tr>
</tbody></table>
<p>As a sanity check, make sure that the bounded convolution is a subset of the full convolution.
In this example, the bounded convolution is the start of the full convolution, but it is entirely possible it could be the middle or somewhere else entirely depending on how you counted within the inner, summation loop for the convolution.</p>
<h2 id="license-14"><a class="header" href="#license-14">License</a></h2>
<h5 id="code-examples-13"><a class="header" href="#code-examples-13">Code Examples</a></h5>
<p>The code examples are licensed under the MIT license (found in <a href="https://github.com/algorithm-archivists/algorithm-archive/blob/master/LICENSE.md">LICENSE.md</a>).</p>
<h5 id="imagesgraphics-8"><a class="header" href="#imagesgraphics-8">Images/Graphics</a></h5>
<ul>
<li>The image &quot;<a href="convolutions/1d/../res/square_wave.png">Square Wave</a>&quot; was created by <a href="https://github.com/leios">James Schloss</a> and is licensed under the <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</li>
<li>The image &quot;<a href="convolutions/1d/../res/triangle_wave.png">Triangle Wave</a>&quot; was created by <a href="https://github.com/leios">James Schloss</a> and is licensed under the <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</li>
<li>The video &quot;<a href="convolutions/1d/../res/triangle_square_conv.mp4">Triangle Square Convolution</a>&quot; was created by <a href="https://github.com/leios">James Schloss</a> and is licensed under the <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</li>
<li>The video &quot;<a href="convolutions/1d/../res/1d_gaussian.mp4">Gaussian Square Convolution</a>&quot; was created by <a href="https://github.com/leios">James Schloss</a> and is licensed under the <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</li>
<li>The video &quot;<a href="convolutions/1d/../res/1d_rand_gaussian_cyclic.mp4">Gaussian Random Convolution</a>&quot; was created by <a href="https://github.com/leios">James Schloss</a> and is licensed under the <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</li>
<li>The video &quot;<a href="convolutions/1d/../res/double_gaussian.mp4">Double Convolution</a>&quot; was created by <a href="https://github.com/leios">James Schloss</a> and is licensed under the <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</li>
<li>The image &quot;<a href="convolutions/1d/../res/sawtooth.png">Sawtooth Wave</a>&quot; was created by <a href="https://github.com/leios">James Schloss</a> and is licensed under the <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</li>
<li>The video &quot;<a href="convolutions/1d/../res/1d_sawtooth.mp4">Sawtooth Square Convolution</a>&quot; was created by <a href="https://github.com/leios">James Schloss</a> and is licensed under the <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</li>
<li>The video &quot;<a href="convolutions/1d/../res/1d_rand_gaussian_full.mp4">Full Random Convolution</a>&quot; was created by <a href="https://github.com/leios">James Schloss</a> and is licensed under the <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</li>
<li>The video &quot;<a href="convolutions/1d/../res/1d_rand_gaussian_simple.mp4">Simple Random Convolution</a>&quot; was created by <a href="https://github.com/leios">James Schloss</a> and is licensed under the <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</li>
<li>The image &quot;<a href="convolutions/1d/../res/simple_linear.png">Simple Linear</a>&quot; was created by <a href="https://github.com/leios">James Schloss</a> and is licensed under the <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</li>
<li>The image &quot;<a href="convolutions/1d/../res/full_linear.png">Full Linear</a>&quot; was created by <a href="https://github.com/leios">James Schloss</a> and is licensed under the <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</li>
<li>The image &quot;<a href="convolutions/1d/../res/cyclic.png">Cyclic</a>&quot; was created by <a href="https://github.com/leios">James Schloss</a> and is licensed under the <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</li>
</ul>
<h5 id="text-14"><a class="header" href="#text-14">Text</a></h5>
<p>The text of this chapter was written by <a href="https://github.com/leios">James Schloss</a> and is licensed under the <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</p>
<p><a href="https://creativecommons.org/licenses/by-sa/4.0/"><p><img  class="center" src="convolutions/1d/../../cc/CC-BY-SA_icon.svg" /></p></a></p>
<h5 id="pull-requests-11"><a class="header" href="#pull-requests-11">Pull Requests</a></h5>
<p>After initial licensing (<a href="https://github.com/algorithm-archivists/algorithm-archive/pull/560">#560</a>), the following pull requests have modified the text or graphics of this chapter:</p>
<ul>
<li>none</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="multiplication-as-a-convolution"><a class="header" href="#multiplication-as-a-convolution">Multiplication as a convolution</a></h1>
<p>As a brief aside, we will touch on a rather interesting side topic: the relation between integer multiplication and convolutions
As an example, let us consider the following multiplication: \( 123 \times 456 = 56088 \).</p>
<p>In this case, we might line up the numbers, like so:</p>
<p>\[
\begin{matrix}
&amp;&amp;1&amp;2&amp;3 \\
&amp;\times &amp;4&amp;5&amp;6 \\
\hline
5 &amp; 6 &amp; 0 &amp; 8 &amp; 8
\end{matrix}
\]</p>
<p>Here, each column represents another power of 10, such that in the number 123, there is 1 100, 2 10s, and 3 1s.
So let us use a similar notation to perform the convolution, by reversing the second set of numbers and moving it to the right, performing an element-wise multiplication at each step:</p>
<p>\[
\begin{matrix}
&amp;&amp;&amp;\color{red}1&amp;2&amp;3 \\
\times &amp;6&amp;5&amp;\color{red}4&amp;&amp; \\
\hline
\end{matrix}\\
\color{red}{1}\times\color{red}{4} = 4
\]</p>
<p>\[
\begin{matrix}
&amp;&amp;&amp;\color{red}1&amp;\color{green}2&amp;3 \\
\times &amp;&amp;6&amp;\color{red}5&amp;\color{green}4&amp; \\
\hline
\end{matrix}\\
\color{red}1\times\color{red}5+\color{green}2\times\color{green}4=13
\]</p>
<p>\[
\begin{matrix}
&amp;&amp;&amp;\color{red}1&amp;\color{green}2&amp;\color{blue}3 \\
\times &amp;&amp;&amp;\color{red}6&amp;\color{green}5&amp;\color{blue}4 \\
\hline
\end{matrix}\\
\color{red}1\times\color{red}6+\color{green}2\times\color{green}5+\color{blue}3\times\color{blue}4=28
\]</p>
<p>\[
\begin{matrix}
&amp;&amp;1&amp;\color{green}2&amp;\color{blue}3&amp; \\
\times &amp;&amp;&amp;\color{green}6&amp;\color{blue}5&amp;4 \\
\hline
\end{matrix}\\
\color{green}2\times\color{green}6+\color{blue}3\times\color{blue}5=27
\[  \]
\begin{matrix}
&amp;1&amp;2&amp;\color{blue}3&amp;&amp; \\
\times &amp;&amp;&amp;\color{blue}6&amp;5&amp;4 \\
\hline
\end{matrix}\\
\color{blue}3\times\color{blue}6=18
\]</p>
<p>For these operations, any blank space should be considered a \( 0 \).
In the end, we will have a new set of numbers:</p>
<p>\[
\begin{matrix}
&amp;&amp;1&amp;2&amp;3 \\
&amp;\times &amp;4&amp;5&amp;6 \\
\hline
4 &amp; 13 &amp; 28 &amp; 27 &amp; 18
\end{matrix}
\]</p>
<p>Now all that is left is to perform the <em>carrying</em> operation by moving any number in the 10s digit to its left-bound neighbor.
For example, the numbers \( [4, 18]=[4+1, 8]=[5,8] \) or 58.
For these numbers, </p>
<p>\[
\begin{matrix}
&amp;4 &amp; 13 &amp; 28 &amp; 27 &amp; 18\\
=&amp;4+1 &amp; 3+2 &amp; 8+2 &amp; 7+1 &amp; 8\\
=&amp;5 &amp; 5 &amp; 10 &amp; 8 &amp; 8\\
=&amp;5 &amp; 5+1 &amp; 0 &amp; 8 &amp; 8\\
=&amp;5 &amp; 6 &amp; 0 &amp; 8 &amp; 8
\end{matrix}
\]</p>
<p>Which give us \( 123\times456=56088 \), the correct answer for integer multiplication.
I am not suggesting that we teach elementary school students to learn convolutions, but I do feel this is an interesting fact that most people do not know: integer multiplication can be performed with a convolution.</p>
<p>This will be discussed in further detail when we talk about the Schonhage-Strassen algorithm, which uses this fact to perform multiplications for incredibly large integers.</p>
<h2 id="license-15"><a class="header" href="#license-15">License</a></h2>
<h5 id="text-15"><a class="header" href="#text-15">Text</a></h5>
<p>The text of this chapter was written by <a href="https://github.com/leios">James Schloss</a> and is licensed under the <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</p>
<p><a href="https://creativecommons.org/licenses/by-sa/4.0/"><p><img  class="center" src="convolutions/multiplication/../../cc/CC-BY-SA_icon.svg" /></p></a></p>
<h5 id="pull-requests-12"><a class="header" href="#pull-requests-12">Pull Requests</a></h5>
<p>After initial licensing (<a href="https://github.com/algorithm-archivists/algorithm-archive/pull/560">#560</a>), the following pull requests have modified the text or graphics of this chapter:</p>
<ul>
<li>none</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="convolutions-on-images"><a class="header" href="#convolutions-on-images">Convolutions on Images</a></h1>
<p>For this section, we will no longer be focusing on signals, but instead images (arrays filled with elements of red, green, and blue values).
That said, for the code examples, greyscale images may be used such that each array element is composed of some floating-point value instead of color.
In addition, we will not be discussing boundary conditions too much in this chapter and will instead be using the simple boundaries introduced in the section on <a href="convolutions/2d/../1d/1d.html">one-dimensional convolutions</a>.</p>
<p>The extension of one-dimensional convolutions to two dimensions requires a little thought about indexing and the like, but is ultimately the same operation.
Here is an animation of a convolution for a two-dimensional image:</p>
<div style="text-align:center">
<video style="width:90%" controls loop>
  <source src="../res/2d.mp4" type="video/mp4">
Your browser does not support the video tag.
</video>
</div>
<p>In this case, we convolved the image with a 3x3 square filter, all filled with values of \( \frac{1}{9} \).
This created a simple blurring effect, which is somewhat expected from the discussion in the previous section.
In code, a two-dimensional convolution might look like this:</p>
<pre><code class="language-julia">function convolve_linear(signal::Array{T, 2}, filter::Array{T, 2},
                         output_size) where {T &lt;: Number}

    # convolutional output
    out = Array{Float64,2}(undef, output_size)
    sum = 0

    for i = 1:output_size[1]
        for j = 1:output_size[2]
            for k = max(1, i-size(filter)[1]):i
                for l = max(1, j-size(filter)[2]):j
                    if k &lt;= size(signal)[1] &amp;&amp; i-k+1 &lt;= size(filter)[1] &amp;&amp;
                       l &lt;= size(signal)[2] &amp;&amp; j-l+1 &lt;= size(filter)[2]
                        sum += signal[k,l] * filter[i-k+1, j-l+1]
                    end
                end
            end

            out[i,j] = sum
            sum = 0
        end
    end

    return out
end
</code></pre>
<pre><code class="language-python">def convolve_linear(signal, filter, output_size):
    out = np.zeros(output_size)
    sum = 0

    for i in range(output_size[0]):
        for j in range(output_size[1]):
            for k in range(max(0, i-filter.shape[0]), i+1):
                for l in range(max(0, j-filter.shape[1]), j+1):
                    with suppress(IndexError):
                        sum += signal[k, l] * filter[i-k, j-l]
            out[i, j] = sum
            sum = 0

    return out

</code></pre>
<p>This is very similar to what we have shown in previous sections; however, it essentially requires four iterable dimensions because we need to iterate through each axis of the output domain <em>and</em> the filter.</p>
<p>At this stage, it is worth highlighting common filters used for convolutions of images.
In particular, we will further discuss the Gaussian filter introduced in the <a href="convolutions/2d/../1d/1d.html">previous section</a>, and then introduce another set of kernels known as Sobel operators, which are used for nave edge detection or image derivatives.</p>
<h2 id="the-gaussian-kernel"><a class="header" href="#the-gaussian-kernel">The Gaussian kernel</a></h2>
<p>The Gaussian kernel serves as an effective <em>blurring</em> operation for images.
As a reminder, the formula for any Gaussian distribution is</p>
<p>\[ g(x,y) = \frac{1}{2\pi\sigma^2}e^{-\frac{x^2+y^2}{2\sigma^2}}, \]</p>
<p>where \( \sigma \) is the standard deviation and is a measure of the width of the Gaussian.
A larger \( \sigma \) means a larger Gaussian; however, remember that the Gaussian must fit onto the filter, otherwise it will be cut off!
For example, if you are using a \( 3\times 3 \) filter, you should not be using \( \sigma = 10 \).
Some definitions of \( \sigma \) allow users to have a separate deviation in \( x \) and \( y \) to create an ellipsoid Gaussian, but for the purposes of this chapter, we will assume \( \sigma_x = \sigma_y \).
As a general rule of thumb, the larger the filter and standard deviation, the more &quot;smeared&quot; the final convolution will be.</p>
<p>At this stage, it is important to write some code, so we will generate a simple function that returns a Gaussian kernel with a specified standard deviation and filter size.</p>
<pre><code class="language-julia">function create_gaussian_kernel(kernel_size)

    kernel = zeros(kernel_size, kernel_size)

    # The center must be offset by 0.5 to find the correct index
    center = kernel_size * 0.5 + 0.5

    sigma = sqrt(0.1*kernel_size)

    for i = 1:kernel_size
        for j = 1:kernel_size
            kernel[i,j] = exp(-((i-center)^2 + (j-center)^2) / (2*sigma^2))
        end
    end

    return normalize(kernel)
    
end
</code></pre>
<pre><code class="language-python">def create_gaussian_kernel(kernel_size):
    kernel = np.zeros((kernel_size, kernel_size))

    # The center must be offset by 0.5 to find the correct index
    center = kernel_size*0.5 + 0.5

    sigma = np.sqrt(0.1*kernel_size)

    def kernel_function(x, y):
        return np.exp(-((x-center+1)**2 + (y-center+1)**2)/(2*sigma**2))

    kernel = np.fromfunction(kernel_function, (kernel_size, kernel_size))
    return kernel / np.linalg.norm(kernel)
</code></pre>
<p>Though it is entirely possible to create a Gaussian kernel whose standard deviation is independent on the kernel size, we have decided to enforce a relation between the two in this chapter.
As always, we encourage you to play with the code and create your own Gaussian kernels any way you want!
As a note, all the kernels will be scaled (normalized) at the end by the sum of all internal elements.
This ensures that the output of the convolution will not have an obnoxious scale factor associated with it.</p>
<p>Below are a few images generated by applying a kernel generated with the code above to a black and white image of a circle.</p>
<p>
  <img  class="center" src="convolutions/2d/../res/circle_blur.png" style="width:100%" />
</p>
<p>In (a), we show the original image, which is just a white circle at the center of a \( 50\times 50 \) grid.
In (b), we show the image after convolution with a \( 3\times 3 \) kernel.
In (c), we show the image after convolution with a \( 20\times 20 \) kernel.
Here, we see that (c) is significantly fuzzier than (b), which is a direct consequence of the kernel size.</p>
<p>There is a lot more that we could talk about, but now is a good time to move on to a slightly more complicated convolutional method: the Sobel operator.</p>
<h2 id="the-sobel-operator"><a class="header" href="#the-sobel-operator">The Sobel operator</a></h2>
<p>The Sobel operator effectively performs a gradient operation on an image by highlighting areas where a large change has been made.
In essence, this means that this operation can be thought of as a nave edge detector.
Essentially, the \( n \)-dimensional Sobel operator is composed of \( n \) separate gradient convolutions (one for each dimension) that are then combined together into a final output array.
Again, for the purposes of this chapter, we will stick to two dimensions, which will be composed of two separate gradients along the \( x \) and \( y \) directions.
Each gradient will be created by convolving our image with their corresponding Sobel operator:</p>
<p>\[
\begin{align}
S_x &amp;= \left(\begin{bmatrix}
1 \\
2 \\
1 \\
\end{bmatrix} \otimes [1~0~-1]
\right) = \begin{bmatrix}
1 &amp; 0 &amp; -1 \\
2 &amp; 0 &amp; -2 \\
1 &amp; 0 &amp; -1 \\
\end{bmatrix}\\</p>
<p>S_y &amp;= \left(
\begin{bmatrix}
1 \\
0 \\
-1 \\
\end{bmatrix} \otimes [1~2~1]
\right) = \begin{bmatrix}
1 &amp; 2 &amp; 1 \\
0 &amp; 0 &amp; 0 \\
-1 &amp; -2 &amp; -1 \\
\end{bmatrix}.
\end{align}
\]</p>
<p>The gradients can then be found with a convolution, such that:</p>
<p>\[
\begin{align}
G_x &amp;= S_x<em>A \\
G_y &amp;= S_y</em>A.
\end{align}
\]</p>
<p>Here, \( A \) is the input array or image.
Finally, these gradients can be summed in quadrature to find the total Sobel operator or image gradient:</p>
<p>\[ G_{\text{total}} = \sqrt{G_x^2 + G_y^2} \]</p>
<p>So let us now show what it does in practice:</p>
<p>
  <img  class="center" src="convolutions/2d/../res/sobel_filters.png" style="width:100%" />
</p>
<p>In this diagram, we start with the circle image on the right, and then convolve it with the \( S_x \) and \( S_y \) operators to find the gradients along \( x \) and \( y \) before summing them in quadrature to get the final image gradient.
Here, we see that the edges of our input image have been highlighted, showing outline of our circle.
This is why the Sobel operator is also known as nave edge detection and is an integral component to many more sophisticated edge detection methods like one proposed by Canny {{ &quot;canny1986computational&quot; | cite }}.</p>
<p>In code, the Sobel operator involves first finding the operators in \( x \) and \( y \) and then applying them with a traditional convolution:</p>
<pre><code class="language-julia">function create_sobel_operators()
    Sx = [1.0, 2.0, 1.0]*[-1.0 0.0 1.0] / 9
    Sy = [-1.0, 0.0, 1.0]*[1.0 2.0 1.0] / 9

    return Sx, Sy
end

function compute_sobel(signal)
    Sx, Sy = create_sobel_operators()

    Gx = convolve_linear(signal, Sx, size(signal) .+ size(Sx))
    Gy = convolve_linear(signal, Sy, size(signal) .+ size(Sy))

    return sqrt.(Gx.^2 .+ Gy.^2)
end
</code></pre>
<pre><code class="language-python">def create_sobel_operators():
    Sx = np.dot([[1.0], [2.0], [1.0]], [[-1.0, 0.0, 1.0]]) / 9
    Sy = np.dot([[-1.0], [0.0], [1.0]], [[1.0, 2.0, 1.0]]) / 9

    return Sx, Sy

def sum_matrix_dimensions(mat1, mat2):
    return (mat1.shape[0] + mat2.shape[0], 
            mat1.shape[1] + mat2.shape[1])

def compute_sobel(signal):
    Sx, Sy = create_sobel_operators()
    
    Gx = convolve_linear(signal, Sx, sum_matrix_dimensions(signal, Sx))
    Gy = convolve_linear(signal, Sy, sum_matrix_dimensions(signal, Sy))

    return np.sqrt(np.power(Gx, 2) + np.power(Gy, 2))
</code></pre>
<p>With that, I believe we are at a good place to stop discussions on two-dimensional convolutions.
We will definitely return to this topic in the future as new algorithms require more information.</p>
<h2 id="example-code-5"><a class="header" href="#example-code-5">Example Code</a></h2>
<p>For the code in this section, we have modified the visualizations from the <a href="convolutions/2d/../1d/1d.html">one-dimensional convolution chapter</a> to add a two-dimensional variant for blurring an image of random white noise.
We have also added code to create the Gaussian kernel and Sobel operator and apply it to the circle, as shown in the text.</p>
<pre><code class="language-julia">using DelimitedFiles
using LinearAlgebra

function convolve_linear(signal::Array{T, 2}, filter::Array{T, 2},
                         output_size) where {T &lt;: Number}

    # convolutional output
    out = Array{Float64,2}(undef, output_size)
    sum = 0

    for i = 1:output_size[1]
        for j = 1:output_size[2]
            for k = max(1, i-size(filter)[1]):i
                for l = max(1, j-size(filter)[2]):j
                    if k &lt;= size(signal)[1] &amp;&amp; i-k+1 &lt;= size(filter)[1] &amp;&amp;
                       l &lt;= size(signal)[2] &amp;&amp; j-l+1 &lt;= size(filter)[2]
                        sum += signal[k,l] * filter[i-k+1, j-l+1]
                    end
                end
            end

            out[i,j] = sum
            sum = 0
        end
    end

    return out
end

function create_gaussian_kernel(kernel_size)

    kernel = zeros(kernel_size, kernel_size)

    # The center must be offset by 0.5 to find the correct index
    center = kernel_size * 0.5 + 0.5

    sigma = sqrt(0.1*kernel_size)

    for i = 1:kernel_size
        for j = 1:kernel_size
            kernel[i,j] = exp(-((i-center)^2 + (j-center)^2) / (2*sigma^2))
        end
    end

    return normalize(kernel)
    
end

function create_sobel_operators()
    Sx = [1.0, 2.0, 1.0]*[-1.0 0.0 1.0] / 9
    Sy = [-1.0, 0.0, 1.0]*[1.0 2.0 1.0] / 9

    return Sx, Sy
end

function compute_sobel(signal)
    Sx, Sy = create_sobel_operators()

    Gx = convolve_linear(signal, Sx, size(signal) .+ size(Sx))
    Gy = convolve_linear(signal, Sy, size(signal) .+ size(Sy))

    return sqrt.(Gx.^2 .+ Gy.^2)
end

# Simple function to create a square grid with a circle embedded inside of it
function create_circle(image_resolution, grid_extents, radius)
    out = zeros(image_resolution, image_resolution)

    for i = 1:image_resolution
        x_position = ((i-1)*grid_extents/image_resolution)-0.5*grid_extents
        for j = 1:image_resolution
            y_position = ((j-1)*grid_extents/image_resolution)-0.5*grid_extents
            if x_position^2 + y_position^2 &lt;= radius^2
                out[i,j] = 1.0
            end
        end
    end 

    return out
end

function main()

    # Random distribution in x
    x = rand(100, 100)

    # Gaussian signals
    y = [exp(-(((i-50)/100)^2 + ((j-50)/100)^2)/.01) for i = 1:100, j=1:100]

    # Normalization is not strictly necessary, but good practice
    normalize!(x)
    normalize!(y)

    # full convolution, output will be the size of x + y
    full_linear_output = convolve_linear(x, y, size(x) .+ size(y))

    # simple boundaries
    simple_linear_output = convolve_linear(x, y, size(x))

    # outputting convolutions to different files for plotting in external code
    writedlm(&quot;full_linear.dat&quot;, full_linear_output)
    writedlm(&quot;simple_linear.dat&quot;, simple_linear_output)

    # creating simple circle and 2 different Gaussian kernels
    circle = create_circle(50,2,0.5)

    normalize!(circle)

    small_kernel = create_gaussian_kernel(3)
    large_kernel = create_gaussian_kernel(25)

    small_kernel_output = convolve_linear(circle, small_kernel,
                                          size(circle).+size(small_kernel))
    large_kernel_output = convolve_linear(circle, large_kernel,
                                          size(circle).+size(large_kernel))

    writedlm(&quot;small_kernel.dat&quot;, small_kernel_output)
    writedlm(&quot;large_kernel.dat&quot;, large_kernel_output)

    # Using the circle for Sobel operations as well
    sobel_output = compute_sobel(circle)

    writedlm(&quot;sobel_output.dat&quot;, sobel_output)

end
</code></pre>
<pre><code class="language-python">import numpy as np
from contextlib import suppress


def convolve_linear(signal, filter, output_size):
    out = np.zeros(output_size)
    sum = 0

    for i in range(output_size[0]):
        for j in range(output_size[1]):
            for k in range(max(0, i-filter.shape[0]), i+1):
                for l in range(max(0, j-filter.shape[1]), j+1):
                    with suppress(IndexError):
                        sum += signal[k, l] * filter[i-k, j-l]
            out[i, j] = sum
            sum = 0

    return out


def create_gaussian_kernel(kernel_size):
    kernel = np.zeros((kernel_size, kernel_size))

    # The center must be offset by 0.5 to find the correct index
    center = kernel_size*0.5 + 0.5

    sigma = np.sqrt(0.1*kernel_size)

    def kernel_function(x, y):
        return np.exp(-((x-center+1)**2 + (y-center+1)**2)/(2*sigma**2))

    kernel = np.fromfunction(kernel_function, (kernel_size, kernel_size))
    return kernel / np.linalg.norm(kernel)


def create_sobel_operators():
    Sx = np.dot([[1.0], [2.0], [1.0]], [[-1.0, 0.0, 1.0]]) / 9
    Sy = np.dot([[-1.0], [0.0], [1.0]], [[1.0, 2.0, 1.0]]) / 9

    return Sx, Sy

def sum_matrix_dimensions(mat1, mat2):
    return (mat1.shape[0] + mat2.shape[0], 
            mat1.shape[1] + mat2.shape[1])

def compute_sobel(signal):
    Sx, Sy = create_sobel_operators()
    
    Gx = convolve_linear(signal, Sx, sum_matrix_dimensions(signal, Sx))
    Gy = convolve_linear(signal, Sy, sum_matrix_dimensions(signal, Sy))

    return np.sqrt(np.power(Gx, 2) + np.power(Gy, 2))


def create_circle(image_resolution, grid_extents, radius):
    out = np.zeros((image_resolution, image_resolution))

    for i in range(image_resolution):
        x_position = ((i * grid_extents / image_resolution)
                      - 0.5 * grid_extents)
        for j in range(image_resolution):
            y_position = ((j * grid_extents / image_resolution)
                          - 0.5 * grid_extents)
            if x_position ** 2 + y_position ** 2 &lt;= radius ** 2:
                out[i, j] = 1.0

    return out


def main():

    # Random distribution in x
    x = np.random.rand(100, 100)

    # Gaussian signals
    def create_gaussian_signals(i, j):
        return np.exp(-(((i-50)/100) ** 2 +
                        ((j-50)/100) ** 2) / .01)
    y = np.fromfunction(create_gaussian_signals, (100, 100))

    # Normalization is not strictly necessary, but good practice
    x /= np.linalg.norm(x)
    y /= np.linalg.norm(y)

    # full convolution, output will be the size of x + y
    full_linear_output = convolve_linear(x, y, sum_matrix_dimensions(x, y))

    # simple boundaries
    simple_linear_output = convolve_linear(x, y, x.shape)

    np.savetxt(&quot;full_linear.dat&quot;, full_linear_output)
    np.savetxt(&quot;simple_linear.dat&quot;, simple_linear_output)

    # creating simple circle and 2 different Gaussian kernels
    circle = create_circle(50, 2, 0.5)

    circle = circle / np.linalg.norm(circle)

    small_kernel = create_gaussian_kernel(3)
    large_kernel = create_gaussian_kernel(25)

    small_kernel_output = convolve_linear(circle, small_kernel,
                                          sum_matrix_dimensions(circle,
                                                                small_kernel))

    large_kernel_output = convolve_linear(circle, large_kernel,
                                          sum_matrix_dimensions(circle,
                                                                large_kernel))

    np.savetxt(&quot;small_kernel.dat&quot;, small_kernel_output)
    np.savetxt(&quot;large_kernel.dat&quot;, large_kernel_output)

    circle = create_circle(50, 2, 0.5)

    # Normalization
    circle = circle / np.linalg.norm(circle)

    # using the circle for sobel operations as well
    sobel_output = compute_sobel(circle)

    np.savetxt(&quot;sobel_output.dat&quot;, sobel_output)

</code></pre>
<h3 id="bibliography-4"><a class="header" href="#bibliography-4">Bibliography</a></h3>
<p>{% references %} {% endreferences %}</p>
<h2 id="license-16"><a class="header" href="#license-16">License</a></h2>
<h5 id="code-examples-14"><a class="header" href="#code-examples-14">Code Examples</a></h5>
<p>The code examples are licensed under the MIT license (found in <a href="https://github.com/algorithm-archivists/algorithm-archive/blob/master/LICENSE.md">LICENSE.md</a>).</p>
<h5 id="imagesgraphics-9"><a class="header" href="#imagesgraphics-9">Images/Graphics</a></h5>
<ul>
<li>The image &quot;<a href="convolutions/2d/../res/heart_8bit.png">8bit Heart</a>&quot; was created by <a href="https://github.com/leios">James Schloss</a> and is licensed under the <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</li>
<li>The image &quot;<a href="convolutions/2d/../res/circle_blur.png">Circle Blur</a>&quot; was created by <a href="https://github.com/leios">James Schloss</a> and is licensed under the <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</li>
<li>The image &quot;<a href="convolutions/2d/../res/sobel_filters.png">Sobel Filters</a>&quot; was created by <a href="https://github.com/leios">James Schloss</a> and is licensed under the <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</li>
<li>The video &quot;<a href="convolutions/2d/../res/2d.mp4">2D Convolution</a>&quot; was created by <a href="https://github.com/leios">James Schloss</a> and <a href="https://github.com/3b1b">Grant Sanderson</a> and is licensed under the <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</li>
</ul>
<h5 id="text-16"><a class="header" href="#text-16">Text</a></h5>
<p>The text of this chapter was written by <a href="https://github.com/leios">James Schloss</a> and is licensed under the <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</p>
<p><a href="https://creativecommons.org/licenses/by-sa/4.0/"><p><img  class="center" src="convolutions/2d/../../cc/CC-BY-SA_icon.svg" /></p></a></p>
<h5 id="pull-requests-13"><a class="header" href="#pull-requests-13">Pull Requests</a></h5>
<p>After initial licensing (<a href="https://github.com/algorithm-archivists/algorithm-archive/pull/560">#560</a>), the following pull requests have modified the text or graphics of this chapter:</p>
<ul>
<li>none</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="convolutional-theorem"><a class="header" href="#convolutional-theorem">Convolutional Theorem</a></h1>
<p>Important note: this particular section will be expanded upon after the Fourier transform and Fast Fourier Transform (FFT) chapters have been revised.</p>
<p>Now, let me tell you about a bit of computational magic:</p>
<p><strong>Convolutions can be performed with Fourier Transforms!</strong></p>
<p>This is crazy, but it is also incredibly hard to explain, so let me do my best.
As described in the chapter on <a href="convolutions/convolutional_theorem/../cooley_tukey/cooley_tukey.html">Fourier Transforms</a>, Fourier Transforms allow programmers to move from real space to frequency space.
When we transform a wave into frequency space, we can see a single peak in frequency space related to the frequency of that wave.
No matter what function we send into a Fourier Transform, the frequency-space image can be interpreted as a series of different waves with a specified frequency.
Each of these waves is parameterized by another \( e^{2\pi i k n / N} \) term, where \( k \) is the element's value in the frequency domain, \( n \) is its value in the time domain, and \( N \) is the overall length of the signal.
In this way, each wave can be seen as a complex exponential.</p>
<p>So here's the idea: if we take two functions \( f(x) \) and \( g(x) \) and move them to frequency space to be \( \hat f(\xi) \) and \( \hat g(\xi) \), we can then multiply those two functions and transform them back into to blend the signals together.
In this way, we will have a third function that relates the frequency-space images of the two input functions.
This is known as the <em>convolution theorem</em> which looks something like this:</p>
<p>\( \mathcal{F}(f*g) = \mathcal{F}(f) \cdot \mathcal{F}(g) \)</p>
<p>Where \( \mathcal{F} \) denotes the Fourier Transform.</p>
<p>At first, this might not seem particularly intuitive, but remember that frequency space is essentially composed of a set of exponentials.
As mentioned in the section about <a href="convolutions/convolutional_theorem/../multiplication/multiplication.html">Multiplication as a Convolution</a>, multiplication in base 10 space is also a convolution.
The convolutional theorem extends this concept into multiplication with <em>any</em> set of exponentials, not just base 10.
Obviously, this description is still lacking a bit of explanation, but I promise we will add more when revising the Fourier transform sections!</p>
<p>By using a Fast Fourier Transform (FFT) in code, this can take a standard convolution on two arrays of length \( n \), which is an \( \mathcal{O}(n^2) \) process, to \( \mathcal{O}(n\log(n)) \).
This means that the convolution theorem is fundamental to creating fast convolutional methods for certain large inputs.</p>
<pre><code class="language-julia"># using the convolutional theorem
function convolve_fft(signal1::Array{T}, signal2::Array{T}) where {T &lt;: Number}
    return ifft(fft(signal1).*fft(signal2))
end
</code></pre>
<p>This method also has the added advantage that it will <em>always output an array of the size of your signal</em>; however, if your signals are not of equal size, we need to pad the smaller signal with zeros.
Also note that the Fourier Transform is a periodic or cyclic operation, so there are no real edges in this method, instead the arrays &quot;wrap around&quot; to the other side, creating a cyclic convolution like we showed in the periodic boundary condition case for the <a href="convolutions/convolutional_theorem/../1d/1d.html">one-dimensional convolution</a>.</p>
<h2 id="example-code-6"><a class="header" href="#example-code-6">Example Code</a></h2>
<p>For this example code, we will be using two sawtooth functions as we did in the chapter on <a href="convolutions/convolutional_theorem/../1d/1d.html">one-dimensional convolutions</a>:</p>
<pre><code class="language-julia">using FFTW
using LinearAlgebra
using DelimitedFiles

# using the convolutional theorem
function convolve_fft(signal1::Array{T}, signal2::Array{T}) where {T &lt;: Number}
    return ifft(fft(signal1).*fft(signal2))
end

function main()

    # sawtooth functions for x and y
    x = [float(i)/200 for i = 1:200]
    y = [float(i)/200 for i = 1:200]

    # Normalization is not strictly necessary, but good practice
    normalize!(x)
    normalize!(y)

    # cyclic convolution via the convolutional theorem
    fft_output = convolve_fft(x, y)

    # outputting convolutions to different files for plotting in external code
    # note: we are outputting just the real component because the imaginary
    #       component is virtually 0
    writedlm(&quot;fft.dat&quot;, real(fft_output))

end

main()
</code></pre>
<pre><code class="language-python">from scipy.fft import fft, ifft
import numpy as np

# using the convolutional theorem
def convolve_fft(signal1, signal2):
    return ifft(np.multiply(fft(signal1),fft(signal2)))

# Sawtooth functions
x = [float(i)/200 for i in range(1,101)]
y = [float(i)/200 for i in range(1,101)]

x /= np.linalg.norm(x)
y /= np.linalg.norm(y)

# Convolving the two signals
fft_output = convolve_fft(x, y)

np.savetxt(&quot;fft.dat&quot;, np.real(fft_output))

</code></pre>
<p>This should produce the following output:</p>
<p>
    <img class="center" src="convolutions/convolutional_theorem/../res/cyclic.png" style="width:75%">
</p>
<h2 id="license-17"><a class="header" href="#license-17">License</a></h2>
<h5 id="code-examples-15"><a class="header" href="#code-examples-15">Code Examples</a></h5>
<p>The code examples are licensed under the MIT license (found in <a href="https://github.com/algorithm-archivists/algorithm-archive/blob/master/LICENSE.md">LICENSE.md</a>).</p>
<h5 id="imagesgraphics-10"><a class="header" href="#imagesgraphics-10">Images/Graphics</a></h5>
<ul>
<li>The image &quot;<a href="convolutions/convolutional_theorem/../res/cyclic.png">Cyclic</a>&quot; was created by <a href="https://github.com/leios">James Schloss</a> and is licensed under the <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</li>
</ul>
<h5 id="text-17"><a class="header" href="#text-17">Text</a></h5>
<p>The text of this chapter was written by <a href="https://github.com/leios">James Schloss</a> and is licensed under the <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</p>
<p><a href="https://creativecommons.org/licenses/by-sa/4.0/"><p><img  class="center" src="convolutions/convolutional_theorem/../../cc/CC-BY-SA_icon.svg" /></p></a></p>
<h5 id="pull-requests-14"><a class="header" href="#pull-requests-14">Pull Requests</a></h5>
<p>After initial licensing (<a href="https://github.com/algorithm-archivists/algorithm-archive/pull/560">#560</a>), the following pull requests have modified the text or graphics of this chapter:</p>
<ul>
<li>none</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tree-traversal"><a class="header" href="#tree-traversal">Tree Traversal</a></h1>
<p>Trees are naturally recursive data structures, and because of this, we cannot access their elements like we might access the elements of a vector or array. Instead, we need to use more interesting methods to work through each element. This is often called <em>Tree Traversal</em>, and there are many different ways to do this. For now, we will restrict the discussion to two common and related methods of tree traversal: <em>Depth-First</em> and <em>Breadth-First Search</em>. Note that trees vary greatly in shape and size depending on how they are used; however, they are composed primarily of nodes that house other, children nodes, like so:</p>
<pre><code class="language-julia">struct Node
    children::Vector{Node}
    ID::Int64
    Node(ID::Int64) = new(Vector{Node}(), ID)
end
``````julia
struct Node
    children::Vector{Node}
    ID::Int64
    Node(ID::Int64) = new(Vector{Node}(), ID)
end
``````julia
struct Node
    children::Vector{Node}
    ID::Int64
    Node(ID::Int64) = new(Vector{Node}(), ID)
end
```c```julia
struct Node
    children::Vector{Node}
    ID::Int64
    Node(ID::Int64) = new(Vector{Node}(), ID)
end
``````julia
struct Node
    children::Vector{Node}
    ID::Int64
    Node(ID::Int64) = new(Vector{Node}(), ID)
end
``````julia
struct Node
    children::Vector{Node}
    ID::Int64
    Node(ID::Int64) = new(Vector{Node}(), ID)
end
</code></pre>
<p><a href="tree_traversal/code/c/tree_traversal.c">import:7-11, lang:&quot;c&quot;</a>
{% sample lang=&quot;java&quot; %}
<a href="tree_traversal/code/java/Tree.java">import:112-128, lang:&quot;java&quot;</a>
{% sample lang=&quot;js&quot; %}
<a href="tree_traversal/code/javascript/tree.js">import:1-10, lang:&quot;javascript&quot;</a>
As a note, a <code>node</code> struct is not necessary in javascript, so this is an example of how a tree might be constructed.</p>
<pre><code class="language-python">class Node:
    def __init__(self):
        self.data = None
        self.children = []
</code></pre>
<p>{% sample lang=&quot;scratch&quot; %}</p>
<p>
  <img  class="center" src="tree_traversal/code/scratch/struct.svg" style="width:25%" />
</p>
```rust
struct Node {
    children: Vec<Node>,
    value: u64,
}
``````rust
struct Node {
    children: Vec<Node>,
    value: u64,
}
``````rust
struct Node {
    children: Vec<Node>,
    value: u64,
}
```v```rust
struct Node {
    children: Vec<Node>,
    value: u64,
}
``````rust
struct Node {
    children: Vec<Node>,
    value: u64,
}
``````rust
struct Node {
    children: Vec<Node>,
    value: u64,
}
``````rust
struct Node {
    children: Vec<Node>,
    value: u64,
}
```.```rust
struct Node {
    children: Vec<Node>,
    value: u64,
}
``````rust
struct Node {
    children: Vec<Node>,
    value: u64,
}
``````rust
struct Node {
    children: Vec<Node>,
    value: u64,
}
``````rust
struct Node {
    children: Vec<Node>,
    value: u64,
}
```t```rust
struct Node {
    children: Vec<Node>,
    value: u64,
}
```
[import:5-8, lang:"go"](code/go/treetraversal.go)
{% sample lang="asm-x64" %}
[import:24-27, lang:"asm-x64"](code/asm-x64/tree_traversal.s)
{% sample lang="emojic" %}
[import:1-3, lang:"emojicode"](code/emojicode/tree_traversal.emojic)
{% sample lang="lisp" %}
[import:3-3, lang:"lisp"](code/clisp/tree-traversal.lisp)
{% sample lang="m" %}
[import:6-6, lang:"matlab"](code/matlab/tree.m)
{% sample lang="coco" %}
[import:3-3, lang:"coconut"](code/coconut/tree_traversal.coco)
<p>Because of this, the most straightforward way to traverse the tree might be recursive. This naturally leads us to the Depth-First Search (DFS) method:</p>
<pre><code class="language-julia">function DFS_recursive(n::Node)
    # Here we are doing something...
    print(n.ID, &quot; &quot;)

    for child in n.children
        DFS_recursive(child)
    end
end
``````julia
function DFS_recursive(n::Node)
    # Here we are doing something...
    print(n.ID, &quot; &quot;)

    for child in n.children
        DFS_recursive(child)
    end
end
``````julia
function DFS_recursive(n::Node)
    # Here we are doing something...
    print(n.ID, &quot; &quot;)

    for child in n.children
        DFS_recursive(child)
    end
end
```p```julia
function DFS_recursive(n::Node)
    # Here we are doing something...
    print(n.ID, &quot; &quot;)

    for child in n.children
        DFS_recursive(child)
    end
end
``````julia
function DFS_recursive(n::Node)
    # Here we are doing something...
    print(n.ID, &quot; &quot;)

    for child in n.children
        DFS_recursive(child)
    end
end
```s```julia
function DFS_recursive(n::Node)
    # Here we are doing something...
    print(n.ID, &quot; &quot;)

    for child in n.children
        DFS_recursive(child)
    end
end
``````julia
function DFS_recursive(n::Node)
    # Here we are doing something...
    print(n.ID, &quot; &quot;)

    for child in n.children
        DFS_recursive(child)
    end
end
</code></pre>
<p>{% sample lang=&quot;java&quot; %}
<a href="tree_traversal/code/java/Tree.java">import:20-26, lang:&quot;java&quot;</a>
{% sample lang=&quot;js&quot; %}
<a href="tree_traversal/code/javascript/tree.js">import:12-19, lang:&quot;javascript&quot;</a>
{% sample lang=&quot;py&quot; %}
<a href="tree_traversal/code/python/tree_traversal.py">import:17-22, lang:&quot;python&quot;</a>
{% sample lang=&quot;scratch&quot; %}</p>
<p>
  <img  class="center" src="tree_traversal/code/scratch/dfs-pre.svg" style="width:40%" />
</p>
{% sample lang="rs" %}
[import:9-15 lang:"rust"](code/rust/tree.rs)
```haskell
dfs :: Tree a -> [a]
dfs (Node x ts) = x : concatMap dfs ts
``````haskell
dfs :: Tree a -> [a]
dfs (Node x ts) = x : concatMap dfs ts
``````haskell
dfs :: Tree a -> [a]
dfs (Node x ts) = x : concatMap dfs ts
``````haskell
dfs :: Tree a -> [a]
dfs (Node x ts) = x : concatMap dfs ts
``````haskell
dfs :: Tree a -> [a]
dfs (Node x ts) = x : concatMap dfs ts
``````haskell
dfs :: Tree a -> [a]
dfs (Node x ts) = x : concatMap dfs ts
``````haskell
dfs :: Tree a -> [a]
dfs (Node x ts) = x : concatMap dfs ts
``````haskell
dfs :: Tree a -> [a]
dfs (Node x ts) = x : concatMap dfs ts
``````haskell
dfs :: Tree a -> [a]
dfs (Node x ts) = x : concatMap dfs ts
```r```haskell
dfs :: Tree a -> [a]
dfs (Node x ts) = x : concatMap dfs ts
``````haskell
dfs :: Tree a -> [a]
dfs (Node x ts) = x : concatMap dfs ts
```
{% sample lang="asm-x64" %}
[import:290-314, lang:"asm-x64"](code/asm-x64/tree_traversal.s)
{% sample lang="emojic" %}
[import:27-34, lang:"emojicode"](code/emojicode/tree_traversal.emojic)
{% sample lang="lisp" %}
[import:5-10, lang:"lisp"](code/clisp/tree-traversal.lisp)
{% sample lang="m" %}
[import:31-45, lang:"matlab"](code/matlab/tree.m)
{% sample lang="coco" %}
[import:5-9, lang:"coconut"](code/coconut/tree_traversal.coco)
<p>At least to me, this makes a lot of sense. We fight recursion with recursion! First, we first output the node we are on and then we call <code>DFS_recursive(...)</code> on each of its children nodes. This method of tree traversal does what its name implies: it goes to the depths of the tree first before going through the rest of the branches. In this case, the ordering looks like:</p>
<p>
    <img  class="center" src="tree_traversal/res/DFS_pre.png" style="width:70%" />
</p>
<p>Note that the in the code above, we are missing a crucial step: <em>checking to see if the node we are using actually exists!</em> Because we are using a vector to store all the nodes, we will be careful not to run into a case where we call <code>DFS_recursive(...)</code> on a node that has yet to be initialized; however, depending on the language we are using, we might need to be careful of this to avoid recursion errors!</p>
<p>Now, in this case the first element searched through is still the root of the tree. This type of tree traversal is known as <em>pre-order</em> DFS. We perform an action (output the ID) <em>before</em> searching through the children. If we shift the function around and place the data output at the end of the function, we can modify the order in which we search through the tree to be <em>post-order</em> and look something like this:</p>
<pre><code class="language-julia">function DFS_recursive_postorder(n::Node)

    for child in n.children
        DFS_recursive_postorder(child)
    end

    # Here we are doing something...
    print(n.ID, &quot; &quot;)
end
``````julia
function DFS_recursive_postorder(n::Node)

    for child in n.children
        DFS_recursive_postorder(child)
    end

    # Here we are doing something...
    print(n.ID, &quot; &quot;)
end
``````julia
function DFS_recursive_postorder(n::Node)

    for child in n.children
        DFS_recursive_postorder(child)
    end

    # Here we are doing something...
    print(n.ID, &quot; &quot;)
end
```p```julia
function DFS_recursive_postorder(n::Node)

    for child in n.children
        DFS_recursive_postorder(child)
    end

    # Here we are doing something...
    print(n.ID, &quot; &quot;)
end
``````julia
function DFS_recursive_postorder(n::Node)

    for child in n.children
        DFS_recursive_postorder(child)
    end

    # Here we are doing something...
    print(n.ID, &quot; &quot;)
end
```s```julia
function DFS_recursive_postorder(n::Node)

    for child in n.children
        DFS_recursive_postorder(child)
    end

    # Here we are doing something...
    print(n.ID, &quot; &quot;)
end
``````julia
function DFS_recursive_postorder(n::Node)

    for child in n.children
        DFS_recursive_postorder(child)
    end

    # Here we are doing something...
    print(n.ID, &quot; &quot;)
end
</code></pre>
<p>{% sample lang=&quot;java&quot; %}
<a href="tree_traversal/code/java/Tree.java">import:33-40, lang:&quot;java&quot;</a>
{% sample lang=&quot;js&quot; %}
<a href="tree_traversal/code/javascript/tree.js">import:21-28, lang:&quot;javascript&quot;</a>
{% sample lang=&quot;py&quot; %}
<a href="tree_traversal/code/python/tree_traversal.py">import:25-30, lang:&quot;python&quot;</a>
{% sample lang=&quot;scratch&quot; %}</p>
<p>
  <img  class="center" src="tree_traversal/code/scratch/dfs-post.svg" style="width:40%" />
</p>
```rust
fn dfs_recursive_postorder(n: &Node) {
    for child in &n.children {
        dfs_recursive_postorder(child);
    }
<pre><code>print!(&quot;{} &quot;, n.value);
</code></pre>
<p>}</p>
<pre><pre class="playground"><code class="language-rust">fn dfs_recursive_postorder(n: &amp;Node) {
    for child in &amp;n.children {
        dfs_recursive_postorder(child);
    }

    print!(&quot;{} &quot;, n.value);
}

``````rust
fn dfs_recursive_postorder(n: &amp;Node) {
    for child in &amp;n.children {
        dfs_recursive_postorder(child);
    }

    print!(&quot;{} &quot;, n.value);
}

```v```rust
fn dfs_recursive_postorder(n: &amp;Node) {
    for child in &amp;n.children {
        dfs_recursive_postorder(child);
    }

    print!(&quot;{} &quot;, n.value);
}

``````rust
fn dfs_recursive_postorder(n: &amp;Node) {
    for child in &amp;n.children {
        dfs_recursive_postorder(child);
    }

    print!(&quot;{} &quot;, n.value);
}

``````rust
fn dfs_recursive_postorder(n: &amp;Node) {
    for child in &amp;n.children {
        dfs_recursive_postorder(child);
    }

    print!(&quot;{} &quot;, n.value);
}

``````rust
fn dfs_recursive_postorder(n: &amp;Node) {
    for child in &amp;n.children {
        dfs_recursive_postorder(child);
    }

    print!(&quot;{} &quot;, n.value);
}

```p```rust
fn dfs_recursive_postorder(n: &amp;Node) {
    for child in &amp;n.children {
        dfs_recursive_postorder(child);
    }

    print!(&quot;{} &quot;, n.value);
}

``````rust
fn dfs_recursive_postorder(n: &amp;Node) {
    for child in &amp;n.children {
        dfs_recursive_postorder(child);
    }

    print!(&quot;{} &quot;, n.value);
}

``````rust
fn dfs_recursive_postorder(n: &amp;Node) {
    for child in &amp;n.children {
        dfs_recursive_postorder(child);
    }

    print!(&quot;{} &quot;, n.value);
}

``````rust
fn dfs_recursive_postorder(n: &amp;Node) {
    for child in &amp;n.children {
        dfs_recursive_postorder(child);
    }

    print!(&quot;{} &quot;, n.value);
}

```ree_traversal.st)
{% sample lang=&quot;go&quot; %}
[import:17-22, lang:&quot;go&quot;](code/go/treetraversal.go)
{% sample lang=&quot;asm-x64&quot; %}
[import:316-344, lang:&quot;asm-x64&quot;](code/asm-x64/tree_traversal.s)
{% sample lang=&quot;emojic&quot; %}
[import:36-43, lang:&quot;emojicode&quot;](code/emojicode/tree_traversal.emojic)
{% sample lang=&quot;lisp&quot; %}
[import:12-17, lang:&quot;lisp&quot;](code/clisp/tree-traversal.lisp)
{% sample lang=&quot;m&quot; %}
[import:47-62, lang:&quot;matlab&quot;](code/matlab/tree.m)
{% sample lang=&quot;coco&quot; %}
[import:11-15, lang:=&quot;coconut&quot;](code/coconut/tree_traversal.coco)


&lt;p&gt;
    &lt;img  class=&quot;center&quot; src=&quot;res/DFS_post.png&quot; style=&quot;width:70%&quot; /&gt;
&lt;/p&gt;

In this case, the first node visited is at the bottom of the tree and moves up the tree branch by branch. In addition to these two types, binary trees have an *in-order* traversal scheme that looks something like this:


```julia
<span class="boring">This assumes only 2 children, but accounts for other possibilities
</span>function DFS_recursive_inorder_btree(n::Node)

    if (length(n.children) == 2)
        DFS_recursive_inorder_btree(n.children[1])
        print(n.ID, &quot; &quot;)
        DFS_recursive_inorder_btree(n.children[2])
    elseif (length(n.children) == 1)
        DFS_recursive_inorder_btree(n.children[1])
        print(n.ID, &quot; &quot;)
    elseif (length(n.children) == 0)
        print(n.ID, &quot; &quot;)
    else
        println(&quot;Not a binary tree!&quot;)
    end
end
```
{% sample lang=&quot;cpp&quot; %}
[import:34-52 lang:&quot;cpp&quot;](code/cpp/tree_example.cpp)
```csharp
        public void DFSRecursiveInorderBinary()
        {
            DFSRecursiveInorderBinary(this);

            void DFSRecursiveInorderBinary(Tree tree)
            {
                switch (tree._children.Count)
                {
                    case 2:
                        DFSRecursiveInorderBinary(tree._children[0]);
                        Console.Write(tree.Id + &quot; &quot;);
                        DFSRecursiveInorderBinary(tree._children[1]);
                        break;
                    case 1:
                        DFSRecursiveInorderBinary(tree._children[0]);
                        Console.Write(tree.Id + &quot; &quot;);
                        break;
                    case 0:
                        Console.Write(tree.Id + &quot; &quot;);
                        break;
                    default:
                        throw new Exception(&quot;Not binary tree!&quot;);
                }
            }
        }
``````csharp
        public void DFSRecursiveInorderBinary()
        {
            DFSRecursiveInorderBinary(this);

            void DFSRecursiveInorderBinary(Tree tree)
            {
                switch (tree._children.Count)
                {
                    case 2:
                        DFSRecursiveInorderBinary(tree._children[0]);
                        Console.Write(tree.Id + &quot; &quot;);
                        DFSRecursiveInorderBinary(tree._children[1]);
                        break;
                    case 1:
                        DFSRecursiveInorderBinary(tree._children[0]);
                        Console.Write(tree.Id + &quot; &quot;);
                        break;
                    case 0:
                        Console.Write(tree.Id + &quot; &quot;);
                        break;
                    default:
                        throw new Exception(&quot;Not binary tree!&quot;);
                }
            }
        }
``````csharp
        public void DFSRecursiveInorderBinary()
        {
            DFSRecursiveInorderBinary(this);

            void DFSRecursiveInorderBinary(Tree tree)
            {
                switch (tree._children.Count)
                {
                    case 2:
                        DFSRecursiveInorderBinary(tree._children[0]);
                        Console.Write(tree.Id + &quot; &quot;);
                        DFSRecursiveInorderBinary(tree._children[1]);
                        break;
                    case 1:
                        DFSRecursiveInorderBinary(tree._children[0]);
                        Console.Write(tree.Id + &quot; &quot;);
                        break;
                    case 0:
                        Console.Write(tree.Id + &quot; &quot;);
                        break;
                    default:
                        throw new Exception(&quot;Not binary tree!&quot;);
                }
            }
        }
```)```csharp
        public void DFSRecursiveInorderBinary()
        {
            DFSRecursiveInorderBinary(this);

            void DFSRecursiveInorderBinary(Tree tree)
            {
                switch (tree._children.Count)
                {
                    case 2:
                        DFSRecursiveInorderBinary(tree._children[0]);
                        Console.Write(tree.Id + &quot; &quot;);
                        DFSRecursiveInorderBinary(tree._children[1]);
                        break;
                    case 1:
                        DFSRecursiveInorderBinary(tree._children[0]);
                        Console.Write(tree.Id + &quot; &quot;);
                        break;
                    case 0:
                        Console.Write(tree.Id + &quot; &quot;);
                        break;
                    default:
                        throw new Exception(&quot;Not binary tree!&quot;);
                }
            }
        }
``````csharp
        public void DFSRecursiveInorderBinary()
        {
            DFSRecursiveInorderBinary(this);

            void DFSRecursiveInorderBinary(Tree tree)
            {
                switch (tree._children.Count)
                {
                    case 2:
                        DFSRecursiveInorderBinary(tree._children[0]);
                        Console.Write(tree.Id + &quot; &quot;);
                        DFSRecursiveInorderBinary(tree._children[1]);
                        break;
                    case 1:
                        DFSRecursiveInorderBinary(tree._children[0]);
                        Console.Write(tree.Id + &quot; &quot;);
                        break;
                    case 0:
                        Console.Write(tree.Id + &quot; &quot;);
                        break;
                    default:
                        throw new Exception(&quot;Not binary tree!&quot;);
                }
            }
        }
```
{% sample lang=&quot;js&quot; %}
[import:30-51, lang:&quot;javascript&quot;](code/javascript/tree.js)
{% sample lang=&quot;py&quot; %}
[import:34-45, lang:&quot;python&quot;](code/python/tree_traversal.py)
{% sample lang=&quot;scratch&quot; %}
&lt;p&gt;
  &lt;img  class=&quot;center&quot; src=&quot;code/scratch/dfs-in.svg&quot; style=&quot;width:40%&quot; /&gt;
&lt;/p&gt;
```rust
fn dfs_recursive_inorder_btree(n: &amp;Node) {
    match &amp;n.children[..] {
        [left, right] =&gt; {
            dfs_recursive_inorder_btree(left);
            print!(&quot;{} &quot;, n.value);
            dfs_recursive_inorder_btree(right);
        }
        [left] =&gt; {
            dfs_recursive_inorder_btree(left);
            print!(&quot;{} &quot;, n.value);
        }
        [] =&gt; print!(&quot;{} &quot;, n.value),
        _ =&gt; print!(&quot;This is not a binary tree. &quot;),
    }
}

``````rust
fn dfs_recursive_inorder_btree(n: &amp;Node) {
    match &amp;n.children[..] {
        [left, right] =&gt; {
            dfs_recursive_inorder_btree(left);
            print!(&quot;{} &quot;, n.value);
            dfs_recursive_inorder_btree(right);
        }
        [left] =&gt; {
            dfs_recursive_inorder_btree(left);
            print!(&quot;{} &quot;, n.value);
        }
        [] =&gt; print!(&quot;{} &quot;, n.value),
        _ =&gt; print!(&quot;This is not a binary tree. &quot;),
    }
}

``````rust
fn dfs_recursive_inorder_btree(n: &amp;Node) {
    match &amp;n.children[..] {
        [left, right] =&gt; {
            dfs_recursive_inorder_btree(left);
            print!(&quot;{} &quot;, n.value);
            dfs_recursive_inorder_btree(right);
        }
        [left] =&gt; {
            dfs_recursive_inorder_btree(left);
            print!(&quot;{} &quot;, n.value);
        }
        [] =&gt; print!(&quot;{} &quot;, n.value),
        _ =&gt; print!(&quot;This is not a binary tree. &quot;),
    }
}

```v```rust
fn dfs_recursive_inorder_btree(n: &amp;Node) {
    match &amp;n.children[..] {
        [left, right] =&gt; {
            dfs_recursive_inorder_btree(left);
            print!(&quot;{} &quot;, n.value);
            dfs_recursive_inorder_btree(right);
        }
        [left] =&gt; {
            dfs_recursive_inorder_btree(left);
            print!(&quot;{} &quot;, n.value);
        }
        [] =&gt; print!(&quot;{} &quot;, n.value),
        _ =&gt; print!(&quot;This is not a binary tree. &quot;),
    }
}

``````rust
fn dfs_recursive_inorder_btree(n: &amp;Node) {
    match &amp;n.children[..] {
        [left, right] =&gt; {
            dfs_recursive_inorder_btree(left);
            print!(&quot;{} &quot;, n.value);
            dfs_recursive_inorder_btree(right);
        }
        [left] =&gt; {
            dfs_recursive_inorder_btree(left);
            print!(&quot;{} &quot;, n.value);
        }
        [] =&gt; print!(&quot;{} &quot;, n.value),
        _ =&gt; print!(&quot;This is not a binary tree. &quot;),
    }
}

``````rust
fn dfs_recursive_inorder_btree(n: &amp;Node) {
    match &amp;n.children[..] {
        [left, right] =&gt; {
            dfs_recursive_inorder_btree(left);
            print!(&quot;{} &quot;, n.value);
            dfs_recursive_inorder_btree(right);
        }
        [left] =&gt; {
            dfs_recursive_inorder_btree(left);
            print!(&quot;{} &quot;, n.value);
        }
        [] =&gt; print!(&quot;{} &quot;, n.value),
        _ =&gt; print!(&quot;This is not a binary tree. &quot;),
    }
}

``````rust
fn dfs_recursive_inorder_btree(n: &amp;Node) {
    match &amp;n.children[..] {
        [left, right] =&gt; {
            dfs_recursive_inorder_btree(left);
            print!(&quot;{} &quot;, n.value);
            dfs_recursive_inorder_btree(right);
        }
        [left] =&gt; {
            dfs_recursive_inorder_btree(left);
            print!(&quot;{} &quot;, n.value);
        }
        [] =&gt; print!(&quot;{} &quot;, n.value),
        _ =&gt; print!(&quot;This is not a binary tree. &quot;),
    }
}

```p```rust
fn dfs_recursive_inorder_btree(n: &amp;Node) {
    match &amp;n.children[..] {
        [left, right] =&gt; {
            dfs_recursive_inorder_btree(left);
            print!(&quot;{} &quot;, n.value);
            dfs_recursive_inorder_btree(right);
        }
        [left] =&gt; {
            dfs_recursive_inorder_btree(left);
            print!(&quot;{} &quot;, n.value);
        }
        [] =&gt; print!(&quot;{} &quot;, n.value),
        _ =&gt; print!(&quot;This is not a binary tree. &quot;),
    }
}

``````rust
fn dfs_recursive_inorder_btree(n: &amp;Node) {
    match &amp;n.children[..] {
        [left, right] =&gt; {
            dfs_recursive_inorder_btree(left);
            print!(&quot;{} &quot;, n.value);
            dfs_recursive_inorder_btree(right);
        }
        [left] =&gt; {
            dfs_recursive_inorder_btree(left);
            print!(&quot;{} &quot;, n.value);
        }
        [] =&gt; print!(&quot;{} &quot;, n.value),
        _ =&gt; print!(&quot;This is not a binary tree. &quot;),
    }
}

``````rust
fn dfs_recursive_inorder_btree(n: &amp;Node) {
    match &amp;n.children[..] {
        [left, right] =&gt; {
            dfs_recursive_inorder_btree(left);
            print!(&quot;{} &quot;, n.value);
            dfs_recursive_inorder_btree(right);
        }
        [left] =&gt; {
            dfs_recursive_inorder_btree(left);
            print!(&quot;{} &quot;, n.value);
        }
        [] =&gt; print!(&quot;{} &quot;, n.value),
        _ =&gt; print!(&quot;This is not a binary tree. &quot;),
    }
}

``````rust
fn dfs_recursive_inorder_btree(n: &amp;Node) {
    match &amp;n.children[..] {
        [left, right] =&gt; {
            dfs_recursive_inorder_btree(left);
            print!(&quot;{} &quot;, n.value);
            dfs_recursive_inorder_btree(right);
        }
        [left] =&gt; {
            dfs_recursive_inorder_btree(left);
            print!(&quot;{} &quot;, n.value);
        }
        [] =&gt; print!(&quot;{} &quot;, n.value),
        _ =&gt; print!(&quot;This is not a binary tree. &quot;),
    }
}

```r```rust
fn dfs_recursive_inorder_btree(n: &amp;Node) {
    match &amp;n.children[..] {
        [left, right] =&gt; {
            dfs_recursive_inorder_btree(left);
            print!(&quot;{} &quot;, n.value);
            dfs_recursive_inorder_btree(right);
        }
        [left] =&gt; {
            dfs_recursive_inorder_btree(left);
            print!(&quot;{} &quot;, n.value);
        }
        [] =&gt; print!(&quot;{} &quot;, n.value),
        _ =&gt; print!(&quot;This is not a binary tree. &quot;),
    }
}

```
[import:24-38, lang:&quot;go&quot;](code/go/treetraversal.go)
{% sample lang=&quot;asm-x64&quot; %}
[import:346-396, lang:&quot;asm-x64&quot;](code/asm-x64/tree_traversal.s)
{% sample lang=&quot;emojic&quot; %}
[import:45-62, lang:&quot;emojicode&quot;](code/emojicode/tree_traversal.emojic)
{% sample lang=&quot;lisp&quot; %}
[import:19-32, lang:&quot;lisp&quot;](code/clisp/tree-traversal.lisp)
{% sample lang=&quot;m&quot; %}
[import:64-82, lang:&quot;matlab&quot;](code/matlab/tree.m)
{% sample lang=&quot;coco&quot; %}
[import:17-30, lang:&quot;coconut&quot;](code/coconut/tree_traversal.coco)


&lt;p&gt;
    &lt;img  class=&quot;center&quot; src=&quot;res/DFS_in.png&quot; width=&quot;500&quot; /&gt;
&lt;/p&gt;

The order here seems to be some mix of the other 2 methods and works through the binary tree from left to right.

Now, at this point, it might seem that the only way to search through a recursive data structure is with recursion, but this is not necessarily the case! Rather surprisingly, we can perform a DFS non-recursively by using a stack, which are data structures that hold multiple elements, but only allow you to interact with the very last element you put in. The idea here is simple:

1. Put the root node in the stack
2. Take it out and put in its children
3. Pop the top of the stack and put its children in
4. Repeat 3 until the stack is empty

In code, it looks like this:


```julia
function DFS_stack(n::Node)
    s = Stack{Node}()
    push!(s, n)

    while(length(s) &gt; 0)
        print(top(s).ID, &quot; &quot;)
        temp = pop!(s)
        for child in temp.children
            push!(s, child)
        end
    end
end
``````julia
function DFS_stack(n::Node)
    s = Stack{Node}()
    push!(s, n)

    while(length(s) &gt; 0)
        print(top(s).ID, &quot; &quot;)
        temp = pop!(s)
        for child in temp.children
            push!(s, child)
        end
    end
end
``````julia
function DFS_stack(n::Node)
    s = Stack{Node}()
    push!(s, n)

    while(length(s) &gt; 0)
        print(top(s).ID, &quot; &quot;)
        temp = pop!(s)
        for child in temp.children
            push!(s, child)
        end
    end
end
```p```julia
function DFS_stack(n::Node)
    s = Stack{Node}()
    push!(s, n)

    while(length(s) &gt; 0)
        print(top(s).ID, &quot; &quot;)
        temp = pop!(s)
        for child in temp.children
            push!(s, child)
        end
    end
end
``````julia
function DFS_stack(n::Node)
    s = Stack{Node}()
    push!(s, n)

    while(length(s) &gt; 0)
        print(top(s).ID, &quot; &quot;)
        temp = pop!(s)
        for child in temp.children
            push!(s, child)
        end
    end
end
```s```julia
function DFS_stack(n::Node)
    s = Stack{Node}()
    push!(s, n)

    while(length(s) &gt; 0)
        print(top(s).ID, &quot; &quot;)
        temp = pop!(s)
        for child in temp.children
            push!(s, child)
        end
    end
end
``````julia
function DFS_stack(n::Node)
    s = Stack{Node}()
    push!(s, n)

    while(length(s) &gt; 0)
        print(top(s).ID, &quot; &quot;)
        temp = pop!(s)
        for child in temp.children
            push!(s, child)
        end
    end
end
```
{% sample lang=&quot;java&quot; %}
[import:67-81, lang:&quot;java&quot;](code/java/Tree.java)
{% sample lang=&quot;js&quot; %}
[import:53-60, lang:&quot;javascript&quot;](code/javascript/tree.js)
{% sample lang=&quot;py&quot; %}
[import:48-59, lang:&quot;python&quot;](code/python/tree_traversal.py)
{% sample lang=&quot;scratch&quot; %}
&lt;p&gt;
  &lt;img  class=&quot;center&quot; src=&quot;code/scratch/dfs-stack.svg&quot; style=&quot;width:70%&quot; /&gt;
&lt;/p&gt;
```rust
fn dfs_stack(n: &amp;Node) {
    let mut stack = vec![n];

    while let Some(current) = stack.pop() {
        print!(&quot;{} &quot;, current.value);
        stack.extend(&amp;current.children);
    }
}
``````rust
fn dfs_stack(n: &amp;Node) {
    let mut stack = vec![n];

    while let Some(current) = stack.pop() {
        print!(&quot;{} &quot;, current.value);
        stack.extend(&amp;current.children);
    }
}
``````rust
fn dfs_stack(n: &amp;Node) {
    let mut stack = vec![n];

    while let Some(current) = stack.pop() {
        print!(&quot;{} &quot;, current.value);
        stack.extend(&amp;current.children);
    }
}
```v```rust
fn dfs_stack(n: &amp;Node) {
    let mut stack = vec![n];

    while let Some(current) = stack.pop() {
        print!(&quot;{} &quot;, current.value);
        stack.extend(&amp;current.children);
    }
}
``````rust
fn dfs_stack(n: &amp;Node) {
    let mut stack = vec![n];

    while let Some(current) = stack.pop() {
        print!(&quot;{} &quot;, current.value);
        stack.extend(&amp;current.children);
    }
}
``````rust
fn dfs_stack(n: &amp;Node) {
    let mut stack = vec![n];

    while let Some(current) = stack.pop() {
        print!(&quot;{} &quot;, current.value);
        stack.extend(&amp;current.children);
    }
}
``````rust
fn dfs_stack(n: &amp;Node) {
    let mut stack = vec![n];

    while let Some(current) = stack.pop() {
        print!(&quot;{} &quot;, current.value);
        stack.extend(&amp;current.children);
    }
}
```p```rust
fn dfs_stack(n: &amp;Node) {
    let mut stack = vec![n];

    while let Some(current) = stack.pop() {
        print!(&quot;{} &quot;, current.value);
        stack.extend(&amp;current.children);
    }
}
``````rust
fn dfs_stack(n: &amp;Node) {
    let mut stack = vec![n];

    while let Some(current) = stack.pop() {
        print!(&quot;{} &quot;, current.value);
        stack.extend(&amp;current.children);
    }
}
``````rust
fn dfs_stack(n: &amp;Node) {
    let mut stack = vec![n];

    while let Some(current) = stack.pop() {
        print!(&quot;{} &quot;, current.value);
        stack.extend(&amp;current.children);
    }
}
``````rust
fn dfs_stack(n: &amp;Node) {
    let mut stack = vec![n];

    while let Some(current) = stack.pop() {
        print!(&quot;{} &quot;, current.value);
        stack.extend(&amp;current.children);
    }
}
```e```rust
fn dfs_stack(n: &amp;Node) {
    let mut stack = vec![n];

    while let Some(current) = stack.pop() {
        print!(&quot;{} &quot;, current.value);
        stack.extend(&amp;current.children);
    }
}
```
[import:40-49, lang:&quot;go&quot;](code/go/treetraversal.go)
{% sample lang=&quot;asm-x64&quot; %}
[import:398-445, lang:&quot;asm-x64&quot;](code/asm-x64/tree_traversal.s)
{% sample lang=&quot;emojic&quot; %}
[import:64-79, lang:&quot;emojicode&quot;](code/emojicode/tree_traversal.emojic)
{% sample lang=&quot;lisp&quot; %}
[import:34-43, lang:&quot;lisp&quot;](code/clisp/tree-traversal.lisp)
{% sample lang=&quot;m&quot; %}
[import:84-106, lang:&quot;matlab&quot;](code/matlab/tree.m)
{% sample lang=&quot;coco&quot; %}
[import:32-39, lang:&quot;coconut&quot;](code/coconut/tree_traversal.coco)


All this said, there are a few details about DFS that might not be ideal, depending on the situation. For example, if we use DFS on an incredibly long tree, we will spend a lot of time going further and further down a single branch without searching the rest of the data structure. In addition, it is not the natural way humans would order a tree if asked to number all the nodes from top to bottom. I would argue a more natural traversal order would look something like this:

&lt;p&gt;
    &lt;img  class=&quot;center&quot; src=&quot;res/BFS_simple.png&quot; style=&quot;width:70%&quot; /&gt;
&lt;/p&gt;

And this is exactly what Breadth-First Search (BFS) does! On top of that, it can be implemented in the same way as the `DFS_stack(...)` function above, simply by swapping the `stack` for a `queue`, which is similar to a stack, except that it only allows you to interact with the very first element instead of the last. In code, this looks something like:


```julia
function BFS_queue(n::Node)
    q = Queue{Node}()
    enqueue!(q, n)

    while(length(q) &gt; 0)
        print(first(q).ID, &quot; &quot;)
        temp = dequeue!(q)
        for child in temp.children
            enqueue!(q, child)
        end
    end
end
``````julia
function BFS_queue(n::Node)
    q = Queue{Node}()
    enqueue!(q, n)

    while(length(q) &gt; 0)
        print(first(q).ID, &quot; &quot;)
        temp = dequeue!(q)
        for child in temp.children
            enqueue!(q, child)
        end
    end
end
``````julia
function BFS_queue(n::Node)
    q = Queue{Node}()
    enqueue!(q, n)

    while(length(q) &gt; 0)
        print(first(q).ID, &quot; &quot;)
        temp = dequeue!(q)
        for child in temp.children
            enqueue!(q, child)
        end
    end
end
```)```julia
function BFS_queue(n::Node)
    q = Queue{Node}()
    enqueue!(q, n)

    while(length(q) &gt; 0)
        print(first(q).ID, &quot; &quot;)
        temp = dequeue!(q)
        for child in temp.children
            enqueue!(q, child)
        end
    end
end
``````julia
function BFS_queue(n::Node)
    q = Queue{Node}()
    enqueue!(q, n)

    while(length(q) &gt; 0)
        print(first(q).ID, &quot; &quot;)
        temp = dequeue!(q)
        for child in temp.children
            enqueue!(q, child)
        end
    end
end
```.```julia
function BFS_queue(n::Node)
    q = Queue{Node}()
    enqueue!(q, n)

    while(length(q) &gt; 0)
        print(first(q).ID, &quot; &quot;)
        temp = dequeue!(q)
        for child in temp.children
            enqueue!(q, child)
        end
    end
end
``````julia
function BFS_queue(n::Node)
    q = Queue{Node}()
    enqueue!(q, n)

    while(length(q) &gt; 0)
        print(first(q).ID, &quot; &quot;)
        temp = dequeue!(q)
        for child in temp.children
            enqueue!(q, child)
        end
    end
end
```
{% sample lang=&quot;java&quot; %}
[import:83-97, lang:&quot;java&quot;](code/java/Tree.java)
{% sample lang=&quot;js&quot; %}
[import:62-69, lang:&quot;javascript&quot;](code/javascript/tree.js)
{% sample lang=&quot;py&quot; %}
[import:62-72, lang:&quot;python&quot;](code/python/tree_traversal.py)
{% sample lang=&quot;scratch&quot; %}
&lt;p&gt;
  &lt;img  class=&quot;center&quot; src=&quot;code/scratch/bfs.svg&quot; style=&quot;width:70%&quot; /&gt;
&lt;/p&gt;
```rust
fn bfs_queue(n: &amp;Node) {
    let mut queue = VecDeque::new();
    queue.push_back(n);

    while let Some(current) = queue.pop_front() {
        print!(&quot;{} &quot;, current.value);
        queue.extend(&amp;current.children);
    }
}
``````rust
fn bfs_queue(n: &amp;Node) {
    let mut queue = VecDeque::new();
    queue.push_back(n);

    while let Some(current) = queue.pop_front() {
        print!(&quot;{} &quot;, current.value);
        queue.extend(&amp;current.children);
    }
}
``````rust
fn bfs_queue(n: &amp;Node) {
    let mut queue = VecDeque::new();
    queue.push_back(n);

    while let Some(current) = queue.pop_front() {
        print!(&quot;{} &quot;, current.value);
        queue.extend(&amp;current.children);
    }
}
```v```rust
fn bfs_queue(n: &amp;Node) {
    let mut queue = VecDeque::new();
    queue.push_back(n);

    while let Some(current) = queue.pop_front() {
        print!(&quot;{} &quot;, current.value);
        queue.extend(&amp;current.children);
    }
}
``````rust
fn bfs_queue(n: &amp;Node) {
    let mut queue = VecDeque::new();
    queue.push_back(n);

    while let Some(current) = queue.pop_front() {
        print!(&quot;{} &quot;, current.value);
        queue.extend(&amp;current.children);
    }
}
``````rust
fn bfs_queue(n: &amp;Node) {
    let mut queue = VecDeque::new();
    queue.push_back(n);

    while let Some(current) = queue.pop_front() {
        print!(&quot;{} &quot;, current.value);
        queue.extend(&amp;current.children);
    }
}
``````rust
fn bfs_queue(n: &amp;Node) {
    let mut queue = VecDeque::new();
    queue.push_back(n);

    while let Some(current) = queue.pop_front() {
        print!(&quot;{} &quot;, current.value);
        queue.extend(&amp;current.children);
    }
}
```.```rust
fn bfs_queue(n: &amp;Node) {
    let mut queue = VecDeque::new();
    queue.push_back(n);

    while let Some(current) = queue.pop_front() {
        print!(&quot;{} &quot;, current.value);
        queue.extend(&amp;current.children);
    }
}
``````rust
fn bfs_queue(n: &amp;Node) {
    let mut queue = VecDeque::new();
    queue.push_back(n);

    while let Some(current) = queue.pop_front() {
        print!(&quot;{} &quot;, current.value);
        queue.extend(&amp;current.children);
    }
}
``````rust
fn bfs_queue(n: &amp;Node) {
    let mut queue = VecDeque::new();
    queue.push_back(n);

    while let Some(current) = queue.pop_front() {
        print!(&quot;{} &quot;, current.value);
        queue.extend(&amp;current.children);
    }
}
``````rust
fn bfs_queue(n: &amp;Node) {
    let mut queue = VecDeque::new();
    queue.push_back(n);

    while let Some(current) = queue.pop_front() {
        print!(&quot;{} &quot;, current.value);
        queue.extend(&amp;current.children);
    }
}
```e```rust
fn bfs_queue(n: &amp;Node) {
    let mut queue = VecDeque::new();
    queue.push_back(n);

    while let Some(current) = queue.pop_front() {
        print!(&quot;{} &quot;, current.value);
        queue.extend(&amp;current.children);
    }
}
```
[import:51-60, lang:&quot;go&quot;](code/go/treetraversal.go)
{% sample lang=&quot;asm-x64&quot; %}
[import:447-498, lang:&quot;asm-x64&quot;](code/asm-x64/tree_traversal.s)
{% sample lang=&quot;emojic&quot; %}
[import:81-96, lang:&quot;emojicode&quot;](code/emojicode/tree_traversal.emojic)
{% sample lang=&quot;lisp&quot; %}
[import:45-56, lang:&quot;lisp&quot;](code/clisp/tree-traversal.lisp)
{% sample lang=&quot;m&quot; %}
[import:108-129, lang:&quot;matlab&quot;](code/matlab/tree.m)
{% sample lang=&quot;coco&quot; %}
[import:41-48, lang:&quot;coconut&quot;](code/coconut/tree_traversal.coco)


# Video Explanation

Here is a video describing tree traversal:

&lt;div style=&quot;text-align:center&quot;&gt;
&lt;iframe width=&quot;560&quot; height=&quot;315&quot; src=&quot;https://www.youtube.com/embed/cZPXfl_tUkA&quot; frameborder=&quot;0&quot; allow=&quot;accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture&quot; allowfullscreen&gt;&lt;/iframe&gt;
&lt;/div&gt;

# Example Code

```julia
using DataStructures, Printf

struct Node
    children::Vector{Node}
    ID::Int64
    Node(ID::Int64) = new(Vector{Node}(), ID)
end

function DFS_recursive(n::Node)
<span class="boring">    Here we are doing something...
</span>    print(n.ID, &quot; &quot;)

    for child in n.children
        DFS_recursive(child)
    end
end

function DFS_recursive_postorder(n::Node)

    for child in n.children
        DFS_recursive_postorder(child)
    end

<span class="boring">    Here we are doing something...
</span>    print(n.ID, &quot; &quot;)
end

<span class="boring">This assumes only 2 children, but accounts for other possibilities
</span>function DFS_recursive_inorder_btree(n::Node)

    if (length(n.children) == 2)
        DFS_recursive_inorder_btree(n.children[1])
        print(n.ID, &quot; &quot;)
        DFS_recursive_inorder_btree(n.children[2])
    elseif (length(n.children) == 1)
        DFS_recursive_inorder_btree(n.children[1])
        print(n.ID, &quot; &quot;)
    elseif (length(n.children) == 0)
        print(n.ID, &quot; &quot;)
    else
        println(&quot;Not a binary tree!&quot;)
    end
end

function DFS_stack(n::Node)
    s = Stack{Node}()
    push!(s, n)

    while(length(s) &gt; 0)
        print(top(s).ID, &quot; &quot;)
        temp = pop!(s)
        for child in temp.children
            push!(s, child)
        end
    end
end

function BFS_queue(n::Node)
    q = Queue{Node}()
    enqueue!(q, n)

    while(length(q) &gt; 0)
        print(first(q).ID, &quot; &quot;)
        temp = dequeue!(q)
        for child in temp.children
            enqueue!(q, child)
        end
    end
end

<span class="boring">function to create a simple, balanced tree
</span>function create_tree(num_row::Int64, num_child::Int64)
    ret = Node(num_row)
    if (num_row == 0)
        return ret
    end

    for i = 1:num_child
        child = create_tree(num_row - 1, num_child)
        push!(ret.children, child)
    end

    return ret
end

function main()
    root = create_tree(2, 3)

    println(&quot;[#]\nRecursive DFS:&quot;)
    DFS_recursive(root);
    println()

    println(&quot;[#]\nRecursive Postorder DFS:&quot;)
    DFS_recursive_postorder(root);
    println()

    println(&quot;[#]\nStack-based DFS:&quot;)
    DFS_stack(root);
    println()

    println(&quot;[#]\nQueue-based BFS:&quot;)
    BFS_queue(root);
    println()

    root_binary = create_tree(3,2)
    println(&quot;[#]\nRecursive Inorder DFS for Binary Tree:&quot;)
    DFS_recursive_inorder_btree(root_binary)
    println()
end

main()
``````julia
using DataStructures, Printf

struct Node
    children::Vector{Node}
    ID::Int64
    Node(ID::Int64) = new(Vector{Node}(), ID)
end

function DFS_recursive(n::Node)
<span class="boring">    Here we are doing something...
</span>    print(n.ID, &quot; &quot;)

    for child in n.children
        DFS_recursive(child)
    end
end

function DFS_recursive_postorder(n::Node)

    for child in n.children
        DFS_recursive_postorder(child)
    end

<span class="boring">    Here we are doing something...
</span>    print(n.ID, &quot; &quot;)
end

<span class="boring">This assumes only 2 children, but accounts for other possibilities
</span>function DFS_recursive_inorder_btree(n::Node)

    if (length(n.children) == 2)
        DFS_recursive_inorder_btree(n.children[1])
        print(n.ID, &quot; &quot;)
        DFS_recursive_inorder_btree(n.children[2])
    elseif (length(n.children) == 1)
        DFS_recursive_inorder_btree(n.children[1])
        print(n.ID, &quot; &quot;)
    elseif (length(n.children) == 0)
        print(n.ID, &quot; &quot;)
    else
        println(&quot;Not a binary tree!&quot;)
    end
end

function DFS_stack(n::Node)
    s = Stack{Node}()
    push!(s, n)

    while(length(s) &gt; 0)
        print(top(s).ID, &quot; &quot;)
        temp = pop!(s)
        for child in temp.children
            push!(s, child)
        end
    end
end

function BFS_queue(n::Node)
    q = Queue{Node}()
    enqueue!(q, n)

    while(length(q) &gt; 0)
        print(first(q).ID, &quot; &quot;)
        temp = dequeue!(q)
        for child in temp.children
            enqueue!(q, child)
        end
    end
end

<span class="boring">function to create a simple, balanced tree
</span>function create_tree(num_row::Int64, num_child::Int64)
    ret = Node(num_row)
    if (num_row == 0)
        return ret
    end

    for i = 1:num_child
        child = create_tree(num_row - 1, num_child)
        push!(ret.children, child)
    end

    return ret
end

function main()
    root = create_tree(2, 3)

    println(&quot;[#]\nRecursive DFS:&quot;)
    DFS_recursive(root);
    println()

    println(&quot;[#]\nRecursive Postorder DFS:&quot;)
    DFS_recursive_postorder(root);
    println()

    println(&quot;[#]\nStack-based DFS:&quot;)
    DFS_stack(root);
    println()

    println(&quot;[#]\nQueue-based BFS:&quot;)
    BFS_queue(root);
    println()

    root_binary = create_tree(3,2)
    println(&quot;[#]\nRecursive Inorder DFS for Binary Tree:&quot;)
    DFS_recursive_inorder_btree(root_binary)
    println()
end

main()
```
[import, lang:&quot;cpp&quot;](code/cpp/tree_example.cpp)
{% sample lang=&quot;cs&quot; %}
#### Tree.cs
[import, lang:&quot;csharp&quot;](code/csharp/Tree.cs)
#### Program.cs
[import, lang:&quot;csharp&quot;](code/csharp/Program.cs)
{% sample lang=&quot;c&quot; %}
#### utility.h
[import, lang:&quot;c&quot;](code/c/utility.h)
#### tree_traversal.c
[import, lang:&quot;c&quot;](code/c/tree_traversal.c)
{% sample lang=&quot;java&quot; %}
#### Tree.java
[import, lang:&quot;java&quot;](code/java/Tree.java)
```javascript
function createTree(rows, children) {
  if (rows === 0) {
    return { id: rows, children: [] };
  }

  return {
    id: rows,
    children: [...Array(children).keys()].map(() =&gt; createTree(rows - 1, children))
  };
}

function dfsPreorder(tree) {
  if (!tree) {
    return;
  }

  process.stdout.write(tree.id + &quot; &quot;);
  tree.children.forEach(dfsPreorder);
}

function dfsPostorder(tree) {
  if (!tree) {
    return;
  }

  tree.children.forEach(dfsPostorder);
  process.stdout.write(tree.id + &quot; &quot;);
}

function dfsInorder(tree) {
  if (!tree) {
    return;
  }

  switch (tree.children.length) {
    case 2:
      dfsInorder(tree.children[0]);
      console.log(tree.id);
      dfsInorder(tree.children[1]);
      break;
    case 1:
      dfsInorder(tree.children[0]);
      console.log(tree.id);
      break;
    case 0:
      console.log(tree.id);
      break;
    default:
      throw new Error(&quot;Postorder traversal is only valid for binary trees&quot;);
  }
}

function dfsIterative(tree) {
  const stack = [tree];
  while (stack.length &gt; 0) {
    const current = stack.pop();
    process.stdout.write(current.id + &quot; &quot;);
    stack.push(...current.children);
  }
}

function bfs(tree) {
  const queue = [tree];
  while (queue.length &gt; 0) {
    const current = queue.shift();
    process.stdout.write(current.id + &quot; &quot;);
    queue.push(...current.children);
  }
}

const root = createTree(2, 3);
console.log(&quot;[#]\nRecursive DFS:&quot;);
dfsPreorder(root);
console.log();
console.log(&quot;[#]\nRecursive Postorder DFS:&quot;);
dfsPostorder(root);
console.log();
console.log(&quot;[#]\nStack-based DFS:&quot;);
dfsIterative(root);
console.log();
console.log(&quot;[#]\nQueue-based BFS:&quot;);
bfs(root);
console.log();
const root_binary = createTree(3, 2);
console.log(&quot;[#]\nRecursive Inorder DFS for Binary Tree:&quot;);
dfsInorder(root_binary);
console.log();

``````javascript
function createTree(rows, children) {
  if (rows === 0) {
    return { id: rows, children: [] };
  }

  return {
    id: rows,
    children: [...Array(children).keys()].map(() =&gt; createTree(rows - 1, children))
  };
}

function dfsPreorder(tree) {
  if (!tree) {
    return;
  }

  process.stdout.write(tree.id + &quot; &quot;);
  tree.children.forEach(dfsPreorder);
}

function dfsPostorder(tree) {
  if (!tree) {
    return;
  }

  tree.children.forEach(dfsPostorder);
  process.stdout.write(tree.id + &quot; &quot;);
}

function dfsInorder(tree) {
  if (!tree) {
    return;
  }

  switch (tree.children.length) {
    case 2:
      dfsInorder(tree.children[0]);
      console.log(tree.id);
      dfsInorder(tree.children[1]);
      break;
    case 1:
      dfsInorder(tree.children[0]);
      console.log(tree.id);
      break;
    case 0:
      console.log(tree.id);
      break;
    default:
      throw new Error(&quot;Postorder traversal is only valid for binary trees&quot;);
  }
}

function dfsIterative(tree) {
  const stack = [tree];
  while (stack.length &gt; 0) {
    const current = stack.pop();
    process.stdout.write(current.id + &quot; &quot;);
    stack.push(...current.children);
  }
}

function bfs(tree) {
  const queue = [tree];
  while (queue.length &gt; 0) {
    const current = queue.shift();
    process.stdout.write(current.id + &quot; &quot;);
    queue.push(...current.children);
  }
}

const root = createTree(2, 3);
console.log(&quot;[#]\nRecursive DFS:&quot;);
dfsPreorder(root);
console.log();
console.log(&quot;[#]\nRecursive Postorder DFS:&quot;);
dfsPostorder(root);
console.log();
console.log(&quot;[#]\nStack-based DFS:&quot;);
dfsIterative(root);
console.log();
console.log(&quot;[#]\nQueue-based BFS:&quot;);
bfs(root);
console.log();
const root_binary = createTree(3, 2);
console.log(&quot;[#]\nRecursive Inorder DFS for Binary Tree:&quot;);
dfsInorder(root_binary);
console.log();

```
[import, lang:&quot;python&quot;](code/python/tree_traversal.py)
{% sample lang=&quot;scratch&quot; %}

The code snippets were taken from this [Scratch project](https://scratch.mit.edu/projects/174017753/)

&lt;p&gt;
  &lt;img  class=&quot;center&quot; src=&quot;code/scratch/all.svg&quot; style=&quot;width:100%&quot; /&gt;
&lt;/p&gt;
```rust
use std::collections::VecDeque;

#[derive(Debug)]
struct Node {
    children: Vec&lt;Node&gt;,
    value: u64,
}

fn dfs_recursive(n: &amp;Node) {
    print!(&quot;{} &quot;, n.value);

    for child in &amp;n.children {
        dfs_recursive(child);
    }
}

fn dfs_recursive_postorder(n: &amp;Node) {
    for child in &amp;n.children {
        dfs_recursive_postorder(child);
    }

    print!(&quot;{} &quot;, n.value);
}

fn dfs_recursive_inorder_btree(n: &amp;Node) {
    match &amp;n.children[..] {
        [left, right] =&gt; {
            dfs_recursive_inorder_btree(left);
            print!(&quot;{} &quot;, n.value);
            dfs_recursive_inorder_btree(right);
        }
        [left] =&gt; {
            dfs_recursive_inorder_btree(left);
            print!(&quot;{} &quot;, n.value);
        }
        [] =&gt; print!(&quot;{} &quot;, n.value),
        _ =&gt; print!(&quot;This is not a binary tree. &quot;),
    }
}

fn dfs_stack(n: &amp;Node) {
    let mut stack = vec![n];

    while let Some(current) = stack.pop() {
        print!(&quot;{} &quot;, current.value);
        stack.extend(&amp;current.children);
    }
}

fn bfs_queue(n: &amp;Node) {
    let mut queue = VecDeque::new();
    queue.push_back(n);

    while let Some(current) = queue.pop_front() {
        print!(&quot;{} &quot;, current.value);
        queue.extend(&amp;current.children);
    }
}

fn create_tree(num_row: u64, num_child: u64) -&gt; Node {
    if num_row == 0 {
        return Node {
            children: vec![],
            value: 0,
        };
    }

    let children = (0..num_child)
        .map(|_| create_tree(num_row - 1, num_child))
        .collect();

    Node {
        children,
        value: num_row,
    }
}

fn main() {
    let root = create_tree(2, 3);

    println!(&quot;[#]\nRecursive DFS:&quot;);
    dfs_recursive(&amp;root);
    println!();

    println!(&quot;[#]\nRecursive Postorder DFS:&quot;);
    dfs_recursive_postorder(&amp;root);
    println!();

    println!(&quot;[#]\nStack-based DFS:&quot;);
    dfs_stack(&amp;root);
    println!();

    println!(&quot;[#]\nQueue-based BFS:&quot;);
    bfs_queue(&amp;root);
    println!();

    println!(&quot;[#]\nRecursive Inorder DFS for Binary Tree:&quot;);
    let root_binary = create_tree(3, 2);
    dfs_recursive_inorder_btree(&amp;root_binary);
    println!();
}
``````rust
use std::collections::VecDeque;

#[derive(Debug)]
struct Node {
    children: Vec&lt;Node&gt;,
    value: u64,
}

fn dfs_recursive(n: &amp;Node) {
    print!(&quot;{} &quot;, n.value);

    for child in &amp;n.children {
        dfs_recursive(child);
    }
}

fn dfs_recursive_postorder(n: &amp;Node) {
    for child in &amp;n.children {
        dfs_recursive_postorder(child);
    }

    print!(&quot;{} &quot;, n.value);
}

fn dfs_recursive_inorder_btree(n: &amp;Node) {
    match &amp;n.children[..] {
        [left, right] =&gt; {
            dfs_recursive_inorder_btree(left);
            print!(&quot;{} &quot;, n.value);
            dfs_recursive_inorder_btree(right);
        }
        [left] =&gt; {
            dfs_recursive_inorder_btree(left);
            print!(&quot;{} &quot;, n.value);
        }
        [] =&gt; print!(&quot;{} &quot;, n.value),
        _ =&gt; print!(&quot;This is not a binary tree. &quot;),
    }
}

fn dfs_stack(n: &amp;Node) {
    let mut stack = vec![n];

    while let Some(current) = stack.pop() {
        print!(&quot;{} &quot;, current.value);
        stack.extend(&amp;current.children);
    }
}

fn bfs_queue(n: &amp;Node) {
    let mut queue = VecDeque::new();
    queue.push_back(n);

    while let Some(current) = queue.pop_front() {
        print!(&quot;{} &quot;, current.value);
        queue.extend(&amp;current.children);
    }
}

fn create_tree(num_row: u64, num_child: u64) -&gt; Node {
    if num_row == 0 {
        return Node {
            children: vec![],
            value: 0,
        };
    }

    let children = (0..num_child)
        .map(|_| create_tree(num_row - 1, num_child))
        .collect();

    Node {
        children,
        value: num_row,
    }
}

fn main() {
    let root = create_tree(2, 3);

    println!(&quot;[#]\nRecursive DFS:&quot;);
    dfs_recursive(&amp;root);
    println!();

    println!(&quot;[#]\nRecursive Postorder DFS:&quot;);
    dfs_recursive_postorder(&amp;root);
    println!();

    println!(&quot;[#]\nStack-based DFS:&quot;);
    dfs_stack(&amp;root);
    println!();

    println!(&quot;[#]\nQueue-based BFS:&quot;);
    bfs_queue(&amp;root);
    println!();

    println!(&quot;[#]\nRecursive Inorder DFS for Binary Tree:&quot;);
    let root_binary = create_tree(3, 2);
    dfs_recursive_inorder_btree(&amp;root_binary);
    println!();
}
``````rust
use std::collections::VecDeque;

#[derive(Debug)]
struct Node {
    children: Vec&lt;Node&gt;,
    value: u64,
}

fn dfs_recursive(n: &amp;Node) {
    print!(&quot;{} &quot;, n.value);

    for child in &amp;n.children {
        dfs_recursive(child);
    }
}

fn dfs_recursive_postorder(n: &amp;Node) {
    for child in &amp;n.children {
        dfs_recursive_postorder(child);
    }

    print!(&quot;{} &quot;, n.value);
}

fn dfs_recursive_inorder_btree(n: &amp;Node) {
    match &amp;n.children[..] {
        [left, right] =&gt; {
            dfs_recursive_inorder_btree(left);
            print!(&quot;{} &quot;, n.value);
            dfs_recursive_inorder_btree(right);
        }
        [left] =&gt; {
            dfs_recursive_inorder_btree(left);
            print!(&quot;{} &quot;, n.value);
        }
        [] =&gt; print!(&quot;{} &quot;, n.value),
        _ =&gt; print!(&quot;This is not a binary tree. &quot;),
    }
}

fn dfs_stack(n: &amp;Node) {
    let mut stack = vec![n];

    while let Some(current) = stack.pop() {
        print!(&quot;{} &quot;, current.value);
        stack.extend(&amp;current.children);
    }
}

fn bfs_queue(n: &amp;Node) {
    let mut queue = VecDeque::new();
    queue.push_back(n);

    while let Some(current) = queue.pop_front() {
        print!(&quot;{} &quot;, current.value);
        queue.extend(&amp;current.children);
    }
}

fn create_tree(num_row: u64, num_child: u64) -&gt; Node {
    if num_row == 0 {
        return Node {
            children: vec![],
            value: 0,
        };
    }

    let children = (0..num_child)
        .map(|_| create_tree(num_row - 1, num_child))
        .collect();

    Node {
        children,
        value: num_row,
    }
}

fn main() {
    let root = create_tree(2, 3);

    println!(&quot;[#]\nRecursive DFS:&quot;);
    dfs_recursive(&amp;root);
    println!();

    println!(&quot;[#]\nRecursive Postorder DFS:&quot;);
    dfs_recursive_postorder(&amp;root);
    println!();

    println!(&quot;[#]\nStack-based DFS:&quot;);
    dfs_stack(&amp;root);
    println!();

    println!(&quot;[#]\nQueue-based BFS:&quot;);
    bfs_queue(&amp;root);
    println!();

    println!(&quot;[#]\nRecursive Inorder DFS for Binary Tree:&quot;);
    let root_binary = create_tree(3, 2);
    dfs_recursive_inorder_btree(&amp;root_binary);
    println!();
}
```v```rust
use std::collections::VecDeque;

#[derive(Debug)]
struct Node {
    children: Vec&lt;Node&gt;,
    value: u64,
}

fn dfs_recursive(n: &amp;Node) {
    print!(&quot;{} &quot;, n.value);

    for child in &amp;n.children {
        dfs_recursive(child);
    }
}

fn dfs_recursive_postorder(n: &amp;Node) {
    for child in &amp;n.children {
        dfs_recursive_postorder(child);
    }

    print!(&quot;{} &quot;, n.value);
}

fn dfs_recursive_inorder_btree(n: &amp;Node) {
    match &amp;n.children[..] {
        [left, right] =&gt; {
            dfs_recursive_inorder_btree(left);
            print!(&quot;{} &quot;, n.value);
            dfs_recursive_inorder_btree(right);
        }
        [left] =&gt; {
            dfs_recursive_inorder_btree(left);
            print!(&quot;{} &quot;, n.value);
        }
        [] =&gt; print!(&quot;{} &quot;, n.value),
        _ =&gt; print!(&quot;This is not a binary tree. &quot;),
    }
}

fn dfs_stack(n: &amp;Node) {
    let mut stack = vec![n];

    while let Some(current) = stack.pop() {
        print!(&quot;{} &quot;, current.value);
        stack.extend(&amp;current.children);
    }
}

fn bfs_queue(n: &amp;Node) {
    let mut queue = VecDeque::new();
    queue.push_back(n);

    while let Some(current) = queue.pop_front() {
        print!(&quot;{} &quot;, current.value);
        queue.extend(&amp;current.children);
    }
}

fn create_tree(num_row: u64, num_child: u64) -&gt; Node {
    if num_row == 0 {
        return Node {
            children: vec![],
            value: 0,
        };
    }

    let children = (0..num_child)
        .map(|_| create_tree(num_row - 1, num_child))
        .collect();

    Node {
        children,
        value: num_row,
    }
}

fn main() {
    let root = create_tree(2, 3);

    println!(&quot;[#]\nRecursive DFS:&quot;);
    dfs_recursive(&amp;root);
    println!();

    println!(&quot;[#]\nRecursive Postorder DFS:&quot;);
    dfs_recursive_postorder(&amp;root);
    println!();

    println!(&quot;[#]\nStack-based DFS:&quot;);
    dfs_stack(&amp;root);
    println!();

    println!(&quot;[#]\nQueue-based BFS:&quot;);
    bfs_queue(&amp;root);
    println!();

    println!(&quot;[#]\nRecursive Inorder DFS for Binary Tree:&quot;);
    let root_binary = create_tree(3, 2);
    dfs_recursive_inorder_btree(&amp;root_binary);
    println!();
}
``````rust
use std::collections::VecDeque;

#[derive(Debug)]
struct Node {
    children: Vec&lt;Node&gt;,
    value: u64,
}

fn dfs_recursive(n: &amp;Node) {
    print!(&quot;{} &quot;, n.value);

    for child in &amp;n.children {
        dfs_recursive(child);
    }
}

fn dfs_recursive_postorder(n: &amp;Node) {
    for child in &amp;n.children {
        dfs_recursive_postorder(child);
    }

    print!(&quot;{} &quot;, n.value);
}

fn dfs_recursive_inorder_btree(n: &amp;Node) {
    match &amp;n.children[..] {
        [left, right] =&gt; {
            dfs_recursive_inorder_btree(left);
            print!(&quot;{} &quot;, n.value);
            dfs_recursive_inorder_btree(right);
        }
        [left] =&gt; {
            dfs_recursive_inorder_btree(left);
            print!(&quot;{} &quot;, n.value);
        }
        [] =&gt; print!(&quot;{} &quot;, n.value),
        _ =&gt; print!(&quot;This is not a binary tree. &quot;),
    }
}

fn dfs_stack(n: &amp;Node) {
    let mut stack = vec![n];

    while let Some(current) = stack.pop() {
        print!(&quot;{} &quot;, current.value);
        stack.extend(&amp;current.children);
    }
}

fn bfs_queue(n: &amp;Node) {
    let mut queue = VecDeque::new();
    queue.push_back(n);

    while let Some(current) = queue.pop_front() {
        print!(&quot;{} &quot;, current.value);
        queue.extend(&amp;current.children);
    }
}

fn create_tree(num_row: u64, num_child: u64) -&gt; Node {
    if num_row == 0 {
        return Node {
            children: vec![],
            value: 0,
        };
    }

    let children = (0..num_child)
        .map(|_| create_tree(num_row - 1, num_child))
        .collect();

    Node {
        children,
        value: num_row,
    }
}

fn main() {
    let root = create_tree(2, 3);

    println!(&quot;[#]\nRecursive DFS:&quot;);
    dfs_recursive(&amp;root);
    println!();

    println!(&quot;[#]\nRecursive Postorder DFS:&quot;);
    dfs_recursive_postorder(&amp;root);
    println!();

    println!(&quot;[#]\nStack-based DFS:&quot;);
    dfs_stack(&amp;root);
    println!();

    println!(&quot;[#]\nQueue-based BFS:&quot;);
    bfs_queue(&amp;root);
    println!();

    println!(&quot;[#]\nRecursive Inorder DFS for Binary Tree:&quot;);
    let root_binary = create_tree(3, 2);
    dfs_recursive_inorder_btree(&amp;root_binary);
    println!();
}
``````rust
use std::collections::VecDeque;

#[derive(Debug)]
struct Node {
    children: Vec&lt;Node&gt;,
    value: u64,
}

fn dfs_recursive(n: &amp;Node) {
    print!(&quot;{} &quot;, n.value);

    for child in &amp;n.children {
        dfs_recursive(child);
    }
}

fn dfs_recursive_postorder(n: &amp;Node) {
    for child in &amp;n.children {
        dfs_recursive_postorder(child);
    }

    print!(&quot;{} &quot;, n.value);
}

fn dfs_recursive_inorder_btree(n: &amp;Node) {
    match &amp;n.children[..] {
        [left, right] =&gt; {
            dfs_recursive_inorder_btree(left);
            print!(&quot;{} &quot;, n.value);
            dfs_recursive_inorder_btree(right);
        }
        [left] =&gt; {
            dfs_recursive_inorder_btree(left);
            print!(&quot;{} &quot;, n.value);
        }
        [] =&gt; print!(&quot;{} &quot;, n.value),
        _ =&gt; print!(&quot;This is not a binary tree. &quot;),
    }
}

fn dfs_stack(n: &amp;Node) {
    let mut stack = vec![n];

    while let Some(current) = stack.pop() {
        print!(&quot;{} &quot;, current.value);
        stack.extend(&amp;current.children);
    }
}

fn bfs_queue(n: &amp;Node) {
    let mut queue = VecDeque::new();
    queue.push_back(n);

    while let Some(current) = queue.pop_front() {
        print!(&quot;{} &quot;, current.value);
        queue.extend(&amp;current.children);
    }
}

fn create_tree(num_row: u64, num_child: u64) -&gt; Node {
    if num_row == 0 {
        return Node {
            children: vec![],
            value: 0,
        };
    }

    let children = (0..num_child)
        .map(|_| create_tree(num_row - 1, num_child))
        .collect();

    Node {
        children,
        value: num_row,
    }
}

fn main() {
    let root = create_tree(2, 3);

    println!(&quot;[#]\nRecursive DFS:&quot;);
    dfs_recursive(&amp;root);
    println!();

    println!(&quot;[#]\nRecursive Postorder DFS:&quot;);
    dfs_recursive_postorder(&amp;root);
    println!();

    println!(&quot;[#]\nStack-based DFS:&quot;);
    dfs_stack(&amp;root);
    println!();

    println!(&quot;[#]\nQueue-based BFS:&quot;);
    bfs_queue(&amp;root);
    println!();

    println!(&quot;[#]\nRecursive Inorder DFS for Binary Tree:&quot;);
    let root_binary = create_tree(3, 2);
    dfs_recursive_inorder_btree(&amp;root_binary);
    println!();
}
``````rust
use std::collections::VecDeque;

#[derive(Debug)]
struct Node {
    children: Vec&lt;Node&gt;,
    value: u64,
}

fn dfs_recursive(n: &amp;Node) {
    print!(&quot;{} &quot;, n.value);

    for child in &amp;n.children {
        dfs_recursive(child);
    }
}

fn dfs_recursive_postorder(n: &amp;Node) {
    for child in &amp;n.children {
        dfs_recursive_postorder(child);
    }

    print!(&quot;{} &quot;, n.value);
}

fn dfs_recursive_inorder_btree(n: &amp;Node) {
    match &amp;n.children[..] {
        [left, right] =&gt; {
            dfs_recursive_inorder_btree(left);
            print!(&quot;{} &quot;, n.value);
            dfs_recursive_inorder_btree(right);
        }
        [left] =&gt; {
            dfs_recursive_inorder_btree(left);
            print!(&quot;{} &quot;, n.value);
        }
        [] =&gt; print!(&quot;{} &quot;, n.value),
        _ =&gt; print!(&quot;This is not a binary tree. &quot;),
    }
}

fn dfs_stack(n: &amp;Node) {
    let mut stack = vec![n];

    while let Some(current) = stack.pop() {
        print!(&quot;{} &quot;, current.value);
        stack.extend(&amp;current.children);
    }
}

fn bfs_queue(n: &amp;Node) {
    let mut queue = VecDeque::new();
    queue.push_back(n);

    while let Some(current) = queue.pop_front() {
        print!(&quot;{} &quot;, current.value);
        queue.extend(&amp;current.children);
    }
}

fn create_tree(num_row: u64, num_child: u64) -&gt; Node {
    if num_row == 0 {
        return Node {
            children: vec![],
            value: 0,
        };
    }

    let children = (0..num_child)
        .map(|_| create_tree(num_row - 1, num_child))
        .collect();

    Node {
        children,
        value: num_row,
    }
}

fn main() {
    let root = create_tree(2, 3);

    println!(&quot;[#]\nRecursive DFS:&quot;);
    dfs_recursive(&amp;root);
    println!();

    println!(&quot;[#]\nRecursive Postorder DFS:&quot;);
    dfs_recursive_postorder(&amp;root);
    println!();

    println!(&quot;[#]\nStack-based DFS:&quot;);
    dfs_stack(&amp;root);
    println!();

    println!(&quot;[#]\nQueue-based BFS:&quot;);
    bfs_queue(&amp;root);
    println!();

    println!(&quot;[#]\nRecursive Inorder DFS for Binary Tree:&quot;);
    let root_binary = create_tree(3, 2);
    dfs_recursive_inorder_btree(&amp;root_binary);
    println!();
}
```p```rust
use std::collections::VecDeque;

#[derive(Debug)]
struct Node {
    children: Vec&lt;Node&gt;,
    value: u64,
}

fn dfs_recursive(n: &amp;Node) {
    print!(&quot;{} &quot;, n.value);

    for child in &amp;n.children {
        dfs_recursive(child);
    }
}

fn dfs_recursive_postorder(n: &amp;Node) {
    for child in &amp;n.children {
        dfs_recursive_postorder(child);
    }

    print!(&quot;{} &quot;, n.value);
}

fn dfs_recursive_inorder_btree(n: &amp;Node) {
    match &amp;n.children[..] {
        [left, right] =&gt; {
            dfs_recursive_inorder_btree(left);
            print!(&quot;{} &quot;, n.value);
            dfs_recursive_inorder_btree(right);
        }
        [left] =&gt; {
            dfs_recursive_inorder_btree(left);
            print!(&quot;{} &quot;, n.value);
        }
        [] =&gt; print!(&quot;{} &quot;, n.value),
        _ =&gt; print!(&quot;This is not a binary tree. &quot;),
    }
}

fn dfs_stack(n: &amp;Node) {
    let mut stack = vec![n];

    while let Some(current) = stack.pop() {
        print!(&quot;{} &quot;, current.value);
        stack.extend(&amp;current.children);
    }
}

fn bfs_queue(n: &amp;Node) {
    let mut queue = VecDeque::new();
    queue.push_back(n);

    while let Some(current) = queue.pop_front() {
        print!(&quot;{} &quot;, current.value);
        queue.extend(&amp;current.children);
    }
}

fn create_tree(num_row: u64, num_child: u64) -&gt; Node {
    if num_row == 0 {
        return Node {
            children: vec![],
            value: 0,
        };
    }

    let children = (0..num_child)
        .map(|_| create_tree(num_row - 1, num_child))
        .collect();

    Node {
        children,
        value: num_row,
    }
}

fn main() {
    let root = create_tree(2, 3);

    println!(&quot;[#]\nRecursive DFS:&quot;);
    dfs_recursive(&amp;root);
    println!();

    println!(&quot;[#]\nRecursive Postorder DFS:&quot;);
    dfs_recursive_postorder(&amp;root);
    println!();

    println!(&quot;[#]\nStack-based DFS:&quot;);
    dfs_stack(&amp;root);
    println!();

    println!(&quot;[#]\nQueue-based BFS:&quot;);
    bfs_queue(&amp;root);
    println!();

    println!(&quot;[#]\nRecursive Inorder DFS for Binary Tree:&quot;);
    let root_binary = create_tree(3, 2);
    dfs_recursive_inorder_btree(&amp;root_binary);
    println!();
}
``````rust
use std::collections::VecDeque;

#[derive(Debug)]
struct Node {
    children: Vec&lt;Node&gt;,
    value: u64,
}

fn dfs_recursive(n: &amp;Node) {
    print!(&quot;{} &quot;, n.value);

    for child in &amp;n.children {
        dfs_recursive(child);
    }
}

fn dfs_recursive_postorder(n: &amp;Node) {
    for child in &amp;n.children {
        dfs_recursive_postorder(child);
    }

    print!(&quot;{} &quot;, n.value);
}

fn dfs_recursive_inorder_btree(n: &amp;Node) {
    match &amp;n.children[..] {
        [left, right] =&gt; {
            dfs_recursive_inorder_btree(left);
            print!(&quot;{} &quot;, n.value);
            dfs_recursive_inorder_btree(right);
        }
        [left] =&gt; {
            dfs_recursive_inorder_btree(left);
            print!(&quot;{} &quot;, n.value);
        }
        [] =&gt; print!(&quot;{} &quot;, n.value),
        _ =&gt; print!(&quot;This is not a binary tree. &quot;),
    }
}

fn dfs_stack(n: &amp;Node) {
    let mut stack = vec![n];

    while let Some(current) = stack.pop() {
        print!(&quot;{} &quot;, current.value);
        stack.extend(&amp;current.children);
    }
}

fn bfs_queue(n: &amp;Node) {
    let mut queue = VecDeque::new();
    queue.push_back(n);

    while let Some(current) = queue.pop_front() {
        print!(&quot;{} &quot;, current.value);
        queue.extend(&amp;current.children);
    }
}

fn create_tree(num_row: u64, num_child: u64) -&gt; Node {
    if num_row == 0 {
        return Node {
            children: vec![],
            value: 0,
        };
    }

    let children = (0..num_child)
        .map(|_| create_tree(num_row - 1, num_child))
        .collect();

    Node {
        children,
        value: num_row,
    }
}

fn main() {
    let root = create_tree(2, 3);

    println!(&quot;[#]\nRecursive DFS:&quot;);
    dfs_recursive(&amp;root);
    println!();

    println!(&quot;[#]\nRecursive Postorder DFS:&quot;);
    dfs_recursive_postorder(&amp;root);
    println!();

    println!(&quot;[#]\nStack-based DFS:&quot;);
    dfs_stack(&amp;root);
    println!();

    println!(&quot;[#]\nQueue-based BFS:&quot;);
    bfs_queue(&amp;root);
    println!();

    println!(&quot;[#]\nRecursive Inorder DFS for Binary Tree:&quot;);
    let root_binary = create_tree(3, 2);
    dfs_recursive_inorder_btree(&amp;root_binary);
    println!();
}
``````rust
use std::collections::VecDeque;

#[derive(Debug)]
struct Node {
    children: Vec&lt;Node&gt;,
    value: u64,
}

fn dfs_recursive(n: &amp;Node) {
    print!(&quot;{} &quot;, n.value);

    for child in &amp;n.children {
        dfs_recursive(child);
    }
}

fn dfs_recursive_postorder(n: &amp;Node) {
    for child in &amp;n.children {
        dfs_recursive_postorder(child);
    }

    print!(&quot;{} &quot;, n.value);
}

fn dfs_recursive_inorder_btree(n: &amp;Node) {
    match &amp;n.children[..] {
        [left, right] =&gt; {
            dfs_recursive_inorder_btree(left);
            print!(&quot;{} &quot;, n.value);
            dfs_recursive_inorder_btree(right);
        }
        [left] =&gt; {
            dfs_recursive_inorder_btree(left);
            print!(&quot;{} &quot;, n.value);
        }
        [] =&gt; print!(&quot;{} &quot;, n.value),
        _ =&gt; print!(&quot;This is not a binary tree. &quot;),
    }
}

fn dfs_stack(n: &amp;Node) {
    let mut stack = vec![n];

    while let Some(current) = stack.pop() {
        print!(&quot;{} &quot;, current.value);
        stack.extend(&amp;current.children);
    }
}

fn bfs_queue(n: &amp;Node) {
    let mut queue = VecDeque::new();
    queue.push_back(n);

    while let Some(current) = queue.pop_front() {
        print!(&quot;{} &quot;, current.value);
        queue.extend(&amp;current.children);
    }
}

fn create_tree(num_row: u64, num_child: u64) -&gt; Node {
    if num_row == 0 {
        return Node {
            children: vec![],
            value: 0,
        };
    }

    let children = (0..num_child)
        .map(|_| create_tree(num_row - 1, num_child))
        .collect();

    Node {
        children,
        value: num_row,
    }
}

fn main() {
    let root = create_tree(2, 3);

    println!(&quot;[#]\nRecursive DFS:&quot;);
    dfs_recursive(&amp;root);
    println!();

    println!(&quot;[#]\nRecursive Postorder DFS:&quot;);
    dfs_recursive_postorder(&amp;root);
    println!();

    println!(&quot;[#]\nStack-based DFS:&quot;);
    dfs_stack(&amp;root);
    println!();

    println!(&quot;[#]\nQueue-based BFS:&quot;);
    bfs_queue(&amp;root);
    println!();

    println!(&quot;[#]\nRecursive Inorder DFS for Binary Tree:&quot;);
    let root_binary = create_tree(3, 2);
    dfs_recursive_inorder_btree(&amp;root_binary);
    println!();
}
``````rust
use std::collections::VecDeque;

#[derive(Debug)]
struct Node {
    children: Vec&lt;Node&gt;,
    value: u64,
}

fn dfs_recursive(n: &amp;Node) {
    print!(&quot;{} &quot;, n.value);

    for child in &amp;n.children {
        dfs_recursive(child);
    }
}

fn dfs_recursive_postorder(n: &amp;Node) {
    for child in &amp;n.children {
        dfs_recursive_postorder(child);
    }

    print!(&quot;{} &quot;, n.value);
}

fn dfs_recursive_inorder_btree(n: &amp;Node) {
    match &amp;n.children[..] {
        [left, right] =&gt; {
            dfs_recursive_inorder_btree(left);
            print!(&quot;{} &quot;, n.value);
            dfs_recursive_inorder_btree(right);
        }
        [left] =&gt; {
            dfs_recursive_inorder_btree(left);
            print!(&quot;{} &quot;, n.value);
        }
        [] =&gt; print!(&quot;{} &quot;, n.value),
        _ =&gt; print!(&quot;This is not a binary tree. &quot;),
    }
}

fn dfs_stack(n: &amp;Node) {
    let mut stack = vec![n];

    while let Some(current) = stack.pop() {
        print!(&quot;{} &quot;, current.value);
        stack.extend(&amp;current.children);
    }
}

fn bfs_queue(n: &amp;Node) {
    let mut queue = VecDeque::new();
    queue.push_back(n);

    while let Some(current) = queue.pop_front() {
        print!(&quot;{} &quot;, current.value);
        queue.extend(&amp;current.children);
    }
}

fn create_tree(num_row: u64, num_child: u64) -&gt; Node {
    if num_row == 0 {
        return Node {
            children: vec![],
            value: 0,
        };
    }

    let children = (0..num_child)
        .map(|_| create_tree(num_row - 1, num_child))
        .collect();

    Node {
        children,
        value: num_row,
    }
}

fn main() {
    let root = create_tree(2, 3);

    println!(&quot;[#]\nRecursive DFS:&quot;);
    dfs_recursive(&amp;root);
    println!();

    println!(&quot;[#]\nRecursive Postorder DFS:&quot;);
    dfs_recursive_postorder(&amp;root);
    println!();

    println!(&quot;[#]\nStack-based DFS:&quot;);
    dfs_stack(&amp;root);
    println!();

    println!(&quot;[#]\nQueue-based BFS:&quot;);
    bfs_queue(&amp;root);
    println!();

    println!(&quot;[#]\nRecursive Inorder DFS for Binary Tree:&quot;);
    let root_binary = create_tree(3, 2);
    dfs_recursive_inorder_btree(&amp;root_binary);
    println!();
}
```r```rust
use std::collections::VecDeque;

#[derive(Debug)]
struct Node {
    children: Vec&lt;Node&gt;,
    value: u64,
}

fn dfs_recursive(n: &amp;Node) {
    print!(&quot;{} &quot;, n.value);

    for child in &amp;n.children {
        dfs_recursive(child);
    }
}

fn dfs_recursive_postorder(n: &amp;Node) {
    for child in &amp;n.children {
        dfs_recursive_postorder(child);
    }

    print!(&quot;{} &quot;, n.value);
}

fn dfs_recursive_inorder_btree(n: &amp;Node) {
    match &amp;n.children[..] {
        [left, right] =&gt; {
            dfs_recursive_inorder_btree(left);
            print!(&quot;{} &quot;, n.value);
            dfs_recursive_inorder_btree(right);
        }
        [left] =&gt; {
            dfs_recursive_inorder_btree(left);
            print!(&quot;{} &quot;, n.value);
        }
        [] =&gt; print!(&quot;{} &quot;, n.value),
        _ =&gt; print!(&quot;This is not a binary tree. &quot;),
    }
}

fn dfs_stack(n: &amp;Node) {
    let mut stack = vec![n];

    while let Some(current) = stack.pop() {
        print!(&quot;{} &quot;, current.value);
        stack.extend(&amp;current.children);
    }
}

fn bfs_queue(n: &amp;Node) {
    let mut queue = VecDeque::new();
    queue.push_back(n);

    while let Some(current) = queue.pop_front() {
        print!(&quot;{} &quot;, current.value);
        queue.extend(&amp;current.children);
    }
}

fn create_tree(num_row: u64, num_child: u64) -&gt; Node {
    if num_row == 0 {
        return Node {
            children: vec![],
            value: 0,
        };
    }

    let children = (0..num_child)
        .map(|_| create_tree(num_row - 1, num_child))
        .collect();

    Node {
        children,
        value: num_row,
    }
}

fn main() {
    let root = create_tree(2, 3);

    println!(&quot;[#]\nRecursive DFS:&quot;);
    dfs_recursive(&amp;root);
    println!();

    println!(&quot;[#]\nRecursive Postorder DFS:&quot;);
    dfs_recursive_postorder(&amp;root);
    println!();

    println!(&quot;[#]\nStack-based DFS:&quot;);
    dfs_stack(&amp;root);
    println!();

    println!(&quot;[#]\nQueue-based BFS:&quot;);
    bfs_queue(&amp;root);
    println!();

    println!(&quot;[#]\nRecursive Inorder DFS for Binary Tree:&quot;);
    let root_binary = create_tree(3, 2);
    dfs_recursive_inorder_btree(&amp;root_binary);
    println!();
}
```
[import, lang:&quot;go&quot;](code/go/treetraversal.go)
{% sample lang=&quot;asm-x64&quot; %}
[import, lang:&quot;asm-x64&quot;](code/asm-x64/tree_traversal.s)
{% sample lang=&quot;emojic&quot; %}
[import, lang:&quot;emojicode&quot;](code/emojicode/tree_traversal.emojic)
{% sample lang=&quot;lisp&quot; %}
[import, lang:&quot;lisp&quot;](code/clisp/tree-traversal.lisp)
{% sample lang=&quot;m&quot; %}
[import, lang:&quot;matlab&quot;](code/matlab/tree.m)
{% sample lang=&quot;coco&quot; %}
[import, lang:&quot;coconut&quot;](code/coconut/tree_traversal.coco)





# License

#### Code Examples

The code examples are licensed under the MIT license (found in [LICENSE.md](https://github.com/algorithm-archivists/algorithm-archive/blob/master/LICENSE.md)).

#### Text

The text of this chapter was written by [James Schloss](https://github.com/leios) and is licensed under the [Creative Commons Attribution-ShareAlike 4.0 International License](https://creativecommons.org/licenses/by-sa/4.0/legalcode).

[&lt;p&gt;&lt;img  class=&quot;center&quot; src=&quot;../cc/CC-BY-SA_icon.svg&quot; /&gt;&lt;/p&gt;](https://creativecommons.org/licenses/by-sa/4.0/)

#### Images/Graphics
- The image &quot;[DFSpreorder](res/DFS_pre.png)&quot; was created by [James Schloss](https://github.com/leios) and is licensed under the [Creative Commons Attribution-ShareAlike 4.0 International License](https://creativecommons.org/licenses/by-sa/4.0/legalcode).
- The image &quot;[DFSpostorder](res/DFS_post.png)&quot; was created by [James Schloss](https://github.com/leios) and is licensed under the [Creative Commons Attribution-ShareAlike 4.0 International License](https://creativecommons.org/licenses/by-sa/4.0/legalcode).
- The image &quot;[DFSinorder](res/DFS_in.png)&quot; was created by [James Schloss](https://github.com/leios) and is licensed under the [Creative Commons Attribution-ShareAlike 4.0 International License](https://creativecommons.org/licenses/by-sa/4.0/legalcode).
- The image &quot;[BFSsimple](res/BFS_simple.png)&quot; was created by [James Schloss](https://github.com/leios) and is licensed under the [Creative Commons Attribution-ShareAlike 4.0 International License](https://creativecommons.org/licenses/by-sa/4.0/legalcode).


#### Pull Requests

After initial licensing ([#560](https://github.com/algorithm-archivists/algorithm-archive/pull/560)), the following pull requests have modified the text or graphics of this chapter:
- none
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="euclidean-algorithm"><a class="header" href="#euclidean-algorithm">Euclidean Algorithm</a></h1>
<p>Computer science is (almost by definition) a science about computers -- a device first conceptualized in the 1800's. Computers have become so revolutionary, that it is difficult to think of our lives today without them. That said, <em>algorithms</em> are much older and have existed in the world for millennia. Incredibly, a few of the algorithms created before the Common Era (AD) are still in use today. One such algorithm was first described in Euclid's <em>Elements</em> (~ 300 BC) and has come to be known as the <em>Euclidean Algorithm</em>.</p>
<p>The algorithm is a simple way to find the <em>greatest common divisor</em> (GCD) of two numbers, which is useful for a number of different applications (like reducing fractions). The first method (envisioned by Euclid) uses simple subtraction:</p>
<pre><code class="language-vim">function s:euclid_sub(a, b)
	let l:a = abs(a:a)
	let l:b = abs(a:b)

	while l:a != l:b
		if l:a &gt; l:b
			let l:a -= l:b
		else
			let l:b -= l:a
		endif
	endwhile

	return l:a
endfunction
</code></pre>
<pre><code class="language-c_cpp">int euclid_sub(int a, int b) {
    a = abs(a);
    b = abs(b);

    while (a != b) {
        if (a &gt; b) {
            a -= b;
        } else {
            b -= a;
        }
    }

    return a;
}
</code></pre>
<pre><code class="language-csharp">        public int EuclidSub(int a, int b)
        {
            // Math.Abs for negative number support
            a = Math.Abs(a);
            b = Math.Abs(b);

            while (a != b)
            {
                if (a &gt; b)
                    a = a - b;
                else
                    b = b - a;
            }

            return a;
        }
</code></pre>
<pre><code class="language-clojure">(defn euclid-sub [a b]
  (loop [i (Math/abs a) j (Math/abs b)]
    (if (= i j)
      i
      (if (&gt; i j)
        (recur (- i j) j)
        (recur i (- j i))))))
</code></pre>
<pre><code class="language-c_cpp">int euclid_sub(int a, int b) {
  a = std::abs(a);
  b = std::abs(b);

  while (a != b) {
    if (a &gt; b) {
      a -= b;
    } else {
      b -= a;
    }
  }

  return a;
}
</code></pre>
<pre><code class="language-java">    public static int euclidSub(int a, int b) {
        a = Math.abs(a);
        b = Math.abs(b);
        
        while (a != b) {
            if (a &gt; b) {
                a -= b;
            } else {
                b -= a;
            }
        }
        
        return a;
    }
</code></pre>
<pre><code class="language-kotlin">fun euclidSub(a: Int, b: Int): Int {
    var a = a.absoluteValue
    var b = b.absoluteValue

    while (a != b) {
        if (a &gt; b) a -= b
        else b -= a
    }

    return a
}
</code></pre>
<pre><code class="language-javascript">function euclidSub(a, b) {
  a = Math.abs(a);
  b = Math.abs(b);

  while (a !== b) {
    if (a &gt; b) {
      a -= a - b;
    } else {
      b = b - a;
    }
  }

  return a;
}

</code></pre>
<pre><code class="language-lisp">(defun euclid-sub (a b)
  &quot;Finds the greatest common divsor for any two integers&quot;
  (defun euclid-sub* (a b)
    &quot;Finds the greatest common divisor for any two positive integers&quot;
    (if (eql a b)
        a
        (if (&gt; a b)
            (euclid-sub* (- a b) b)
            (euclid-sub* a (- b a)))))
  (euclid-sub* (abs a) (abs b)))
</code></pre>
<pre><code class="language-python">def euclid_sub(a, b):

    a = abs(a)
    b = abs(b)

    if a == 0:
        return b
    elif b == 0:
        return a

    while a != b:
        if a &gt; b:
            a -= b
        else:
            b -= a

    return a
</code></pre>
<pre><code class="language-haskell">euclidSub :: Integer -&gt; Integer -&gt; Integer
euclidSub a b = inner (abs a) (abs b)
  where
    inner x y
      -- if a = b, then the gcd is a
      | x == y = x
      -- if a &lt; b: Recursively call euclidSub with the a and (b-a) as new inputs
      | x &lt; y = euclidSub x (y - x)
      -- otherwise: Recursively call euclidSub with the a and (b-a) as new inputs
      | otherwise = euclidSub (x - y) y

</code></pre>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn euclid_sub(mut a: i64, mut b: i64) -&gt; i64 {
    a = a.abs();
    b = b.abs();
    while a != b {
        if a &lt; b {
            b -= a;
        } else {
            a -= b;
        }
    }

    a
}
<span class="boring">}
</span></code></pre></pre>
<pre><code class="language-ocaml">let euclid_sub a b =
  let rec inner a b =
    if a = b then
      a
    else if a &lt; b then
      inner a (b - a)
    else
      inner (a - b) b
  in (inner (abs a) (abs b))
</code></pre>
<pre><code class="language-go">func euclidSub(a, b int) int {
	a = abs(a)
	b = abs(b)

	for a != b {
		if a &gt; b {
			a -= b
		} else {
			b -= a
		}
	}

	return a
}
</code></pre>
<pre><code class="language-swift">func euclidSub(a: Int, b: Int) -&gt; Int {
    var a = abs(a)
    var b = abs(b)
    
    while (a != b) {
        if (a &gt; b) {
            a -= b
        } else {
            b -= a
        }
    }
    
    return a
}
</code></pre>
<pre><code class="language-matlab">function gcd = euclidSub(a,b)
    
    a = abs(a);
    b = abs(b);
    
    while a ~= b
        if a &gt; b
            a = a - b;
        else
            b = b - a;
        end
    end
    
    gcd = a;
end
</code></pre>
<pre><code class="language-lua">local function euclid_sub(a, b)
  a = math.abs(a)
  b = math.abs(b)

  while a ~= b do
    if a &gt; b then
      a = a-b
    else
      b = b-a
    end
  end

  return a
end
</code></pre>
<pre><code class="language-julia">function euclid_sub(a::Int64, b::Int64)
    a = abs(a)
    b = abs(b)

    while (a != b)
        if (a &gt; b)
            a -= b
        else
            b -= a
        end
    end

    return a
end
</code></pre>
<pre><code class="language-nim">func euclid_sub(in1, in2: int): int =
  var
    a = abs(in1)
    b = abs(in2)

  while a != b:
    if a &gt; b:
      a -= b
    else:
      b -= a

  result = a
</code></pre>
<pre><code class="language-asm-x64">euclid_sub:
  mov    rax, rdi           # Get abs of a
  sar    rax, 31
  xor    rdi, rax
  sub    rdi, rax
  mov    rax, rsi           # Get abs of b
  sar    rax, 31
  xor    rsi, rax
  sub    rsi, rax
  jmp    check
loop:
  cmp    rdi, rsi           # Find which is bigger
  jle    if_true
  sub    rdi, rsi           # If a is bigger then a -= b
  jmp    check
if_true:
  sub    rsi, rdi           # Else b -= a
check:
  cmp    rsi, rdi           # Check if a and b are not equal
  jne    loop
  mov    rax, rdi           # Return results
  ret
</code></pre>
<pre><code class="language-fortran">INTEGER FUNCTION euclid_sub(a, b)
    IMPLICIT NONE
    INTEGER, INTENT(INOUT) :: a, b

    a = ABS(a)
    b = ABS(b)

    DO WHILE (a /= b)
    
        IF (a &gt; b) THEN
            a = a - b
        ELSE
            b = b - a
        END IF
    END DO

    euclid_sub = a

END FUNCTION euclid_sub 
</code></pre>
<pre><code class="language-php">function euclid_sub(int $a, int $b): int
{
    $a = abs($a);
    $b = abs($b);

    while ($a !== $b) {
        if ($a &gt; $b) {
            $a = $a - $b;
        } else {
            $b = $b - $a;
        }
    }

    return $a;
}
</code></pre>
<pre><code class="language-factor">: euclid- ( a b -- gcd )
  [ abs ] bi@
  [ 2dup = ]
  [
    ! make sure the lower number is deeper
    2dup &gt;= [ swap ] when
    over -
    ! leaves us with stack { &lt;lower&gt; &lt;greater - lower&gt; }
  ]
  until
  ! we have the GCD twice now, drop one
  drop
;
</code></pre>
<pre><code class="language-whitespace">Euclidian algorithm subtraction method.
Enter two positive integers.	
	
			
		
  			  	    
   
			   	
				  	 
 
	 			  	   	
 
 
					  	  	 
   
 
			 
 
			  	    

  			  	   	
   
				
 	



  			  	  	 
   
 
		  	   	
 
			 
 
The			  	    
end.
</code></pre>
<pre><code class="language-scala">  def euclid_sub(a: Int, b: Int): Int =
    (Math.abs(a), Math.abs(b)) match {
      case (0, _) | (_, 0) =&gt; 0
      case (x, y) if x &lt; y =&gt; euclid(x, y - x)
      case (x, y) if x &gt; y =&gt; euclid(x - y, y)
      case _ =&gt; a
</code></pre>
<pre><code class="language-racket">(define (euclid_sub a b)
  (local ((define (euclid_sub* x y)
          (if (= x y)
              x
              (if (&gt; x y)
                  (euclid_sub* (- x y) y)
                  (euclid_sub* x (- y x))
                  )
              )
          )) (euclid_sub* (abs a) (abs b))
    )
  )
</code></pre>
<pre><code class="language-ruby">def gcd_minus(a, b)
	a = a.abs
	b = b.abs
	until a == b
		if a &gt; b
			a -= b
		else
			b -= a
		end
	end
	a
end
</code></pre>
<pre><code class="language-smalltalk">Integer&gt;&gt;euclidSub: secondNumber
    &quot;Euclidean algorithm with subtraction&quot;
    | a b |
    a := self abs.
    b := secondNumber abs.
    [ a == b ] whileFalse: [ 
        a &gt; b ifTrue: [ 
            a := a - b.
        ] ifFalse: [ 
            b := b - a.
        ].
    ].
    ^a.
</code></pre>
<pre><code class="language-emojicode">     a  b    
     Use  (returns the absolute value) to support negative numbers.
    a   var_a
    b   var_b

      var_a  var_b  
       var_a  var_b 
        var_a   var_b
      
       
        var_b   var_a
      
    

     var_a
  
</code></pre>
<pre><code class="language-LOLCODE">    HOW IZ I UKLIDSUP YR NUM1 AN YR NUM2
        NUM1 R I IZ ABZ YR NUM1 MKAY
        NUM2 R I IZ ABZ YR NUM2 MKAY

        IM IN YR LOOP 
            BOTH SAEM NUM1 AN NUM2, O RLY?
                YA RLY, FOUND YR NUM1
            OIC        

            DIFFRINT NUM1 AN SMALLR OF NUM1 AN NUM2, O RLY?
                YA RLY, NUM1 R DIFF OF NUM1 AN NUM2
                NO WAI, NUM2 R DIFF OF NUM2 AN NUM1
            OIC
        IM OUTTA YR LOOP

    IF U SAY SO
</code></pre>
<pre><code class="language-bash">euclid_sub() {
    local a
    local b
    a=$(abs &quot;$1&quot;)
    b=$(abs &quot;$2&quot;)
    
    while (( a != b )); do
        if (( a &gt; b )); then
            ((a -= b))
        else
            ((b -= a))
        fi
    done
    printf &quot;%s&quot; &quot;$a&quot;
}
</code></pre>
<pre><code class="language-d">// Euclidean algorithm with subtraction
int euclid_sub(int a, int b) {
    a = abs(a);
    b = abs(b);

    while (a != b) {
        if (a &gt; b) {
            a -= b;
        } else {
            b -= a;
        }
    }

    return a;
}
</code></pre>
<blockquote>
<p><img src="euclidean_algorithm/code/piet/subtract/euclidian_algorithm_subtract_large.png" alt="" /> <img src="euclidean_algorithm/code/piet/subtract/euclidian_algorithm_subtract.png" alt="" /></p>
</blockquote>
<pre><code class="language-scheme">(define (euclid-sub a b)
    (cond                                                                                                                                                                                                                                                                         
        [(or (negative? a)(negative? b))(euclid-sub (abs a)(abs b))]                                                                                                                                                                                                              
        [(eq? a b) a]
        [(&gt; a b)(euclid-sub(- a b) b)]
        [else
            (euclid-sub a (- b a))]))
</code></pre>
<!-- {% sample lang="scratch" %} -->
<p>
  <img  class="center" src="euclidean_algorithm/code/scratch/euclid_sub.svg" style="width:30%" />
</p>
# leave one line empty:
<pre><code class="language-powershell">function Sub-Euclid($a, $b) {
    $a = [Math]::Abs($a)
    $b = [Math]::Abs($b)

    while ($a -ne $b) {
        if ($a -gt $b) {
            $a = $a - $b
        } else {
            $b = $b - $a
        }
    }
    
    return $a
}
</code></pre>
<pre><code class="language-coconut">def euclid_sub(a is int, 0) = a
addpattern def euclid_sub(0, b is int) = b

addpattern def euclid_sub(a is int, b is int):
    if a &lt; b:
        return euclid_sub(a, b - a)
    elif b &lt; a:
        return euclid_sub(a - b, b)
    return a
</code></pre>
<p>Here, we simply line the two numbers up every step and subtract the lower value from the higher one every timestep. Once the two values are equal, we call that value the greatest common divisor. A graph of <code>a</code> and <code>b</code> as they change every step would look something like this:</p>
<p>
    <img  class="center" src="euclidean_algorithm/res/subtraction.png" style="width:70%" />
</p>
<p>Modern implementations, though, often use the modulus operator (%) like so</p>
<pre><code class="language-vim">function s:euclid_mod(a, b)
	let l:a = abs(a:a)
	let l:b = abs(a:b)

	while l:b != 0
		let l:c = l:b
		let l:b = l:a % l:b
		let l:a = l:c
	endwhile

	return l:a
endfunction
</code></pre>
<pre><code class="language-c">int euclid_mod(int a, int b) {
    a = abs(a);
    b = abs(b);

    while (b != 0) {
        int temp = b;
        b = a % b;
        a = temp;
    }

    return a;
}

</code></pre>
<pre><code class="language-csharp">        public int EuclidMod(int a, int b)
        {
            // Math.Abs for negative number support
            a = Math.Abs(a);
            b = Math.Abs(b);

            while (b != 0)
            {
                var temp = b;
                b = a % b;
                a = temp;
            }

            return a;
        }
</code></pre>
<pre><code class="language-clojure">(defn euclid-mod [a b]
  (loop [i (Math/abs a) j (Math/abs b)]
    (if (zero? j)
      i
      (recur j (% i j)))))
</code></pre>
<pre><code class="language-c_cpp">// Euclidean algorithm using modulus
int euclid_mod(int a, int b) {
  a = std::abs(a);
  b = std::abs(b);

  while (b != 0) {
    a = std::exchange(b, a % b);
  }

  return a;
}
</code></pre>
<pre><code class="language-java">    public static int euclidMod(int a, int b) {
        while (b != 0) {
            int tmp = b;
            b = a % b;
            a = tmp;
        }

        return a;
    }
</code></pre>
<pre><code class="language-kotlin">fun euclidMod(a: Int, b: Int): Int {
    var a = a.absoluteValue
    var b = b.absoluteValue

    while (b != 0) {
        val tmp = b
        b = a % b
        a = tmp
    }

    return a
}
</code></pre>
<pre><code class="language-javascript">function euclidMod(a, b) {
  a = Math.abs(a);
  b = Math.abs(b);

  let temp;
  while (b !== 0) {
    temp = b;
    b = a % b;
    a = temp;
  }

  return a;
}
</code></pre>
<pre><code class="language-lisp">(defun euclid-mod (a b)
  &quot;Finds the greatest common divisor for any two integers&quot;
  (if (zerop b)
      (abs a)
      (euclid-mod b (mod a b))))
</code></pre>
<pre><code class="language-python">def euclid_mod(a, b):

    a = abs(a)
    b = abs(b)

    while b &gt; 0:
        a, b = b, a % b

    return a
</code></pre>
<pre><code class="language-haskell">euclidMod :: Integer -&gt; Integer -&gt; Integer
euclidMod a b = inner (abs a) (abs b)
  where
    -- if a divides b, then gcd is a
    inner x 0 = x
    -- otherwise, recursively call inner with b and (a mod b) as new inputs
    inner x y = inner y (x `mod` y)

</code></pre>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn euclid_rem(mut a: i64, mut b: i64) -&gt; i64 {
    a = a.abs();
    b = b.abs();
    while b != 0 {
        let tmp = b;
        b = a % b;
        a = tmp;
    }

    a
}
<span class="boring">}
</span></code></pre></pre>
<pre><code class="language-ocaml">let euclid_mod a b =
  let rec inner a = function
  | 0 -&gt; a
  | b -&gt; inner b (a mod b)
  in (inner (abs a) (abs b))
</code></pre>
<pre><code class="language-go">func euclidMod(a, b int) int {
	a = abs(a)
	b = abs(b)

	for b != 0 {
		a, b = b, a%b
	}

	return a
}
</code></pre>
<pre><code class="language-swift">func euclidMod(a: Int, b: Int) -&gt; Int {
    var a = abs(a);
    var b = abs(b);
    
    while (b != 0) {
        let temp = b
        b = a % b
        a = temp
    }
    
    return a
}
</code></pre>
<pre><code class="language-matlab">function gcd = euclidMod(a,b)
    
    a=abs(a);
    b=abs(b);
    
    while b &gt; 0
        temp = b;
        b = mod(a,b);
        a = temp;
    end
    
    gcd = a;
end
</code></pre>
<pre><code class="language-lua">local function euclid_mod(a, b)
  a = math.abs(a)
  b = math.abs(b)

  while b ~= 0 do
    a, b = b, a%b
  end

  return a
end
</code></pre>
<pre><code class="language-julia">function euclid_mod(a::Int64, b::Int64)
    a = abs(a)
    b = abs(b)

    while(b != 0)
        b,a = a%b,b
    end

    return a
end
</code></pre>
<pre><code class="language-nim">func euclid_mod(in1, in2: int): int =
  var
    a = abs(in1)
    b = abs(in2)

  while b != 0:
    let temp: int = b
    b = a mod b
    a = temp;

  result = a
</code></pre>
<pre><code class="language-asm-x64"># rdi - a
# rsi - b
# RET rax - gcd of a and b
euclid_mod:
  mov    rax, rdi           # Get abs of a
  sar    rax, 31
  xor    rdi, rax
  sub    rdi, rax
  mov    rax, rsi           # Get abs of b
  sar    rax, 31
  xor    rsi, rax
  sub    rsi, rax
  jmp    mod_check
mod_loop:
  xor    rdx, rdx           # Take the mod of a and b
  mov    rax, rdi
  div    rsi
  mov    rdi, rsi           # Set b to the mod of a and b
  mov    rsi, rdx           # Set a to b
mod_check:
  cmp    rsi, 0             # Check if b is non-zero
  jne    mod_loop
  mov    rax, rdi           # Return the result
  ret
</code></pre>
<pre><code class="language-fortran">INTEGER FUNCTION euclid_mod(a, b)
    IMPLICIT NONE
    INTEGER, INTENT(INOUT) :: a, b
    INTEGER                :: temp

    DO WHILE (b &gt; 0)
        temp = b
        b = MODULO(a,b)
        a = temp
    END DO

    euclid_mod = a

END FUNCTION euclid_mod
</code></pre>
<pre><code class="language-php">function euclid_mod(int $a, int $b): int
{
    $a = abs($a);
    $b = abs($b);

    while ($b !== 0) {
        list($b, $a) = [$a % $b, $b];
    }

    return $a;
}
</code></pre>
<pre><code class="language-factor">: euclid% ( a b -- gcd )
  [ abs ] bi@   ! take both absolute values
  [ dup zero? ] ! check if `b` (on top) is 0
  [
    ! a b -&gt; a b b -&gt; b a b -&gt; b a%b
    dup -rot mod
  ]
  until
  ! the zero is on top, so get rid of it
  drop
;
</code></pre>
<pre><code class="language-whitespace">Euclidian algorithm modulo method.
Enter two positive integers.	
	
			
		
  
   
			 
 
	 	
   	
			 
		 		   
			   	
 
			    
 
			 
 


  	
   	
				
 	

The
end.
</code></pre>
<pre><code class="language-scala">
  def euclid_mod(a: Int, b: Int): Int =
    (Math.abs(a), Math.abs(b)) match {
      case (_, 0) =&gt; a
      case (a, b) =&gt; euclid_mod(b, a % b)
</code></pre>
<pre><code class="language-racket">(define (euclid_mod a b)
  (local ((define (euclid_mod* a b)
           (if (= 0 b)
               (abs a)
               (euclid_mod* b (modulo a b))
               )
           )) (euclid_mod* a b)
    )
  )
</code></pre>
<pre><code class="language-ruby">def gcd_mod(a, b)
	a = a.abs
	b = b.abs
	a, b = b, a%b until b.zero?
	a
end
</code></pre>
<pre><code class="language-smalltalk">Integer&gt;&gt;euclidMod: secondNumber
    &quot;Euclidean algorithm with modulus.&quot;
    | a b oldB |
    a := self abs.
    b := secondNumber abs.
    [ b == 0 ] whileFalse: [ 
        oldB := b.
        b := a % b.
        a := oldB.
    ].
    ^a.
</code></pre>
<pre><code class="language-emojicode">     a  b    
     Use  (returns the absolute value) to support negative numbers.
    a   var_a
    b   var_b

      var_b  0  
      var_b  temp
      var_a  var_b  var_b
      temp  var_a
    

     var_a
  
</code></pre>
<pre><code class="language-LOLCODE">    HOW IZ I UKLIDMOD YR NUM1 AN YR NUM2
        NUM1 R I IZ ABZ YR NUM1 MKAY
        NUM2 R I IZ ABZ YR NUM2 MKAY

        IM IN YR LOOP 
            BOTH SAEM NUM2 AN 0, O RLY?
                YA RLY, FOUND YR NUM1
            OIC

            I HAS A TMP ITZ NUM2
            NUM2 R MOD OF NUM1 AN NUM2
            NUM1 R TMP
        IM OUTTA YR LOOP

    IF U SAY SO
</code></pre>
<pre><code class="language-bash">euclid_mod() {
    local a
    local b
    a=$(abs &quot;$1&quot;)
    b=$(abs &quot;$2&quot;)
    
    while (( b != 0 )); do
        ((tmp = b))
        ((b = a % b))
        ((a = tmp))
    done
    printf &quot;%s&quot; &quot;$a&quot;
}
</code></pre>
<pre><code class="language-d">// Euclidean algorithm using modulus
int euclid_mod(int a, int b) {
    int tmp;
    a = abs(a);
    b = abs(b);

    while (b != 0) {
        tmp = a % b;
        a = b;
        b = tmp;
    }

    return a;
}
</code></pre>
<!-- {% sample lang="piet" %} -->
<blockquote>
<p><img src="euclidean_algorithm/code/piet/mod/euclidian_algorithm_mod_large.png" alt="" /> <img src="euclidean_algorithm/code/piet/mod/euclidian_algorithm_mod.png" alt="" /></p>
</blockquote>
<pre><code class="language-scheme">(define (euclid-mod a b)
    (if (zero? b)
        a
        (euclid-mod b (modulo a b))))
</code></pre>
<!-- {% sample lang="scratch" %} -->
<p>
  <img  class="center" src="euclidean_algorithm/code/scratch/euclid_mod.svg" style="width:30%" />
</p>
# leave one line empty:
<pre><code class="language-powershell">function Mod-Euclid($a, $b) {
    $a = [Math]::Abs($a)
    $b = [Math]::Abs($b)

    while ($b -ne 0) {
        $tmp = $b
        $b = $a % $b
        $a = $tmp
    }

    return $a
}
</code></pre>
<pre><code class="language-coconut">def euclid_mod(a is int, 0) = a
addpattern def euclid_mod(0, b is int) = b

addpattern def euclid_mod(a is int, b is int) = euclid_mod(b, a % b)
</code></pre>
<p>Here, we set <code>b</code> to be the remainder of <code>a%b</code> and <code>a</code> to be whatever <code>b</code> was last timestep. Because of how the modulus operator works, this will provide the same information as the subtraction-based implementation, but when we show <code>a</code> and <code>b</code> as they change with time, we can see that it might take many fewer steps:</p>
<p>
    <img  class="center" src="euclidean_algorithm/res/modulus.png" style="width:70%" />
</p>
<p>The Euclidean Algorithm is truly fundamental to many other algorithms throughout the history of computer science and will definitely be used again later. At least to me, it's amazing how such an ancient algorithm can still have modern use and appeal. That said, there are still other algorithms out there that can find the greatest common divisor of two numbers that are arguably better in certain cases than the Euclidean algorithm, but the fact that we are discussing Euclid two millennia after his death shows how timeless and universal mathematics truly is. I think that's pretty cool.</p>
<h2 id="video-explanation-5"><a class="header" href="#video-explanation-5">Video Explanation</a></h2>
<p>Here's a video on the Euclidean algorithm:</p>
<div style="text-align:center">
<iframe width="560" height="315" src="https://www.youtube.com/embed/h86RzlyHfUE" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
</div>
<h2 id="example-code-7"><a class="header" href="#example-code-7">Example Code</a></h2>
<pre><code class="language-vim">function s:euclid_mod(a, b)
	let l:a = abs(a:a)
	let l:b = abs(a:b)

	while l:b != 0
		let l:c = l:b
		let l:b = l:a % l:b
		let l:a = l:c
	endwhile

	return l:a
endfunction

function s:euclid_sub(a, b)
	let l:a = abs(a:a)
	let l:b = abs(a:b)

	while l:a != l:b
		if l:a &gt; l:b
			let l:a -= l:b
		else
			let l:b -= l:a
		endif
	endwhile

	return l:a
endfunction

let s:check_1 = s:euclid_mod(64 * 67, 64 * 71)
let s:check_2 = s:euclid_sub(128 * 12, 128 * 77)

echo 'Modulus-based euclidean algorithm result:' s:check_1
echo 'subtraction-based euclidean algorithm result:' s:check_2
</code></pre>
<pre><code class="language-c_cpp">#include &lt;stdio.h&gt;
#include &lt;math.h&gt;

int euclid_mod(int a, int b) {
    a = abs(a);
    b = abs(b);

    while (b != 0) {
        int temp = b;
        b = a % b;
        a = temp;
    }

    return a;
}

int euclid_sub(int a, int b) {
    a = abs(a);
    b = abs(b);

    while (a != b) {
        if (a &gt; b) {
            a -= b;
        } else {
            b -= a;
        }
    }

    return a;
}

int main() {
    int check1 = euclid_mod(64 * 67, 64 * 81);
    int check2 = euclid_sub(128 * 12, 128 * 77);

    printf(&quot;%d\n&quot;, check1);
    printf(&quot;%d\n&quot;, check2);

    return 0;
}
</code></pre>
<h5 id="euclideanalgorithmcs"><a class="header" href="#euclideanalgorithmcs">EuclideanAlgorithm.cs</a></h5>
<pre><code class="language-csharp">// submitted by Julian Schacher (jspp)
using System;

namespace EuclideanAlgorithm
{
    public class EuclideanAlgorithm
    {
        public int EuclidSub(int a, int b)
        {
            // Math.Abs for negative number support
            a = Math.Abs(a);
            b = Math.Abs(b);

            while (a != b)
            {
                if (a &gt; b)
                    a = a - b;
                else
                    b = b - a;
            }

            return a;
        }

        public int EuclidMod(int a, int b)
        {
            // Math.Abs for negative number support
            a = Math.Abs(a);
            b = Math.Abs(b);

            while (b != 0)
            {
                var temp = b;
                b = a % b;
                a = temp;
            }

            return a;
        }
    }
}
</code></pre>
<h5 id="programcs"><a class="header" href="#programcs">Program.cs</a></h5>
<pre><code class="language-csharp">// submitted by Julian Schacher (jspp)
using System;

namespace EuclideanAlgorithm
{
    class Program
    {
        static void Main(string[] args)
        {
            Console.WriteLine(&quot;EuclideanAlgorithm&quot;);
            var euclideanAlgorithm = new EuclideanAlgorithm();
            int check = euclideanAlgorithm.EuclidMod(64 * 67, 64 * 81);
            int check2 = euclideanAlgorithm.EuclidSub(128 * 12, 128 * 77);

            Console.WriteLine(check);
            Console.WriteLine(check2);
        }
    }
}
</code></pre>
<pre><code class="language-clojure">;; earthfail
(defn euclid-sub [a b]
  (loop [i (Math/abs a) j (Math/abs b)]
    (if (= i j)
      i
      (if (&gt; i j)
        (recur (- i j) j)
        (recur i (- j i))))))
(defn euclid-mod [a b]
  (loop [i (Math/abs a) j (Math/abs b)]
    (if (zero? j)
      i
      (recur j (% i j)))))

(print
 (euclid-sub (* 64 67)
             (* 64 81))
 (euclid-mod (* 128 12)
             (* 128 77)))
</code></pre>
<pre><code class="language-c_cpp">#include &lt;cmath&gt;
#include &lt;iostream&gt;
#include &lt;utility&gt;

// Euclidean algorithm using modulus
int euclid_mod(int a, int b) {
  a = std::abs(a);
  b = std::abs(b);

  while (b != 0) {
    a = std::exchange(b, a % b);
  }

  return a;
}

// Euclidean algorithm with subtraction
int euclid_sub(int a, int b) {
  a = std::abs(a);
  b = std::abs(b);

  while (a != b) {
    if (a &gt; b) {
      a -= b;
    } else {
      b -= a;
    }
  }

  return a;
}

int main() {
  auto check1 = euclid_mod(64 * 67, 64 * 81);
  auto check2 = euclid_sub(128 * 12, 128 * 77);

  std::cout &lt;&lt; check1 &lt;&lt; '\n';
  std::cout &lt;&lt; check2 &lt;&lt; '\n';
}
</code></pre>
<pre><code class="language-java">// submitted by lolatomroflsinnlos, modified by xam4lor
public class EuclideanAlgo {
    public static int euclidSub(int a, int b) {
        a = Math.abs(a);
        b = Math.abs(b);
        
        while (a != b) {
            if (a &gt; b) {
                a -= b;
            } else {
                b -= a;
            }
        }
        
        return a;
    }
    
    public static int euclidMod(int a, int b) {
        while (b != 0) {
            int tmp = b;
            b = a % b;
            a = tmp;
        }

        return a;
    }
    
    public static void main(String[] args) {
        System.out.println(euclidMod(64 * 67, 64 * 81));
        System.out.println(euclidSub(128 * 12, 128 * 77));
    }
}
</code></pre>
<pre><code class="language-kotlin">import kotlin.math.absoluteValue

fun euclidSub(a: Int, b: Int): Int {
    var a = a.absoluteValue
    var b = b.absoluteValue

    while (a != b) {
        if (a &gt; b) a -= b
        else b -= a
    }

    return a
}

fun euclidMod(a: Int, b: Int): Int {
    var a = a.absoluteValue
    var b = b.absoluteValue

    while (b != 0) {
        val tmp = b
        b = a % b
        a = tmp
    }

    return a
}

fun main(args: Array&lt;String&gt;) {
    println(euclidSub(128 * 12, 128 * 77))
    println(euclidMod(64 * 67, 64 * 81))
}
</code></pre>
<pre><code class="language-javascript">function euclidMod(a, b) {
  a = Math.abs(a);
  b = Math.abs(b);

  let temp;
  while (b !== 0) {
    temp = b;
    b = a % b;
    a = temp;
  }

  return a;
}

function euclidSub(a, b) {
  a = Math.abs(a);
  b = Math.abs(b);

  while (a !== b) {
    if (a &gt; b) {
      a -= a - b;
    } else {
      b = b - a;
    }
  }

  return a;
}

console.log(euclidMod(64 * 67, 64 * 81));
console.log(euclidSub(128 * 12, 128 * 77));
</code></pre>
<pre><code class="language-lisp">;;;; Euclidean algorithm implementation in Common Lisp

(defun euclid-sub (a b)
  &quot;Finds the greatest common divsor for any two integers&quot;
  (defun euclid-sub* (a b)
    &quot;Finds the greatest common divisor for any two positive integers&quot;
    (if (eql a b)
        a
        (if (&gt; a b)
            (euclid-sub* (- a b) b)
            (euclid-sub* a (- b a)))))
  (euclid-sub* (abs a) (abs b)))

(defun euclid-mod (a b)
  &quot;Finds the greatest common divisor for any two integers&quot;
  (if (zerop b)
      (abs a)
      (euclid-mod b (mod a b))))

(print (euclid-sub (* 64 67) (* 64 81)))
(print (euclid-mod (* 128 12) (* 128 77)))

;; Quick test
(assert
  (eql (euclid-sub (* 64 67) (* 64 81))
       (gcd (* 64 67) (* 64 81))))

(assert
  (eql (euclid-mod (* 64 67) (* 64 81))
       (gcd (* 64 67) (* 64 81))))
</code></pre>
<pre><code class="language-python">def euclid_mod(a, b):

    a = abs(a)
    b = abs(b)

    while b &gt; 0:
        a, b = b, a % b

    return a

def euclid_sub(a, b):

    a = abs(a)
    b = abs(b)

    if a == 0:
        return b
    elif b == 0:
        return a

    while a != b:
        if a &gt; b:
            a -= b
        else:
            b -= a

    return a

if __name__==&quot;__main__&quot;:
    print('Euclidean mod: ', euclid_mod(64 * 67, 64 * 81))
    print('Euclidean sub: ', euclid_sub(128 * 12, 128 * 77))
</code></pre>
<pre><code class="language-haskell">-- Method 1: Euclid's original subtraction algorithm

euclidSub :: Integer -&gt; Integer -&gt; Integer
euclidSub a b = inner (abs a) (abs b)
  where
    inner x y
      -- if a = b, then the gcd is a
      | x == y = x
      -- if a &lt; b: Recursively call euclidSub with the a and (b-a) as new inputs
      | x &lt; y = euclidSub x (y - x)
      -- otherwise: Recursively call euclidSub with the a and (b-a) as new inputs
      | otherwise = euclidSub (x - y) y

-- _______________________________________________________________________

-- Method 2: Modern implemetation - The modulus method.

euclidMod :: Integer -&gt; Integer -&gt; Integer
euclidMod a b = inner (abs a) (abs b)
  where
    -- if a divides b, then gcd is a
    inner x 0 = x
    -- otherwise, recursively call inner with b and (a mod b) as new inputs
    inner x y = inner y (x `mod` y)

-- _________________________________________________________________________

-- Examples

main :: IO ()
main = do
  let chk1 = euclidMod (64 * 67) (64 * 81)
      chk2 = euclidSub (128 * 12) (128 * 77)
  print chk1
  print chk2
</code></pre>
<pre><pre class="playground"><code class="language-rust">// contributed by Nicole Mazzuca (ubsan)

fn euclid_sub(mut a: i64, mut b: i64) -&gt; i64 {
    a = a.abs();
    b = b.abs();
    while a != b {
        if a &lt; b {
            b -= a;
        } else {
            a -= b;
        }
    }

    a
}

fn euclid_rem(mut a: i64, mut b: i64) -&gt; i64 {
    a = a.abs();
    b = b.abs();
    while b != 0 {
        let tmp = b;
        b = a % b;
        a = tmp;
    }

    a
}

fn main() {
    let chk1 = euclid_rem(64 * 67, 64 * 81);
    let chk2 = euclid_sub(128 * 12, 128 * 77);
    println!(&quot;{}&quot;, chk1);
    println!(&quot;{}&quot;, chk2);
}
</code></pre></pre>
<pre><code class="language-ocaml">(* contributed by Nicole Mazzuca (ubsan) *)

let euclid_mod a b =
  let rec inner a = function
  | 0 -&gt; a
  | b -&gt; inner b (a mod b)
  in (inner (abs a) (abs b))

let euclid_sub a b =
  let rec inner a b =
    if a = b then
      a
    else if a &lt; b then
      inner a (b - a)
    else
      inner (a - b) b
  in (inner (abs a) (abs b))

let chk1 = euclid_mod (64 * 67) (64 * 81)
let chk2 = euclid_sub (128 * 12) (128 * 77)
let () =
  chk1 |&gt; print_int |&gt; print_newline;
  chk2 |&gt; print_int |&gt; print_newline

</code></pre>
<pre><code class="language-go">// Submitted by Chinmaya Mahesh (chin123)

package main

import &quot;fmt&quot;

func abs(a int) int {
	if a &lt; 0 {
		a = -a
	}
	return a
}

func euclidMod(a, b int) int {
	a = abs(a)
	b = abs(b)

	for b != 0 {
		a, b = b, a%b
	}

	return a
}

func euclidSub(a, b int) int {
	a = abs(a)
	b = abs(b)

	for a != b {
		if a &gt; b {
			a -= b
		} else {
			b -= a
		}
	}

	return a
}

func main() {
	check1 := euclidMod(64*67, 64*81)
	check2 := euclidSub(128*12, 128*77)

	fmt.Println(check1)
	fmt.Println(check2)
}
</code></pre>
<pre><code class="language-swift">func euclidSub(a: Int, b: Int) -&gt; Int {
    var a = abs(a)
    var b = abs(b)
    
    while (a != b) {
        if (a &gt; b) {
            a -= b
        } else {
            b -= a
        }
    }
    
    return a
}

func euclidMod(a: Int, b: Int) -&gt; Int {
    var a = abs(a);
    var b = abs(b);
    
    while (b != 0) {
        let temp = b
        b = a % b
        a = temp
    }
    
    return a
}

func main() {
    print(euclidMod(a: 64 * 67, b: 64 * 81))
    print(euclidSub(a: 128 * 12, b: 128 * 77))
}

main()
</code></pre>
<pre><code class="language-matlab">// Submitted by Max Weinstein

function gcd = euclidSub(a,b)
    
    a = abs(a);
    b = abs(b);
    
    while a ~= b
        if a &gt; b
            a = a - b;
        else
            b = b - a;
        end
    end
    
    gcd = a;
end

function gcd = euclidMod(a,b)
    
    a=abs(a);
    b=abs(b);
    
    while b &gt; 0
        temp = b;
        b = mod(a,b);
        a = temp;
    end
    
    gcd = a;
end

function euclid()
    ['gcd(520,420) via euclidSub: ',num2str(euclidSub(520,420))]
    ['gcd(183,244) via euclidMod: ',num2str(euclidMod(183,244))]
end
</code></pre>
<pre><code class="language-lua">local function euclid_sub(a, b)
  a = math.abs(a)
  b = math.abs(b)

  while a ~= b do
    if a &gt; b then
      a = a-b
    else
      b = b-a
    end
  end

  return a
end

local function euclid_mod(a, b)
  a = math.abs(a)
  b = math.abs(b)

  while b ~= 0 do
    a, b = b, a%b
  end

  return a
end

local function main()
  print(euclid_sub(128 * 12, 128 * 77))
  print(euclid_mod(64 * 67, 64 * 81))
end

main()
</code></pre>
<pre><code class="language-julia">function euclid_mod(a::Int64, b::Int64)
    a = abs(a)
    b = abs(b)

    while(b != 0)
        b,a = a%b,b
    end

    return a
end

function euclid_sub(a::Int64, b::Int64)
    a = abs(a)
    b = abs(b)

    while (a != b)
        if (a &gt; b)
            a -= b
        else
            b -= a
        end
    end

    return a
end

function main()
    check1 = euclid_mod(64 * 67, 64 * 81);
    check2 = euclid_sub(128 * 12, 128 * 77);

    println(&quot;Modulus-based euclidean algorithm result: $(check1)&quot;)
    println(&quot;subtraction-based euclidean algorithm result: $(check2)&quot;)

end

main()
</code></pre>
<p>{% sample lang=&quot;nim&quot; %}
<a href="euclidean_algorithm/code/nim/euclid_algorithm.nim">import, lang=&quot;nim&quot; %</a></p>
<pre><code class="language-asm-x64">.intel_syntax noprefix

.section .rodata
  fmt:  .string &quot;%d\n&quot;

.section .text
  .global main
  .extern printf

# rdi - a
# rsi - b
# RET rax - gcd of a and b
euclid_mod:
  mov    rax, rdi           # Get abs of a
  sar    rax, 31
  xor    rdi, rax
  sub    rdi, rax
  mov    rax, rsi           # Get abs of b
  sar    rax, 31
  xor    rsi, rax
  sub    rsi, rax
  jmp    mod_check
mod_loop:
  xor    rdx, rdx           # Take the mod of a and b
  mov    rax, rdi
  div    rsi
  mov    rdi, rsi           # Set b to the mod of a and b
  mov    rsi, rdx           # Set a to b
mod_check:
  cmp    rsi, 0             # Check if b is non-zero
  jne    mod_loop
  mov    rax, rdi           # Return the result
  ret

euclid_sub:
  mov    rax, rdi           # Get abs of a
  sar    rax, 31
  xor    rdi, rax
  sub    rdi, rax
  mov    rax, rsi           # Get abs of b
  sar    rax, 31
  xor    rsi, rax
  sub    rsi, rax
  jmp    check
loop:
  cmp    rdi, rsi           # Find which is bigger
  jle    if_true
  sub    rdi, rsi           # If a is bigger then a -= b
  jmp    check
if_true:
  sub    rsi, rdi           # Else b -= a
check:
  cmp    rsi, rdi           # Check if a and b are not equal
  jne    loop
  mov    rax, rdi           # Return results
  ret

main:
  mov    rdi, 4288          # Call euclid_mod
  mov    rsi, 5184
  call   euclid_mod
  mov    rdi, OFFSET fmt    # Print output
  mov    rsi, rax
  xor    rax, rax
  call   printf
  mov    rdi, 1536          # Call euclid_sub
  mov    rsi, 9856
  call   euclid_sub
  mov    rdi, OFFSET fmt    # Print output
  mov    rsi, rax
  xor    rax, rax
  call   printf
  xor    rax, rax           # Return 0
  ret
</code></pre>
<pre><code class="language-fortran">INTEGER FUNCTION euclid_sub(a, b)
    IMPLICIT NONE
    INTEGER, INTENT(INOUT) :: a, b

    a = ABS(a)
    b = ABS(b)

    DO WHILE (a /= b)
    
        IF (a &gt; b) THEN
            a = a - b
        ELSE
            b = b - a
        END IF
    END DO

    euclid_sub = a

END FUNCTION euclid_sub 

INTEGER FUNCTION euclid_mod(a, b)
    IMPLICIT NONE
    INTEGER, INTENT(INOUT) :: a, b
    INTEGER                :: temp

    DO WHILE (b &gt; 0)
        temp = b
        b = MODULO(a,b)
        a = temp
    END DO

    euclid_mod = a

END FUNCTION euclid_mod

PROGRAM euclidean

    IMPLICIT NONE
    INTEGER :: a, b, euclid_sub, euclid_mod
    
    a = 24
    b = 27
    WRITE(*,*) 'Subtraction method: GCD is: ', euclid_sub(a, b)
    
    a = 24
    b = 27
    WRITE(*,*) 'Modulus method:     GCD is: ', euclid_mod(a, b)

END PROGRAM euclidean 
</code></pre>
<pre><code class="language-php">&lt;?php
declare(strict_types=1);

function euclid_sub(int $a, int $b): int
{
    $a = abs($a);
    $b = abs($b);

    while ($a !== $b) {
        if ($a &gt; $b) {
            $a = $a - $b;
        } else {
            $b = $b - $a;
        }
    }

    return $a;
}

function euclid_mod(int $a, int $b): int
{
    $a = abs($a);
    $b = abs($b);

    while ($b !== 0) {
        list($b, $a) = [$a % $b, $b];
    }

    return $a;
}

printf('Euclidean mod: %s', euclid_mod(64 * 67, 64 * 81));
echo PHP_EOL;
printf('Euclidean sub: %s', euclid_sub(128 * 12, 128 * 77));
echo PHP_EOL;
</code></pre>
<pre><code class="language-factor">: euclid- ( a b -- gcd )
  [ abs ] bi@
  [ 2dup = ]
  [
    ! make sure the lower number is deeper
    2dup &gt;= [ swap ] when
    over -
    ! leaves us with stack { &lt;lower&gt; &lt;greater - lower&gt; }
  ]
  until
  ! we have the GCD twice now, drop one
  drop
;

: euclid% ( a b -- gcd )
  [ abs ] bi@   ! take both absolute values
  [ dup zero? ] ! check if `b` (on top) is 0
  [
    ! a b -&gt; a b b -&gt; b a b -&gt; b a%b
    dup -rot mod
  ]
  until
  ! the zero is on top, so get rid of it
  drop
;

42 56 euclid% .  ! 14
48 180 euclid% . ! 12

42 56 euclid- .  ! 14
48 180 euclid- . ! 12

</code></pre>
<pre><code class="language-whitespace">Reading the input: a, b
[SPACE][SPACE][SPACE][LF]            push 0
[SPACE][SPACE][SPACE][TAB][LF]       push 1
[TAB][LF][TAB][TAB]                  readi
[TAB][LF][TAB][TAB]                  readi

Loop: a, b =&gt; a, b-a
[LF][SPACE][SPACE][LF]               label_0:
[SPACE][SPACE][SPACE][LF]              push 0
[TAB][TAB][TAB]                        retrieve
[SPACE][SPACE][SPACE][TAB][LF]         push 1
[TAB][TAB][TAB]                        retrieve
[TAB][SPACE][SPACE][TAB]               sub
[SPACE][LF][SPACE]                     dup
[LF][TAB][SPACE][TAB][LF]              jmp zero label_1
[SPACE][LF][SPACE]                     dup
[LF][TAB][TAB][TAB][SPACE][LF]         jmp neg label_2
[SPACE][SPACE][SPACE][LF]              push 0
[SPACE][LF][TAB]                       swap
[TAB][TAB][SPACE]                      store
[LF][SPACE][LF][LF]                    jmp label_0

Exit when a=b
[LF][SPACE][SPACE][TAB][LF]          label_1:
[SPACE][SPACE][SPACE][LF]              push 0
[TAB][TAB][TAB]                        retrieve
[TAB][LF][SPACE][TAB]                  printi
[LF][LF][LF]                           end

If a&gt;b: a, b =&gt; a-b, b
[LF][SPACE][SPACE][TAB][SPACE][LF]   label_2:
[SPACE][SPACE][SPACE][LF]              push 0
[SPACE][LF][TAB]                       swap
[TAB][SPACE][SPACE][TAB]               sub
[SPACE][SPACE][SPACE][TAB][LF]         push 1
[SPACE][LF][TAB]                       swap
[TAB][TAB][SPACE]                      store
[LF][SPACE][LF][LF]                    jmp label_0
</code></pre>
<pre><code class="language-whitespace">Reading the input: a, b
[SPACE][SPACE][SPACE][LF]       push 0
[SPACE][SPACE][SPACE][TAB][LF]  push 1
[TAB][LF][TAB][TAB]             readi
[TAB][LF][TAB][TAB]             readi

Loop: a, b =&gt; b, a%b
[LF][SPACE][SPACE][LF]          label_0:
[SPACE][SPACE][SPACE][LF]         push 0
[TAB][TAB][TAB]                   retrieve
[SPACE][LF][SPACE]                dup
[LF][TAB][SPACE][TAB][LF]         jmp zero label_1
[SPACE][SPACE][SPACE][TAB][LF]    push 1
[TAB][TAB][TAB]                   retrieve
[SPACE][LF][TAB]                  swap
[TAB][SPACE][TAB][TAB]            mod
[SPACE][SPACE][SPACE][LF]         push 0
[TAB][TAB][TAB]                   retrieve
[SPACE][SPACE][SPACE][TAB][LF]    push 1
[SPACE][LF][TAB]                  swap
[TAB][TAB][SPACE]                 store
[SPACE][SPACE][SPACE][LF]         push 0
[SPACE][LF][TAB]                  swap
[TAB][TAB][SPACE]                 store
[LF][SPACE][LF][LF]               jmp label_0

Exit when b=0
[LF][SPACE][SPACE][TAB][LF]     label_1:
[SPACE][SPACE][SPACE][TAB][LF]    push 1
[TAB][TAB][TAB]                   retrieve
[TAB][LF][SPACE][TAB]             printi
[LF][LF][LF][LF]                  end
</code></pre>
<pre><code class="language-scala">object Euclid {

  def euclid_sub(a: Int, b: Int): Int =
    (Math.abs(a), Math.abs(b)) match {
      case (0, _) | (_, 0) =&gt; 0
      case (x, y) if x &lt; y =&gt; euclid(x, y - x)
      case (x, y) if x &gt; y =&gt; euclid(x - y, y)
      case _ =&gt; a
    }

  def euclid_mod(a: Int, b: Int): Int =
    (Math.abs(a), Math.abs(b)) match {
      case (_, 0) =&gt; a
      case (a, b) =&gt; euclid_mod(b, a % b)
    }

  def main(args: Array[String]): Unit = {
    println(euclid_sub(151 * 899, 151 * 182))
    println(euclid_mod(151 * 899, 151 * 182))
  }

}
</code></pre>
<pre><code class="language-racket">#lang racket

(define (euclid_sub a b)
  (local ((define (euclid_sub* x y)
          (if (= x y)
              x
              (if (&gt; x y)
                  (euclid_sub* (- x y) y)
                  (euclid_sub* x (- y x))
                  )
              )
          )) (euclid_sub* (abs a) (abs b))
    )
  )

(define (euclid_mod a b)
  (local ((define (euclid_mod* a b)
           (if (= 0 b)
               (abs a)
               (euclid_mod* b (modulo a b))
               )
           )) (euclid_mod* a b)
    )
  )

(displayln (euclid_sub (* 64 67) (* 64 81)))
(displayln (euclid_mod (* 128 12) (* 128 77)))
</code></pre>
<pre><code class="language-ruby">def gcd_mod(a, b)
	a = a.abs
	b = b.abs
	a, b = b, a%b until b.zero?
	a
end
 
def gcd_minus(a, b)
	a = a.abs
	b = b.abs
	until a == b
		if a &gt; b
			a -= b
		else
			b -= a
		end
	end
	a
end
 
p gcd_mod(12 * 6, 12 * 4) #=&gt; 12
p gcd_mod(9 * 667, 9 * 104) #=&gt; 9

p gcd_minus(12 * 6, 12 * 4) #=&gt; 12
p gcd_minus(9 * 667, 9 * 104) #=&gt; 9
</code></pre>
<pre><code class="language-smalltalk">Integer&gt;&gt;euclidSub: secondNumber
    &quot;Euclidean algorithm with subtraction&quot;
    | a b |
    a := self abs.
    b := secondNumber abs.
    [ a == b ] whileFalse: [ 
        a &gt; b ifTrue: [ 
            a := a - b.
        ] ifFalse: [ 
            b := b - a.
        ].
    ].
    ^a.

Integer&gt;&gt;euclidMod: secondNumber
    &quot;Euclidean algorithm with modulus.&quot;
    | a b oldB |
    a := self abs.
    b := secondNumber abs.
    [ b == 0 ] whileFalse: [ 
        oldB := b.
        b := a % b.
        a := oldB.
    ].
    ^a.

Transcript show: ((64 * 67) euclidSub: (64 * 81)).
Transcript cr.
Transcript show: ((128 * 12) euclidMod: (128 * 77)).
</code></pre>
<pre><code class="language-emojicode">  
     a  b    
     Use  (returns the absolute value) to support negative numbers.
    a   var_a
    b   var_b

      var_a  var_b  
       var_a  var_b 
        var_a   var_b
      
       
        var_b   var_a
      
    

     var_a
  

     a  b    
     Use  (returns the absolute value) to support negative numbers.
    a   var_a
    b   var_b

      var_b  0  
      var_b  temp
      var_a  var_b  var_b
      temp  var_a
    

     var_a
  


 
     64  67 64  81  10 
     128  12 128  77  10 

</code></pre>
<pre><code class="language-LOLCODE">HAI 1.2
    HOW IZ I ABZ YR NUM
        DIFFRINT NUM AN BIGGR OF NUM AN 0, O RLY?
            YA RLY, FOUND YR DIFF OF 0 AN NUM
            NO WAI, FOUND YR NUM
        OIC
    IF U SAY SO

    HOW IZ I UKLIDMOD YR NUM1 AN YR NUM2
        NUM1 R I IZ ABZ YR NUM1 MKAY
        NUM2 R I IZ ABZ YR NUM2 MKAY

        IM IN YR LOOP 
            BOTH SAEM NUM2 AN 0, O RLY?
                YA RLY, FOUND YR NUM1
            OIC

            I HAS A TMP ITZ NUM2
            NUM2 R MOD OF NUM1 AN NUM2
            NUM1 R TMP
        IM OUTTA YR LOOP

    IF U SAY SO

    HOW IZ I UKLIDSUP YR NUM1 AN YR NUM2
        NUM1 R I IZ ABZ YR NUM1 MKAY
        NUM2 R I IZ ABZ YR NUM2 MKAY

        IM IN YR LOOP 
            BOTH SAEM NUM1 AN NUM2, O RLY?
                YA RLY, FOUND YR NUM1
            OIC        

            DIFFRINT NUM1 AN SMALLR OF NUM1 AN NUM2, O RLY?
                YA RLY, NUM1 R DIFF OF NUM1 AN NUM2
                NO WAI, NUM2 R DIFF OF NUM2 AN NUM1
            OIC
        IM OUTTA YR LOOP

    IF U SAY SO

    I HAS A CHECK1 ITZ I IZ UKLIDMOD YR PRODUKT OF 64 AN 67 AN YR PRODUKT OF 64 AN 81 MKAY
    I HAS A CHECK2 ITZ I IZ UKLIDSUP YR PRODUKT OF 128 AN 12  AN YR PRODUKT OF 128 AN 77 MKAY

    VISIBLE CHECK1
    VISIBLE CHECK2
KTHXBYE
</code></pre>
<pre><code class="language-bash">#!/usr/bin/env bash
abs() {
    local ret=$1
    if (( ret &lt; 0 )); then
        ((ret *= -1))
    fi
    printf &quot;%s&quot; &quot;$ret&quot;
} 

euclid_mod() {
    local a
    local b
    a=$(abs &quot;$1&quot;)
    b=$(abs &quot;$2&quot;)
    
    while (( b != 0 )); do
        ((tmp = b))
        ((b = a % b))
        ((a = tmp))
    done
    printf &quot;%s&quot; &quot;$a&quot;
}

euclid_sub() {
    local a
    local b
    a=$(abs &quot;$1&quot;)
    b=$(abs &quot;$2&quot;)
    
    while (( a != b )); do
        if (( a &gt; b )); then
            ((a -= b))
        else
            ((b -= a))
        fi
    done
    printf &quot;%s&quot; &quot;$a&quot;
}

result=$(euclid_mod $((64 * 67)) $((64 * 81)))
echo &quot;$result&quot;
result=$(euclid_sub $((128 * 12)) $((128 * 77)))
echo &quot;$result&quot;
</code></pre>
<pre><code class="language-d">import std.stdio;
import std.math;

// Euclidean algorithm using modulus
int euclid_mod(int a, int b) {
    int tmp;
    a = abs(a);
    b = abs(b);

    while (b != 0) {
        tmp = a % b;
        a = b;
        b = tmp;
    }

    return a;
}

// Euclidean algorithm with subtraction
int euclid_sub(int a, int b) {
    a = abs(a);
    b = abs(b);

    while (a != b) {
        if (a &gt; b) {
            a -= b;
        } else {
            b -= a;
        }
    }

    return a;
}

void main()
{
    auto check1 = euclid_mod(64 * 67, 64 * 81);
    auto check2 = euclid_sub(128 * 12, 128 * 77);

    writeln(&quot;Modulus-based euclidean algorithm result: &quot;, check1);
    writeln(&quot;Subtraction-based euclidean algorithm result: &quot;, check2);
}
</code></pre>
<p>A text version of the program is provided for both versions.</p>
<h4 id="subtraction"><a class="header" href="#subtraction">Subtraction</a></h4>
<blockquote>
<p><img src="euclidean_algorithm/code/piet/subtract/euclidian_algorithm_subtract_large.png" alt="" /> <img src="euclidean_algorithm/code/piet/subtract/euclidian_algorithm_subtract.png" alt="" /></p>
</blockquote>
<pre><code class="language-piet">COMMAND                 STATE OF STACK
in(number)              A           // Take A as an input
duplicate               AA          // Start to take the absolute value of A
push 1                  1AA
duplicate               11AA
subtract                0AA
greater                 0/1A        // 1 if A &gt; 0, 0 if A &lt;= 0
not                     1/0A        // 0 if A &gt; 0, 1 if A &lt;= 0
push 1                  1 1/0 A
push 3                  31 1/0 A
subtract                -2 1/0 A
multiply                -2/0 A
push 1                  1 -2/0 A
add                     -1/1 A
multiply                A           // A should now be an absolute value

in(number)              BA          // Take B as an input
duplicate               BBA         // Start to take the absolute value of B
push 1                  1BBA
duplicate               11BBA
subtract                0BBA
greater                 0/1BA        // 1 if B &gt; 0, 0 if B &lt;= 0
not                     1/0BA        // 0 if B &gt; 0, 1 if B &lt;= 0
push 1                  1 1/0 BA
push 3                  31 1/0 BA
subtract                -2 1/0 BA
multiply                -2/0 BA
push 1                  1 -2/0 BA
add                     -1/1 BA
multiply                BA          // B should now be an absolute value

// Start of the main loop while a  b 
duplicate               BBA
push 3                  3BBA
push 2                  23BBA
roll                    ABB
duplicate               AABB
push 4                  4AABB
push 1                  14AABB
roll                    ABBA
subtract                0/x BA
not                     1/0 BA      // 1 if a = b and 0 if a  b
not                     0/1 BA      // 1 if a  b and 0 if a = b
pointer                 BA          // If a  b, the DP should change one clockwise, otherwise, go straight ahead.

    // Go left if a  b (DP changed one clockwise)
    duplicate               BBA
    push 3                  3BBA
    push 2                  23BBA
    roll                    ABB
    duplicate               AABB
    push 4                  4AABB
    push 1                  14AABB
    roll                    ABBA
    push 2                  2ABBA
    push 1                  12ABBA
    roll                    BABA
    greater                 0/1 BA          // A &gt; B; 1 if true; 0 if false
    pointer                 BA              // If A &gt; B, DP goes one clockwise, otherwise, DP stays the same. 

        // If A &gt; B (DP has changed 1 clockwise)
        duplicate               BBA
        push 3                  3BBA
        push 1                  13BBA
        roll                    BAB
        subtract                AB              // A = A - B
        push 2                  2AB
        push 1                  12AB
        roll                    BA
        // Go back to start of loop

        // If B &gt; A (DP stayed the same)
        push 2                  2BA
        push 1                  12BA
        roll                    AB
        duplicate               AAB
        push 3                  3AAB
        push 1                  13AAB
        roll                    ABA
        subtract                BA              // B = B - A
        // Go back to start of loop

// Go down if a = b (end of while loop)
pop                     A
out(number)             -               // Print out A when done.
</code></pre>
<h4 id="modulo"><a class="header" href="#modulo">Modulo</a></h4>
<blockquote>
<p><img src="euclidean_algorithm/code/piet/mod/euclidian_algorithm_mod_large.png" alt="" /> <img src="euclidean_algorithm/code/piet/mod/euclidian_algorithm_mod.png" alt="" /></p>
</blockquote>
<pre><code class="language-piet">COMMAND                 STATE OF STACK
in(number)              A
in(number)              BA

//  Start of loop
duplicate               BBA
not                     0/1 BA
not                     1/0 BA
pointer                 BA

    // Go down if b  0
    duplicate               TBA
    push 3                  3TBA                  
    push 1                  13TBA
    roll                    BAT
    mod                     BA          // b = a mod b; a = t
    // Go back to the start of the loop

// Go right if b = 0
pop                     A
out(number)             -               // Print out A when done.
</code></pre>
<pre><code class="language-scheme">(define (euclid-sub a b)
    (cond                                                                                                                                                                                                                                                                         
        [(or (negative? a)(negative? b))(euclid-sub (abs a)(abs b))]                                                                                                                                                                                                              
        [(eq? a b) a]
        [(&gt; a b)(euclid-sub(- a b) b)]
        [else
            (euclid-sub a (- b a))]))

(define (euclid-mod a b)
    (if (zero? b)
        a
        (euclid-mod b (modulo a b))))

(display (euclid-mod (* 64 67) (* 64 81))) (newline)
(display (euclid-sub (* 128 12) (* 128 77))) (newline)

</code></pre>
<p>
The code snippets were taken from this [Scratch project](https://scratch.mit.edu/projects/278727055/)
</p>
<p>
  <img  class="center" src="euclidean_algorithm/code/scratch/main.svg" style="width:30%" />
</p>
<pre><code class="language-powershell">function Sub-Euclid($a, $b) {
    $a = [Math]::Abs($a)
    $b = [Math]::Abs($b)

    while ($a -ne $b) {
        if ($a -gt $b) {
            $a = $a - $b
        } else {
            $b = $b - $a
        }
    }
    
    return $a
}

function Mod-Euclid($a, $b) {
    $a = [Math]::Abs($a)
    $b = [Math]::Abs($b)

    while ($b -ne 0) {
        $tmp = $b
        $b = $a % $b
        $a = $tmp
    }

    return $a
}

Write-Host &quot;Subtraction-based euclidean algorithm result: $(Mod-Euclid $(64 * 67) $(64 * 81))&quot;
Write-Host &quot;Modulus-based euclidean algorithm result: $(Sub-Euclid $(128 * 12) $(128 * 77))&quot;
</code></pre>
<pre><code class="language-coconut">def euclid_sub(a is int, 0) = a
addpattern def euclid_sub(0, b is int) = b

addpattern def euclid_sub(a is int, b is int):
    if a &lt; b:
        return euclid_sub(a, b - a)
    elif b &lt; a:
        return euclid_sub(a - b, b)
    return a


def euclid_mod(a is int, 0) = a
addpattern def euclid_mod(0, b is int) = b

addpattern def euclid_mod(a is int, b is int) = euclid_mod(b, a % b)

if __name__ == '__main__':
    print('Euclidean mod:', euclid_mod(64 * 67, 64 * 81))
    print('Euclidean sub:', euclid_sub(128 * 12, 128 * 77))
</code></pre>
<h2 id="license-18"><a class="header" href="#license-18">License</a></h2>
<h5 id="code-examples-16"><a class="header" href="#code-examples-16">Code Examples</a></h5>
<p>The code examples are licensed under the MIT license (found in <a href="https://github.com/algorithm-archivists/algorithm-archive/blob/master/LICENSE.md">LICENSE.md</a>).</p>
<h5 id="text-18"><a class="header" href="#text-18">Text</a></h5>
<p>The text of this chapter was written by <a href="https://github.com/leios">James Schloss</a> and is licensed under the <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</p>
<p><a href="https://creativecommons.org/licenses/by-sa/4.0/"><p><img  class="center" src="euclidean_algorithm/../cc/CC-BY-SA_icon.svg" /></p></a></p>
<h5 id="imagesgraphics-11"><a class="header" href="#imagesgraphics-11">Images/Graphics</a></h5>
<ul>
<li>The image &quot;<a href="euclidean_algorithm/res/subtraction.png">Euclidsub</a>&quot; was created by <a href="https://github.com/leios">James Schloss</a> and is licensed under the <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</li>
<li>The image &quot;<a href="euclidean_algorithm/res/modulus.png">Euclidmod</a>&quot; was created by <a href="https://github.com/leios">James Schloss</a> and is licensed under the <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</li>
</ul>
<h5 id="pull-requests-15"><a class="header" href="#pull-requests-15">Pull Requests</a></h5>
<p>After initial licensing (<a href="https://github.com/algorithm-archivists/algorithm-archive/pull/560">#560</a>), the following pull requests have modified the text or graphics of this chapter:</p>
<ul>
<li>none</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="monte-carlo-integration"><a class="header" href="#monte-carlo-integration">Monte Carlo Integration</a></h1>
<p>Monte Carlo methods were some of the first methods I ever used for research, and when I learned about them, they seemed like some sort of magic.
Their premise is simple: random numbers can be used to integrate arbitrary shapes embedded into other objects.
Nowadays, &quot;Monte Carlo&quot; has become a bit of a catch-all term for methods that use random numbers to produce real results, but it all started as a straightforward method to integrate objects.
No matter how you slice it, the idea seems a bit crazy at first.
After all, random numbers are random.
How could they possibly be used to find non-random values?</p>
<p>Well, imagine you have a square.
The area of the square is simple, \( \text{Area}<em>{\text{square}} = \text{length} \times \text{width} \).
Since it's a square, the \( \text{length} \) and \( \text{width} \) are the same, so the formula is technically just \( \text{Area}</em>{\text{square}} = \text{length}^2 \).
If we embed a circle into the square with a radius \( r = \tfrac{length}{2} \) (shown below), then its area is \( \text{Area}<em>{\text{circle}}=\pi r^2 \).
For simplicity, we can also say that \( \text{Area}</em>{\text{square}}=4r^2 \).</p>
<p>
    <img  class="center" src="monte_carlo_integration/res/square_circle.png" style="width:40%"/>
</p>
<p>Now, let's say we want to find the area of the circle without an equation.
As we said before, it's embedded in the square, so we should be able to find some ratio of the area of the square to the area of the circle:</p>
<p>\[ \text{Ratio} = \frac{\text{Area}<em>{\text{circle}}}{\text{Area}</em>{\text{square}}} \]</p>
<p>This means,</p>
<p>\[ \text{Area}<em>{\text{circle}} = \text{Area}</em>{\text{square}}\times\text{Ratio} = 4r^2 \times \text{ratio} \]</p>
<p>So, if we can find the \( \text{Ratio} \) and we know \( r \), we should be able to easily find the \( \text{Area}_{\text{circle}} \).
The question is, &quot;How do we easily find the \( \text{Ratio} \)?&quot;
Well, one way is with <em>random sampling</em>.
We basically just pick a bunch of points randomly in the square, and
each point is tested to see whether it's in the circle or not:</p>
<pre><code class="language-julia">function in_circle(x_pos::Float64, y_pos::Float64)

    # Setting radius to 1 for unit circle
    radius = 1
    return x_pos^2 + y_pos^2 &lt; radius^2
end
</code></pre>
<pre><code class="language-clojure">(defn in-circle? [pv r]
  &quot;take a vector representing point and radius return true if the
  point is inside the circle&quot;
  (&lt; (-&gt;&gt;
      pv
      (map #(* % %))
      (reduce +))
     (* r r)))
</code></pre>
<pre><code class="language-c">bool in_circle(double x, double y) {
    return x * x + y * y &lt; 1;
}
</code></pre>
<pre><code class="language-cpp">/**
 * Check if the point (x, y) is within a circle of a given radius.
 * @param x coordinate one
 * @param y coordinate two
 * @param r radius of the circle (optional)
 * @return true if (x, y) is within the circle.
 */
inline bool in_circle(double x, double y, double r = 1) {
    return x * x + y * y &lt; r * r;
}
</code></pre>
<pre><code class="language-javascript">function inCircle(xPos, yPos) {
  // Setting radius to 1 for unit circle
  let radius = 1;
  return xPos * xPos + yPos * yPos &lt; radius * radius;
}
</code></pre>
<pre><code class="language-haskell">        inCircle (x, y) = x^2 + y^2 &lt; 1
</code></pre>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn in_circle(x: f64, y: f64, radius: f64) -&gt; bool {
    x * x + y * y &lt; radius * radius
}
<span class="boring">}
</span></code></pre></pre>
<pre><code class="language-d">bool inCircle(real x, real y)
{
    return x ^^ 2 + y ^^ 2 &lt; 1.0;
}
</code></pre>
<pre><code class="language-go">func inCircle(x, y float64) bool {
	return x*x+y*y &lt; 1.0 // the radius of an unit circle is 1.0
}
</code></pre>
<pre><code class="language-r">in_circle &lt;- function(x, y, radius = 1){
        # Return True if the point is in the circle and False otherwise.
        return((x*x + y*y) &lt; radius*radius)
}

</code></pre>
<pre><code class="language-java">    private static boolean inCircle(double x, double y) {
        return x * x + y * y &lt; 1;
    }
</code></pre>
<pre><code class="language-swift">func inCircle(x: Double, y: Double, radius: Double) -&gt; Bool {
    return (x*x) + (y*y) &lt; radius*radius
}
</code></pre>
<pre><code class="language-python">def in_circle(x, y, radius = 1):
	&quot;&quot;&quot;Return True if the point is in the circle and False otherwise.&quot;&quot;&quot;
	return (x*x + y*y) &lt; radius*radius
</code></pre>
<pre><code class="language-csharp">        public bool IsInMe(Point point) =&gt; Math.Pow(point.X, 2) + Math.Pow(point.Y, 2) &lt; Math.Pow(Radius, 2);
</code></pre>
<pre><code class="language-nim">proc in_circle(x, y, radius: float): bool =
  return x * x + y * y &lt; radius * radius
</code></pre>
<pre><code class="language-ruby">def in_circle(x, y, radius=1)
  # Check if coords are in circle via Pythagorean Thm
  return (x*x + y*y) &lt; radius*radius
end
</code></pre>
<pre><code class="language-fortran">FUNCTION in_circle(pos_x, pos_y, r)
    IMPLICIT NONE
    REAL(16), INTENT(IN) :: pos_x, pos_y, r
    LOGICAL              :: in_circle

    in_circle = (pos_x ** 2 + pos_y ** 2) &lt; r ** 2

END FUNCTION in_circle 
</code></pre>
<p>{% sample lang=&quot;factor&quot; %}
<a href="monte_carlo_integration/code/factor/monte_carlo.factor">import:9-12 lang:&quot;factor&quot;</a></p>
<pre><code class="language-emojicode">    point    
     point  point_x
     point  point_y
     point_x  point_x  point_y  point_y  radius  radius
  
</code></pre>
<pre><code class="language-php">function in_circle(float $positionX, float $positionY, float $radius = 1): bool
{
    return pow($positionX, 2) + pow($positionY, 2) &lt; pow($radius, 2);
}
</code></pre>
<pre><code class="language-lua">local function in_circle(x, y)
  return x*x + y*y &lt; 1
end
</code></pre>
<pre><code class="language-racket">(define (in-circle x y)
  &quot;Checks if a point is in a unit circle&quot;
  (&lt; (+ (sqr x) (sqr y)) 1))
</code></pre>
<pre><code class="language-scala">  def inCircle(x: Double, y: Double) = x * x + y * y &lt; 1
</code></pre>
<pre><code class="language-lisp">(defun in-circle-p (x y)
  &quot;Checks if a point is in a unit circle&quot;
  (&lt; (+ (* x x) (* y y)) 1))
</code></pre>
<pre><code class="language-asm-x64"># xmm0 - x
# xmm1 - y
# RET rax - bool
in_circle:
  mulsd  xmm0, xmm0                  # Calculate x * x + y * y
  mulsd  xmm1, xmm1
  addsd  xmm0, xmm1
  movsd  xmm1, one                   # Set circle radius to 1
  xor    rax, rax
  comisd xmm1, xmm0                  # Return bool xmm0 &lt; xmm1
  seta al
  ret
</code></pre>
<pre><code class="language-bash">inCircle() {
    local ret
    local mag
    ((ret = 0))
    if (($1 ** 2 + $2 ** 2 &lt; 1073676289)); then # 1073676289 = 32767 ** 2
        ((ret = 1))
    fi
    printf &quot;%d&quot; $ret
}
</code></pre>
<pre><code class="language-kotlin">private fun inCircle(x: Double, y: Double, radius: Double = 1.0) = (x * x + y * y) &lt; radius * radius
</code></pre>
<pre><code class="language-matlab">    % a 2 by n array, rows are xs and ys
    xy_array = rand(2, n);   

    % square every element in the array
    squares_array = xy_array.^2;            
    
    % sum the xs and ys and check if it's in the quarter circle
    incircle_array = sum(squares_array)&lt;1;  
</code></pre>
<p>{% sample lang=&quot;scratch&quot; %}</p>
<p>
    <img  class="center" src="monte_carlo_integration/code/scratch/InCircle.svg" style="width:40%" />
</p>
```coconut
data point(x, y):
    def __abs__(self) = (self.x, self.y) |> map$(pow$(?, 2)) |> sum |> math.sqrt
<p>def in_circle(p is point, radius = 1):
&quot;&quot;&quot;Return True if the point is in the circle and False otherwise.&quot;&quot;&quot;
return abs(p) &lt; radius</p>
<pre><code>```powershell
function Is-InCircle($x, $y, $radius=1) {
    return ([Math]::Pow($x, 2) + [Math]::Pow($y, 2)) -lt [Math]::Pow($radius, 2)
}
</code></pre>
<p>If it's in the circle, we increase an internal count by one, and in the end,</p>
<p>\[ \text{Ratio} = \frac{\text{count in circle}}{\text{total number of points used}} \]</p>
<p>If we use a small number of points, this will only give us a rough approximation, but as we start adding more and more points, the approximation becomes much, much better (as shown below)!</p>
<p>
    <img  class="center" src="monte_carlo_integration/res/monte_carlo.gif" style="width:60%"/>
</p>
<p>The true power of Monte Carlo comes from the fact that it can be used to integrate literally any object that can be embedded into the square.
As long as you can write some function to tell whether the provided point is inside the shape you want (like <code>in_circle()</code> in this case), you can use Monte Carlo integration!
This is obviously an incredibly powerful tool and has been used time and time again for many different areas of physics and engineering.
I can guarantee that we will see similar methods crop up all over the place in the future!</p>
<h2 id="video-explanation-6"><a class="header" href="#video-explanation-6">Video Explanation</a></h2>
<p>Here is a video describing Monte Carlo integration:</p>
<div style="text-align:center">
<iframe width="560" height="315" src="https://www.youtube.com/embed/AyBNnkYrSWY" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
</div>
<h2 id="example-code-8"><a class="header" href="#example-code-8">Example Code</a></h2>
<p>Monte Carlo methods are famous for their simplicity.
It doesn't take too many lines to get something simple going.
Here, we are just integrating a circle, like we described above; however, there is a small twist and trick.
Instead of calculating the area of the circle, we are instead trying to find the value of \( \pi \), and
rather than integrating the entire circle, we are only integrating the upper right quadrant of the circle from \( 0 &lt; x, y &lt; 1 \).
This saves a bit of computation time, but also requires us to multiply our output by \( 4 \).</p>
<p>That's all there is to it!
Feel free to submit your version via pull request, and thanks for reading!</p>
<pre><code class="language-julia"># function to determine whether an x, y point is in the unit circle
function in_circle(x_pos::Float64, y_pos::Float64)

    # Setting radius to 1 for unit circle
    radius = 1
    return x_pos^2 + y_pos^2 &lt; radius^2
end

# function to integrate a unit circle to find pi via monte_carlo
function monte_carlo(n::Int64)

    pi_count = 0
    for i = 1:n
        point_x = rand()
        point_y = rand()

        if (in_circle(point_x, point_y))
            pi_count += 1
        end
    end

    # This is using a quarter of the unit sphere in a 1x1 box.
    # The formula is pi = (box_length^2 / radius^2) * (pi_count / n), but we
    #     are only using the upper quadrant and the unit circle, so we can use
    #     4*pi_count/n instead
    return 4*pi_count/n
end

pi_estimate = monte_carlo(10000000)
println(&quot;The pi estimate is: &quot;, pi_estimate)
println(&quot;Percent error is: &quot;, 100 * abs(pi_estimate - pi) / pi, &quot; %&quot;)
</code></pre>
<pre><code class="language-clojure">(ns monte-carlo.core)

(defn in-circle? [pv r]
  &quot;take a vector representing point and radius return true if the
  point is inside the circle&quot;
  (&lt; (-&gt;&gt;
      pv
      (map #(* % %))
      (reduce +))
     (* r r)))

(defn rand-point [r]
  &quot;return a random point from (0,0) inclusive to (r,r) exclusive&quot;
  (repeatedly 2 #(rand r)))

(defn monte-carlo [n r]
  &quot;take the number of random points and radius return an estimate to
pi&quot;
  (*' 4 (/ n)
      (loop [i n count 0]
        (if (zero? i)
          count
          (recur (dec i)
                 (if (in-circle? (rand-point r) r)
                   (inc count)
                   count))))))

(defn -main []
  (let [constant-pi Math/PI
        computed-pi (monte-carlo 10000000 2) ;; this may take some time on lower end machines
        difference (Math/abs (- constant-pi computed-pi))
        error (* 100 (/ difference constant-pi))]
    (println &quot;world's PI: &quot; constant-pi
             &quot;,our PI: &quot; (double computed-pi)
             &quot;,error: &quot; error)))
</code></pre>
<pre><code class="language-c">#include &lt;math.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdbool.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;time.h&gt;

bool in_circle(double x, double y) {
    return x * x + y * y &lt; 1;
}

double monte_carlo(unsigned int samples) {
    unsigned int count = 0;

    for (unsigned int i = 0; i &lt; samples; ++i) {
        double x = (double)rand() / RAND_MAX;
        double y = (double)rand() / RAND_MAX;

        if (in_circle(x, y)) {
            count += 1;
        }
    }

    return 4.0 * count / samples;
}

int main() {
    srand(time(NULL));

    double estimate = monte_carlo(1000000);

    printf(&quot;The estimate of pi is %g\n&quot;, estimate);
    printf(&quot;Percentage error: %0.2f%%\n&quot;, 100 * fabs(M_PI - estimate) / M_PI);

    return 0;
}
</code></pre>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;cstdlib&gt;
#include &lt;random&gt;

constexpr double PI = 3.14159265358979323846264338;

/**
 * Check if the point (x, y) is within a circle of a given radius.
 * @param x coordinate one
 * @param y coordinate two
 * @param r radius of the circle (optional)
 * @return true if (x, y) is within the circle.
 */
inline bool in_circle(double x, double y, double r = 1) {
    return x * x + y * y &lt; r * r;
}

/**
 * Return an estimate of PI using Monte Carlo integration.
 * @param samples number of iterations to use
 * @return estimate of pi
 */
double monte_carlo_pi(unsigned samples) {
    static std::default_random_engine generator;
    static std::uniform_real_distribution&lt;double&gt; dist(0, 1);

    unsigned count = 0;
    for (unsigned i = 0; i &lt; samples; ++i) {
        double x = dist(generator);
        double y = dist(generator);

        if (in_circle(x, y))
            ++count;
    }

    return 4.0 * count / samples;
}

int main() {
    unsigned samples;

    double pi_estimate = monte_carlo_pi(10000000);
    std::cout &lt;&lt; &quot;Pi = &quot; &lt;&lt; pi_estimate &lt;&lt; '\n';
    std::cout &lt;&lt; &quot;Percent error is: &quot; &lt;&lt; 100 * std::abs(pi_estimate - PI) / PI &lt;&lt; &quot; %\n&quot;;
}
</code></pre>
<pre><code class="language-javascript">// submitted by xam4lor
function inCircle(xPos, yPos) {
  // Setting radius to 1 for unit circle
  let radius = 1;
  return xPos * xPos + yPos * yPos &lt; radius * radius;
}

function monteCarlo(n) {
  let piCount = 0;

  for (let i = 0; i &lt; n; i++) {
    const pointX = Math.random();
    const pointY = Math.random();

    if (inCircle(pointX, pointY)) {
      piCount++;
    }
  }

  // This is using a quarter of the unit sphere in a 1x1 box.
  // The formula is pi = (boxLength^2 / radius^2) * (piCount / n), but we
  // are only using the upper quadrant and the unit circle, so we can use
  // 4*piCount/n instead
  // piEstimate = 4*piCount/n
  const piEstimate = 4 * piCount / n;
  console.log('Percent error is: %s%', 100 * Math.abs(piEstimate - Math.PI) / Math.PI);
}

monteCarlo(100000000);
</code></pre>
<pre><code class="language-haskell">import System.Random

monteCarloPi :: RandomGen g =&gt; g -&gt; Int -&gt; Float
monteCarloPi g n = count $ filter inCircle $ makePairs
  where makePairs = take n $ toPair (randomRs (0, 1) g :: [Float])
        toPair (x:y:rest) = (x, y) : toPair rest
        inCircle (x, y) = x^2 + y^2 &lt; 1
        count l = 4 * fromIntegral (length l) / fromIntegral n

main = do
  g &lt;- newStdGen
  let p = monteCarloPi g 100000
  putStrLn $ &quot;Estimated pi: &quot; ++ show p
  putStrLn $ &quot;Percent error: &quot; ++ show (100 * abs (pi - p) / pi)
</code></pre>
<pre><pre class="playground"><code class="language-rust">// Submitted by jess 3jane

extern crate rand;

use std::f64::consts::PI;

fn in_circle(x: f64, y: f64, radius: f64) -&gt; bool {
    x * x + y * y &lt; radius * radius
}

fn monte_carlo(n: i64) -&gt; f64 {
    let mut count = 0;

    for _ in 0..n {
        let x = rand::random();
        let y = rand::random();
        if in_circle(x, y, 1.0) {
            count += 1;
        }
    }

    // return our pi estimate
    (4 * count) as f64 / n as f64
}

fn main() {
    let pi_estimate = monte_carlo(10000000);

    println!(
        &quot;Percent error is {:.3}%&quot;,
        (100.0 * (pi_estimate - PI).abs() / PI)
    );
}
</code></pre></pre>
<pre><code class="language-d">///Returns true if a point (x, y) is in the circle with radius r
bool inCircle(real x, real y)
{
    return x ^^ 2 + y ^^ 2 &lt; 1.0;
}

///Calculate pi using monte carlo
real monteCarloPI(ulong n)
{
    import std.algorithm : count;
    import std.random : uniform01;
    import std.range : generate, take;
    import std.typecons : tuple;

    auto piCount =  generate(() =&gt; tuple!(&quot;x&quot;, &quot;y&quot;)(uniform01, uniform01))
        .take(n)
        .count!(a =&gt; inCircle(a.x, a.y));
    return piCount * 4.0 / n;
}

void main()
{
    import std.math : abs, PI;
    import std.stdio : writeln;

    auto p = monteCarloPI(100_000);
    writeln(&quot;Estimated pi: &quot;, p);
    writeln(&quot;Percent error: &quot;, abs(p - PI) * 100 / PI);
}
</code></pre>
<pre><code class="language-go">// Submitted by Chinmaya Mahesh (chin123)

package main

import (
	&quot;fmt&quot;
	&quot;math&quot;
	&quot;math/rand&quot;
	&quot;time&quot;
)

func inCircle(x, y float64) bool {
	return x*x+y*y &lt; 1.0 // the radius of an unit circle is 1.0
}

func monteCarlo(samples int) {
	count := 0
	s := rand.NewSource(time.Now().UnixNano())
	r := rand.New(s)

	for i := 0; i &lt; samples; i++ {
		x, y := r.Float64(), r.Float64()

		if inCircle(x, y) {
			count += 1
		}
	}
	
	estimate := 4.0 * float64(count) / float64(samples)

	fmt.Println(&quot;The estimate of pi is&quot;, estimate)
	fmt.Printf(&quot;Which has an error of %f%%\n&quot;, 100*math.Abs(math.Pi-estimate)/math.Pi)
}

func main() {
	monteCarlo(10000000)
}
</code></pre>
<pre><code class="language-r">
in_circle &lt;- function(x, y, radius = 1){
        # Return True if the point is in the circle and False otherwise.
        return((x*x + y*y) &lt; radius*radius)
}

monte_carlo &lt;- function(n_samples, radius = 1){
# Return the estimate of pi using the monte carlo algorithm.
        
        # Sample x, y from the uniform distribution
        x &lt;- runif(n_samples, 0, radius)
        y &lt;- runif(n_samples, 0, radius)

        # Count the number of points inside the circle
        in_circle_count &lt;- sum(in_circle(x, y, radius))

        # Since we've generated points in upper left quadrant ([0,radius], [0,])
        # We need to multiply the number of points by 4	
        pi_estimate &lt;- 4 * in_circle_count / n_samples

        return(pi_estimate)
}

pi_estimate &lt;- monte_carlo(10000000)
percent_error &lt;- abs(pi - pi_estimate)/pi

print(paste(&quot;The estimate of pi is: &quot;, formatC(pi_estimate)))
print(paste(&quot;The percent error is:: &quot;, formatC(percent_error)))
</code></pre>
<pre><code class="language-java">import java.util.Random;

public class MonteCarlo {

    public static void main(String[] args) {
        double piEstimation = monteCarlo(1000);
        System.out.println(&quot;Estimated pi value: &quot; + piEstimation);
        System.out.printf(&quot;Percent error: &quot; + 100 * Math.abs(piEstimation - Math.PI) / Math.PI);
    }

    // function to check whether point (x,y) is in unit circle
    private static boolean inCircle(double x, double y) {
        return x * x + y * y &lt; 1;
    }

    // function to calculate estimation of pi
    public static double monteCarlo(int samples) {
        int piCount = 0;

        Random random = new Random();

        for (int i = 0; i &lt; samples; i++) {
            double x = random.nextDouble();
            double y = random.nextDouble();
            if (inCircle(x, y)) {
                piCount++;
            }
        }

        return 4.0 * piCount / samples;
    }
}
</code></pre>
<pre><code class="language-swift">func inCircle(x: Double, y: Double, radius: Double) -&gt; Bool {
    return (x*x) + (y*y) &lt; radius*radius
}

func monteCarlo(n: Int) -&gt; Double {
    let radius: Double = 1
    var piCount = 0
    var randX: Double
    var randY: Double

    for _ in 0...n {
        randX = Double.random(in: 0..&lt;radius)
        randY = Double.random(in: 0..&lt;radius)

        if(inCircle(x: randX, y: randY, radius: radius)) {
            piCount += 1
        }
    }

    let piEstimate = Double(4 * piCount)/(Double(n))
    return piEstimate
}

func main() {
    let piEstimate = monteCarlo(n: 10000)
    print(&quot;Pi estimate is: &quot;, piEstimate)
    print(&quot;Percent error is: \(100 * abs(piEstimate - Double.pi)/Double.pi)%&quot;)
}

main()
</code></pre>
<pre><code class="language-python">import math
import random


def in_circle(x, y, radius = 1):
	&quot;&quot;&quot;Return True if the point is in the circle and False otherwise.&quot;&quot;&quot;
	return (x*x + y*y) &lt; radius*radius

def monte_carlo(n_samples, radius = 1):
	&quot;&quot;&quot;Return the estimate of pi using the monte carlo algorithm.&quot;&quot;&quot;
	in_circle_count = 0
	for i in range(n_samples):
		
		# Sample x, y from the uniform distribution
		x = random.uniform(0, radius)
		y = random.uniform(0, radius)
		
		# Count the number of points inside the circle
		if(in_circle(x, y, radius)):
			in_circle_count += 1

	# Since we've generated points in upper right quadrant ([0,radius], [0, radius])
	# We need to multiply the number of points by 4	
	pi_estimate = 4 * in_circle_count / (n_samples)

	return pi_estimate

if __name__ == '__main__':

	pi_estimate = monte_carlo(100000)
	percent_error = 100*abs(math.pi - pi_estimate)/math.pi

	print(&quot;The estimate of pi is: {:.3f}&quot;.format(pi_estimate))
	print(&quot;The percent error is: {:.3f}&quot;.format(percent_error))

</code></pre>
<p>{% sample lang=&quot;cs&quot; %}</p>
<h5 id="montecarlocs"><a class="header" href="#montecarlocs">MonteCarlo.cs</a></h5>
<p><a href="monte_carlo_integration/code/csharp/MonteCarlo.cs">import, lang:&quot;csharp&quot;</a></p>
<h5 id="circlecs"><a class="header" href="#circlecs">Circle.cs</a></h5>
<p><a href="monte_carlo_integration/code/csharp/Circle.cs">import, lang:&quot;csharp&quot;</a></p>
<h5 id="programcs-1"><a class="header" href="#programcs-1">Program.cs</a></h5>
<p><a href="monte_carlo_integration/code/csharp/Program.cs">import, lang:&quot;csharp&quot;</a></p>
<pre><code class="language-nim">import random
import math

randomize()

proc in_circle(x, y, radius: float): bool =
  return x * x + y * y &lt; radius * radius

proc monte_carlo(samples: int): float =
  const radius: float = 1
  var count: int = 0

  for i in 0 .. &lt; samples:
    let
      x: float = random(radius)
      y: float = random(radius)
        
    if in_circle(x, y, radius):
      count += 1
    
  let pi_estimate: float = 4 * count / samples
  return pi_estimate

let estimate: float = monte_carlo(1000000)

echo &quot;the estimate of pi is &quot;, estimate
echo &quot;percent error: &quot;, 100 * (abs(estimate - PI)/PI)
</code></pre>
<pre><code class="language-ruby">def in_circle(x, y, radius=1)
  # Check if coords are in circle via Pythagorean Thm
  return (x*x + y*y) &lt; radius*radius
end

def monte_carlo(n_samples, radius=1)
  # estimate pi via monte carlo sampling
  in_circle_count = 0.0
  
  for _ in 0...n_samples
    # randomly choose coords within square
	x = rand()*radius
	y = rand()*radius
	if in_circle(x, y, radius)
	  in_circle_count += 1
	end
  end
  
  # circle area is pi*r^2 and rect area is 4r^2
  # ratio between the two is then pi/4 so multiply by 4 to get pi
  return 4 * (in_circle_count / n_samples)
  
end


# Main
pi_estimate = monte_carlo(100000)
percent_error = 100 * (pi_estimate - Math::PI).abs / Math::PI

puts &quot;The estimate of pi is: #{pi_estimate.round(3)}&quot;
puts &quot;The percent error is: #{percent_error.round(3)}&quot;

</code></pre>
<pre><code class="language-fortran">FUNCTION in_circle(pos_x, pos_y, r)
    IMPLICIT NONE
    REAL(16), INTENT(IN) :: pos_x, pos_y, r
    LOGICAL              :: in_circle

    in_circle = (pos_x ** 2 + pos_y ** 2) &lt; r ** 2

END FUNCTION in_circle 

PROGRAM monte_carlo
    
    IMPLICIT NONE
    
    INTERFACE
        FUNCTION in_circle(pos_x, pos_y, r) 
            IMPLICIT NONE
            REAL(16), INTENT(IN) :: pos_x, pos_y, r
            LOGICAL              :: in_circle
        END FUNCTION in_circle 
    END INTERFACE
    
    INTEGER  :: i,n
    REAL(16) :: pos_x,pos_y, r, pi_est, pi_count, pi_error, pi
    
    ! Calculate Pi from trigonometric functions as reference
    pi       = DACOS(-1.d0)
    n        = 1000000
    r        = 1d0
    pos_x    = 0d0
    pos_y    = 0d0
    pi_count = 0d0
    
    DO i=0,n
    
        CALL RANDOM_NUMBER(pos_x)
        CALL RANDOM_NUMBER(pos_y)
    
        IF (in_circle(pos_x, pos_y, r) .EQV. .TRUE.) THEN 
    
            pi_count = pi_count + 1d0
    
        END IF
    END DO
    
    pi_est   = 4d0 * pi_count / n
    pi_error = 100d0 * (abs(pi_est - pi)/pi)
    
    WRITE(*,'(A, F12.4)') 'The pi estimate is: ', pi_est
    WRITE(*,'(A, F12.4, A)') 'Percent error is: ', pi_error, ' %'
    
END PROGRAM monte_carlo
</code></pre>
<pre><code class="language-factor">USING: locals random math.ranges math.functions ;

:: monte-carlo ( n in-shape?: ( x y -- ? ) -- % )
  n &lt;iota&gt; [ drop random-unit random-unit in-shape? call ] count n /
; inline

! Use the monte-carlo approximation to calculate pi
: monte-carlo-pi ( n -- pi-approx )
  [ ! in-circle check
    [ 2 ^ ] bi@ + ! get the distance from the center
    1 &lt;           ! see if it's less than the radius
  ]
  monte-carlo 4 * &gt;float
;

USING: math.constants ;
10000000 monte-carlo-pi ! Approximate pi
dup .                   ! Print the approximation
pi - pi / 100 * &gt;float abs .  ! And the error margin


</code></pre>
<pre><code class="language-emojicode">  
   x 
   y 

    x   y   

      
     x
  

      
     y
  


  
   radius 

   given_radius  
     given_radius  radius
  

    point    
     point  point_x
     point  point_y
     point_x  point_x  point_y  point_y  radius  radius
  


  
     samples    
     1.0   circle
    0   count

       random

     i  0 samples 
        random  random  point
        circle point 
        count   1
      
    

     4.0   count  samples
  


 
   Running with 10,000,000 samples.
   10000000  pi_estimate
   The estimate of pi is:   pi_estimate 10
   pi_estimate        100  percent_error
   The percent error is:   percent_error 10 %

</code></pre>
<pre><code class="language-php">&lt;?php
declare(strict_types=1);

function in_circle(float $positionX, float $positionY, float $radius = 1): bool
{
    return pow($positionX, 2) + pow($positionY, 2) &lt; pow($radius, 2);
}

function random_zero_to_one(): float
{
    return mt_rand() / mt_getrandmax();
}

function monte_carlo(int $samples, float $radius = 1): float
{
    $inCircleCount = 0;

    for ($i = 0; $i &lt; $samples; $i++) {
        if (in_circle(random_zero_to_one() * $radius, random_zero_to_one() * $radius, $radius)) {
            $inCircleCount++;
        }
    }

    return 4 * $inCircleCount / $samples;
}

$piEstimate = monte_carlo(10000000);
$percentError = abs($piEstimate - pi()) / pi() * 100;

printf('The estimate of PI is: %s', $piEstimate);
echo PHP_EOL;
printf('The percent error is: %s', $percentError);
echo PHP_EOL;
</code></pre>
<pre><code class="language-lua">-- function to determine whether an x, y point is in the unit circle
local function in_circle(x, y)
  return x*x + y*y &lt; 1
end

-- function to integrate a unit circle to find pi via monte_carlo
function monte_carlo(nsamples)
  local count = 0

  for i = 1,nsamples do
    if in_circle(math.random(), math.random()) then
      count = count + 1
    end
  end

  -- This is using a quarter of the unit sphere in a 1x1 box.
  -- The formula is pi = (box_length^2 / radius^2) * (pi_count / n), but we
  -- are only using the upper quadrant and the unit circle, so we can use
  -- 4*pi_count/n instead
  return 4 * count/nsamples
end

local pi = monte_carlo(10000000)
print(&quot;Estimate: &quot; .. pi)
print((&quot;Error: %.2f%%&quot;):format(100*math.abs(pi-math.pi)/math.pi))
</code></pre>
<pre><code class="language-racket">#lang racket/base

(require racket/local)
(require racket/math)

(define (in-circle x y)
  &quot;Checks if a point is in a unit circle&quot;
  (&lt; (+ (sqr x) (sqr y)) 1))

(define (monte-carlo-pi n)
  &quot;Returns an approximation of pi&quot;
  (* (/ (local ((define (monte-carlo-pi* n count)
                  (if (= n 0)
                      count
                      (monte-carlo-pi* (sub1 n) 
                                       (if (in-circle (random) (random)) 
                                           (add1 count)
                                           count)))))
          (monte-carlo-pi* n 0)) n) 4))

(define nsamples 5000000)
(define pi-estimate (monte-carlo-pi nsamples))
(displayln (string-append &quot;Estimate (rational): &quot; (number-&gt;string pi-estimate)))
(displayln (string-append &quot;Estimate (float): &quot; (number-&gt;string (real-&gt;single-flonum pi-estimate))))
(displayln (string-append &quot;Error:&quot; (number-&gt;string (* (/ (abs (- pi-estimate pi)) pi) 100))))
</code></pre>
<pre><code class="language-scala">object MonteCarlo {

  def inCircle(x: Double, y: Double) = x * x + y * y &lt; 1

  def monteCarloPi(samples: Int) = {
    def randCoord = math.random() * 2 - 1

    var pointCount = 0

    for (_ &lt;- 0 to samples)
      if (inCircle(randCoord, randCoord)) 
        pointCount += 1

    4.0 * pointCount / samples
  }

  def main(args: Array[String]): Unit = {
    val approxPi = monteCarloPi(1000)
    println(&quot;Estimated pi value: &quot; + approxPi)
    println(&quot;Percent error: &quot; + 100 * Math.abs(approxPi - Math.PI) / Math.PI)
  }
}
</code></pre>
<pre><code class="language-lisp">;;;; Monte carlo integration to approximate pi

(defun in-circle-p (x y)
  &quot;Checks if a point is in a unit circle&quot;
  (&lt; (+ (* x x) (* y y)) 1))

(defun monte-carlo (samples)
  &quot;Returns an approximation of pi&quot;
  (loop repeat samples
    with count = 0 
    do
      (when (in-circle-p (random 1.0) (random 1.0))
            (incf count))
    finally (return (* (/ count samples) 4.0))))

(defvar pi-estimate (monte-carlo 5000000))
(format t &quot;Estimate: ~D ~%&quot; pi-estimate)
(format t &quot;Error: ~D%&quot; (* (/ (abs (- pi-estimate pi)) pi) 100))
</code></pre>
<pre><code class="language-asm-x64">.intel_syntax noprefix

.section .rodata
  pi:            .double 3.141592653589793
  one:           .double 1.0
  four:          .double 4.0
  hundred:       .double 100.0
  rand_max:      .long 4290772992
                 .long 1105199103
  fabs_const:    .long 4294967295
                 .long 2147483647
                 .long 0
                 .long 0
  estimate_fmt:  .string &quot;The estaimate of pi is %lf\n&quot;
  error_fmt:     .string &quot;Percentage error: %0.2f\n&quot;

.section .text
  .global main
  .extern printf, srand, time, rand

# xmm0 - x
# xmm1 - y
# RET rax - bool
in_circle:
  mulsd  xmm0, xmm0                  # Calculate x * x + y * y
  mulsd  xmm1, xmm1
  addsd  xmm0, xmm1
  movsd  xmm1, one                   # Set circle radius to 1
  xor    rax, rax
  comisd xmm1, xmm0                  # Return bool xmm0 &lt; xmm1
  seta al
  ret

# rdi - samples
# RET xmm0 - estimate
monte_carlo:
  pxor   xmm2, xmm2                  # Setting it to zero for loop
  cvtsi2sd xmm3, rdi                 # From int to double
  pxor   xmm4, xmm4                  # Setting to zero for counter
monte_carlo_iter:
  comisd xmm2, xmm3                  # Check if we went through all samples
  je     monte_carlo_return
  call   rand                        # Get random point in the first quartile
  cvtsi2sd xmm0, rax
  divsd  xmm0, rand_max
  call   rand
  cvtsi2sd xmm1, rax
  divsd  xmm1, rand_max
  call   in_circle                   # Check if its in the circle
  test   rax, rax
  jz     monte_carlo_false
  addsd  xmm4, one                   # if so increment counter
monte_carlo_false:
  addsd  xmm2, one
  jmp    monte_carlo_iter
monte_carlo_return:
  mulsd  xmm4, four                  # Return estimate
  divsd  xmm4, xmm2
  movsd  xmm0, xmm4
  ret

main:
  push   rbp
  sub    rsp, 16
  mov    rdi, 0
  call   time
  mov    rdi, rax
  call   srand
  mov    rdi, 1000000
  call   monte_carlo
  movsd  QWORD PTR [rsp], xmm0      # Save estimate to stack
  mov    rdi, OFFSET estimate_fmt   # Print estimate
  mov    rax, 1
  call   printf
  movsd  xmm0, QWORD PTR [rsp]      # Get estimate from stack
  movsd  xmm1, pi                   # Calculate fabs(M_PI - estimate)
  subsd  xmm0, xmm1
  movq   xmm1, fabs_const
  andpd  xmm0, xmm1
  divsd  xmm0, pi                   # Print percentage error on pi
  mulsd  xmm0, hundred
  mov    rdi, OFFSET error_fmt
  mov    rax, 1
  call   printf
  add    rsp, 16
  pop    rbp
  xor    rax, rax                   # Set exit code to 0
  ret

</code></pre>
<pre><code class="language-bash">#!/usr/bin/env bash
inCircle() {
    local ret
    local mag
    ((ret = 0))
    if (($1 ** 2 + $2 ** 2 &lt; 1073676289)); then # 1073676289 = 32767 ** 2
        ((ret = 1))
    fi
    printf &quot;%d&quot; $ret
}

monteCarlo() {
    local count
    local i
    ((count = 0))
    for ((i = 0; i &lt; $1; i++)); do
        if (($(inCircle RANDOM RANDOM) == 1)); then
            ((count++))
        fi
    done
    echo &quot;scale = 8; 4 * $count / $1&quot; | bc
}

est=$(monteCarlo 10000)
echo &quot;The estimate of pi is $est&quot;
echo &quot;Percentage error: $(echo &quot;scale = 8; 100 * sqrt( ( 1 - $est / (4*a(1)) ) ^ 2 )&quot; | bc -l)&quot;
</code></pre>
<pre><code class="language-kotlin">import java.util.Random

private fun inCircle(x: Double, y: Double, radius: Double = 1.0) = (x * x + y * y) &lt; radius * radius

fun monteCarlo(samples: Int): Double {
    var piCount = 0
    val random = Random()

    for (i in 0 until samples) {
        val x = random.nextDouble()
        val y = random.nextDouble()
        if (inCircle(x, y))
            piCount++
    }
    return 4.0 * piCount / samples
}

fun main(args: Array&lt;String&gt;) {
    val piEstimate = monteCarlo(100000)
    println(&quot;Estimated pi value: $piEstimate&quot;)
    val percentError = 100 * Math.abs(piEstimate - Math.PI) / Math.PI
    println(&quot;Percent error: $percentError&quot;)
}
</code></pre>
<pre><code class="language-matlab">pi_estimate = monte_carlo(10000000);

fprintf(&quot;The pi estimate is: %f\n&quot;, pi_estimate);
fprintf(&quot;Percent error is: %f%%\n&quot;, 100 * abs(pi_estimate - pi) / pi);

function pi_estimate=monte_carlo(n)

    % a 2 by n array, rows are xs and ys
    xy_array = rand(2, n);   

    % square every element in the array
    squares_array = xy_array.^2;            
    
    % sum the xs and ys and check if it's in the quarter circle
    incircle_array = sum(squares_array)&lt;1;  

    % determine the average number of points in the circle
    pi_estimate = 4*sum(incircle_array)/n;  
    
end

</code></pre>
<p>{% sample lang=&quot;scratch&quot; %}
The code snippets were taken from this <a href="https://scratch.mit.edu/projects/319610349">scratch project</a></p>
<p>
    <img  class="center" src="monte_carlo_integration/code/scratch/Algorithm.svg" style="width:100%" />
</p>
```coconut
import math
import random
<p>data point(x, y):
def <strong>abs</strong>(self) = (self.x, self.y) |&gt; map$(pow$(?, 2)) |&gt; sum |&gt; math.sqrt</p>
<p>def in_circle(p is point, radius = 1):
&quot;&quot;&quot;Return True if the point is in the circle and False otherwise.&quot;&quot;&quot;
return abs(p) &lt; radius</p>
<p>def monte_carlo(n_samples, radius = 1) = (range(n_samples)
|&gt; map$(-&gt; point(random.uniform(0, radius), random.uniform(0, radius)))
|&gt; filter$(in_circle$(?, radius))
|&gt; tuple
|&gt; len) * 4 / n_samples</p>
<p>if <strong>name</strong> == '<strong>main</strong>':</p>
<pre><code>samples = 100_000

print(f&quot;Using {samples:_} samples.&quot;)

pi_estimate = monte_carlo(samples)
percent_error = 100*abs(math.pi - pi_estimate)/math.pi

print(&quot;The estimate of pi is: {:.3f}&quot;.format(pi_estimate))
print(&quot;The percent error is: {:.3f}&quot;.format(percent_error))
</code></pre>
<pre><code>```powershell
function Is-InCircle($x, $y, $radius=1) {
    return ([Math]::Pow($x, 2) + [Math]::Pow($y, 2)) -lt [Math]::Pow($radius, 2)
}

function Monte-Carlo([int]$n) {
    $PiCount = 0;
    for ($i = 0; $i -lt $n; $i++) {
        $x = Get-Random -Minimum 0.0 -Maximum 1.0
        $y = Get-Random -Minimum 0.0 -Maximum 1.0

        if (Is-InCircle $x $y) {
            $PiCount++
        }
    }
    return 4.0 * $PiCount / $n
}

# This could take some time
$PiEstimate = Monte-Carlo 10000000
Write-Host &quot;The pi estimate is: $PiEstimate&quot;
Write-Host &quot;Percent error is: $(100 * [Math]::Abs($PiEstimate - ([Math]::PI)) / ([Math]::PI))&quot;
</code></pre>
<h2 id="license-19"><a class="header" href="#license-19">License</a></h2>
<h5 id="code-examples-17"><a class="header" href="#code-examples-17">Code Examples</a></h5>
<p>The code examples are licensed under the MIT license (found in <a href="https://github.com/algorithm-archivists/algorithm-archive/blob/master/LICENSE.md">LICENSE.md</a>).</p>
<h5 id="text-19"><a class="header" href="#text-19">Text</a></h5>
<p>The text of this chapter was written by <a href="https://github.com/leios">James Schloss</a> and is licensed under the <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</p>
<p><a href="https://creativecommons.org/licenses/by-sa/4.0/"><p><img  class="center" src="monte_carlo_integration/../cc/CC-BY-SA_icon.svg" /></p></a></p>
<h5 id="imagesgraphics-12"><a class="header" href="#imagesgraphics-12">Images/Graphics</a></h5>
<ul>
<li>The image &quot;<a href="monte_carlo_integration/res/square_circle.png">squarecircle</a>&quot; was created by <a href="https://github.com/leios">James Schloss</a> and is licensed under the <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</li>
<li>The animation &quot;<a href="monte_carlo_integration/res/monte_carlo.gif">simplemontecarlo</a>&quot; was created by <a href="https://github.com/leios">James Schloss</a> and is licensed under the <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</li>
</ul>
<h5 id="pull-requests-16"><a class="header" href="#pull-requests-16">Pull Requests</a></h5>
<p>After initial licensing (<a href="https://github.com/algorithm-archivists/algorithm-archive/pull/560">#560</a>), the following pull requests have modified the text or graphics of this chapter:</p>
<ul>
<li>none</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="matrix-methods"><a class="header" href="#matrix-methods">Matrix Methods</a></h1>
<p>Mathematics is the foundation for many areas of science and engineering, and it is not uncommon for these applications to require the manipulation of large matrices. Though these applications are not mathematics, they use mathematics in everything they do and the methods to manipulate matrices are certainly mathematical. For this reason, I feel we should tour many methods used to manipulate matrices into any usable form. For the most part, we can divide the mathematical matrix methods into the following categories:</p>
<ol>
<li>Diagonalization / Finding the Eigenvalues</li>
<li>Creating upper and lower diagonal matrices</li>
<li>Solving systems of Equations</li>
</ol>
<p>There are certainly more methods out there, so don't be offended if I have failed to list one of your favorite types of algorithms. We'll be filling more in as we go along!</p>
<h2 id="license-20"><a class="header" href="#license-20">License</a></h2>
<h5 id="code-examples-18"><a class="header" href="#code-examples-18">Code Examples</a></h5>
<p>The code examples are licensed under the MIT license (found in <a href="https://github.com/algorithm-archivists/algorithm-archive/blob/master/LICENSE.md">LICENSE.md</a>).</p>
<h5 id="text-20"><a class="header" href="#text-20">Text</a></h5>
<p>The text of this chapter was written by <a href="https://github.com/leios">James Schloss</a> and is licensed under the <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</p>
<p><a href="https://creativecommons.org/licenses/by-sa/4.0/"><p><img  class="center" src="matrix_methods/../cc/CC-BY-SA_icon.svg" /></p></a></p>
<h5 id="pull-requests-17"><a class="header" href="#pull-requests-17">Pull Requests</a></h5>
<p>After initial licensing (<a href="https://github.com/algorithm-archivists/algorithm-archive/pull/560">#560</a>), the following pull requests have modified the text or graphics of this chapter:</p>
<ul>
<li>none</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gaussian-elimination"><a class="header" href="#gaussian-elimination">Gaussian Elimination</a></h1>
<p>Let's say we have a system of equations,</p>
<p>\[
\begin{align}
2x + 3y + 4z &amp;= 6 \\
x + 2y + 3z &amp;= 4 \\
3x - 4y &amp;= 10
\end{align}
\]</p>
<p>and we want to solve for \( x \), \( y \), and \( z \).
Well, one way to do this is with <em>Gaussian Elimination</em>, which you may have encountered before in a math class or two.</p>
<p>The first step is to transform the system of equations into a matrix by using the coefficients in front of each variable, where each row corresponds to another equation and each column corresponds to an independent variable like \( x \), \( y \), or \( z \).
For the previous system of equations, this might look like this:</p>
<h1>\[
\left[
\begin{array}{ccc}
2 &amp; 3  &amp; 4\\
1 &amp; 2 &amp; 3\\
3 &amp; -4 &amp; 0
\end{array}
\right]
\left[
\begin{array}{c}
x \\
y \\
z
\end{array}
\right]</h1>
<p>\left[
\begin{array}{c}
6 \\
4 \\
10
\end{array}
\right]
\]</p>
<p>Or more simply:</p>
<p>\[
\left[
\begin{array}{ccc|c}
2 &amp; 3  &amp; 4 &amp; 6 \\
1 &amp; 2 &amp; 3 &amp; 4 \\
3 &amp; -4 &amp; 0 &amp; 10
\end{array}
\right]
\]</p>
<p>At first, translating the set of equations into a matrix like this doesn't seem to help with anything, so let's think of this in another way.</p>
<h4 id="row-echelon-form"><a class="header" href="#row-echelon-form">Row Echelon Form</a></h4>
<p>Instead of the complicated mess of equations shown above, imagine if the system looked like this:</p>
<p>\[
\begin{align}
2x + 3y + 4z &amp;= 6 \\
y + 2z &amp;= 2 \\
11z &amp;= 18
\end{align}
\]</p>
<p>Then we could just solve for \( z \) and plug that value in to the top two equations to solve for \( x \) and \( y \) through a process known as back-substitution.
In matrix form, this set of equations would look like this:</p>
<p>\[
\left[
\begin{array}{ccc|c}
2 &amp; 3  &amp; 4 &amp; 6 \\
0 &amp; 1 &amp; 2 &amp; 2 \\
0 &amp; 0 &amp; 11 &amp; 18
\end{array}
\right]
\]</p>
<p>This matrix form has a particular name: <em>Row Echelon Form</em>.
Basically, any matrix can be considered in row echelon form if the leading coefficient or <em>pivot</em> (the first non-zero element in every row when reading from left to right) is right of the pivot of the row above it.</p>
<p>This creates a matrix that sometimes resembles an upper-triangular matrix; however, that doesn't mean that all row-echelon matrices are upper-triangular.
For example, all of the following matrices are in row echelon form:</p>
<p>\[
\left[
\begin{array}{ccc|c}
2 &amp; 3  &amp; 4 &amp; 6 \\
0 &amp; 1 &amp; 2 &amp; 2 \\
0 &amp; 0 &amp; 11 &amp; 18
\end{array}
\right]
;,;
\left[
\begin{array}{ccc|c}
5 &amp; 4  &amp; 0 &amp; 10 \\
0 &amp; 0 &amp; 5 &amp; 7 \\
0 &amp; 0 &amp; 0 &amp; 1
\end{array}
\right]
;,;
\left[
\begin{array}{ccccc}
1 &amp; -3 &amp; 4 &amp; 1 &amp; 6 \\
0 &amp; 3 &amp; 3 &amp; 5 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 2 &amp; 0
\end{array}
\right]
;,;
\left[
\begin{array}{cc}
1 &amp;  2 \\
2 &amp;  0 \\
0 &amp;  0
\end{array}
\right]
\]</p>
<p>The first two of these have the right dimensions to find a solution to a system of equations; however, the last two matrices are respectively under- and over-constrained, meaning they do not provide an appropriate solution to a system of equations.
That said, this doesn't mean that every matrix in the correct form can be solved either.
For example, if you translate the second matrix into a system of equations again, the last row translates into \( 0x+0y+0z=1 \), which is a contradiction.
This is due to the fact that the matrix is singular, and there are no solutions to this particular system.
Nevertheless, all of these matrices are in row echelon form.</p>
<h4 id="reduced-row-echelon-form"><a class="header" href="#reduced-row-echelon-form"><em>Reduced</em> Row Echelon Form</a></h4>
<p>Row echelon form is nice, but wouldn't it be even better if our system of equations looked simply like this:</p>
<p>\[
\begin{align}
x &amp;= \frac{18}{11} \\
y &amp;= \frac{-14}{11} \\
z &amp;= \frac{18}{11}
\end{align}
\]</p>
<p>Then we would know exactly what \( x \), \( y \), and \( z \) are without any fuss! In matrix form, it looks like this:</p>
<p>\[
\left[
\begin{array}{ccc|c}
1 &amp; 0 &amp; 0 &amp; \frac{18}{11} \\
0 &amp; 1 &amp; 0 &amp; \frac{-14}{11} \\
0 &amp; 0 &amp; 1 &amp; \frac{18}{11}
\end{array}
\right]
\]</p>
<p>This introduces yet another matrix configuration: * <strong>Reduced</strong> Row Echelon Form*.
A matrix is in reduced row echelon form if it satisfies the following conditions:</p>
<ol>
<li>It is in row echelon form.</li>
<li>Every pivot is 1 and is the only nonzero entry in its column.</li>
</ol>
<p>All the following examples are in the reduced row echelon form:</p>
<p>\[
\left[
\begin{array}{ccc|c}
1 &amp; 0 &amp; 0 &amp; 8 \\
0 &amp; 1 &amp; 0 &amp; -3 \\
0 &amp; 0 &amp; 1 &amp; 9
\end{array}
\right]
;,;
\left[
\begin{array}{ccc|c}
1 &amp; 4  &amp; 0 &amp; 9 \\
0 &amp; 0 &amp; 1 &amp; 7 \\
0 &amp; 0 &amp; 0 &amp; 1
\end{array}
\right]
;,;
\left[
\begin{array}{cc}
0 &amp; 0 \\
0 &amp; 0 \\
0 &amp; 0
\end{array}
\right]
\]</p>
<p>Again, only the first of these (the one that looks like an identity matrix) is desirable in the context of solving a system of equations, but transforming any matrix in this form gives us an immediate and definitive answer at the question: can I solve my system of equations?</p>
<p>Beyond solving a system of equations, reshaping a matrix in this form makes it very easy to deduce other properties of the matrix, such as its rank  the maximum number of linearly independent columns.
In reduced row echelon form, the rank is simply the number of pivots.</p>
<p>For now, I hope the motivation is clear: we want to convert a matrix into row echelon and then reduced row echelon form to make large systems of equations trivial to solve, so we need some method to do that.
In general, the term <em>Gaussian Elimination</em> refers to the process of transforming a matrix into row echelon form, and the process of transforming a row echelon matrix into reduced row echelon form is called <em>Gauss-Jordan Elimination</em>.
That said, the notation here is sometimes inconsistent.
Several authors use the term <em>Gaussian Elimination</em> to include Gauss-Jordan elimination as well.
In addition, the process of Gauss-Jordan elimination is sometimes called <em>Back-substitution</em>, which is also confusing because the term can also be used to mean solving a system of equations from row echelon form, without simplifying to reduced row echelon form.
For this reason, we will be using the following definitions in this chapter:</p>
<ul>
<li><strong>Gaussian Elimination:</strong> The process of transforming a matrix into row echelon form</li>
<li><strong>Gauss-Jordan Elimination:</strong> The process of transforming a row echelon matrix into <em>reduced</em> row echelon form</li>
<li><strong>Back-substitution:</strong> The process of directly solving a row echelon matrix, <em>without transforming into reduced row echelon form</em></li>
</ul>
<h2 id="the-analytical-method"><a class="header" href="#the-analytical-method">The Analytical Method</a></h2>
<p>Gaussian elimination is inherently analytical and can be done by hand for small systems of equations; however, for large systems, this (of course) become tedious and we will need to find an appropriate numerical solution.
For this reason, I have split this section into two parts. One will cover the analytical framework, and the other will cover an algorithm you can write in your favorite programming language.</p>
<p>In the end, reducing large systems of equations boils down to a game you play on a seemingly random matrix with 3 possible moves. You can:</p>
<ol>
<li>Swap any two rows.</li>
<li>Multiply any row by a non-zero scale value.</li>
<li>Add any row to a multiple of any other row.</li>
</ol>
<p>That's it.
Before continuing, I suggest you try to recreate the row echelon matrix we made above.
That is, do the following:</p>
<p>\[
\left[
\begin{array}{ccc|c}
2 &amp; 3  &amp; 4 &amp; 6 \\
1 &amp; 2 &amp; 3 &amp; 4 \\
3 &amp; -4 &amp; 0 &amp; 10
\end{array}
\right]
\quad \rightarrow \quad
\left[
\begin{array}{ccc|c}
2 &amp; 3  &amp; 4 &amp; 6 \\
0 &amp; 1 &amp; 2 &amp; 2 \\
0 &amp; 0 &amp; 11 &amp; 18
\end{array}
\right]
\]</p>
<p>There are plenty of different strategies you could use to do this, and no one strategy is better than the rest.
One method is to subtract a multiple of the top row from subsequent rows below it such that all values beneath the pivot value are zero.
This process might be easier if you swap some rows around first and can be performed for each pivot.</p>
<p>After you get a row echelon matrix, the next step is to find the reduced row echelon form. In other words, we do the following:</p>
<p>\[
\left[
\begin{array}{ccc|c}
2 &amp; 3  &amp; 4 &amp; 6 \\
0 &amp; 1 &amp; 2 &amp; 2 \\
0 &amp; 0 &amp; 11 &amp; 18
\end{array}
\right]
\quad \rightarrow \quad
\left[
\begin{array}{ccc|c}
1 &amp; 0 &amp; 0 &amp; \frac{18}{11} \\
0 &amp; 1 &amp; 0 &amp; \frac{-14}{11} \\
0 &amp; 0 &amp; 1 &amp; \frac{18}{11}
\end{array}
\right]
\]</p>
<p>Here, the idea is similar to above and the same rules apply.
In this case, we might start from the right-most column and subtracts upwards instead of downwards.</p>
<h2 id="the-computational-method"><a class="header" href="#the-computational-method">The Computational Method</a></h2>
<p>The analytical method for Gaussian Elimination may seem straightforward, but the computational method does not obviously follow from the &quot;game&quot; we were playing before.
Ultimately, the computational method boils down to two separate steps and has a complexity of \( \mathcal{O}(n^3) \).</p>
<p>As a note, this process iterates through all the rows in the provided matrix.
When we say &quot;current row&quot; (<code>curr_row</code>), we mean the specific row iteration number we are on at that time, and as before, the &quot;pivot&quot; corresponds to the first non-zero element in that row.</p>
<h4 id="step-1"><a class="header" href="#step-1">Step 1</a></h4>
<p>For each element in the pivot column under the current row, find the highest value and switch the row with the highest value with the current row.
The <em>pivot</em> is then considered to be the first element in the highest swapped row.</p>
<p>For example, in this case the highest value is \( 3 \):</p>
<p>\[
\left[
\begin{array}{ccc|c}
2 &amp; 3  &amp; 4 &amp; 6 \\
1 &amp; 2 &amp; 3 &amp; 4 \\
\mathbf{3} &amp; -4 &amp; 0 &amp; 10
\end{array}
\right]
\]</p>
<p>After finding this value, we simply switch the row with the \( 3 \) to the current row:</p>
<p>\[
\left[
\begin{array}{ccc|c}
\mathbf{2} &amp; \mathbf{3}  &amp; \mathbf{4} &amp; \mathbf{6} \\
1 &amp; 2 &amp; 3 &amp; 4 \\
\mathbf{3} &amp; \mathbf{-4} &amp; \mathbf{0} &amp; \mathbf{10}
\end{array}
\right]
\rightarrow
\left[
\begin{array}{ccc|c}
\mathbf{3} &amp; \mathbf{-4} &amp; \mathbf{0} &amp; \mathbf{10} \\
1 &amp; 2 &amp; 3 &amp; 4 \\
\mathbf{2} &amp; \mathbf{3}  &amp; \mathbf{4} &amp; \mathbf{6}
\end{array}
\right]
\]</p>
<p>In this case, the new pivot is \( 3 \).</p>
<p>In code, this process might look like this:</p>
<pre><code class="language-julia">        # finding the maximum element for each column
        max_index = argmax(abs.(A[row:end,col])) + row-1

        # Check to make sure matrix is good!
        if (A[max_index, col] == 0)
            println(&quot;matrix is singular!&quot;)
            continue
        end

        # swap row with highest value for that column to the top
        temp_vector = A[max_index, :]
        A[max_index, :] = A[row, :]
        A[row, :] = temp_vector
</code></pre>
<pre><code class="language-java">            // finding the maximum element
            for (int i = row + 1; i &lt; row; i++) {
                if (Math.abs(a[i][col]) &gt; Math.abs(a[pivot][col])) {
                    pivot = i;
                }
            }

            if (a[pivot][col] == 0) {
                System.err.println(&quot;The matrix is singular&quot;);
                continue;
            }

            if (row != pivot) {
                // Swap the row with the highest valued element
                // with the current row
                swapRow(a, col, pivot);
            }
</code></pre>
<pre><code class="language-c">void swap_rows(double *a, const size_t i, const size_t pivot,
               const size_t cols) {

    for (size_t j = 0; j &lt; cols; ++j) {
        double tmp = a[i * cols + j];
        a[i * cols + j] = a[pivot * cols + j];
        a[pivot * cols + j] = tmp;
    }
}
</code></pre>
<p><a href="gaussian_elimination/code/c/gaussian_elimination.c">import:19-34, lang:&quot;c&quot;</a></p>
<pre><code class="language-cpp">    int pivot = i;

    for (int j = i + 1; j &lt; rows; j++) {
      if (fabs(eqns[j][i]) &gt; fabs(eqns[pivot][i])) pivot = j;
    }

    if (eqns[pivot][i] == 0.0)
      continue;  // But continuing to simplify the matrix as much as possible

    if (i != pivot)  // Swapping the rows if new row with higher maxVals is found
      std::swap(eqns[pivot], eqns[i]);  // C++ swap function
</code></pre>
<pre><code class="language-haskell">swapRows :: Int -&gt; Int -&gt; Matrix a -&gt; Matrix a
swapRows r1 r2 m
  | r1 == r2 = m
  | otherwise =
    m //
    concat [[((r2, c), m ! (r1, c)), ((r1, c), m ! (r2, c))] | c &lt;- [c1 .. cn]]
  where
    ((_, c1), (_, cn)) = bounds m
</code></pre>
<p><a href="gaussian_elimination/code/haskell/gaussianElimination.hs">import:44-46, lang:&quot;haskell&quot;</a></p>
<pre><code class="language-javascript">    let pivot = row;
    for (let i = row + 1; i &lt; rows; ++i) {
      if (Math.abs(a[i][col]) &gt; Math.abs(a[pivot][col])) {
        pivot = i;
      }
    }

    if (a[pivot][col] === 0) {
      console.log(&quot;The matrix is singular.&quot;);
      continue;
    }

    if (col !== pivot) {
      const t = a[col];
      a[col] = a[pivot];
      a[pivot] = t;
    }
</code></pre>
<pre><code class="language-go">		// 1. find highest value in column below row to be pivot
		p, highest := r, 0.
		for i, row := range a[r:] {
			if abs := math.Abs(row[c]); abs &gt; highest {
				p = r + i
				highest = abs
			}
		}
		highest = a[p][c] // correct sign

		if highest == 0. {
			if !singular {
				singular = true
				fmt.Println(&quot;This matrix is singular.&quot;)
			}
			continue
		}

</code></pre>
<pre><code class="language-python">        temp = A[pivot_row, :].copy()
        A[pivot_row, :] = A[max_i, :]
        A[max_i, :] = temp

        # Skip on singular matrix,  not actually a pivot
        if A[pivot_row, pivot_col] == 0:
            continue
</code></pre>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>        // find the maximum element for this column
        let mut max_row = k;
        let mut max_value = a[(k, k)].abs();
        for row in (k + 1)..a.rows {
            if max_value &lt; a[(row, k)].abs() {
                max_value = a[(row, k)].abs();
                max_row = row;
            }
        }

        // Check to make sure the matrix is good
        if a[(max_row, k)] == 0.0 {
            println!(&quot;Matrix is singular, aborting&quot;);
            return;
        }

        // swap the row with the highest value for this kumn to the top
        a.swap_rows(k, max_row);

        // Loop over all remaining rows
        for i in k + 1..a.rows {
            // find the fraction
            let fraction = a[(i, k)] / a[(k, k)];

            // Loop through all columns for that row
            for j in (k + 1)..a.cols {
                // re-evaluate each element
                a[(i, j)] -= a[(k, j)] * fraction;
            }

            // set lower elements to 0
            a[(i, k)] = 0.0;
        }
    }
<span class="boring">}
</span></code></pre></pre>
<p>As a note, if the highest value is \( 0 \), the matrix is singular and the system has no single solution.
This makes sense because if the highest value in a column is 0, the entire column must be 0, thus there can be no unique solution when we read the matrix as a set of equations.
That said, Gaussian elimination is more general and allows us to continue, even if the matrix is not necessarily solvable as a set of equations.
Feel free to exit after finding a \( 0 \) if your end-goal is to solve a system of equations.</p>
<h4 id="step-2"><a class="header" href="#step-2">Step 2</a></h4>
<p>For the row beneath the current pivot row and within the pivot column, find a fraction that corresponds to the ratio of the value in that column to the pivot, itself.
After this, subtract the current pivot row multiplied by the fraction from each corresponding row element.
This process essentially subtracts an optimal multiple of the current row from each row underneath (similar to Step 3 from the above game).
Ideally, this should always create a 0 under the current row's pivot value.</p>
<p>For example, in this matrix, the next row is \( 1 \) and the pivot value is \( 3 \), so the fraction is \( \frac{1}{3} \).
\[
\rightarrow
\left[
\begin{array}{ccc|c}
3 &amp; -4 &amp; 0 &amp; 10 \\
\mathbf{1} &amp; 2 &amp; 3 &amp; 4 \\
2 &amp; 3  &amp; 4 &amp; 6
\end{array}
\right] \\
\begin{align}
f &amp;= A(\text{curr_row}, \text{pivot}<em>{\text{col}}) /  A(\text{pivot}</em>{\text{row}}, \text{pivot}_{\text{col}}) \\
&amp;= \frac{1}{3}
\end{align}
\]</p>
<p>After finding the fraction, we simply subtract \( \text{current_row} - \frac{1}{3}\times \text{pivot_row} \), like so:</p>
<p>\[
\left[
\begin{array}{ccc|c}
3 &amp; -4 &amp; 0 &amp; 10 \\
\mathbf{1} &amp; \mathbf{2} &amp; \mathbf{3} &amp; \mathbf{4} \\
2 &amp; 3  &amp; 4 &amp; 6
\end{array}
\right]
\rightarrow
\left[
\begin{array}{ccc|c}
3 &amp; -4 &amp; 0 &amp; 10 \\
0 &amp; \mathbf{\frac{10}{3}} &amp; \mathbf{3} &amp; \mathbf{\frac{2}{3}}
\\
2 &amp; 3  &amp; 4 &amp; 6
\end{array}
\right]
\]</p>
<p>After this, repeat the process for all other rows.</p>
<p>Here is what it might look like in code:</p>
<pre><code class="language-julia">        # Loop for all remaining rows
        for i = (row+1):rows

            # finding fraction
            fraction = A[i,col]/A[row,col]

            # loop through all columns for that row
            for j = (col+1):cols

                 # re-evaluate each element
                 A[i,j] -= A[row,j]*fraction

            end
</code></pre>
<pre><code class="language-java">            for (int i = row + 1; i &lt; rows; i++) {
                // finding the inverse
                double scale = a[i][col] / a[row][col];
                // loop through all columns in current row
                for (int j = col + 1; j &lt; cols; j++) {

                    // Subtract rows
                    a[i][j] -= a[row][j] * scale;
                }
</code></pre>
<pre><code class="language-c">        for (size_t i = row + 1; i &lt; rows; ++i) {
            double scale = a[i * cols + col] / a[row * cols + col];

            for (size_t j = col + 1; j &lt; cols; ++j) {
                a[i * cols + j] -= a[row * cols + j] * scale;
            }
</code></pre>
<pre><code class="language-cpp">    for (int j = i + 1; j &lt; rows; j++) {
      double scale = eqns[j][i] / eqns[i][i];

      for (int k = i + 1; k &lt; cols; k++)   // k doesn't start at 0, since
        eqns[j][k] -= scale * eqns[i][k];  // values before from 0 to i
                                           // are already 0
      eqns[j][i] = 0.0;
    }
</code></pre>
<pre><code class="language-haskell">subRows ::
     Fractional a
  =&gt; (Int, Int) -- pivot location
  -&gt; (Int, Int) -- rows to cover
  -&gt; (Int, Int) -- columns to cover
  -&gt; Matrix a
  -&gt; Matrix a
subRows (r, c) (r1, rn) (c1, cn) m =
  accum
    (-)
    m
    [ ((i, j), m ! (i, c) * m ! (r, j) / m ! (r, c))
    | i &lt;- [r1 .. rn]
    , j &lt;- [c1 .. cn]
    ]
</code></pre>
<p><a href="gaussian_elimination/code/haskell/gaussianElimination.hs">import:42-42, lang:&quot;haskell&quot;</a></p>
<pre><code class="language-javascript">    for (let i = row + 1; i &lt; rows; ++i) {
      const scale = a[i][col] / a[row][col];

      for (let j = col + 1; j &lt; cols; ++j) {
        a[i][j] -= a[row][j] * scale;
      }
</code></pre>
<pre><code class="language-go">		for _, row := range a[r+1:] {
			// 3. find fraction from pivot value
			frac := row[c] / highest

			// 4. subtract row to set rest of column to zero
			for j := range row {
				row[j] -= frac * a[r][j]
			}

			// 5. ensure col goes to zero (no float rounding)
			row[c] = 0.
		}
</code></pre>
<pre><code class="language-python">        # Zero out elements below pivot
        for r in range(pivot_row + 1,  A.shape[0]):
            # Get fraction
            frac = -A[r, pivot_col] / A[pivot_row, pivot_col]
            # Add rows
            A[r, :] += frac * A[pivot_row, :]
</code></pre>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>        // Loop over all remaining rows
        for i in k + 1..a.rows {
            // find the fraction
            let fraction = a[(i, k)] / a[(k, k)];

            // Loop through all columns for that row
            for j in (k + 1)..a.cols {
                // re-evaluate each element
                a[(i, j)] -= a[(k, j)] * fraction;
            }

            // set lower elements to 0
            a[(i, k)] = 0.0;
        }
<span class="boring">}
</span></code></pre></pre>
<h4 id="all-together"><a class="header" href="#all-together">All together</a></h4>
<p>When we put everything together, it looks like this:</p>
<pre><code class="language-julia">function gaussian_elimination!(A::Array{Float64,2})

    rows = size(A,1)
    cols = size(A,2)

    # Row index
    row = 1

    # Main loop going through all columns
    for col = 1:(cols-1)

        # finding the maximum element for each column
        max_index = argmax(abs.(A[row:end,col])) + row-1

        # Check to make sure matrix is good!
        if (A[max_index, col] == 0)
            println(&quot;matrix is singular!&quot;)
            continue
        end

        # swap row with highest value for that column to the top
        temp_vector = A[max_index, :]
        A[max_index, :] = A[row, :]
        A[row, :] = temp_vector

        # Loop for all remaining rows
        for i = (row+1):rows

            # finding fraction
            fraction = A[i,col]/A[row,col]

            # loop through all columns for that row
            for j = (col+1):cols

                 # re-evaluate each element
                 A[i,j] -= A[row,j]*fraction

            end

            # Set lower elements to 0
            A[i,col] = 0
        end
        row += 1
    end
end
</code></pre>
<pre><code class="language-c">void gaussian_elimination(double *a, const size_t rows, const size_t cols) {
    size_t row = 0;

    for (size_t col = 0; col &lt; cols - 1; ++col) {
        size_t pivot = row;

        for (size_t i = row + 1; i &lt; rows; ++i) {
            if (fabs(a[i * cols + col]) &gt; fabs(a[pivot * cols + col])) {
                pivot = i;
            }
        }

        if (a[pivot * cols + col] == 0) {
            printf(&quot;The matrix is singular.\n&quot;);
            continue;
        }

        if (col != pivot) {
            swap_rows(a, col, pivot, cols);
        }

        for (size_t i = row + 1; i &lt; rows; ++i) {
            double scale = a[i * cols + col] / a[row * cols + col];

            for (size_t j = col + 1; j &lt; cols; ++j) {
                a[i * cols + j] -= a[row * cols + j] * scale;
            }

            a[i * cols + col] = 0;
        }

        row++;
    }
}
</code></pre>
<pre><code class="language-cpp">void gaussianElimination(std::vector&lt;std::vector&lt;double&gt; &gt; &amp;eqns) {
  // 'eqns' is the matrix, 'rows' is no. of vars
  int rows = eqns.size(), cols = eqns[0].size();

  for (int i = 0; i &lt; rows - 1; i++) {
    int pivot = i;

    for (int j = i + 1; j &lt; rows; j++) {
      if (fabs(eqns[j][i]) &gt; fabs(eqns[pivot][i])) pivot = j;
    }

    if (eqns[pivot][i] == 0.0)
      continue;  // But continuing to simplify the matrix as much as possible

    if (i != pivot)  // Swapping the rows if new row with higher maxVals is found
      std::swap(eqns[pivot], eqns[i]);  // C++ swap function

    for (int j = i + 1; j &lt; rows; j++) {
      double scale = eqns[j][i] / eqns[i][i];

      for (int k = i + 1; k &lt; cols; k++)   // k doesn't start at 0, since
        eqns[j][k] -= scale * eqns[i][k];  // values before from 0 to i
                                           // are already 0
      eqns[j][i] = 0.0;
    }
  }
}
</code></pre>
<pre><code class="language-haskell">swapRows :: Int -&gt; Int -&gt; Matrix a -&gt; Matrix a
swapRows r1 r2 m
  | r1 == r2 = m
  | otherwise =
    m //
    concat [[((r2, c), m ! (r1, c)), ((r1, c), m ! (r2, c))] | c &lt;- [c1 .. cn]]
  where
    ((_, c1), (_, cn)) = bounds m

subRows ::
     Fractional a
  =&gt; (Int, Int) -- pivot location
  -&gt; (Int, Int) -- rows to cover
  -&gt; (Int, Int) -- columns to cover
  -&gt; Matrix a
  -&gt; Matrix a
subRows (r, c) (r1, rn) (c1, cn) m =
  accum
    (-)
    m
    [ ((i, j), m ! (i, c) * m ! (r, j) / m ! (r, c))
    | i &lt;- [r1 .. rn]
    , j &lt;- [c1 .. cn]
    ]

gaussianElimination :: (Fractional a, Ord a) =&gt; Matrix a -&gt; Matrix a
gaussianElimination mat = go (r1, c1) mat
</code></pre>
<pre><code class="language-python">def gaussian_elimination(A):

    pivot_row = 0
    
    # Go by column
    for pivot_col in range(min(A.shape[0], A.shape[1])):

        # Swap row with highest element in col
        max_i = np.argmax(abs(A[pivot_row:, pivot_col])) + pivot_row
        
        temp = A[pivot_row, :].copy()
        A[pivot_row, :] = A[max_i, :]
        A[max_i, :] = temp

        # Skip on singular matrix,  not actually a pivot
        if A[pivot_row, pivot_col] == 0:
            continue

        # Zero out elements below pivot
        for r in range(pivot_row + 1,  A.shape[0]):
            # Get fraction
            frac = -A[r, pivot_col] / A[pivot_row, pivot_col]
            # Add rows
            A[r, :] += frac * A[pivot_row, :]

        pivot_row += 1
</code></pre>
<pre><code class="language-java">    static void gaussianElimination(double[][] a) {
        int row = 0;

        int rows = a.length;
        int cols = a[0].length;

        for (int col = 0; col &lt; cols - 1; col++) {
            int pivot = row;

            // finding the maximum element
            for (int i = row + 1; i &lt; row; i++) {
                if (Math.abs(a[i][col]) &gt; Math.abs(a[pivot][col])) {
                    pivot = i;
                }
            }

            if (a[pivot][col] == 0) {
                System.err.println(&quot;The matrix is singular&quot;);
                continue;
            }

            if (row != pivot) {
                // Swap the row with the highest valued element
                // with the current row
                swapRow(a, col, pivot);
            }

            for (int i = row + 1; i &lt; rows; i++) {
                // finding the inverse
                double scale = a[i][col] / a[row][col];
                // loop through all columns in current row
                for (int j = col + 1; j &lt; cols; j++) {

                    // Subtract rows
                    a[i][j] -= a[row][j] * scale;
                }

                // Set lower elements to 0
                a[i][col] = 0;
            }
            row++;
        }
    }
</code></pre>
<pre><code class="language-javascript">function gaussianElimination(a) {
  const rows = a.length
  const cols = a[0].length
  let row = 0;
  for (let col = 0; col &lt; cols - 1; ++col) {

    let pivot = row;
    for (let i = row + 1; i &lt; rows; ++i) {
      if (Math.abs(a[i][col]) &gt; Math.abs(a[pivot][col])) {
        pivot = i;
      }
    }

    if (a[pivot][col] === 0) {
      console.log(&quot;The matrix is singular.&quot;);
      continue;
    }

    if (col !== pivot) {
      const t = a[col];
      a[col] = a[pivot];
      a[pivot] = t;
    }

    for (let i = row + 1; i &lt; rows; ++i) {
      const scale = a[i][col] / a[row][col];

      for (let j = col + 1; j &lt; cols; ++j) {
        a[i][j] -= a[row][j] * scale;
      }

      a[i][col] = 0;
    }

    ++row;
  }
  return a;
}
</code></pre>
<pre><code class="language-go">func gaussianElimination(a [][]float64) {
	singular := false
	rows := len(a)
	cols := len(a[0])

	for c, r := 0, 0; c &lt; cols &amp;&amp; r &lt; rows; c++ {
		// 1. find highest value in column below row to be pivot
		p, highest := r, 0.
		for i, row := range a[r:] {
			if abs := math.Abs(row[c]); abs &gt; highest {
				p = r + i
				highest = abs
			}
		}
		highest = a[p][c] // correct sign

		if highest == 0. {
			if !singular {
				singular = true
				fmt.Println(&quot;This matrix is singular.&quot;)
			}
			continue
		}

		// 2. swap pivot with current row
		if p != r {
			a[r], a[p] = a[p], a[r]
		}

		for _, row := range a[r+1:] {
			// 3. find fraction from pivot value
			frac := row[c] / highest

			// 4. subtract row to set rest of column to zero
			for j := range row {
				row[j] -= frac * a[r][j]
			}

			// 5. ensure col goes to zero (no float rounding)
			row[c] = 0.
		}

		r++
	}
}
</code></pre>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn gaussian_elimination(a: &amp;mut Matrix) {
    for k in 0..min(a.cols, a.rows) {
        // find the maximum element for this column
        let mut max_row = k;
        let mut max_value = a[(k, k)].abs();
        for row in (k + 1)..a.rows {
            if max_value &lt; a[(row, k)].abs() {
                max_value = a[(row, k)].abs();
                max_row = row;
            }
        }

        // Check to make sure the matrix is good
        if a[(max_row, k)] == 0.0 {
            println!(&quot;Matrix is singular, aborting&quot;);
            return;
        }

        // swap the row with the highest value for this kumn to the top
        a.swap_rows(k, max_row);

        // Loop over all remaining rows
        for i in k + 1..a.rows {
            // find the fraction
            let fraction = a[(i, k)] / a[(k, k)];

            // Loop through all columns for that row
            for j in (k + 1)..a.cols {
                // re-evaluate each element
                a[(i, j)] -= a[(k, j)] * fraction;
            }

            // set lower elements to 0
            a[(i, k)] = 0.0;
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>To be clear: if the matrix is found to be singular during this process, the system of equations is either over- or under-determined and no general solution exists.
For this reason, many implementations of this method will stop the moment the matrix is found to have no unique solutions.
In this implementation, we allowed for the more general case and opted to simply output when the matrix is singular instead.
If you intend to solve a system of equations, then it makes sense to stop the method the moment you know there is no unique solution, so some small modification of this code might be necessary!</p>
<p>So what do we do from here?
Well, we continue reducing the matrix; however, there are two ways to do this:</p>
<ol>
<li>Reduce the matrix further into <em>reduced</em> row echelon form with Gauss-Jordan elimination</li>
<li>Solve the system directly with <em>back-substitution</em> if the matrix allows for such solutions</li>
</ol>
<p>Let's start with Gauss-Jordan Elimination and then back-substitution</p>
<h2 id="gauss-jordan-elimination"><a class="header" href="#gauss-jordan-elimination">Gauss-Jordan Elimination</a></h2>
<p>Gauss-Jordan Elimination is precisely what we said above; however, in this case, we often work from the bottom-up instead of the top-down.
We basically need to find the pivot of every row and set that value to 1 by dividing the entire row by the pivot value.
Afterwards, we subtract upwards until all values above the pivot are 0 before moving on to the next column from right to left (instead of left to right, like before).
Here it is in code:</p>
<pre><code class="language-julia">function gauss_jordan_elimination!(A::Array{Float64,2})

    rows = size(A,1)
    cols = size(A,2)


    # After this, we know what row to start on (r-1)
    # to go back through the matrix
    row = 1
    for col = 1:cols-1
        if (A[row, col] != 0)

            # divide row by pivot and leaving pivot as 1
            for i = cols:-1:col
                A[row,i] /= A[row,col]
            end

            # subtract value from above row and set values above pivot to 0
            for i = 1:row-1
                for j = cols:-1:col
                    A[i,j] -= A[i,col]*A[row,j]
                end
            end
            row += 1
        end
    end
end
</code></pre>
<pre><code class="language-c">void gauss_jordan(double *a, const size_t rows, const size_t cols) {
    int row = 0;

    for (int col = 0; col &lt; cols - 1; ++col) {
        if (a[row * cols + col] != 0) {
            for (int i = cols - 1; i &gt; col - 1; --i) {
                a[row * cols + i] /= a[row * cols + col];
            }

            for (int i = 0; i &lt; row; ++i) {
                for (int j = cols - 1; j &gt; col - 1; --j) {
                    a[i * cols + j] -= a[i * cols + col] * a[row * cols + j];
                }
            }

            row++;
        }
    }
}
</code></pre>
<pre><code class="language-cpp">void gaussJordan(std::vector&lt;std::vector&lt;double&gt; &gt; &amp;eqns) {
  // 'eqns' is the (Row-echelon) matrix, 'rows' is no. of vars
  int rows = eqns.size();

  for (int i = rows - 1; i &gt;= 0; i--) {

    if (eqns[i][i] != 0) {

      eqns[i][rows] /= eqns[i][i];
      eqns[i][i] = 1;  // We know that the only entry in this row is 1

      // subtracting rows from below
      for (int j = i - 1; j &gt;= 0; j--) {
        eqns[j][rows] -= eqns[j][i] * eqns[i][rows];
        eqns[j][i] = 0;  // We also set all the other values in row to 0 directly
      }
    }
  }
}
</code></pre>
<pre><code class="language-haskell">    ((r1, c1), (rn, cn)) = bounds mat
    go (r, c) m
      | c == cn = m
      | pivot == 0 = go (r, c + 1) m
      | otherwise = go (r + 1, c + 1) $ subRows (r, c) (r + 1, rn) (c, cn) m'
      where
        (target, pivot) =
          maximumBy (compare `on` abs . snd) [(k, m ! (k, c)) | k &lt;- [r .. rn]]
        m' = swapRows r target m
</code></pre>
<pre><code class="language-python"># Assumes A is already row echelon form
def gauss_jordan_elimination(A):
    
    col = 0

    # Scan for pivots
    for row in range(A.shape[0]):
        while col &lt; A.shape[1] and A[row, col] == 0:
            col += 1
            
        if col &gt;= A.shape[1]:
            continue

        # Set each pivot to one via row scaling
        A[row, :] /= A[row, col]

        # Zero out elements above pivot
        for r in range(row):
            A[r, :] -= A[r, col] * A[row, :]
</code></pre>
<pre><code class="language-java">    static void gaussJordan(double[][] a) {
        int row = 0;

        int cols = a[0].length;

        for (int col = 0; col &lt; cols - 1; col++) {
            if (a[row][col] != 0) {
                for (int i = cols - 1; i &gt; col - 1; i--) {
                    // divide row by pivot so the pivot is set to 1
                    a[row][i] /= a[row][col];
                }

                // subtract the value form above row and set values above pivot to 0
                for (int i = 0; i &lt; row; i++) {
                    for (int j = cols - 1; j &gt; col - 1; j--) {
                        a[i][j] -= a[i][col] * a[row][j];
                    }
                }
                row++;
            }
        }
    }
</code></pre>
<pre><code class="language-javascript">function gaussJordan(a) {
  const cols = a[0].length;
  let row = 0;

  for (let col = 0; col &lt; cols - 1; ++col) {
    if (a[row][col] !== 0) {
      for (let i = cols - 1; i &gt; col - 1; --i) {
        a[row][i] /= a[row][col];
      }

      for (let i = 0; i &lt; row; ++i) {
        for (let j = cols - 1; j &gt; col - 1; --j) {
          a[i][j] -= a[i][col] * a[row][j];
        }
      }

      ++row;
    }
  }
}
</code></pre>
<pre><code class="language-go">func gaussJordan(a [][]float64) {
	for r := len(a) - 1; r &gt;= 0; r-- {
		// Find pivot col
		p := -1
		for c, cell := range a[r] {
			if cell != 0. {
				p = c
				break
			}
		}
		if p &lt; 0 {
			continue
		}

		// Scale pivot r to 1.
		scale := a[r][p]
		for c := range a[r][p:] {
			a[r][p+c] /= scale
		}
		// Subtract pivot row from each row above
		for _, row := range a[:r] {
			scale = row[p]
			for c, cell := range a[r][p:] {
				row[p+c] -= cell * scale
			}
		}
	}
}
</code></pre>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn gauss_jordan(a: &amp;mut Matrix) {
    let mut row = 0;
    for k in 0..(a.cols - 1) {
        if a[(row, k)] != 0.0 {
            for i in (k..a.cols).rev() {
                a[(row, i)] /= a[(row, k)];
            }

            for i in 0..row {
                for j in (k..a.cols).rev() {
                    a[(i, j)] -= a[(i, k)] * a[(row, j)];
                }
            }

            row += 1;
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>As a note: Gauss-Jordan elimination can also be used to find the inverse of a matrix by following the same procedure to generate a reduced row echelon matrix, but with an identity matrix on the other side instead of the right-hand side of each equation.
This process is straightforward but will not be covered here, simply because there are much faster numerical methods to find an inverse matrix; however, if you would like to see this, let me know and I can add it in for completeness.</p>
<h2 id="back-substitution"><a class="header" href="#back-substitution">Back-substitution</a></h2>
<p>The idea of back-substitution is straightforward: we create a matrix of solutions and iteratively solve for each variable by plugging in all variables before it.
For example, if our matrix looks like this:</p>
<p>\[
\left[
\begin{array}{ccc|c}
2 &amp; 3  &amp; 4 &amp; 6 \\
0 &amp; 1 &amp; 2 &amp; 2 \\
0 &amp; 0 &amp; 11 &amp; 18
\end{array}
\right]
\]</p>
<p>We can quickly solve \( 11z = 18 \) for \( z \), and then use that to solve \( y + 2z = 2 \) for \( y \) by plugging in for \( z \).
After that, we simply need to solve \( 2x + 3y + 4z = 6 \) for \( x \) in a similar fashion.
In code, this involves keeping a rolling sum of all the values we substitute, subtracting that sum from the solution column and then dividing by the coefficient variable.
In code, it looks like this:</p>
<pre><code class="language-julia">function back_substitution(A::Array{Float64,2})

    rows = size(A,1)
    cols = size(A,2)

    # Creating the solution Vector
    soln = zeros(rows)

    for i = rows:-1:1
        sum = 0.0
        for j = rows:-1:i
            sum += soln[j]*A[i,j]
        end
        soln[i] = (A[i, cols] - sum) / A[i, i]
    end

    return soln
end
</code></pre>
<pre><code class="language-c">void back_substitution(const double *a, double *x, const size_t rows,
                       const size_t cols) {

    for (int i = rows - 1; i &gt;= 0; --i) {
        double sum = 0.0;

        for (size_t j = cols - 2; j &gt; i; --j) {
            sum += x[j] * a[i * cols + j];
        }

        x[i] = (a[i * cols + cols - 1] - sum) / a[i * cols + i];
    }
}
</code></pre>
<pre><code class="language-cpp">std::vector&lt;double&gt; backSubs(const std::vector&lt;std::vector&lt;double&gt; &gt; &amp;eqns) {
  // 'eqns' is matrix, 'rows' is no. of variables
  int rows = eqns.size();

  std::vector&lt;double&gt; ans(rows);
  for (int i = rows - 1; i &gt;= 0; i--) {
    double sum = 0.0;

    for (int j = i + 1; j &lt; rows; j++) sum += eqns[i][j] * ans[j];

    if (eqns[i][i] != 0)
      ans[i] = (eqns[i][rows] - sum) / eqns[i][i];
    else
      return std::vector&lt;double&gt;(0);
  }
  return ans;
}
</code></pre>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn back_substitution(a: &amp;Matrix) -&gt; Vec&lt;f64&gt; {
    let mut soln = vec![0.0; a.rows];

    soln[a.rows - 1] = a[(a.rows - 1, a.cols - 1)] / a[(a.rows - 1, a.cols - 2)];

    for i in (0..a.rows - 1).rev() {
        let mut sum = 0.0;
        for j in (i..a.rows).rev() {
            sum += soln[j] * a[(i, j)];
        }
        soln[i] = (a[(i, a.cols - 1)] - sum) / a[(i, i)];
    }

    soln
}
<span class="boring">}
</span></code></pre></pre>
<pre><code class="language-haskell">gaussJordan :: (Fractional a, Eq a) =&gt; Matrix a -&gt; Matrix a
gaussJordan mat = go (r1, c1) mat
  where
    ((r1, c1), (rn, cn)) = bounds mat
    go (r, c) m
      | c == cn = m
</code></pre>
<pre><code class="language-python"># Assumes A has a unique solution and A in row echelon form
def back_substitution(A):
    
    sol = np.zeros(A.shape[0]).T

    # Go by pivots along diagonal
    for pivot_i in range(A.shape[0] - 1,  -1,  -1):
        s = 0
        for col in range(pivot_i + 1,  A.shape[1] - 1):
            s += A[pivot_i, col] * sol[col]
        sol[pivot_i] = (A[pivot_i, A.shape[1] - 1] - s) / A[pivot_i, pivot_i]
        
    return sol
</code></pre>
<pre><code class="language-java">    static double[] backSubstitution(double[][] a) {
        int rows = a.length;
        int cols = a[0].length;

        double[] solution = new double[rows];

        for (int i = rows - 1; i &gt;= 0; i--) {
            double sum = 0;

            for (int j = cols - 2; j &gt; i; j--) {
                sum += solution[j] * a[i][j];
            }
            solution[i] = (a[i][cols - 1] - sum) / a[i][i];
        }
        return solution;
    }
</code></pre>
<pre><code class="language-javascript">function backSubstitution(a) {
  const rows = a.length;
  const cols = a[0].length;
  const sol = [];

  for (let i = rows - 1; i &gt;= 0; --i) {

    let sum = 0;
    for (let j = cols - 2; j &gt; i; --j) {
      sum += sol[j] * a[i][j];
    }

    sol[i] = (a[i][cols - 1] - sum) / a[i][i];
  }
  return sol;
}
</code></pre>
<pre><code class="language-go">func backSubstitution(a [][]float64) []float64 {
	rows := len(a)
	cols := len(a[0])
	x := make([]float64, rows)
	for r := rows - 1; r &gt;= 0; r-- {
		sum := 0.

		for c := cols - 2; c &gt; r; c-- {
			sum += x[c] * a[r][c]
		}

		x[r] = (a[r][cols-1] - sum) / a[r][r]
	}
	return x
}
</code></pre>
<h2 id="visual-representation"><a class="header" href="#visual-representation">Visual Representation</a></h2>
<p>We have thus far used Gaussian elimination as a method to solve a system of equations; however, there is often a much easier way to find a similar solution simply by plotting each row in our matrix.
For the case of 2 equations and 2 unknowns, we would plot the two lines corresponding to each equation and the \( (x, y) \) location of their point of intersection would be the solution for \( x \) and \( y \).
Similarly, for the case of 3 equations and 3 unknowns, we would plot 3 planes and the \( (x, y, z) \) location of their point of intersection would be the solution for \( x \), \( y \), and \( z \).</p>
<p>What, then, is the point of Gaussian elimination if we can simply plot our set of equations to find a solution?
Well, this analogy breaks down quickly when we start moving beyond 3D, so it is obvious we need some method to deal with higher-dimensional systems.
That said, it is particularly interesting to see what happens as we plot our matrix during Gaussian elimination for the 3D case.</p>
<div style="text-align:center">
<video style="width:70%" controls loop>
  <source src="res/GE_vis.mp4" type="video/mp4">
Your browser does not support the video tag.
</video>
</div>
<p>As we can see in the above visualization, the planes wobble about in 3D until they reach row echelon form, where one plane is parallel to the \( x \) and \( y \) axes.
At this point, it's trivial to find the \( z \)-coordinate for the solution because it's simply the \( z \) intercept of the parallel plane.
From there, the matrices become even easier to interpret as they move to the reduced row echelon form.
In this form, the solution is simply the \( x \), \( y \), and \( z \) intercepts of the appropriate planes.</p>
<p>This visualization might have been obvious for some readers, but I found it particularly enlightening at first.
By performing Gaussian elimination, we are manipulating our planes such that they can be interpreted at a glance -- which is precisely the same thing we are doing with the matrix interpretation!</p>
<h2 id="conclusions-1"><a class="header" href="#conclusions-1">Conclusions</a></h2>
<p>And with that, we have two possible ways to reduce our system of equations and find a solution.
If we are sure our matrix is not singular and that a solution exists, it's fastest to use back-substitution to find our solution.
If no solution exists or we are trying to find a reduced row echelon matrix, then Gauss-Jordan elimination is best.
As we said at the start, the notation for Gaussian Elimination is rather ambiguous in the literature, so we are hoping that the definitions provided here are clear and consistent enough to cover all the bases.</p>
<p>As for what's next... Well, we are in for a treat!
The above algorithm clearly has 3 <code>for</code> loops and has a complexity of \( \sim O(n^3) \), which is abysmal!
If we can reduce the matrix to a specifically <strong>tridiagonal</strong> matrix, we can actually solve the system in \( \sim O(n) \)!
How? Well, we can use an algorithm known as the <em>Tri-Diagonal Matrix Algorithm</em> (TDMA) also known as the <a href="gaussian_elimination/../thomas_algorithm/thomas_algorithm.html"><em>Thomas Algorithm</em></a>.</p>
<p>There are also plenty of other solvers that do similar things that we will get to in due time.</p>
<h2 id="video-explanation-7"><a class="header" href="#video-explanation-7">Video Explanation</a></h2>
<p>Here's a video describing Gaussian elimination:</p>
<div style="text-align:center">
<iframe width="560" height="315" src="https://www.youtube.com/embed/2tlwSqblrvU" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
</div>
<h2 id="example-code-9"><a class="header" href="#example-code-9">Example Code</a></h2>
<pre><code class="language-julia">function gaussian_elimination!(A::Array{Float64,2})

    rows = size(A,1)
    cols = size(A,2)

    # Row index
    row = 1

    # Main loop going through all columns
    for col = 1:(cols-1)

        # finding the maximum element for each column
        max_index = argmax(abs.(A[row:end,col])) + row-1

        # Check to make sure matrix is good!
        if (A[max_index, col] == 0)
            println(&quot;matrix is singular!&quot;)
            continue
        end

        # swap row with highest value for that column to the top
        temp_vector = A[max_index, :]
        A[max_index, :] = A[row, :]
        A[row, :] = temp_vector

        # Loop for all remaining rows
        for i = (row+1):rows

            # finding fraction
            fraction = A[i,col]/A[row,col]

            # loop through all columns for that row
            for j = (col+1):cols

                 # re-evaluate each element
                 A[i,j] -= A[row,j]*fraction

            end

            # Set lower elements to 0
            A[i,col] = 0
        end
        row += 1
    end
end

function back_substitution(A::Array{Float64,2})

    rows = size(A,1)
    cols = size(A,2)

    # Creating the solution Vector
    soln = zeros(rows)

    for i = rows:-1:1
        sum = 0.0
        for j = rows:-1:i
            sum += soln[j]*A[i,j]
        end
        soln[i] = (A[i, cols] - sum) / A[i, i]
    end

    return soln
end


function gauss_jordan_elimination!(A::Array{Float64,2})

    rows = size(A,1)
    cols = size(A,2)


    # After this, we know what row to start on (r-1)
    # to go back through the matrix
    row = 1
    for col = 1:cols-1
        if (A[row, col] != 0)

            # divide row by pivot and leaving pivot as 1
            for i = cols:-1:col
                A[row,i] /= A[row,col]
            end

            # subtract value from above row and set values above pivot to 0
            for i = 1:row-1
                for j = cols:-1:col
                    A[i,j] -= A[i,col]*A[row,j]
                end
            end
            row += 1
        end
    end
end

function main()
    A = [2. 3 4 6;
         1 2 3 4;
         3 -4 0 10]

    gaussian_elimination!(A)
    println(A)

    gauss_jordan_elimination!(A)
    println(A)

    soln = back_substitution(A)
    println(soln)

end

main()
</code></pre>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;math.h&gt;

void swap_rows(double *a, const size_t i, const size_t pivot,
               const size_t cols) {

    for (size_t j = 0; j &lt; cols; ++j) {
        double tmp = a[i * cols + j];
        a[i * cols + j] = a[pivot * cols + j];
        a[pivot * cols + j] = tmp;
    }
}

void gaussian_elimination(double *a, const size_t rows, const size_t cols) {
    size_t row = 0;

    for (size_t col = 0; col &lt; cols - 1; ++col) {
        size_t pivot = row;

        for (size_t i = row + 1; i &lt; rows; ++i) {
            if (fabs(a[i * cols + col]) &gt; fabs(a[pivot * cols + col])) {
                pivot = i;
            }
        }

        if (a[pivot * cols + col] == 0) {
            printf(&quot;The matrix is singular.\n&quot;);
            continue;
        }

        if (col != pivot) {
            swap_rows(a, col, pivot, cols);
        }

        for (size_t i = row + 1; i &lt; rows; ++i) {
            double scale = a[i * cols + col] / a[row * cols + col];

            for (size_t j = col + 1; j &lt; cols; ++j) {
                a[i * cols + j] -= a[row * cols + j] * scale;
            }

            a[i * cols + col] = 0;
        }

        row++;
    }
}

void back_substitution(const double *a, double *x, const size_t rows,
                       const size_t cols) {

    for (int i = rows - 1; i &gt;= 0; --i) {
        double sum = 0.0;

        for (size_t j = cols - 2; j &gt; i; --j) {
            sum += x[j] * a[i * cols + j];
        }

        x[i] = (a[i * cols + cols - 1] - sum) / a[i * cols + i];
    }
}

void gauss_jordan(double *a, const size_t rows, const size_t cols) {
    int row = 0;

    for (int col = 0; col &lt; cols - 1; ++col) {
        if (a[row * cols + col] != 0) {
            for (int i = cols - 1; i &gt; col - 1; --i) {
                a[row * cols + i] /= a[row * cols + col];
            }

            for (int i = 0; i &lt; row; ++i) {
                for (int j = cols - 1; j &gt; col - 1; --j) {
                    a[i * cols + j] -= a[i * cols + col] * a[row * cols + j];
                }
            }

            row++;
        }
    }
}

int main() {
    double a[3][4] = {{3.0, 2.0, -4.0, 3.0},
                      {2.0, 3.0, 3.0, 15.0},
                      {5.0, -3.0, 1.0, 14.0}};

    gaussian_elimination((double *)a, 3, 4);

    printf(&quot;Gaussian elimination:\n&quot;);
    for (size_t i = 0; i &lt; 3; ++i) {
        printf(&quot;[&quot;);
        for (size_t j = 0; j &lt; 4; ++j) {
            printf(&quot;%f &quot;, a[i][j]);
        }
        printf(&quot;]\n&quot;);
    }

    printf(&quot;\nGauss-Jordan:\n&quot;);

    gauss_jordan((double *)a, 3, 4);

    for (size_t i = 0; i &lt; 3; ++i) {
        printf(&quot;[&quot;);
        for (size_t j = 0; j &lt; 4; ++j) {
            printf(&quot;%f &quot;, a[i][j]);
        }
        printf(&quot;]\n&quot;);
    }

    printf(&quot;\nSolutions are:\n&quot;);

    double x[3] = {0, 0, 0};
    back_substitution((double *)a, x, 3, 4);

    printf(&quot;(%f,%f,%f)\n&quot;, x[0], x[1], x[2]);

    return 0;
}
</code></pre>
<pre><code class="language-cpp">#include &lt;algorithm&gt;
#include &lt;cmath&gt;
#include &lt;iomanip&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;


void gaussianElimination(std::vector&lt;std::vector&lt;double&gt; &gt; &amp;eqns) {
  // 'eqns' is the matrix, 'rows' is no. of vars
  int rows = eqns.size(), cols = eqns[0].size();

  for (int i = 0; i &lt; rows - 1; i++) {
    int pivot = i;

    for (int j = i + 1; j &lt; rows; j++) {
      if (fabs(eqns[j][i]) &gt; fabs(eqns[pivot][i])) pivot = j;
    }

    if (eqns[pivot][i] == 0.0)
      continue;  // But continuing to simplify the matrix as much as possible

    if (i != pivot)  // Swapping the rows if new row with higher maxVals is found
      std::swap(eqns[pivot], eqns[i]);  // C++ swap function

    for (int j = i + 1; j &lt; rows; j++) {
      double scale = eqns[j][i] / eqns[i][i];

      for (int k = i + 1; k &lt; cols; k++)   // k doesn't start at 0, since
        eqns[j][k] -= scale * eqns[i][k];  // values before from 0 to i
                                           // are already 0
      eqns[j][i] = 0.0;
    }
  }
}

void gaussJordan(std::vector&lt;std::vector&lt;double&gt; &gt; &amp;eqns) {
  // 'eqns' is the (Row-echelon) matrix, 'rows' is no. of vars
  int rows = eqns.size();

  for (int i = rows - 1; i &gt;= 0; i--) {

    if (eqns[i][i] != 0) {

      eqns[i][rows] /= eqns[i][i];
      eqns[i][i] = 1;  // We know that the only entry in this row is 1

      // subtracting rows from below
      for (int j = i - 1; j &gt;= 0; j--) {
        eqns[j][rows] -= eqns[j][i] * eqns[i][rows];
        eqns[j][i] = 0;  // We also set all the other values in row to 0 directly
      }
    }
  }
}

std::vector&lt;double&gt; backSubs(const std::vector&lt;std::vector&lt;double&gt; &gt; &amp;eqns) {
  // 'eqns' is matrix, 'rows' is no. of variables
  int rows = eqns.size();

  std::vector&lt;double&gt; ans(rows);
  for (int i = rows - 1; i &gt;= 0; i--) {
    double sum = 0.0;

    for (int j = i + 1; j &lt; rows; j++) sum += eqns[i][j] * ans[j];

    if (eqns[i][i] != 0)
      ans[i] = (eqns[i][rows] - sum) / eqns[i][i];
    else
      return std::vector&lt;double&gt;(0);
  }
  return ans;
}


void printMatrix(const std::vector&lt;std::vector&lt;double&gt; &gt; &amp;matrix) {
  for (int row = 0; row &lt; matrix.size(); row++) {
    std::cout &lt;&lt; &quot;[&quot;;

    for (int col = 0; col &lt; matrix[row].size() - 1; col++)
      std::cout &lt;&lt; std::setw(8) &lt;&lt; std::fixed &lt;&lt; std::setprecision(3)
                &lt;&lt; matrix[row][col];

    std::cout &lt;&lt; &quot; |&quot; &lt;&lt; std::setw(8) &lt;&lt; std::fixed &lt;&lt; std::setprecision(3)
              &lt;&lt; matrix[row].back() &lt;&lt; &quot; ]&quot; &lt;&lt; std::endl;
  }
}


int main() {
  std::vector&lt;std::vector&lt;double&gt; &gt; equations{
      {2, 3, 4, 6},
      {1, 2, 3, 4},
      {3, -4, 0, 10}};

  std::cout &lt;&lt; &quot;Initial matrix:&quot; &lt;&lt; std::endl;
  printMatrix(equations);
  std::cout &lt;&lt; std::endl;

  gaussianElimination(equations);
  std::cout &lt;&lt; &quot;Matrix after gaussian elimination:&quot; &lt;&lt; std::endl;
  printMatrix(equations);
  std::cout &lt;&lt; std::endl;

  std::vector&lt;double&gt; ans = backSubs(equations);
  std::cout &lt;&lt; &quot;Solution from backsubstitution&quot; &lt;&lt; std::endl;
  std::cout &lt;&lt; &quot;x = &quot; &lt;&lt; ans[0] &lt;&lt; &quot;, y = &quot; &lt;&lt; ans[1] &lt;&lt; &quot;, z = &quot; &lt;&lt; ans[2]
            &lt;&lt; std::endl
            &lt;&lt; std::endl;

  gaussJordan(equations);
  std::cout &lt;&lt; &quot;Matrix after Gauss Jordan:&quot; &lt;&lt; std::endl;
  printMatrix(equations);
  std::cout &lt;&lt; std::endl;
}
</code></pre>
<pre><pre class="playground"><code class="language-rust">// submitted by jess 3jane

use std::cmp::min;
use std::ops::{Index, IndexMut};

pub struct Matrix {
    rows: usize,
    cols: usize,
    data: Vec&lt;f64&gt;,
}

impl Matrix {
    fn new(rows: usize, cols: usize, data: &amp;[f64]) -&gt; Matrix {
        Matrix {
            rows,
            cols,
            data: data.to_vec(),
        }
    }

    fn swap_rows(&amp;mut self, a: usize, b: usize) {
        for col in 0..self.cols {
            self.data.swap(a * self.cols + col, b * self.cols + col);
        }
    }
}

impl Index&lt;(usize, usize)&gt; for Matrix {
    type Output = f64;
    fn index(&amp;self, (row, col): (usize, usize)) -&gt; &amp;f64 {
        &amp;self.data[row * self.cols + col]
    }
}

impl IndexMut&lt;(usize, usize)&gt; for Matrix {
    fn index_mut(&amp;mut self, (row, col): (usize, usize)) -&gt; &amp;mut f64 {
        &amp;mut self.data[row * self.cols + col]
    }
}

fn gaussian_elimination(a: &amp;mut Matrix) {
    for k in 0..min(a.cols, a.rows) {
        // find the maximum element for this column
        let mut max_row = k;
        let mut max_value = a[(k, k)].abs();
        for row in (k + 1)..a.rows {
            if max_value &lt; a[(row, k)].abs() {
                max_value = a[(row, k)].abs();
                max_row = row;
            }
        }

        // Check to make sure the matrix is good
        if a[(max_row, k)] == 0.0 {
            println!(&quot;Matrix is singular, aborting&quot;);
            return;
        }

        // swap the row with the highest value for this kumn to the top
        a.swap_rows(k, max_row);

        // Loop over all remaining rows
        for i in k + 1..a.rows {
            // find the fraction
            let fraction = a[(i, k)] / a[(k, k)];

            // Loop through all columns for that row
            for j in (k + 1)..a.cols {
                // re-evaluate each element
                a[(i, j)] -= a[(k, j)] * fraction;
            }

            // set lower elements to 0
            a[(i, k)] = 0.0;
        }
    }
}

fn gauss_jordan(a: &amp;mut Matrix) {
    let mut row = 0;
    for k in 0..(a.cols - 1) {
        if a[(row, k)] != 0.0 {
            for i in (k..a.cols).rev() {
                a[(row, i)] /= a[(row, k)];
            }

            for i in 0..row {
                for j in (k..a.cols).rev() {
                    a[(i, j)] -= a[(i, k)] * a[(row, j)];
                }
            }

            row += 1;
        }
    }
}

fn back_substitution(a: &amp;Matrix) -&gt; Vec&lt;f64&gt; {
    let mut soln = vec![0.0; a.rows];

    soln[a.rows - 1] = a[(a.rows - 1, a.cols - 1)] / a[(a.rows - 1, a.cols - 2)];

    for i in (0..a.rows - 1).rev() {
        let mut sum = 0.0;
        for j in (i..a.rows).rev() {
            sum += soln[j] * a[(i, j)];
        }
        soln[i] = (a[(i, a.cols - 1)] - sum) / a[(i, i)];
    }

    soln
}

fn main() {
    // The example matrix from the text
    let mut a = Matrix::new(
        3,
        4,
        &amp;vec![2.0, 3.0, 4.0, 6.0, 1.0, 2.0, 3.0, 4.0, 3.0, -4.0, 0.0, 10.0],
    );

    gaussian_elimination(&amp;mut a);
    gauss_jordan(&amp;mut a);
    let soln = back_substitution(&amp;a);
    println!(&quot;Solution: {:?}&quot;, soln);
}
</code></pre></pre>
<pre><code class="language-haskell">import Data.Array
import Data.Function (on)
import Data.List (intercalate, maximumBy)
import Data.Ratio

type Matrix a = Array (Int, Int) a

type Vector a = Array Int a

swapRows :: Int -&gt; Int -&gt; Matrix a -&gt; Matrix a
swapRows r1 r2 m
  | r1 == r2 = m
  | otherwise =
    m //
    concat [[((r2, c), m ! (r1, c)), ((r1, c), m ! (r2, c))] | c &lt;- [c1 .. cn]]
  where
    ((_, c1), (_, cn)) = bounds m

subRows ::
     Fractional a
  =&gt; (Int, Int) -- pivot location
  -&gt; (Int, Int) -- rows to cover
  -&gt; (Int, Int) -- columns to cover
  -&gt; Matrix a
  -&gt; Matrix a
subRows (r, c) (r1, rn) (c1, cn) m =
  accum
    (-)
    m
    [ ((i, j), m ! (i, c) * m ! (r, j) / m ! (r, c))
    | i &lt;- [r1 .. rn]
    , j &lt;- [c1 .. cn]
    ]

gaussianElimination :: (Fractional a, Ord a) =&gt; Matrix a -&gt; Matrix a
gaussianElimination mat = go (r1, c1) mat
  where
    ((r1, c1), (rn, cn)) = bounds mat
    go (r, c) m
      | c == cn = m
      | pivot == 0 = go (r, c + 1) m
      | otherwise = go (r + 1, c + 1) $ subRows (r, c) (r + 1, rn) (c, cn) m'
      where
        (target, pivot) =
          maximumBy (compare `on` abs . snd) [(k, m ! (k, c)) | k &lt;- [r .. rn]]
        m' = swapRows r target m

gaussJordan :: (Fractional a, Eq a) =&gt; Matrix a -&gt; Matrix a
gaussJordan mat = go (r1, c1) mat
  where
    ((r1, c1), (rn, cn)) = bounds mat
    go (r, c) m
      | c == cn = m
      | m ! (r, c) == 0 = go (r, c + 1) m
      | otherwise = go (r + 1, c + 1) $ subRows (r, c) (r1, r - 1) (c, cn) m'
      where
        m' = accum (/) m [((r, j), m ! (r, c)) | j &lt;- [c .. cn]]

backSubstitution :: (Fractional a) =&gt; Matrix a -&gt; Vector a
backSubstitution m = sol
  where
    ((r1, _), (rn, cn)) = bounds m
    sol =
      listArray (r1, rn) [(m ! (r, cn) - sum' r) / m ! (r, r) | r &lt;- [r1 .. rn]]
    sum' r = sum [m ! (r, k) * sol ! k | k &lt;- [r + 1 .. rn]]

printM :: (Show a) =&gt; Matrix a -&gt; String
printM m =
  let ((r1, c1), (rn, cn)) = bounds m
   in unlines
        [ intercalate &quot;\t&quot; [show $ m ! (r, c) | c &lt;- [c1 .. cn]]
        | r &lt;- [r1 .. rn]
        ]

printV :: (Show a) =&gt; Vector a -&gt; String
printV = unlines . map show . elems

main :: IO ()
main = do
  let mat = [2, 3, 4, 6, 1, 2, 3, 4, 3, -4, 0, 10] :: [Ratio Int]
      m = listArray ((1, 1), (3, 4)) mat
  putStrLn &quot;Original Matrix:&quot;
  putStrLn $ printM m
  putStrLn &quot;Echelon form&quot;
  putStrLn $ printM $ gaussianElimination m
  putStrLn &quot;Reduced echelon form&quot;
  putStrLn $ printM $ gaussJordan $ gaussianElimination m
  putStrLn &quot;Solution from back substitution&quot;
  putStrLn $ printV $ backSubstitution $ gaussianElimination m
</code></pre>
<pre><code class="language-python">import numpy as np

def gaussian_elimination(A):

    pivot_row = 0
    
    # Go by column
    for pivot_col in range(min(A.shape[0], A.shape[1])):

        # Swap row with highest element in col
        max_i = np.argmax(abs(A[pivot_row:, pivot_col])) + pivot_row
        
        temp = A[pivot_row, :].copy()
        A[pivot_row, :] = A[max_i, :]
        A[max_i, :] = temp

        # Skip on singular matrix,  not actually a pivot
        if A[pivot_row, pivot_col] == 0:
            continue

        # Zero out elements below pivot
        for r in range(pivot_row + 1,  A.shape[0]):
            # Get fraction
            frac = -A[r, pivot_col] / A[pivot_row, pivot_col]
            # Add rows
            A[r, :] += frac * A[pivot_row, :]

        pivot_row += 1


# Assumes A is already row echelon form
def gauss_jordan_elimination(A):
    
    col = 0

    # Scan for pivots
    for row in range(A.shape[0]):
        while col &lt; A.shape[1] and A[row, col] == 0:
            col += 1
            
        if col &gt;= A.shape[1]:
            continue

        # Set each pivot to one via row scaling
        A[row, :] /= A[row, col]

        # Zero out elements above pivot
        for r in range(row):
            A[r, :] -= A[r, col] * A[row, :]


# Assumes A has a unique solution and A in row echelon form
def back_substitution(A):
    
    sol = np.zeros(A.shape[0]).T

    # Go by pivots along diagonal
    for pivot_i in range(A.shape[0] - 1,  -1,  -1):
        s = 0
        for col in range(pivot_i + 1,  A.shape[1] - 1):
            s += A[pivot_i, col] * sol[col]
        sol[pivot_i] = (A[pivot_i, A.shape[1] - 1] - s) / A[pivot_i, pivot_i]
        
    return sol


def main():
    A = np.array([[2, 3, 4, 6],
                  [1, 2, 3, 4,],
                  [3, -4, 0, 10]], dtype=float)

    print(&quot;Original&quot;)
    print(A, &quot;\n&quot;)

    gaussian_elimination(A)
    print(&quot;Gaussian elimination&quot;)
    print(A, &quot;\n&quot;)

    print(&quot;Back subsitution&quot;)
    print(back_substitution(A), &quot;\n&quot;)

    gauss_jordan_elimination(A)
    print(&quot;Gauss-Jordan&quot;)
    print(A, &quot;\n&quot;)


if __name__ == &quot;__main__&quot;:
    main()

</code></pre>
<pre><code class="language-java">import java.util.Arrays;

public class GaussianElimination {

    static void gaussianElimination(double[][] a) {
        int row = 0;

        int rows = a.length;
        int cols = a[0].length;

        for (int col = 0; col &lt; cols - 1; col++) {
            int pivot = row;

            // finding the maximum element
            for (int i = row + 1; i &lt; row; i++) {
                if (Math.abs(a[i][col]) &gt; Math.abs(a[pivot][col])) {
                    pivot = i;
                }
            }

            if (a[pivot][col] == 0) {
                System.err.println(&quot;The matrix is singular&quot;);
                continue;
            }

            if (row != pivot) {
                // Swap the row with the highest valued element
                // with the current row
                swapRow(a, col, pivot);
            }

            for (int i = row + 1; i &lt; rows; i++) {
                // finding the inverse
                double scale = a[i][col] / a[row][col];
                // loop through all columns in current row
                for (int j = col + 1; j &lt; cols; j++) {

                    // Subtract rows
                    a[i][j] -= a[row][j] * scale;
                }

                // Set lower elements to 0
                a[i][col] = 0;
            }
            row++;
        }
    }

    static void gaussJordan(double[][] a) {
        int row = 0;

        int cols = a[0].length;

        for (int col = 0; col &lt; cols - 1; col++) {
            if (a[row][col] != 0) {
                for (int i = cols - 1; i &gt; col - 1; i--) {
                    // divide row by pivot so the pivot is set to 1
                    a[row][i] /= a[row][col];
                }

                // subtract the value form above row and set values above pivot to 0
                for (int i = 0; i &lt; row; i++) {
                    for (int j = cols - 1; j &gt; col - 1; j--) {
                        a[i][j] -= a[i][col] * a[row][j];
                    }
                }
                row++;
            }
        }
    }

    static double[] backSubstitution(double[][] a) {
        int rows = a.length;
        int cols = a[0].length;

        double[] solution = new double[rows];

        for (int i = rows - 1; i &gt;= 0; i--) {
            double sum = 0;

            for (int j = cols - 2; j &gt; i; j--) {
                sum += solution[j] * a[i][j];
            }
            solution[i] = (a[i][cols - 1] - sum) / a[i][i];
        }
        return solution;
    }

    static void swapRow(double[][] a, int rowA, int rowB) {
        double[] temp = a[rowA];
        a[rowA] = a[rowB];
        a[rowB] = temp;
    }

    public static void main(String[] args) {
        double[][] a = {
            { 3, 2, -4, 3 },
            { 2, 3, 3, 15 },
            { 5, -3, 1, 14 }
        };

        gaussianElimination(a);
        System.out.println(&quot;Gaussian elimination:&quot;);
        Arrays.stream(a).forEach(x -&gt; System.out.println(Arrays.toString(x)));

        gaussJordan(a);
        System.out.println(&quot;\nGauss-Jordan:&quot;);
        Arrays.stream(a).forEach(x -&gt; System.out.println(Arrays.toString(x)));

        System.out.println(&quot;\nSolutions:&quot;);
        System.out.println(Arrays.toString(backSubstitution(a)));
    }
}
</code></pre>
<pre><code class="language-javascript">function gaussianElimination(a) {
  const rows = a.length
  const cols = a[0].length
  let row = 0;
  for (let col = 0; col &lt; cols - 1; ++col) {

    let pivot = row;
    for (let i = row + 1; i &lt; rows; ++i) {
      if (Math.abs(a[i][col]) &gt; Math.abs(a[pivot][col])) {
        pivot = i;
      }
    }

    if (a[pivot][col] === 0) {
      console.log(&quot;The matrix is singular.&quot;);
      continue;
    }

    if (col !== pivot) {
      const t = a[col];
      a[col] = a[pivot];
      a[pivot] = t;
    }

    for (let i = row + 1; i &lt; rows; ++i) {
      const scale = a[i][col] / a[row][col];

      for (let j = col + 1; j &lt; cols; ++j) {
        a[i][j] -= a[row][j] * scale;
      }

      a[i][col] = 0;
    }

    ++row;
  }
  return a;
}

function backSubstitution(a) {
  const rows = a.length;
  const cols = a[0].length;
  const sol = [];

  for (let i = rows - 1; i &gt;= 0; --i) {

    let sum = 0;
    for (let j = cols - 2; j &gt; i; --j) {
      sum += sol[j] * a[i][j];
    }

    sol[i] = (a[i][cols - 1] - sum) / a[i][i];
  }
  return sol;
}

function gaussJordan(a) {
  const cols = a[0].length;
  let row = 0;

  for (let col = 0; col &lt; cols - 1; ++col) {
    if (a[row][col] !== 0) {
      for (let i = cols - 1; i &gt; col - 1; --i) {
        a[row][i] /= a[row][col];
      }

      for (let i = 0; i &lt; row; ++i) {
        for (let j = cols - 1; j &gt; col - 1; --j) {
          a[i][j] -= a[i][col] * a[row][j];
        }
      }

      ++row;
    }
  }
}

function printMatrixRow(row) {
  const text = row
    .map(v =&gt; (v &lt; 0 ? &quot; &quot; : &quot;  &quot;) + v.toPrecision(8))
    .join(&quot;&quot;);

  console.log(text);
}

function printMatrix(a) {
  for (const row of a) {
    printMatrixRow(row);
  }
}

const a = [
  [3,  2, -4,  3],
  [2,  3,  3, 15],
  [5, -3,  1, 14]
];

gaussianElimination(a);
console.log(&quot;Gaussian elimination:&quot;);
printMatrix(a);

gaussJordan(a);
console.log(&quot;\nGauss-Jordan:&quot;);
printMatrix(a);

const sol = backSubstitution(a);
console.log(&quot;\nSolutions are:&quot;);
printMatrixRow(sol);
</code></pre>
<pre><code class="language-go">// Package demonstrates Gaussian Elimination
package main

import (
	&quot;fmt&quot;
	&quot;math&quot;
)

func gaussianElimination(a [][]float64) {
	singular := false
	rows := len(a)
	cols := len(a[0])

	for c, r := 0, 0; c &lt; cols &amp;&amp; r &lt; rows; c++ {
		// 1. find highest value in column below row to be pivot
		p, highest := r, 0.
		for i, row := range a[r:] {
			if abs := math.Abs(row[c]); abs &gt; highest {
				p = r + i
				highest = abs
			}
		}
		highest = a[p][c] // correct sign

		if highest == 0. {
			if !singular {
				singular = true
				fmt.Println(&quot;This matrix is singular.&quot;)
			}
			continue
		}

		// 2. swap pivot with current row
		if p != r {
			a[r], a[p] = a[p], a[r]
		}

		for _, row := range a[r+1:] {
			// 3. find fraction from pivot value
			frac := row[c] / highest

			// 4. subtract row to set rest of column to zero
			for j := range row {
				row[j] -= frac * a[r][j]
			}

			// 5. ensure col goes to zero (no float rounding)
			row[c] = 0.
		}

		r++
	}
}

func gaussJordan(a [][]float64) {
	for r := len(a) - 1; r &gt;= 0; r-- {
		// Find pivot col
		p := -1
		for c, cell := range a[r] {
			if cell != 0. {
				p = c
				break
			}
		}
		if p &lt; 0 {
			continue
		}

		// Scale pivot r to 1.
		scale := a[r][p]
		for c := range a[r][p:] {
			a[r][p+c] /= scale
		}
		// Subtract pivot row from each row above
		for _, row := range a[:r] {
			scale = row[p]
			for c, cell := range a[r][p:] {
				row[p+c] -= cell * scale
			}
		}
	}
}

func backSubstitution(a [][]float64) []float64 {
	rows := len(a)
	cols := len(a[0])
	x := make([]float64, rows)
	for r := rows - 1; r &gt;= 0; r-- {
		sum := 0.

		for c := cols - 2; c &gt; r; c-- {
			sum += x[c] * a[r][c]
		}

		x[r] = (a[r][cols-1] - sum) / a[r][r]
	}
	return x
}

func printMatrixRow(row []float64) {
	fmt.Print(&quot;[&quot;)
	for _, cell := range row {
		fmt.Printf(&quot;%9.4f &quot;, cell)
	}
	fmt.Println(&quot;]&quot;)
}

func printMatrix(a [][]float64) {
	for _, row := range a {
		printMatrixRow(row)
	}
	fmt.Println()
}

func main() {
	a := [][]float64{
		{2, 3, 4, 6},
		{1, 2, 3, 4},
		{3, -4, 0, 10},
	}
	fmt.Println(&quot;Original Matrix:&quot;)
	printMatrix(a)

	fmt.Println(&quot;Gaussian elimination:&quot;)
	gaussianElimination(a)
	printMatrix(a)

	gaussJordan(a)
	fmt.Println(&quot;Gauss-Jordan:&quot;)
	printMatrix(a)

	fmt.Println(&quot;Solutions are:&quot;)
	x := backSubstitution(a)
	printMatrixRow(x)
}
</code></pre>
<h2 id="license-21"><a class="header" href="#license-21">License</a></h2>
<h5 id="code-examples-19"><a class="header" href="#code-examples-19">Code Examples</a></h5>
<p>The code examples are licensed under the MIT license (found in <a href="https://github.com/algorithm-archivists/algorithm-archive/blob/master/LICENSE.md">LICENSE.md</a>).</p>
<h5 id="text-21"><a class="header" href="#text-21">Text</a></h5>
<p>The text of this chapter was written by <a href="https://github.com/leios">James Schloss</a> and is licensed under the <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</p>
<p><a href="https://creativecommons.org/licenses/by-sa/4.0/"><p><img  class="center" src="gaussian_elimination/../cc/CC-BY-SA_icon.svg" /></p></a></p>
<h5 id="imagesgraphics-13"><a class="header" href="#imagesgraphics-13">Images/Graphics</a></h5>
<ul>
<li>The animation &quot;<a href="gaussian_elimination/res/GE_vis.mp4">GEvis</a>&quot; was created by <a href="https://github.com/leios">James Schloss</a> and is licensed under the <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</li>
</ul>
<h5 id="pull-requests-18"><a class="header" href="#pull-requests-18">Pull Requests</a></h5>
<p>After initial licensing (<a href="https://github.com/algorithm-archivists/algorithm-archive/pull/560">#560</a>), the following pull requests have modified the text or graphics of this chapter:</p>
<ul>
<li>none</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="thomas-algorithm"><a class="header" href="#thomas-algorithm">Thomas Algorithm</a></h1>
<p>As alluded to in the <a href="thomas_algorithm/../gaussian_elimination/gaussian_elimination.html">Gaussian Elimination chapter</a>, the Thomas Algorithm (or TDMA, Tri-Diagonal Matrix Algorithm) allows for programmers to <strong>massively</strong> cut the computational cost of their code from \(  O(n^3) \) to \( O(n) \) in certain cases!
This is done by exploiting a particular case of Gaussian Elimination where the matrix looks like this:</p>
<p>\[
\left[
\begin{array}{ccccc|c}
b_0 &amp; c_0 &amp; &amp; &amp; &amp; d_0 \\
a_1 &amp; b_1 &amp; c_1 &amp; &amp; &amp; d_1 \\
&amp; a_2 &amp; \ddots &amp; &amp; &amp; \vdots \\
&amp; &amp; &amp; &amp; c_{n-1}&amp; d_{n-1} \\
&amp; &amp; &amp; a_n &amp; b_n &amp; d_n
\end{array}
\right]
\]</p>
<p>This matrix shape is called <em>Tri-Diagonal</em> (excluding the right-hand side of our system of equations, of course!).
Now, at first, it might not be obvious how this helps. Well, firstly, it makes the system easier to encode: we may divide it into four separate vectors corresponding to \( a \), \( b \), \( c \), and \( d \) (in some implementations, you will see the missing \( a_0 \) and \( c_n \) set to zero to get four vectors of the same size).
Secondly, and most importantly, equations this short and regular are easy to solve analytically.</p>
<p>We'll start by applying mechanisms familiar to those who have read the <a href="thomas_algorithm/../gaussian_elimination/gaussian_elimination.html">Gaussian Elimination</a> chapter.
Our first goal is to eliminate the \( a_i \) terms and set the diagonal values \( b_i \) to \( 1 \). The \( c_i \) and \( d_i \) terms will be transformed into \( c'_i \) and \( d'_i \).
The first row is particularly easy to transform since there is no \( a_0 \), we simply need to divide the row by \( b_0 \):</p>
<p>\[
\left{
\begin{align}
c'_0 &amp;= \frac{c_0}{b_0} \\
d'_0 &amp;= \frac{d_0}{b_0}
\end{align}
\right.
\]</p>
<p>Let's assume that we found a way to transform the first \( i-1 \) rows. How would we transform the next one? We have</p>
<p>\[
\begin{array}{ccccccc|c}
&amp;  &amp; \ddots &amp; &amp; &amp; &amp; &amp;  \\
(i-1) &amp; &amp; 0 &amp; 1 &amp; c'<em>{i-1} &amp; &amp; &amp; d'</em>{i-1} \\
(i)   &amp; &amp;   &amp; a_i &amp; b_i &amp; c_i &amp; &amp; d_i \\
&amp; &amp;   &amp;   &amp;   &amp;  \ddots &amp;  &amp;
\end{array}
\]</p>
<p>Let's transform row \( (i) \) in two steps.</p>
<p><strong>Step one</strong>: eliminate \( a_i \) with the transformation \( (i)^* = (i) - a_i \times (i-1) \):</p>
<p>\[
\left{
\begin{align}
a^<em>_i &amp;= 0 \\
b^</em><em>i &amp;= b_i - a_i \times c'</em>{i-1} \\
c^<em>_i &amp;= c_i \\
d^</em><em>i &amp;= d_i - a_i \times d'</em>{i-1}
\end{align}
\right.
\]</p>
<p><strong>Step two</strong>: get \( b'_i=1 \) with the transformation \( (i)' = (i)^* / b^*_i  \):</p>
<p>\[
\left{
\begin{align}
a'_i &amp;= 0 \\
b'<em>i &amp;= 1 \\
c'<em>i &amp;= \frac{c_i}{b_i - a_i \times c'</em>{i-1}} \\
d'<em>i &amp;= \frac{d_i - a_i \times d'</em>{i-1}}{b_i - a_i \times c'</em>{i-1}}
\end{align}
\right.
\]</p>
<p>Brilliant! With the last two formula, we can calculate all the \( c'_i \) and \( d'_i \) in a single pass, starting from row \( 1 \), since we already know the values of \( c'_0 \) and \( d'_0 \).</p>
<p>Of course, what we really need are the solutions \( x_i \). It's back substitution time!</p>
<p>If we express our system in terms of equations instead of a matrix, we get</p>
<p>\[ x_i + c'<em>i \times x</em>{i+1} = d'_i \]</p>
<p>plus the last row that is even simpler: \( x_n = d'_n \). One solution for free!
Maybe we can backtrack from the last solution? Let's (barely) transform the above equation:</p>
<p>\[ x_i = d'_i - c'<em>i \times x</em>{i+1} \]</p>
<p>and that's all there is to it. We can calculate all the \( x_i \) in a single pass starting from the end.</p>
<p>Overall, we only need two passes, and that's why our algorithm is \( O(n) \)!
The transformations are quite easy too, isn't that neat?</p>
<h2 id="example-code-10"><a class="header" href="#example-code-10">Example Code</a></h2>
<pre><code class="language-julia">function thomas(a::Vector{Float64}, b::Vector{Float64}, c::Vector{Float64},
                d::Vector{Float64}, n::Int64)

    x = copy(d)
    c_prime = copy(c)

    # Setting initial elements
    c_prime[1] /= b[1]
    x[1] /= b[1]

    for i = 2:n
        # Scale factor is for c_prime and x
        scale = 1.0 / (b[i] - c_prime[i-1]*a[i])
        c_prime[i] *= scale
        x[i] = (x[i] - a[i] * x[i-1]) * scale
    end

    # Back-substitution
    for i = n-1:-1:1
        x[i] -= (c_prime[i] * x[i+1])
    end

    return x

end

function main()
    a = [0.0, 2.0, 3.0]
    b = [1.0, 3.0, 6.0]
    c = [4.0, 5.0, 0.0]
    d = [7.0, 5.0, 3.0]

    println(
        &quot;&quot;&quot;The system
        $(join((b[1], c[1], &quot;&quot;,   &quot;|&quot;, d[1]), &quot;\t&quot;))
        $(join((a[2], b[2], c[2], &quot;|&quot;, d[2]), &quot;\t&quot;))
        $(join((&quot;&quot;,   a[3], b[3], &quot;|&quot;, d[3]), &quot;\t&quot;))
        Has the solution:&quot;&quot;&quot;
    )

    soln = thomas(a, b, c, d, 3)

    println(soln)
end

main()
</code></pre>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

void thomas(double * const a, double * const b, double * const c,
            double * const x, const size_t size) {

    double y[size];
    memset(y, 0, size * sizeof(double));

    y[0] = c[0] / b[0];
    x[0] = x[0] / b[0];

    for (size_t i = 1; i &lt; size; ++i) {
        double scale = 1.0 / (b[i] - a[i] * y[i - 1]);
        y[i] = c[i] * scale;
        x[i] = (x[i] - a[i] * x[i - 1]) * scale;
    }

    for (int i = size - 2; i &gt;= 0; --i) {
        x[i] -= y[i] * x[i + 1];
    }
}

int main() {
    double a[] = {0.0, 2.0, 3.0};
    double b[] = {1.0, 3.0, 6.0};
    double c[] = {4.0, 5.0, 0.0};
    double x[] = {7.0, 5.0, 3.0};

    printf(&quot;The system,\n&quot;);
    printf(&quot;[1.0  4.0  0.0][x] = [7.0]\n&quot;);
    printf(&quot;[2.0  3.0  5.0][y] = [5.0]\n&quot;);
    printf(&quot;[0.0  3.0  6.0][z] = [3.0]\n&quot;);
    printf(&quot;has the solution:\n&quot;);

    thomas(a, b, c, x, 3);

    for (size_t i = 0; i &lt; 3; ++i) {
        printf(&quot;[%f]\n&quot;, x[i]);
    }

    return 0;
}
</code></pre>
<pre><code class="language-python"># Author: gammison

# note this example is inplace and destructive
def thomas(a, b, c, d):

    # set the initial elements
    c[0] = c[0] / b[0]
    d[0] = d[0] / b[0]

    n = len(d) # number of equations to solve
    for i in range(1, n):
        # scale factor for c and d
        scale = 1 / (b[i] - c[i-1] * a[i])

        c[i] *= scale
        d[i] = (d[i] - a[i] * d[i-1]) * scale


    # do the back substitution
    for i in range(n-2, -1, -1):
        d[i] -= c[i] * d[i+1]

    return d

def main():
    # example for matrix
    # [1  4  0][x]   [7]
    # [2  3  5][y] = [5]
    # [0  3  6][z]   [3]

    #                 [.8666]
    # soln will equal [1.533]
    #                 [-.266]
    # note we index a from 1 and c from 0
    a = [0, 2, 3]
    b = [1, 3, 6]
    c = [4, 5, 0]
    d = [7, 5, 3]

    soln = thomas(a, b, c, d)
    print(soln)

if __name__ == '__main__':
    main()
</code></pre>
<p>{% sample lang=&quot;scratch&quot; %}
You will find this algorithm implemented <a href="https://scratch.mit.edu/projects/169418273/">in this project</a>.</p>
<p>
  <img  class="center" src="thomas_algorithm/code/scratch/thomas.svg" style="width:100%" />
</p>
```java
public class Thomas {
    private static double[] thomasAlgorithm(double[] a, double[] b, double[] c, double[] x) {
        int size = a.length;
        double[] y = new double[size]; // This is needed so that we don't have to modify c
        double[] solution = new double[size];
<pre><code>    // Set initial elements
    y[0] = c[0] / b[0];
    solution[0] = x[0] / b[0];

    for (int i = 1; i &lt; size; ++i) {
        // Scale factor is for c and x
        double scale = 1.0 / (b[i] - a[i] * y[i - 1]);
        y[i] = c[i] * scale;
        solution[i] = (x[i] - a[i] * solution[i - 1]) * scale;
    }

    // Back-substitution
    for (int i = size - 2; i &gt;= 0; --i) {
        solution[i] -= y[i] * solution[i + 1];
    }

    return solution;
}

public static void main(String[] args) {
    double[] a = {0.0, 2.0, 3.0};
    double[] b = {1.0, 3.0, 6.0};
    double[] c = {4.0, 5.0, 0.0};
    double[] x = {7.0, 5.0, 3.0};
    double[] solution = thomasAlgorithm(a, b, c, x);

    System.out.format(&quot;The system,\n&quot;);
    System.out.format(&quot;[%.1f, %.1f, %.1f][x] = [%.1f]\n&quot;, b[0], c[0], 0f, x[0]);
    System.out.format(&quot;[%.1f, %.1f, %.1f][y] = [%.1f]\n&quot;, a[1], b[1], c[1], x[1]);
    System.out.format(&quot;[%.1f, %.1f, %.1f][z] = [%.1f]\n&quot;, 0f, a[2], b[2], x[2]);
    System.out.format(&quot;has the solution:\n&quot;);

    for (int i = 0; i &lt; solution.length; i++) {
        System.out.format(&quot;[% .5f]\n&quot;, solution[i]);
    }
}
</code></pre>
<p>}</p>
<pre><code>```haskell
import Data.List (zip4)
import Data.Ratio

thomas :: Fractional a =&gt; [a] -&gt; [a] -&gt; [a] -&gt; [a] -&gt; [a]
thomas a b c = init . scanr back 0 . tail . scanl forward (0, 0) . zip4 a b c
  where
    forward (c', d') (a, b, c, d) =
      let denominator = b - a * c'
       in (c / denominator, (d - a * d') / denominator)
    back (c, d) x = d - c * x

main :: IO ()
main = do
  let a = [0, 2, 3] :: [Ratio Int]
      b = [1, 3, 6]
      c = [4, 5, 0]
      d = [7, 5, 3]
  print $ thomas a b c d
</code></pre>
<pre><code class="language-go">package main

import &quot;fmt&quot;

func thomas(a, b, c, d []float64) []float64 {
	c[0] = c[0] / b[0]
	d[0] = d[0] / b[0]

	for i := 1; i &lt; len(d); i++ {
		scale := 1. / (b[i] - c[i-1]*a[i])
		c[i] *= scale
		d[i] = (d[i] - a[i]*d[i-1]) * scale
	}

	for i := len(d) - 2; i &gt;= 0; i-- {
		d[i] -= c[i] * d[i+1]
	}

	return d
}

func main() {
	a := []float64{0., 2., 3.}
	b := []float64{1., 3., 6.}
	c := []float64{4., 5., 0.}
	d := []float64{7., 5., 3.}

	fmt.Println(&quot;The system,&quot;)
	fmt.Println(&quot;[1.0  4.0  0.0][x] = [7.0]&quot;)
	fmt.Println(&quot;[2.0  3.0  5.0][y] = [5.0]&quot;)
	fmt.Println(&quot;[0.0  3.0  6.0][z] = [3.0]&quot;)
	fmt.Println(&quot;has the solution:&quot;)
	solve := thomas(a, b, c, d)
	for _, i := range solve {
		fmt.Printf(&quot;[%f]\n&quot;, i)
	}
}
</code></pre>
<pre><code class="language-v">fn thomas(a []f32, b []f32, c []f32, d []f32) []f32 {
	mut new_c := c
	mut new_d := d
	new_c[0] = new_c[0] / b[0]
	new_d[0] = new_d[0] / b[0]

	for i := 1; i &lt; d.len; i++ {
		scale := 1. / (b[i] - new_c[i-1]*a[i])
		new_c[i] *= scale
		new_d[i] = (new_d[i] - a[i]*new_d[i-1]) * scale
	}

	for i := d.len - 2; i &gt;= 0; i-- {
		new_d[i] -= new_c[i] * new_d[i+1]
	}

	return new_d
}

fn main() {
	a := [0.0, 2.0, 3.0]
	b := [1.0, 3.0, 6.0]
	c := [4.0, 5.0, 0.0]
	d := [7.0, 5.0, 3.0]

	println(&quot;The system,&quot;)
	println(&quot;[1.0  4.0  0.0][x] = [7.0]&quot;)
	println(&quot;[2.0  3.0  5.0][y] = [5.0]&quot;)
	println(&quot;[0.0  3.0  6.0][z] = [3.0]&quot;)
	println(&quot;has the solution:&quot;)
	solution := thomas(a, b, c, d)
	for i in solution {
		println(&quot;[$i]&quot;)
	}
}
</code></pre>
<pre><code class="language-swift">func thomas(a: [Double], b: [Double], c: [Double], d: [Double]) -&gt; [Double] {
    var a = a
    var b = b
    var c = c
    var d = d

    // set the initial elements
    c[0] = c[0] / b[0]
    d[0] = d[0] / b[0]

    let n = d.count // number of equations to solve
    for i in 1..&lt;n {
        // scale factor for c and d
        let scale = 1 / (b[i] - c[i-1] * a[i])

        c[i] = c[i] * scale
        d[i] = (d[i] - a[i] * d[i-1]) * scale
    }

    // do the back substitution
    for i in stride(from: n-2, to: -1, by: -1) {
        d[i] = d[i] - c[i] * d[i+1]
    }

    return d
}

func main() {
    let a = [0.0, 2.0, 3.0]
    let b = [1.0, 3.0, 6.0]
    let c = [4.0, 5.0, 0.0]
    let d = [7.0, 5.0, 3.0]

    print(thomas(a: a, b: b, c: c, d: d))
}

main()
</code></pre>
<pre><code class="language-php">&lt;?php
declare(strict_types=1);

function thomas_algorithm(array $a, array $b, array $c, array $x, int $size): array
{
    $y = [];
    $y[0] = $b[0] == 0 ? 0 : $c[0] / $b[0];
    $x[0] = $b[0] == 0 ? 0 : $x[0] / $b[0];

    for ($i = 1; $i &lt; $size; ++$i) {
        $scale = (float)(1 / ($b[$i] - $a[$i] * $y[$i - 1]));
        $y[$i] = $c[$i] * $scale;
        $x[$i] = ($x[$i] - $a[$i] * $x[$i - 1]) * $scale;
    }

    for ($i = $size - 2; $i &gt;= 0; --$i)
        $x[$i] -= $y[$i] &amp; $x[$i + 1];

    return $x;
}


$a = [0.0, 2.0, 3.0];
$b = [1.0, 3.0, 6.0];
$c = [4.0, 5.0, 0.0];
$x = [7.0, 5.0, 3.0];

printf('The system,%s', PHP_EOL);
printf('  [%s, %s, %s][x] = [%s]%s', $b[0], $c[0], 0, $x[0], PHP_EOL);
printf('  [%s, %s, %s][y] = [%s]%s', $a[1], $b[1], $c[1], $x[1], PHP_EOL);
printf('  [%s, %s, %s][z] = [%s]%s', 0, $a[2], $b[2], $x[2], PHP_EOL);
printf('has the solution:%s', PHP_EOL);

$solution = thomas_algorithm($a, $a, $c, $x, count($x));
for ($i = 0; $i &lt; count($solution); $i++)
    printf('  [%s]%s', $solution[$i], PHP_EOL);
</code></pre>
<pre><code class="language-nim">proc thomas_algorithm(a, b, c_in, d_in: seq[float]): seq[float] = 

  let n: int = len(d_in)

  var c: seq[float] = c_in
  var d: seq[float] = d_in
    
  c[0] /= b[0]
  d[0] /= b[0]

  for i in 1..n - 1:
    let scale: float = (1 / (b[i] - c[i - 1] * a[i]))

    c[i] *= scale
    d[i] = (d[i] - a[i] * d[i - 1]) * scale

  for i in countdown(n - 2,0):
    d[i] -= c[i] * d[i + 1]

  
  return d
            

const x: seq[float] = @[0.0, 2.0, 3.0]
const y: seq[float] = @[1.0, 3.0, 6.0]
const z: seq[float] = @[4.0, 5.0, 0.0]
const w: seq[float] = @[7.0, 5.0, 3.0]            
            
echo &quot;The system,&quot;
echo &quot;[1.0 4.0 0.0][x] = [7.0]&quot;
echo &quot;[2.0 3.0 5.0][y] = [5.0]&quot;
echo &quot;[0.0 3.0 6.0][z] = [3.0]&quot;

echo &quot;has the solution:&quot;

const soln: seq[float] = thomas_algorithm(x, y, z, w)

for i in 0..len(w) - 1:
  echo soln[i]
</code></pre>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;cstring&gt;

void thomas(std::vector&lt;double&gt; const a, std::vector&lt;double&gt; const b, std::vector&lt;double&gt; const c, std::vector&lt;double&gt;&amp; x) {
    int size = a.size();
    double y[size];
    memset(y, 0, size * sizeof(double));

    y[0] = c[0] / b[0];
    x[0] = x[0] / b[0];

    for (size_t i = 1; i &lt; size; ++i) {
        double scale = 1.0 / (b[i] - a[i] * y[i - 1]);
        y[i] = c[i] * scale;
        x[i] = (x[i] - a[i] * x[i - 1]) * scale;
    }

    for (int i = size - 2; i &gt;= 0; --i) {
        x[i] -= y[i] * x[i + 1];
    }
}

int main() {
    std::vector&lt;double&gt; a = {0.0, 2.0, 3.0};
    std::vector&lt;double&gt; b = {1.0, 3.0, 6.0};
    std::vector&lt;double&gt; c = {4.0, 5.0, 0.0};
    std::vector&lt;double&gt; x = {7.0, 5.0, 3.0};

    std::cout &lt;&lt; &quot;The system&quot; &lt;&lt; std::endl; 
    std::cout &lt;&lt; &quot;[1.0  4.0  0.0][x] = [7.0]&quot; &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;[2.0  3.0  5.0][y] = [5.0]&quot; &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;[0.0  3.0  6.0][z] = [3.0]&quot; &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;has the solution&quot; &lt;&lt; std::endl;

    thomas(a, b, c, x);

    for (size_t i = 0; i &lt; 3; ++i) {
        std::cout &lt;&lt; &quot;[&quot; &lt;&lt; x[i] &lt;&lt; &quot;]&quot; &lt;&lt; std::endl;
    }

    return 0;
}
</code></pre>
<pre><code class="language-lua">local function thomas(a, b, c, d)

  -- Create tables and set initial elements
  local c_prime = {c[1] / b[1]}
  local result = {d[1] / b[1]}

  for i = 2, #a do
    -- Scale factor is for c_prime and result
    local scale = 1.0 / (b[i] - a[i] * c_prime[i - 1])
    c_prime[i] = c[i] * scale
    result[i] = (d[i] - a[i] * result[i - 1]) * scale
  end

  -- Back-substitution
  for i = #a-1, 1, -1 do
    result[i] = result[i] - (c_prime[i] * result [i + 1])
  end

  return result
end

local a = {0.0, 2.0, 3.0}
local b = {1.0, 3.0, 6.0}
local c = {4.0, 5.0, 0.0}
local d = {7.0, 5.0, 3.0}

print(&quot;The system&quot;)
print(b[1], c[1], &quot;&quot;,   &quot;|&quot;, d[1])
print(a[2], b[2], c[2], &quot;|&quot;, d[2])
print(&quot;&quot;,   a[3], b[3], &quot;|&quot;, d[3])
print(&quot;Has the solution:&quot;)

local solution = thomas(a, b, c, d)

print(table.unpack(solution))
</code></pre>
<pre><code class="language-crystal">def thomas(a, b, c, d)
  c_prime = c.dup
  x = d.dup

  # Setting initial elements
  c_prime[0] /= b[0]
  x[0] /= b[0]

  1.upto(a.size - 1) do |i|
    # Scale factor is for c_prime and x
    scale = 1.0 / (b[i] - c_prime[i - 1]*a[i])
    c_prime[i] *= scale
    x[i] = (x[i] - a[i] * x[i - 1]) * scale
  end

  # Back-substitution
  (a.size - 2).downto(0) do |i|
    x[i] -= (c_prime[i] * x[i + 1])
  end

  x
end

def main
  a = [0.0, 2.0, 3.0]
  b = [1.0, 3.0, 6.0]
  c = [4.0, 5.0, 0.0]
  d = [7.0, 5.0, 3.0]

  puts &quot;The system&quot;
  puts [b[0], c[0], &quot;&quot;,   &quot;|&quot;, d[0]].join(&quot;\t&quot;)
  puts [a[1], b[1], c[1], &quot;|&quot;, d[1]].join(&quot;\t&quot;)
  puts [&quot;&quot;,   a[2], b[2], &quot;|&quot;, d[2]].join(&quot;\t&quot;)
  puts &quot;Has the solution:&quot;

  soln = thomas(a, b, c, d)

  puts soln.join(&quot;\t&quot;)
end

main
</code></pre>
<pre><code class="language-kotlin">private fun thomas(a: DoubleArray, b: DoubleArray, c: DoubleArray, d: DoubleArray): DoubleArray {
    val cPrime = c.clone()
    val x = d.clone()
    val size = a.size
    cPrime[0] /= b[0]
    x[0] /= b[0]
    for (i in 1 until size) {
        val scale = 1.0 / (b[i] - cPrime[i - 1] * a[i])
        cPrime[i] *= scale
        x[i] = (x[i] - a[i] * x[i - 1]) * scale
    }
    for (i in (size - 2) downTo 0) {
        x[i] -= cPrime[i] * x[i + 1]
    }
    return x
}

fun main(args: Array&lt;String&gt;) {
    val a = doubleArrayOf(0.0, 2.0, 3.0)
    val b = doubleArrayOf(1.0, 3.0, 6.0)
    val c = doubleArrayOf(4.0, 5.0, 0.0)
    val x = doubleArrayOf(7.0, 5.0, 3.0)
    val solution = thomas(a, b, c, x)

    println(&quot;System:&quot;)
    println(&quot;[%.1f, %.1f, %.1f][x] = [%.1f]&quot;.format(b[0], c[0], 0f, x[0]))
    println(&quot;[%.1f, %.1f, %.1f][y] = [%.1f]&quot;.format(a[1], b[1], c[1], x[1]))
    println(&quot;[%.1f, %.1f, %.1f][z] = [%.1f]\n&quot;.format(0f, a[2], b[2], x[2]))
    println(&quot;Solution:&quot;)
    for (i in solution.indices) {
        println(&quot;[% .5f]&quot;.format(solution[i]))
    }
}
</code></pre>
<pre><code class="language-lisp">;;;; Thomas algorithm implementation in Common Lisp

(defmacro divf (place divisor)
  &quot;Divides the value at place by divisor&quot;
  `(setf ,place (/ ,place ,divisor)))

(defun helper (v1 v2 v3 row)
  (- (svref v1 row) (* (svref v2 row) (svref v3 (1- row)))))

(defun thomas (diagonal-a diagonal-b diagonal-c last-column)
  &quot;Returns the solutions to a tri-diagonal matrix non-destructively&quot;
  ;; We have to copy the inputs to ensure non-destructiveness
  (let ((a (copy-seq diagonal-a))
         (b (copy-seq diagonal-b))
         (c (copy-seq diagonal-c))
         (d (copy-seq last-column)))
    (divf (svref c 0) (svref b 0))
    (divf (svref d 0) (svref b 0))
    (loop
      for i from 1 upto (1- (length a)) do
      (divf (svref c i) (helper b a c i))
      (setf (svref d i) (/ (helper d a d i) (helper b a c i))))
    (loop
      for i from (- (length a) 2) downto 0 do
      (decf (svref d i) (* (svref c i) (svref d (1+ i)))))
    d))

(defparameter diagonal-a #(0 2 3))
(defparameter diagonal-b #(1 3 6))
(defparameter diagonal-c #(4 5 0))
(defparameter last-column #(7 5 3))

;; should print 0.8666667 1.5333333 -0.26666668
(format t &quot;~{~f ~}~%&quot; (coerce (thomas diagonal-a diagonal-b diagonal-c last-column) 'list))
</code></pre>
<pre><code class="language-ruby"># note this example is inplace and destructive
def thomas(a, b, c, d)
  # set the initial elements
  c[0] = c[0] / b[0]
  d[0] = d[0] / b[0]

  n = d.length # number of equations to solve
  (1...n).each do |i|
    scale = 1 / (b[i] - c[i - 1] * a[i]) # scale factor for c and d
    c[i] *= scale
    d[i] = (d[i] - a[i] * d[i - 1]) * scale
  end

  # do the back substitution
  (n - 2).downto(0).each do |j|
    d[j] -= c[j] * d[j + 1]
  end

  d
end

# example for matrix
# [1  4  0][x]   [7]
# [2  3  5][y] = [5]
# [0  3  6][z]   [3]

#                 [.8666]
# soln will equal [1.533]
#                 [-.266]
# note we index a from 1 and c from 0

a = [0.0, 2.0, 3.0]
b = [1.0, 3.0, 6.0]
c = [4.0, 5.0, 0.0]
d = [7.0, 5.0, 3.0]

soln = thomas(a, b, c, d)
puts soln
</code></pre>
<pre><code class="language-javascript">function thomas(a, b, c, x) {
	const y = [];

	y[0] = c[0] / b[0];
	x[0] = x[0] / b[0];

	for (let i = 1; i &lt; a.length; i++) {
		const scale = 1.0 / (b[i] - a[i] * y[i - 1]);
		y[i] = c[i] * scale;
		x[i] = (x[i] - a[i] * x[i - 1]) * scale;
	}

	for (let i = a.length - 2; i &gt;= 0; i--)
		x[i] -= y[i] * x[i + 1];
}

let a = [0.0, 2.0, 3.0];
let b = [1.0, 3.0, 6.0];
let c = [4.0, 5.0, 0.0];
let x = [7.0, 5.0, 3.0];

console.log(&quot;The system,&quot;);
console.log(&quot;[1.0  4.0  0.0][x] = [7.0]&quot;);
console.log(&quot;[2.0  3.0  5.0][y] = [5.0]&quot;);
console.log(&quot;[0.0  3.0  6.0][z] = [3.0]&quot;);
console.log(&quot;has the solution:\n&quot;);

thomas(a, b, c, x);

for (let i = 0; i &lt; 3; i++)
	console.log(&quot;[&quot; + x[i] + &quot;]&quot;);
</code></pre>
<pre><pre class="playground"><code class="language-rust">fn thomas(a: &amp;[f64], b: &amp;[f64], c: &amp;[f64], x: &amp;[f64]) -&gt; Vec&lt;f64&gt; {
    let size = a.len();
    let mut y = vec![0.0; size];
    let mut z = Vec::from(x);

    y[0] = c[0] / b[0];
    z[0] = x[0] / b[0];

    for i in 1..size {
        let scale = 1.0 / (b[i] - a[i] * y[i - 1]);
        y[i] = c[i] * scale;
        z[i] = (z[i] - a[i] * z[i - 1]) * scale;
    }

    for i in (0..(size - 1)).rev() {
        z[i] -= y[i] * z[i + 1];
    }

    z
}

fn main() {
    let a = vec![0.0, 2.0, 3.0];
    let b = vec![1.0, 3.0, 6.0];
    let c = vec![4.0, 5.0, 0.0];
    let x = vec![7.0, 5.0, 3.0];

    println!(&quot;The system&quot;);
    println!(&quot;[{:?} {:?} {:?}][x] = [{:?}]&quot;, a[0], b[0], c[0], &amp;x[0]);
    println!(&quot;[{:?} {:?} {:?}][x] = [{:?}]&quot;, a[1], b[1], c[1], &amp;x[1]);
    println!(&quot;[{:?} {:?} {:?}][x] = [{:?}]&quot;, a[2], b[2], c[2], &amp;x[2]);
    println!(&quot;has the solution&quot;);

    let y = thomas(&amp;a, &amp;b, &amp;c, &amp;x);

    y.iter()
        .for_each(|i| println!(&quot;[{:&gt;19}]&quot;, format!(&quot;{:18}&quot;, format!(&quot;{:?}&quot;, i))));
}
</code></pre></pre>
<h2 id="license-22"><a class="header" href="#license-22">License</a></h2>
<h5 id="code-examples-20"><a class="header" href="#code-examples-20">Code Examples</a></h5>
<p>The code examples are licensed under the MIT license (found in <a href="https://github.com/algorithm-archivists/algorithm-archive/blob/master/LICENSE.md">LICENSE.md</a>).</p>
<h5 id="text-22"><a class="header" href="#text-22">Text</a></h5>
<p>The text of this chapter was written by <a href="https://github.com/leios">James Schloss</a> and is licensed under the <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</p>
<p><a href="https://creativecommons.org/licenses/by-sa/4.0/"><p><img  class="center" src="thomas_algorithm/../cc/CC-BY-SA_icon.svg" /></p></a></p>
<h5 id="pull-requests-19"><a class="header" href="#pull-requests-19">Pull Requests</a></h5>
<p>After initial licensing (<a href="https://github.com/algorithm-archivists/algorithm-archive/pull/560">#560</a>), the following pull requests have modified the text or graphics of this chapter:</p>
<ul>
<li>none</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="computational-geometry"><a class="header" href="#computational-geometry">Computational Geometry</a></h1>
<p>When it comes to the different sectors of computational mathematics, there are none that bring me more joy than computational geometry.
In some sense, it is the foundation for almost every area of automatically generated two and three dimensional graphics.
If you have time to spend poring through some interesting research, I would definitely recommend going to the <a href="https://arxiv.org/list/cs.CG/recent">arXiv.org section for computational geometry</a>.
We will add more to this section as the Archive evolves, so let me know of any algorithms that you would like to cover in the future!</p>
<h2 id="license-23"><a class="header" href="#license-23">License</a></h2>
<h5 id="code-examples-21"><a class="header" href="#code-examples-21">Code Examples</a></h5>
<p>The code examples are licensed under the MIT license (found in <a href="https://github.com/algorithm-archivists/algorithm-archive/blob/master/LICENSE.md">LICENSE.md</a>).</p>
<h5 id="text-23"><a class="header" href="#text-23">Text</a></h5>
<p>The text of this chapter was written by <a href="https://github.com/leios">James Schloss</a> and is licensed under the <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</p>
<p><a href="https://creativecommons.org/licenses/by-sa/4.0/"><p><img  class="center" src="computational_geometry/../cc/CC-BY-SA_icon.svg" /></p></a></p>
<h5 id="pull-requests-20"><a class="header" href="#pull-requests-20">Pull Requests</a></h5>
<p>After initial licensing (<a href="https://github.com/algorithm-archivists/algorithm-archive/pull/560">#560</a>), the following pull requests have modified the text or graphics of this chapter:</p>
<ul>
<li>none</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gift-wrapping"><a class="header" href="#gift-wrapping">Gift Wrapping</a></h1>
<p>If given a &quot;gift&quot;, here defined as a random distribution of points in two or three dimensions, gift-wrapping algorithms allow programmers to find its convex hull -- the smallest convex shape that holds all interior points.
This is one of the many cases where the leap from two to three dimensions leads to an incredibly more complicated code.
That said, there is a rich history of algorithms to solve this problem.</p>
<p>To be fair, only the Jarvis March is classified as <em>the</em> gift wrapping algorithm; however, it's a neat name to give algorithms that solve for the convex hull of a distribution of points.
Strictly speaking, though, the term is not entirely accurate for all convex hull methods.</p>
<h2 id="license-24"><a class="header" href="#license-24">License</a></h2>
<h5 id="code-examples-22"><a class="header" href="#code-examples-22">Code Examples</a></h5>
<p>The code examples are licensed under the MIT license (found in <a href="https://github.com/algorithm-archivists/algorithm-archive/blob/master/LICENSE.md">LICENSE.md</a>).</p>
<h5 id="text-24"><a class="header" href="#text-24">Text</a></h5>
<p>The text of this chapter was written by <a href="https://github.com/leios">James Schloss</a> and is licensed under the <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</p>
<p><a href="https://creativecommons.org/licenses/by-sa/4.0/"><p><img  class="center" src="gift_wrapping/../cc/CC-BY-SA_icon.svg" /></p></a></p>
<h5 id="pull-requests-21"><a class="header" href="#pull-requests-21">Pull Requests</a></h5>
<p>After initial licensing (<a href="https://github.com/algorithm-archivists/algorithm-archive/pull/560">#560</a>), the following pull requests have modified the text or graphics of this chapter:</p>
<ul>
<li>none</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="jarvis-march"><a class="header" href="#jarvis-march">Jarvis March</a></h1>
<p>The first two-dimensional convex hull algorithm was originally developed by R. A. Jarvis in 1973 {{ &quot;jm1973&quot; | cite }}.
Though other convex hull algorithms exist, this algorithm is often called <em>the</em> gift-wrapping algorithm.</p>
<p>The idea behind this algorithm is simple.
If we start with a random distribution of points, we can find the convex hull by first starting with the left-most point and using the origin to calculate an angle between every other point in the simulation.
As a note, the &quot;angle&quot; can be roughly approximated with a cross-product or a dot product, which is common for some implementations here.
Whichever point has the largest interior angle is chosen as the next point in the convex hull and we draw a line between the two points.
From there, we use the two known points to again calculate the angle between all other points in the simulation.
We then choose the point with the largest interior angle and move the simulation forward.
We keep repeating this process until we have returned to our original point.
The set of points chosen in this simulation will be the convex hull.</p>
<p>As we might expect, this algorithm is not incredibly efficient and has a runtime of \( \mathcal{O}(nh) \), where \( n \) is the number of points and \( h \) is the size of the hull.
As a note, the Jarvis March can be generalized to higher dimensions.
Since this algorithm, there have been many other algorithms that have advanced the field of two-dimensional gift-wrapping forward, including the Graham Scan and Chan's Algorithm, which will be discussed in due time.</p>
<h3 id="bibliography-5"><a class="header" href="#bibliography-5">Bibliography</a></h3>
<p>{% references %} {% endreferences %}</p>
<h2 id="example-code-11"><a class="header" href="#example-code-11">Example Code</a></h2>
<p>{% sample lang=&quot;cs&quot; %}</p>
<h5 id="jarvismarchcs"><a class="header" href="#jarvismarchcs">JarvisMarch.cs</a></h5>
<p><a href="jarvis_march/code/csharp/JarvisMarch.cs">import, lang=&quot;csharp&quot;</a></p>
<h5 id="programcs-2"><a class="header" href="#programcs-2">Program.cs</a></h5>
<p><a href="jarvis_march/code/csharp/Program.cs">import, lang=&quot;csharp&quot;</a></p>
<pre><code class="language-julia">struct Pos
    x::Float64
    y::Float64
end

function jarvis_cross(point1::Pos, point2::Pos, point3::Pos)
    vec1 = Pos(point2.x - point1.x, point2.y - point1.y)
    vec2 = Pos(point3.x - point2.x, point3.y - point2.y)
    ret_cross = vec1.x*vec2.y - vec1.y*vec2.x
    return ret_cross*ret_cross
end

function jarvis_march(points::Vector{Pos})
    hull = Vector{Pos}()

    # sorting array based on leftmost point
    sort!(points, by = item -&gt; item.x)
    push!(hull, points[1])

    i = 1
    curr_point = points[2]

    # Find cross product between points
    curr_product = jarvis_cross(Pos(0,0), hull[1], curr_point)
    while (curr_point != hull[1])
        for point in points
                product = 0.0
            if (i == 1)
                if (hull[i] != point)
                    product = jarvis_cross(Pos(0,0), hull[i], point)
                end
            else
                if (hull[i] != point &amp;&amp; hull[i-1] != point)
                    product = jarvis_cross(hull[i-1], hull[i], point)
                end
            end
            if (product &gt; curr_product)
                curr_point = point
                curr_product = product
            end
        end
        push!(hull, curr_point)
        curr_product = 0
        i += 1
    end

    return hull
end

function main()

    points = [Pos(2,1.5), Pos(1, 1), Pos(2, 4), Pos(3, 1)]
    hull = jarvis_march(points)
    println(hull)
end

main()
</code></pre>
<pre><code class="language-haskell">import Data.List (sort, maximumBy)
import Data.Function (on)

type Point = (Double, Double)

angle :: Point -&gt; Point -&gt; Point -&gt; Double
angle a@(xa, ya) b@(xb, yb) c@(xc, yc)
  | a==b || c==b = 0
  | theta&lt;0      = theta+2*pi
  | otherwise    = theta
  where thetaA = atan2 (ya-yb) (xa-xb)
        thetaC = atan2 (yc-yb) (xc-xb)
        theta = thetaC - thetaA

jarvisMarch :: [Point] -&gt; [Point]
jarvisMarch [] = []
jarvisMarch pts = p0 : wrap (x, y-1) p0
  where p0@(x, y)= minimum pts
        wrap p1 p2
          | pm == p0  = []
          | otherwise = pm : wrap p2 pm
          where pm = maximumBy (compare `on` angle p1 p2) pts

main = do
  let pts = filter (\(x,y) -&gt; x^2+y^2&lt;=5^2) [(x,y)|x&lt;-[-5..5], y&lt;-[-5..5]]
  print $ jarvisMarch pts
</code></pre>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stddef.h&gt;
#include &lt;stdbool.h&gt;

struct point {
    double x,y;
};

struct point left_most_point(struct point *points, size_t num_points) {
    struct point ret = points[0];

    for (size_t i = 0; i &lt; num_points; ++i) {
        if (points[i].x &lt; ret.x) {
            ret = points[i];
        } else if(points[i].x == ret.x) {
            if (points[i].y &lt; ret.y) {
                ret = points[i];
            }
        }
    }

    return ret;
}

bool equal(struct point a, struct point b) {
    return a.x == b.x &amp;&amp; a.y == b.y;
}

double winding(struct point p, struct point q, struct point r) {
    return (q.x - p.x)*(r.y - p.y) - (q.y - p.y)*(r.x - p.x);
}

size_t jarvis_march(struct point *points, struct point *hull_points,
                    size_t num_points) {
    struct point hull_point = left_most_point(points, num_points);
    struct point end_point;

    size_t i = 0;
    do {
        hull_points[i] = hull_point;
        end_point = points[0];

        for (size_t j = 1; j &lt; num_points; ++j) {
            if (equal(end_point, hull_point) ||
                    winding(hull_points[i], end_point, points[j]) &gt; 0.0) {
                end_point = points[j];
            }
        }

        i++;
        hull_point = end_point;
    } while (!equal(end_point, hull_points[0]));

    return i;
}

int main() {
    struct point points[] = {
        { -5.0, 2.0 },
        { 5.0, 7.0 },
        { -6.0, -12.0 },
        { -14.0, -14.0 },
        { 9.0, 9.0 },
        { -1.0, -1.0 },
        { -10.0, 11.0 },
        { -6.0, 15.0 },
        { -6.0, -8.0 },
        { 15.0, -9.0 },
        { 7.0, -7.0 },
        { -2.0, -9.0 },
        { 6.0, -5.0 },
        { 0.0, 14.0 },
        { 2.0, 8.0 }
    };
    struct point hull_points[15];

    size_t num_hull_points = jarvis_march(points, hull_points, 15);

    printf(&quot;The Hull points are:\n&quot;);
    for (size_t i = 0; i &lt; num_hull_points; ++i) {
        printf(&quot;x=%f y=%f\n&quot;, hull_points[i].x, hull_points[i].y);
    }

    return 0;
}
</code></pre>
<pre><code class="language-javascript">function jarvisMarch(points) {
  const hull = [];

  let pointOnHull = points.reduce((leftmost, current) =&gt; leftmost.x &lt; current.x ? leftmost : current);
  do {
    hull.push(pointOnHull);
    pointOnHull = points.reduce(chooseNextPointOnHull(pointOnHull));
  } while (pointOnHull !== hull[0]);

  return hull;
}

function chooseNextPointOnHull(currentPoint) {
  return function (nextPoint, candidate) {
      if (nextPoint === currentPoint || isLeftOf({ a: currentPoint, b: nextPoint }, candidate)) {
        return candidate;
      }
      return nextPoint;
  }
}

function isLeftOf({ a, b }, p) {
  return (b.x - a.x) * (p.y - a.y) &gt; (p.x - a.x) * (b.y - a.y);
}

const points = [
  { x: 1, y: 3 },
  { x: 2, y: 4 },
  { x: 4, y: 0 },
  { x: 1, y: 0 },
  { x: 0, y: 2 },
  { x: 2, y: 2 },
  { x: 3, y: 4 },
  { x: 3, y: 1 },
];

const convexHull = jarvisMarch(points);
convexHull.forEach(p =&gt; console.log(`(${p.x}, ${p.y})`));

</code></pre>
<pre><code class="language-python"># Is the turn counter clockwise?
def ccw(p1, p2, p3):
    return (p3[1] - p1[1]) * (p2[0] - p1[0]) \
        &gt;= (p2[1] - p1[1]) * (p3[0] - p1[0])


def jarvis_march(gift):
    n = len(gift)  # Number of points in list
    point_on_hull = min(gift)  # leftmost point in gift
    hull = [point_on_hull]  # leftmost point guaranteed to be in hull

    while True:
        # Candidate for next point in hull
        endpoint = gift[0]
        for j in range(1, n):
            if endpoint == point_on_hull \
               or not ccw(gift[j], hull[-1], endpoint):
                endpoint = gift[j]

        point_on_hull = endpoint

        # Check if we have completely wrapped gift
        if hull[0] == endpoint:
            break
        else:
            hull.append(point_on_hull)

    return hull


def main():
    test_gift = [
        (-5, 2), (5, 7), (-6, -12), (-14, -14), (9, 9),
        (-1, -1), (-10, 11), (-6, 15), (-6, -8), (15, -9),
        (7, -7), (-2, -9), (6, -5), (0, 14), (2, 8)
    ]
    hull = jarvis_march(test_gift)

    print(&quot;The points in the hull are:&quot;)
    for point in hull:
        print(point)


if __name__ == &quot;__main__&quot;:
    main()
</code></pre>
<pre><code class="language-cpp">#include &lt;vector&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;

struct Point
{
    double x, y;

    bool operator==(const Point&amp; b) const
    {
        return x == b.x &amp;&amp; y == b.y;
    }

    bool operator!=(const Point&amp; b) const
    {
        return !(*this == b);
    }
};

std::vector&lt;Point&gt; jarvis_march(const std::vector&lt;Point&gt;&amp; points)
{
    std::vector&lt;Point&gt; hull_points;

    if(points.empty())
        return hull_points;

    // Left most point
    auto first_point_it = std::min_element(points.begin(), points.end(), [](const Point&amp; a, const Point&amp; b){ return a.x &lt; b.x; });

    auto next_point_it = first_point_it;
    do
    {
        hull_points.push_back(*next_point_it);

        const Point&amp; p1 = hull_points.back();

        // Largest internal angle
        next_point_it = std::max_element(
            points.begin(),
            points.end(),
            [p1](const Point&amp; p2, const Point&amp; p3){
                return (p1 == p2) || (p2.x - p1.x) * (p3.y - p1.y) &gt; (p3.x - p1.x) * (p2.y - p1.y);
            }
        );
    }
    while(*next_point_it != *first_point_it);

    return hull_points;
}

int main() {
    std::vector&lt;Point&gt; points = {
        { -5.0, 2.0 },
        { 5.0, 7.0 },
        { -6.0, -12.0 },
        { -14.0, -14.0 },
        { 9.0, 9.0 },
        { -1.0, -1.0 },
        { -10.0, 11.0 },
        { -6.0, 15.0 },
        { -6.0, -8.0 },
        { 15.0, -9.0 },
        { 7.0, -7.0 },
        { -2.0, -9.0 },
        { 6.0, -5.0 },
        { 0.0, 14.0 },
        { 2.0, 8.0 }
    };

    auto hull_points = jarvis_march(points);

    std::cout &lt;&lt; &quot;Hull points are:&quot; &lt;&lt; std::endl;

    for(const Point&amp; point : hull_points) {
        std::cout &lt;&lt; '(' &lt;&lt; point.x &lt;&lt; &quot;, &quot; &lt;&lt; point.y &lt;&lt; ')' &lt;&lt; std::endl;
    }
}
</code></pre>
<pre><code class="language-lisp">;;;; Jarvis March implementation

(defstruct (point (:constructor make-point (x y))) x y)

(defun is-left-p (p1 p2 p3)
  &quot;Checks if the point p3 is to the left of the line p1 -&gt; p2&quot;
  (&gt;
    (*
      (- (point-y p3) (point-y p1))
      (- (point-x p2) (point-x p1)))
    (*
      (- (point-y p2) (point-y p1))
      (- (point-x p3) (point-x p1)))))

(defun next-point-on-hull (p1 p2 gift)
  &quot;Finds the next point on the convex hull of a gift&quot;
  (if (null gift)
      p2
      (if (is-left-p p1 p2 (first gift))
          (next-point-on-hull p1 (first gift) (rest gift))
          (next-point-on-hull p1 p2 (rest gift)))))

(defun leftmost-point (gift)
  &quot;Returns the lefmost point of a gift&quot;
  (reduce 
    (lambda (p1 p2)
      (if (&lt; (point-x p1) (point-x p2)) p1 p2))
    gift))

(defun jarvis-march (gift)
  &quot;finds the convex hull of any distribution of points&quot;
  ;deals with the edge cases
  (if (&lt; (length gift) 3)
    gift
    (loop
      with start = (leftmost-point gift)
      with hull = (list start (make-point (point-x start) (- (point-y start) 1)))
      do 
        (setq hull
          (cons 
            (next-point-on-hull (first hull) (second hull) gift)
            hull))
      until (equalp (first hull) start)
      ;deletes extra points
      finally (return (rest (butlast hull))))))

(defvar gift
  (map 
    'list
    (lambda (e) (apply #'make-point e))
    '((2 1.5) (1 1) (2 4) (3 1))))

(print (jarvis-march gift))
</code></pre>
<pre><code class="language-java">import java.util.*;

public class JarvisMarch {
    
    static class Point {
        private double x;
        private double y;
        
        public Point(double a, double b) {
            x = a;
            y = b;
        }
        
        public double getX() {
            return x;
        }
        public double getY() {
            return y;
        }
        
        public boolean equals(Point p) {
            if (p.getX() == x &amp;&amp; p.getY() == y) {
                return true;
            } else {
                return false;
            }
        }
        public double magnitude() {
            return Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2));
        }
    }
    
    //find the angle by creating two vectors and then using a property of dot products
    private static double angle(Point a, Point b, Point c) {
        Point ab = new Point(b.getX() - a.getX(), b.getY() - a.getY());
        Point bc = new Point(c.getX() - b.getX(), c.getY() - b.getY());
        return Math.acos(-1 * ((ab.getX() * bc.getX()) + (ab.getY() * bc.getY())) /
                               (ab.magnitude() * bc.magnitude()));
    }
    
    public static ArrayList&lt;Point&gt; jarvisMarch(ArrayList&lt;Point&gt; arr) {
        ArrayList&lt;Point&gt; hull = new ArrayList&lt;Point&gt;();
        Point pointOnHull = new Point(Double.MAX_VALUE, 0);
        
        //find leftmost point
        for (Point p: arr) {
            if (p.getX() &lt; pointOnHull.getX()) {
                pointOnHull = p;
            }
        }
        hull.add(pointOnHull);
        
        //look for the rest of the points on the hull
        Point ref;
        while (true) {
            if (hull.size() == 1) {
                ref = new Point(pointOnHull.getX(), pointOnHull.getY() + 1); //finds a third point to use in calculating the angle
            } else {
                ref = hull.get(hull.size() - 2);
            }
            Point endpoint = arr.get(0); //initial canidate for next point in hull
            for (Point p: arr) {
                if (angle(p, pointOnHull, ref) &gt; angle(endpoint, pointOnHull, ref)) { //found a point that makes a greater angle
                    endpoint = p;
                }
            }
            pointOnHull = endpoint;
            if (pointOnHull.equals(hull.get(0))) { //add next point to hull if not equal to the leftmost point
                break;
            } else {
                hull.add(pointOnHull);
            }
        }
        return hull;
    }
    
    public static void main(String[] args) {
        
        //test array setup
        ArrayList&lt;Point&gt; gift = new ArrayList&lt;Point&gt;();
        gift.add(new Point(-5, 2));
        gift.add(new Point(5, 7));
        gift.add(new Point(-6, -12));
        gift.add(new Point(-14, -14));
        gift.add(new Point(9, 9));
        gift.add(new Point(-1, -1));
        gift.add(new Point(-10, 11));
        gift.add(new Point(-6, 15));
        gift.add(new Point(-6, -8));
        gift.add(new Point(15, -9));
        gift.add(new Point(7, -7));
        gift.add(new Point(-2, -9));
        gift.add(new Point(6, -5));
        gift.add(new Point(0, 14));
        gift.add(new Point(2, 8));
        
        //print initial array of points
        System.out.println(&quot;Gift:&quot;);
        for (Point p: gift) {
            System.out.println(&quot;[&quot; + p.getX() + &quot;, &quot; + p.getY() + &quot;]&quot;);
        }
        
        //find and print the array of points in the hull
        ArrayList&lt;Point&gt; hull = jarvisMarch(gift);
        System.out.println(&quot;Wrapping:&quot;);
        for (Point p: hull) {
            System.out.println(&quot;[&quot; + p.getX() + &quot;, &quot; + p.getY() + &quot;]&quot;);
        }
    }
    
}
</code></pre>
<pre><code class="language-go">package main

import (
	&quot;fmt&quot;
)

type point struct {
	x, y float64
}

func leftMostPoint(points []point) point {
	ret := points[0]

	for _, p := range points {
		if (p.x &lt; ret.x) || (p.x == ret.x &amp;&amp; p.y &lt; ret.y) {
			ret = p
		}
	}

	return ret
}

func (p point) equal(o point) bool {
	return p.x == o.x &amp;&amp; p.y == o.y
}

func counterClockWise(p1, p2, p3 point) bool {
	return (p3.y-p1.y)*(p2.x-p1.x) &gt;= (p2.y-p1.y)*(p3.x-p1.x)
}

func jarvisMarch(points []point) []point {
	hullPoints := make([]point, 0)
	hullPoint := leftMostPoint(points)
	hullPoints = append(hullPoints, hullPoint)

	for {
		endPoint := points[0]

		for _, p := range points[1:] {
			if endPoint.equal(hullPoint) || !counterClockWise(p, hullPoints[len(hullPoints)-1], endPoint) {
				endPoint = p
			}
		}

		hullPoint = endPoint

		if endPoint.equal(hullPoints[0]) {
			break
		}

		hullPoints = append(hullPoints, hullPoint)
	}
	return hullPoints
}

func main() {
	points := []point{{-5, 2}, {5, 7}, {-6, -12}, {-14, -14}, {9, 9},
		{-1, -1}, {-10, 11}, {-6, 15}, {-6, -8}, {15, -9},
		{7, -7}, {-2, -9}, {6, -5}, {0, 14}, {2, 8},
	}

	hullPoints := jarvisMarch(points)
	fmt.Println(&quot;The hull points are:&quot;)

	for _, p := range hullPoints {
		fmt.Printf(&quot;x=%f y=%f\n&quot;, p.x, p.y)
	}
}
</code></pre>
<pre><code class="language-v">struct Point {
	x int
	y int
}

fn left_most_point(points []Point) Point {
	mut ret := points[0]

	for p in points {
		if (p.x &lt; ret.x) || (p.x == ret.x &amp;&amp; p.y &lt; ret.y) {
			ret = p
		}
	}

	return ret
}

fn (p Point) equal(o Point) bool {
	return p.x == o.x &amp;&amp; p.y == o.x
}

fn counter_clock_wise(p1, p2, p3 Point) bool {
	return (p3.y-p1.y) * (p2.x-p1.x) &gt;= (p2.y-p1.y) * (p3.x-p1.x)
}

fn jarvis_march(points []Point) []Point {
	mut hull_point := left_most_point(points)
	mut hull_points := [hull_point]


	for {
		mut end_point := points[0]

		for i := 1; i &lt; points.len; i++ {
			if end_point.equal(points[i]) || !counter_clock_wise(points[i], hull_points[hull_points.len-1], end_point) {
				end_point = points[i]
			}
		}

		hull_point = end_point
		if end_point.equal(hull_points[0]) {
			break
		}

		hull_points &lt;&lt; hull_point
	}
	return hull_points
}

fn main() {
	points := [
		Point{-5, 2}, Point{5, 7}, Point{-6, -12}, Point{-14, -14}, Point{9, 9},
		Point{-1, -1}, Point{-10, 11}, Point{-6, 15}, Point{-6, -8}, Point{15, -9},
		Point{7, -7}, Point{-2, -9}, Point{6, -5}, Point{0, 14}, Point{2, 8}
	]

	hull_points := jarvis_march(points)

	println('The hull points are:')
	for p in hull_points {
		println('x=$p.x y=$p.y')
	}
}
</code></pre>
<pre><pre class="playground"><code class="language-rust">
type Point = (i64, i64);

// Is the turn counter clockwise?
fn turn_counter_clockwise(p1: Point, p2: Point, p3: Point) -&gt; bool {
    (p3.1 - p1.1) * (p2.0 - p1.0) &gt;= (p2.1 - p1.1) * (p3.0 - p1.0)
}

fn jarvis_march(gift: &amp;[Point]) -&gt; Option&lt;Vec&lt;Point&gt;&gt; {
    // There can only be a convex hull if there are more than 2 points
    if gift.len() &lt; 3 {
        return None;
    }

    let leftmost_point = gift
        // Iterate over all points
        .iter()
        // Find the point with minimum x
        .min_by_key(|i| i.0)
        // If there are no points in the gift, there might
        // not be a minimum. Unwrap fails (panics) the program
        // if there wasn't a minimum, but we know there always
        // is because we checked the size of the gift.
        .unwrap()
        .clone();

    let mut hull = vec![leftmost_point];

    let mut point_on_hull = leftmost_point;
    loop {
        // Search for the next point on the hull
        let mut endpoint = gift[0];
        for i in 1..gift.len() {
            if endpoint == point_on_hull || !turn_counter_clockwise(gift[i], hull[hull.len() - 1], endpoint) {
                endpoint = gift[i];
            }
        }

        point_on_hull = endpoint;

        // Stop whenever we got back to the same point
        // as we started with, and we wrapped the gift
        // completely.
        if hull[0] == endpoint {
            break;
        } else {
            hull.push(point_on_hull);
        }
    }

    Some(hull)
}

fn main() {
    let test_gift = vec![
        (-5, 2), (5, 7), (-6, -12), (-14, -14), (9, 9),
        (-1, -1), (-10, 11), (-6, 15), (-6, -8), (15, -9),
        (7, -7), (-2, -9), (6, -5), (0, 14), (2, 8)
    ];

    let hull = jarvis_march(&amp;test_gift);

    println!(&quot;The points in the hull are: {:?}&quot;, hull);
}
</code></pre></pre>
<pre><code class="language-coconut">data point(x=0, y=0):
    def __str__(self):
        return f'({self.x}, {self.y})'

# Is the turn counter-clockwise?
def counter_clockwise(p1 is point, p2 is point, p3 is point) =
    (p3.y - p1.y) * (p2.x - p1.x) &gt;= (p2.y - p1.y) * (p3.x - p1.x)


def jarvis_march(gift: point[]) -&gt; point[]:
    point_on_hull = min(gift) # The leftmost point in the gift
    hull = [point_on_hull] # It is guaranteed it will be on the hull.

    while True:
        # Candidate for the next point in the hull
        endpoint = gift[0]
        for p in gift:
            if (endpoint == point_on_hull
                or not counter_clockwise(p, hull[-1], endpoint)):
                endpoint = p

        point_on_hull = endpoint

        # Check if the gift is completely covered.
        if hull[0] == endpoint:
            return hull
        hull.append(point_on_hull)


if __name__ == '__main__':
    test_gift = [
        (-5, 2), (5, 7), (-6, -12), (-14, -14), (9, 9),
        (-1, -1), (-10, 11), (-6, 15), (-6, -8), (15, -9),
        (7, -7), (-2, -9), (6, -5), (0, 14), (2, 8)
    ] |&gt; map$(t -&gt; point(*t)) |&gt; list
    hull = jarvis_march(test_gift)

    print(&quot;[#] The points in the hull are:&quot;)
    for point in hull:
        print(point)
</code></pre>
<h2 id="license-25"><a class="header" href="#license-25">License</a></h2>
<h5 id="code-examples-23"><a class="header" href="#code-examples-23">Code Examples</a></h5>
<p>The code examples are licensed under the MIT license (found in <a href="https://github.com/algorithm-archivists/algorithm-archive/blob/master/LICENSE.md">LICENSE.md</a>).</p>
<h5 id="text-25"><a class="header" href="#text-25">Text</a></h5>
<p>The text of this chapter was written by <a href="https://github.com/leios">James Schloss</a> and is licensed under the <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</p>
<p><a href="https://creativecommons.org/licenses/by-sa/4.0/"><p><img  class="center" src="jarvis_march/../cc/CC-BY-SA_icon.svg" /></p></a></p>
<h5 id="pull-requests-22"><a class="header" href="#pull-requests-22">Pull Requests</a></h5>
<p>After initial licensing (<a href="https://github.com/algorithm-archivists/algorithm-archive/pull/560">#560</a>), the following pull requests have modified the text or graphics of this chapter:</p>
<ul>
<li>none</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="graham-scan"><a class="header" href="#graham-scan">Graham Scan</a></h1>
<p>At around the same time of the <a href="graham_scan/../jarvis_march/jarvis_march.html">Jarvis March</a>, R. L. Graham was also developing an algorithm to find the convex hull of a random set of points {{ &quot;gs1972&quot; | cite }}.
Unlike the Jarvis March, which is an \( \mathcal{O}(nh) \) operation, the Graham Scan is \( \mathcal{O}(n\log(n)) \), where \( n \) is the number of points and \( h \) is the size for the hull.
This means that the complexity of the Graham Scan is not output-sensitive; moreover, there are some cases where the Jarvis March is more optimal, depending on the size of the hull and the number of points to wrap.</p>
<p>Rather than starting at the leftmost point like the Jarvis March, the Graham scan starts at the bottom.
We then sort the distribution of points based on the angle between the bottom-most point, the origin, and each other point.
After sorting, we go through point-by-point, searching for points that are on the convex hull and throwing out any other points.
We do this by looking for counter-clockwise rotations.
If an angle between three points turns inward, the shape is obviously not convex, so we can throw that result out.
We can find whether a rotation is counter-clockwise with trigonometric functions or by using a cross-product, like so:</p>
<pre><code class="language-julia">function ccw(a::Point, b::Point, c::Point)
    return ((b.x - a.x)*(c.y - a.y) - (b.y - a.y)*(c.x - a.x))
end
</code></pre>
<pre><code class="language-haskell">ccw :: Point -&gt; Point -&gt; Point -&gt; Double
ccw (xa, ya) (xb, yb) (xc, yc) = (xb - xa) * (yc - ya) - (yb - ya) * (xc - xa)
</code></pre>
<pre><code class="language-c">double ccw(struct point a, struct point b, struct point c) {
    return (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x);
}
</code></pre>
<pre><code class="language-javascript">function ccw(a, b, c) {
  return (b.x - a.x) * (c.y - a.y) - (c.x - a.x) * (b.y - a.y);
}
</code></pre>
<pre><code class="language-python">def counter_clockwise(p1, p2, p3):
    &quot;&quot;&quot;Is the turn counter-clockwise?&quot;&quot;&quot;
    return (p3[1] - p1[1]) * (p2[0] - p1[0]) &gt;= (p2[1] - p1[1]) * (p3[0] - p1[0])
</code></pre>
<pre><code class="language-go">func counterClockwise(p1, p2, p3 point) bool {
	return (p3.y-p1.y)*(p2.x-p1.x) &gt;= (p2.y-p1.y)*(p3.x-p1.x)
}
</code></pre>
<pre><code class="language-java">    static double ccw(Point a, Point b, Point c) {
        return (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x);
    }
</code></pre>
<pre><code class="language-lisp">(defun ccw (p1 p2 p3)
  &quot;Determines if a turn between three points is counterclockwise&quot;
  (-
    (*
      (- (point-y p2) (point-y p1))
      (- (point-x p3) (point-x p1)))
    (*
      (- (point-y p3) (point-y p1))
      (- (point-x p2) (point-x p1)))))
</code></pre>
<pre><code class="language-cpp">double ccw(const point&amp; a, const point&amp; b, const point&amp; c) {
  return (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x);
}
``````cpp
double ccw(const point&amp; a, const point&amp; b, const point&amp; c) {
  return (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x);
}
</code></pre>
<p><a href="graham_scan/code/coconut/graham_scan.coco">import:4-8, lang=&quot;coconut&quot;</a></p>
<p>If the output of this function is 0, the points are collinear.
If the output is positive, then the points form a counter-clockwise &quot;left&quot; turn.
If the output is negative, then the points form a clockwise &quot;right&quot; turn.
We basically do not want clockwise rotations, because this means we are at an interior angle.</p>
<!---ADD FIGURE--->
<p>To save memory and expensive <code>append()</code> operations, we ultimately look for points that should be on the hull and swap them with the first elements in the array.
If there are \( M \) elements on the hull, then the first \( M \) elements in our output random distribution of points will be the hull.
In the end, the code should look something like this:</p>
<pre><code class="language-julia">function graham_scan!(points::Vector{Point})
    N = length(points)

    # Place the lowest point at the start of the array
    sort!(points, by = item -&gt; item.y)

    # Sort all other points according to angle with that point
    other_points = sort(points[2:end], by = item -&gt; atan(item.y - points[1].y,
                                                         item.x - points[1].x))

    # Place points sorted by angle back into points vector
    for i in 1:length(other_points)
        points[i+1] = other_points[i]
    end

    # M will be the point on the hull
    M = 2
    for i = 1:N
        while (ccw(points[M-1], points[M], points[i]) &lt;= 0)
            if (M &gt; 2)
                M -= 1
            # All points are collinear
            elseif (i == N)
                break
            else
                i += 1
            end
        end

        # ccw point found, updating hull and swapping points
        M += 1
        points[i], points[M] = points[M], points[i]
    end

    return points[1:M]
end
</code></pre>
<pre><code class="language-haskell">grahamScan :: [Point] -&gt; [Point]
grahamScan [] = []
grahamScan pts = wrap sortedPts [p0]
  where p0@(x, y)= minimumBy (compare `on` snd) pts
        sortedPts = sortOn (\(px, py) -&gt; atan2 (py-y) (px-x) ) $ filter (/=p0) pts
        wrap [] ps = ps
        wrap (s:ss) [p] = wrap ss [s, p]
        wrap (s:ss) (p1:p2:ps)
          | ccw s p1 p2 &gt; 0 = wrap (s:ss) (p2:ps)
          | otherwise       = wrap ss (s:p1:p2:ps)
</code></pre>
<pre><code class="language-c">size_t graham_scan(struct point *points, size_t size) {
    qsort(points, size, sizeof(struct point), cmp_points);
    polar_angles_sort(points, points[0], size);

    struct point tmp_points[size + 1];
    memcpy(tmp_points + 1, points, size * sizeof(struct point));
    tmp_points[0] = tmp_points[size];

    size_t m = 1;
    for (size_t i = 2; i &lt;= size; ++i) {
        while (ccw(tmp_points[m - 1], tmp_points[m], tmp_points[i]) &lt;= 0) {
            if (m &gt; 1) {
                m--;
                continue;
            } else if (i == size) {
                break;
            } else {
                i++;
            }
        }

        m++;
        struct point tmp = tmp_points[i];
        tmp_points[i] = tmp_points[m];
        tmp_points[m] = tmp;
    }

    memcpy(points, tmp_points + 1, size * sizeof(struct point));

    return m;
}
</code></pre>
<pre><code class="language-javascript">function grahamScan(points) {
  // First, sort the points so the one with the lowest y-coordinate comes first (the pivot)
  points = [...points].sort((a, b) =&gt; (a.y - b.y));
  const pivot = points[0];

  // Then sort all remaining points based on the angle between the pivot and itself
  const hull = points.slice(1).sort((a, b) =&gt; polarAngle(a, pivot) - polarAngle(b, pivot));

  // The pivot is always on the hull
  hull.unshift(pivot);

  let n = hull.length;
  let m = 1;
  for (let i = 2; i &lt; n; i++) {
    while (ccw(hull[m - 1], hull[m], hull[i]) &lt;= 0) {
      if (m &gt; 1) {
        m -= 1;
      } else if (m === i) {
        break;
      } else {
        i += 1;
      }
    }

    m += 1;
    [hull[i], hull[m]] = [hull[m], hull[i]];
  }

  return hull.slice(0, m + 1);
}
</code></pre>
<pre><code class="language-python">def graham_scan(gift):
    gift = list(set(gift))  # Remove duplicate points
    start = min(gift, key=lambda p: (p[1], p[0]))  # Must be in hull
    gift.remove(start)

    s = sorted(gift, key=lambda point: polar_angle(start, point))
    hull = [start, s[0], s[1]]

    # Remove points from hull that make the hull concave
    for pt in s[2:]:
        while not counter_clockwise(hull[-2], hull[-1], pt):
            del hull[-1]
        hull.append(pt)

    return hull
</code></pre>
<pre><code class="language-go">func grahamScan(points []point) []point {
	sort.Slice(points, func(a, b int) bool {
		return points[a].y &lt; points[b].y || (points[a].y == points[b].y &amp;&amp; points[a].x &lt; points[b].x)
	})

	start := points[0]
	points = points[1:]

	sort.Slice(points, func(a, b int) bool {
		return polarAngle(start, points[a]) &lt; polarAngle(start, points[b])
	})

	hull := []point{start, points[0], points[1]}
	for _, p := range points[2:] {
		for !counterClockwise(hull[len(hull)-2], hull[len(hull)-1], p) {
			hull = hull[:len(hull)-1]
		}
		hull = append(hull, p)
	}

	return hull
}
</code></pre>
<pre><code class="language-java">    static List&lt;Point&gt; grahamScan(List&lt;Point&gt; gift) {
        gift = gift.stream()
                   .distinct()
                   .sorted(Comparator.comparingDouble(point -&gt; -point.y))
                   .collect(Collectors.toList());

        Point pivot = gift.get(0);

        // Sort the remaining Points based on the angle between the pivot and itself
        List&lt;Point&gt; hull = gift.subList(1, gift.size());
        hull.sort(Comparator.comparingDouble(point -&gt; polarAngle(point, pivot)));

        // The pivot is always on the hull
        hull.add(0, pivot);

        int n = hull.size();
        int m = 1;

        for (int i = 2; i &lt; n; i++) {
            while (ccw(hull.get(m - 1), hull.get(m), hull.get(i)) &lt;= 0) {
                if (m &gt; 1) {
                    m--;
                } else if (m == 1) {
                    break;
                } else {
                    i++;
                }
            }
            m++;

            Point temp = hull.get(i);
            hull.set(i, hull.get(m));
            hull.set(m, temp);
        }
        return hull.subList(0, m + 1);
    }
</code></pre>
<pre><code class="language-lisp">(defun atan2 (y x)
  &quot;Calculates the angle of a point in the euclidean plane in radians&quot;
  (cond
    ((&gt; x 0)                    (atan y x))
    ((and (&lt; x 0) (&gt;= y 0))     (+ (atan y x) pi))
    ((and (&lt; x 0) (&lt; y 0))      (- (atan y x) pi))
    ((and (eql x 0) (&gt; y 0))    (/ pi 2))
    ((and (eql x 0) (&lt; y 0))    (- (/ pi 2)))
    ;; The -1 signifies an exception and is usefull later for sorting by the polar angle
    ((and (eql x 0) (eql y 0))  -1)))

(defun polar-angle (ref point)
  &quot;Returns the polar angle from a point relative to a reference point&quot;
  (atan2 (- (point-y point) (point-y ref)) (- (point-x point) (point-x ref))))

(defun lowest-point (gift)
  &quot;Returns the lowest point of a gift&quot;
  (reduce
    (lambda (p1 p2)
      (if (&lt; (point-y p1) (point-y p2)) p1 p2))
    gift))

(defun graham-scan (gift)
  &quot;Finds the convex hull of a distribution of points with a graham scan&quot;
  ;; An empty list evaluates to false (nil) and a non-empty list evaluates to true (t).
  ;; We can therefore use 'gift' instead of '(&gt; (length gift) 0)'.
  (if gift
      (labels ((wrap (sorted-points hull)
                 (if sorted-points
                   ;; This covers the case where the hull has one or more element.
                   ;; We aren't concerned about the hull being empty, because then the gift must
                   ;; also be empty and this function is never given an empty gift.
                     (if (rest hull)
                         (if (&lt;= (ccw (first sorted-points) (first hull) (second hull)) 0)
                             (wrap sorted-points (rest hull))
                             (wrap (rest sorted-points) (cons (first sorted-points) hull)))
                         (wrap (rest sorted-points) (list (first sorted-points) (first hull))))
                     hull)))
        ;; Because 'sort' shuffles things around destructively, graham-scan is also destructive. But
        ;; since the order of the points is generally not important, this shouldn't cause a problem.
        (let* ((lowest (lowest-point gift))
                (sorted (sort gift #'&lt; :key (lambda (p) (polar-angle lowest p)))))
          (wrap sorted (list lowest))))
      nil))
</code></pre>
<pre><code class="language-cpp">std::vector&lt;point&gt; graham_scan(std::vector&lt;point&gt;&amp; points) {
  // selecting lowest point as pivot
  size_t low_index = 0;
  for (size_t i = 1; i &lt; points.size(); i++) {
    if (points[i].y &lt; points[low_index].y) {
      low_index = i;
    }
  }
  std::swap(points[0], points[low_index]);
  point pivot = points[0];

  // sorting points by polar angle
  std::sort(
      points.begin() + 1,
      points.end(),
      [&amp;pivot](const point&amp; pa, const point&amp; pb) {
        return polar_angle(pivot, pa) &lt; polar_angle(pivot, pb);
      });

  // creating convex hull
  size_t m = 1;
  for (size_t i = 2; i &lt; points.size(); i++) {
    while (ccw(points[m - 1], points[m], points[i]) &lt;= 0) {
      if (m &gt; 1) {
        m--;
        continue;
      } else if (i == points.size()) {
        break;
      } else {
        i++;
      }
    }
    m++;
    std::swap(points[i], points[m]);
  }
  return std::vector&lt;point&gt;(points.begin(), points.begin() + m + 1);
}
``````cpp
std::vector&lt;point&gt; graham_scan(std::vector&lt;point&gt;&amp; points) {
  // selecting lowest point as pivot
  size_t low_index = 0;
  for (size_t i = 1; i &lt; points.size(); i++) {
    if (points[i].y &lt; points[low_index].y) {
      low_index = i;
    }
  }
  std::swap(points[0], points[low_index]);
  point pivot = points[0];

  // sorting points by polar angle
  std::sort(
      points.begin() + 1,
      points.end(),
      [&amp;pivot](const point&amp; pa, const point&amp; pb) {
        return polar_angle(pivot, pa) &lt; polar_angle(pivot, pb);
      });

  // creating convex hull
  size_t m = 1;
  for (size_t i = 2; i &lt; points.size(); i++) {
    while (ccw(points[m - 1], points[m], points[i]) &lt;= 0) {
      if (m &gt; 1) {
        m--;
        continue;
      } else if (i == points.size()) {
        break;
      } else {
        i++;
      }
    }
    m++;
    std::swap(points[i], points[m]);
  }
  return std::vector&lt;point&gt;(points.begin(), points.begin() + m + 1);
}
</code></pre>
<p><a href="graham_scan/code/coconut/graham_scan.coco">import:17-30, lang=&quot;coconut&quot;</a></p>
<h3 id="bibliography-6"><a class="header" href="#bibliography-6">Bibliography</a></h3>
<p>{% references %} {% endreferences %}</p>
<h2 id="example-code-12"><a class="header" href="#example-code-12">Example Code</a></h2>
<pre><code class="language-julia">struct Point
    x::Float64
    y::Float64
end

function ccw(a::Point, b::Point, c::Point)
    return ((b.x - a.x)*(c.y - a.y) - (b.y - a.y)*(c.x - a.x))
end

function graham_scan!(points::Vector{Point})
    N = length(points)

    # Place the lowest point at the start of the array
    sort!(points, by = item -&gt; item.y)

    # Sort all other points according to angle with that point
    other_points = sort(points[2:end], by = item -&gt; atan(item.y - points[1].y,
                                                         item.x - points[1].x))

    # Place points sorted by angle back into points vector
    for i in 1:length(other_points)
        points[i+1] = other_points[i]
    end

    # M will be the point on the hull
    M = 2
    for i = 1:N
        while (ccw(points[M-1], points[M], points[i]) &lt;= 0)
            if (M &gt; 2)
                M -= 1
            # All points are collinear
            elseif (i == N)
                break
            else
                i += 1
            end
        end

        # ccw point found, updating hull and swapping points
        M += 1
        points[i], points[M] = points[M], points[i]
    end

    return points[1:M]
end

function main()
    # This hull is just a simple test so we know what the output should be
    points = [
        Point(-5,2), Point(5,7), Point(-6,-12), Point(-14,-14), Point(9,9),
        Point(-1,-1), Point(-10,11), Point(-6,15), Point(-6,-8), Point(15,-9),
        Point(7,-7), Point(-2,-9), Point(6,-5), Point(0,14), Point(2,8)
    ]
    hull = graham_scan!(points)
    println(hull)
end

main()

</code></pre>
<pre><code class="language-haskell">import Data.List (sortOn, minimumBy)
import Data.Function (on)

type Point = (Double, Double)

ccw :: Point -&gt; Point -&gt; Point -&gt; Double
ccw (xa, ya) (xb, yb) (xc, yc) = (xb - xa) * (yc - ya) - (yb - ya) * (xc - xa)

grahamScan :: [Point] -&gt; [Point]
grahamScan [] = []
grahamScan pts = wrap sortedPts [p0]
  where p0@(x, y)= minimumBy (compare `on` snd) pts
        sortedPts = sortOn (\(px, py) -&gt; atan2 (py-y) (px-x) ) $ filter (/=p0) pts
        wrap [] ps = ps
        wrap (s:ss) [p] = wrap ss [s, p]
        wrap (s:ss) (p1:p2:ps)
          | ccw s p1 p2 &gt; 0 = wrap (s:ss) (p2:ps)
          | otherwise       = wrap ss (s:p1:p2:ps)

main = do
  -- We build the set of points of integer coordinates within a circle of radius 5
  let pts = [(x,y) | x&lt;-[-5..5], y&lt;-[-5..5], x^2+y^2&lt;=5^2]
  -- And extract the convex hull
  print $ grahamScan pts
</code></pre>
<pre><code class="language-c">#include &lt;math.h&gt;
#include &lt;stddef.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

struct point {
    double x, y;
};

int cmp_points(const void *a, const void *b) {
    struct point* pa = (struct point*) a;
    struct point* pb = (struct point*) b;

    if (pa-&gt;y &gt; pb-&gt;y) {
        return 1;
    } else if (pa-&gt;y &lt; pb-&gt;y) {
        return -1;
    } else {
        return 0;
    }
}

double ccw(struct point a, struct point b, struct point c) {
    return (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x);
}

double polar_angle(struct point origin, struct point p) {
    return atan2(p.y - origin.y, p.x - origin.x);
}

void polar_angles_sort(struct point *points, struct point origin, size_t size) {
    if (size &lt; 2) {
        return;
    }

    double pivot_angle = polar_angle(origin, points[size / 2]);

    int i = 0;
    int j = size - 1;
    while (1) {
        while (polar_angle(origin, points[i]) &lt; pivot_angle) {
            i++;
        }
        while (polar_angle(origin, points[j]) &gt; pivot_angle) {
            j--;
        }

        if (i &gt;= j) {
            break;
        }

        struct point tmp = points[i];
        points[i] = points[j];
        points[j] = tmp;

        i++;
        j--;
    }

    polar_angles_sort(points, origin, i);
    polar_angles_sort(points + i, origin, size - i);
}

size_t graham_scan(struct point *points, size_t size) {
    qsort(points, size, sizeof(struct point), cmp_points);
    polar_angles_sort(points, points[0], size);

    struct point tmp_points[size + 1];
    memcpy(tmp_points + 1, points, size * sizeof(struct point));
    tmp_points[0] = tmp_points[size];

    size_t m = 1;
    for (size_t i = 2; i &lt;= size; ++i) {
        while (ccw(tmp_points[m - 1], tmp_points[m], tmp_points[i]) &lt;= 0) {
            if (m &gt; 1) {
                m--;
                continue;
            } else if (i == size) {
                break;
            } else {
                i++;
            }
        }

        m++;
        struct point tmp = tmp_points[i];
        tmp_points[i] = tmp_points[m];
        tmp_points[m] = tmp;
    }

    memcpy(points, tmp_points + 1, size * sizeof(struct point));

    return m;
}

int main() {
    struct point points[] = {{-5, 2}, {5, 7}, {-6, -12}, {-14, -14}, {9, 9},
                             {-1, -1}, {-10, 11}, {-6, 15}, {-6, -8}, {15, -9},
                             {7, -7}, {-2, -9}, {6, -5}, {0, 14}, {2, 8}};
    size_t num_initial_points = 15;

    printf(&quot;Points:\n&quot;);
    for (size_t i = 0; i &lt; num_initial_points; ++i) {
        printf(&quot;(%f,%f)\n&quot;, points[i].x, points[i].y);
    }

    size_t hull_size = graham_scan(points, num_initial_points);

    printf(&quot;\nHull:\n&quot;);
    for (size_t i = 0; i &lt; hull_size; ++i) {
        printf(&quot;(%f,%f)\n&quot;, points[i].x, points[i].y);
    }

    return 0;
}
</code></pre>
<pre><code class="language-javascript">function grahamScan(points) {
  // First, sort the points so the one with the lowest y-coordinate comes first (the pivot)
  points = [...points].sort((a, b) =&gt; (a.y - b.y));
  const pivot = points[0];

  // Then sort all remaining points based on the angle between the pivot and itself
  const hull = points.slice(1).sort((a, b) =&gt; polarAngle(a, pivot) - polarAngle(b, pivot));

  // The pivot is always on the hull
  hull.unshift(pivot);

  let n = hull.length;
  let m = 1;
  for (let i = 2; i &lt; n; i++) {
    while (ccw(hull[m - 1], hull[m], hull[i]) &lt;= 0) {
      if (m &gt; 1) {
        m -= 1;
      } else if (m === i) {
        break;
      } else {
        i += 1;
      }
    }

    m += 1;
    [hull[i], hull[m]] = [hull[m], hull[i]];
  }

  return hull.slice(0, m + 1);
}

function polarAngle(a, b) {
  return Math.atan2(a.y - b.y, a.x - b.x);
}

function ccw(a, b, c) {
  return (b.x - a.x) * (c.y - a.y) - (c.x - a.x) * (b.y - a.y);
}

const points = [
  { x: -5, y: 2 },
  { x: 5, y: 7 },
  { x: -6, y: -12 },
  { x: -14, y: -14 },
  { x: 9, y: 9 },
  { x: -1, y: -1 },
  { x: -10, y: 11 },
  { x: -6, y: 15 },
  { x: -6, y: -8 },
  { x: 15, y: -9 },
  { x: 7, y: -7 },
  { x: -2, y: -9 },
  { x: 6, y: -5 },
  { x: 0, y: 14 },
  { x: 2, y: 8 },
];

const convexHull = grahamScan(points);
console.log(&quot;The points in the hull are:&quot;);
convexHull.forEach(p =&gt; console.log(`(${p.x}, ${p.y})`));
</code></pre>
<pre><code class="language-python">from math import atan2


def counter_clockwise(p1, p2, p3):
    &quot;&quot;&quot;Is the turn counter-clockwise?&quot;&quot;&quot;
    return (p3[1] - p1[1]) * (p2[0] - p1[0]) &gt;= (p2[1] - p1[1]) * (p3[0] - p1[0])


def polar_angle(ref, point):
    &quot;&quot;&quot;Find the polar angle of a point relative to a reference point&quot;&quot;&quot;
    return atan2(point[1] - ref[1], point[0] - ref[0])


def graham_scan(gift):
    gift = list(set(gift))  # Remove duplicate points
    start = min(gift, key=lambda p: (p[1], p[0]))  # Must be in hull
    gift.remove(start)

    s = sorted(gift, key=lambda point: polar_angle(start, point))
    hull = [start, s[0], s[1]]

    # Remove points from hull that make the hull concave
    for pt in s[2:]:
        while not counter_clockwise(hull[-2], hull[-1], pt):
            del hull[-1]
        hull.append(pt)

    return hull


def main():
    test_gift = [
        (-5, 2),
        (5, 7),
        (-6, -12),
        (-14, -14),
        (9, 9),
        (-1, -1),
        (-10, 11),
        (-6, 15),
        (-6, -8),
        (15, -9),
        (7, -7),
        (-2, -9),
        (6, -5),
        (0, 14),
        (2, 8),
    ]
    hull = graham_scan(test_gift)

    print(&quot;The points in the hull are:&quot;)
    for point in hull:
        print(point)


main()
</code></pre>
<pre><code class="language-go">package main

import (
	&quot;fmt&quot;
	&quot;math&quot;
	&quot;sort&quot;
)

type point struct {
	x, y int
}

func counterClockwise(p1, p2, p3 point) bool {
	return (p3.y-p1.y)*(p2.x-p1.x) &gt;= (p2.y-p1.y)*(p3.x-p1.x)
}

func polarAngle(ref, point point) float64 {
	return math.Atan2(float64(point.y-ref.y), float64(point.x-ref.x))
}

func grahamScan(points []point) []point {
	sort.Slice(points, func(a, b int) bool {
		return points[a].y &lt; points[b].y || (points[a].y == points[b].y &amp;&amp; points[a].x &lt; points[b].x)
	})

	start := points[0]
	points = points[1:]

	sort.Slice(points, func(a, b int) bool {
		return polarAngle(start, points[a]) &lt; polarAngle(start, points[b])
	})

	hull := []point{start, points[0], points[1]}
	for _, p := range points[2:] {
		for !counterClockwise(hull[len(hull)-2], hull[len(hull)-1], p) {
			hull = hull[:len(hull)-1]
		}
		hull = append(hull, p)
	}

	return hull
}

func main() {
	points := []point{{-5, 2}, {5, 7}, {-6, -12}, {-14, -14}, {9, 9},
		{-1, -1}, {-10, 11}, {-6, 15}, {-6, -8}, {15, -9},
		{7, -7}, {-2, -9}, {6, -5}, {0, 14}, {2, 8}}

	fmt.Println(&quot;The points in the hull are:&quot;)
	hull := grahamScan(points)
	for _, p := range hull {
		fmt.Println(p)
	}
}
</code></pre>
<pre><code class="language-java">import java.util.ArrayList;
import java.util.Comparator;
import java.util.List;
import java.util.stream.Collectors;

public class GrahamScan {

    static class Point {
        public double x;
        public double y;

        public Point(double x, double y) {
            this.x = x;
            this.y = y;
        }

        @Override
        public boolean equals(Object o) {
            if (o == null) return false;
            if (o == this) return true;
            if (!(o instanceof Point)) return false;
            Point p = (Point)o;
            return p.x == this.x &amp;&amp; p.y == this.y;
        }
    }

    static double ccw(Point a, Point b, Point c) {
        return (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x);
    }

    static double polarAngle(Point origin, Point p) {
        return Math.atan2(p.y - origin.y, p.x - origin.x);
    }

    static List&lt;Point&gt; grahamScan(List&lt;Point&gt; gift) {
        gift = gift.stream()
                   .distinct()
                   .sorted(Comparator.comparingDouble(point -&gt; -point.y))
                   .collect(Collectors.toList());

        Point pivot = gift.get(0);

        // Sort the remaining Points based on the angle between the pivot and itself
        List&lt;Point&gt; hull = gift.subList(1, gift.size());
        hull.sort(Comparator.comparingDouble(point -&gt; polarAngle(point, pivot)));

        // The pivot is always on the hull
        hull.add(0, pivot);

        int n = hull.size();
        int m = 1;

        for (int i = 2; i &lt; n; i++) {
            while (ccw(hull.get(m - 1), hull.get(m), hull.get(i)) &lt;= 0) {
                if (m &gt; 1) {
                    m--;
                } else if (m == 1) {
                    break;
                } else {
                    i++;
                }
            }
            m++;

            Point temp = hull.get(i);
            hull.set(i, hull.get(m));
            hull.set(m, temp);
        }
        return hull.subList(0, m + 1);
    }

    public static void main(String[] args) {
        ArrayList&lt;Point&gt; points = new ArrayList&lt;&gt;();

        points.add(new Point(-5, 2));
        points.add(new Point(5, 7));
        points.add(new Point(-6, -12));
        points.add(new Point(-14, -14));
        points.add(new Point(9, 9));
        points.add(new Point(-1, -1));
        points.add(new Point(-10, 11));
        points.add(new Point(-6, 15));
        points.add(new Point(-6, -8));
        points.add(new Point(15, -9));
        points.add(new Point(7, -7));
        points.add(new Point(-2, -9));
        points.add(new Point(6, -5));
        points.add(new Point(0, 14));
        points.add(new Point(2, 8));

        List&lt;Point&gt; convexHull = grahamScan(points);

        convexHull.forEach(p -&gt; System.out.printf(&quot;% 1.0f, % 1.0f\n&quot;, p.x, p.y));
    }
}
</code></pre>
<pre><code class="language-lisp">;;;; Graham scan implementation in Common Lisp

(defstruct (point (:constructor make-point (x y))) x y)

(defun ccw (p1 p2 p3)
  &quot;Determines if a turn between three points is counterclockwise&quot;
  (-
    (*
      (- (point-y p2) (point-y p1))
      (- (point-x p3) (point-x p1)))
    (*
      (- (point-y p3) (point-y p1))
      (- (point-x p2) (point-x p1)))))

(defun atan2 (y x)
  &quot;Calculates the angle of a point in the euclidean plane in radians&quot;
  (cond
    ((&gt; x 0)                    (atan y x))
    ((and (&lt; x 0) (&gt;= y 0))     (+ (atan y x) pi))
    ((and (&lt; x 0) (&lt; y 0))      (- (atan y x) pi))
    ((and (eql x 0) (&gt; y 0))    (/ pi 2))
    ((and (eql x 0) (&lt; y 0))    (- (/ pi 2)))
    ;; The -1 signifies an exception and is usefull later for sorting by the polar angle
    ((and (eql x 0) (eql y 0))  -1)))

(defun polar-angle (ref point)
  &quot;Returns the polar angle from a point relative to a reference point&quot;
  (atan2 (- (point-y point) (point-y ref)) (- (point-x point) (point-x ref))))

(defun lowest-point (gift)
  &quot;Returns the lowest point of a gift&quot;
  (reduce
    (lambda (p1 p2)
      (if (&lt; (point-y p1) (point-y p2)) p1 p2))
    gift))

(defun graham-scan (gift)
  &quot;Finds the convex hull of a distribution of points with a graham scan&quot;
  ;; An empty list evaluates to false (nil) and a non-empty list evaluates to true (t).
  ;; We can therefore use 'gift' instead of '(&gt; (length gift) 0)'.
  (if gift
      (labels ((wrap (sorted-points hull)
                 (if sorted-points
                   ;; This covers the case where the hull has one or more element.
                   ;; We aren't concerned about the hull being empty, because then the gift must
                   ;; also be empty and this function is never given an empty gift.
                     (if (rest hull)
                         (if (&lt;= (ccw (first sorted-points) (first hull) (second hull)) 0)
                             (wrap sorted-points (rest hull))
                             (wrap (rest sorted-points) (cons (first sorted-points) hull)))
                         (wrap (rest sorted-points) (list (first sorted-points) (first hull))))
                     hull)))
        ;; Because 'sort' shuffles things around destructively, graham-scan is also destructive. But
        ;; since the order of the points is generally not important, this shouldn't cause a problem.
        (let* ((lowest (lowest-point gift))
                (sorted (sort gift #'&lt; :key (lambda (p) (polar-angle lowest p)))))
          (wrap sorted (list lowest))))
      nil))

(defvar gift
  (map
    'list
    (lambda (e) (apply #'make-point e))
    '((-5 2) (5 7) (-6 -12) (-14 -14) (9 9)
      (-1 -1) (-10 11) (-6 15) (-6 -8) (15 -9)
      (7 -7) (-2 -9) (6 -5) (0 14) (2 8))))

;; This should print out the following:
;; (#S(POINT :X -10 :Y 11) #S(POINT :X -6 :Y 15) #S(POINT :X 0 :Y 14)
;; #S(POINT :X 9 :Y 9) #S(POINT :X 7 :Y -7) #S(POINT :X -6 :Y -12))
(print (graham-scan gift))
</code></pre>
<pre><code class="language-cpp">#include &lt;algorithm&gt;
#include &lt;cmath&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;

struct point {
  double x;
  double y;
};

std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const std::vector&lt;point&gt;&amp; points) {
  for (auto p : points) {
    os &lt;&lt; &quot;(&quot; &lt;&lt; p.x &lt;&lt; &quot;, &quot; &lt;&lt; p.y &lt;&lt; &quot;)\n&quot;;
  }
  return os;
}

double ccw(const point&amp; a, const point&amp; b, const point&amp; c) {
  return (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x);
}

double polar_angle(const point&amp; origin, const point&amp; p) {
  return std::atan2(p.y - origin.y, p.x - origin.x);
}

std::vector&lt;point&gt; graham_scan(std::vector&lt;point&gt;&amp; points) {
  // selecting lowest point as pivot
  size_t low_index = 0;
  for (size_t i = 1; i &lt; points.size(); i++) {
    if (points[i].y &lt; points[low_index].y) {
      low_index = i;
    }
  }
  std::swap(points[0], points[low_index]);
  point pivot = points[0];

  // sorting points by polar angle
  std::sort(
      points.begin() + 1,
      points.end(),
      [&amp;pivot](const point&amp; pa, const point&amp; pb) {
        return polar_angle(pivot, pa) &lt; polar_angle(pivot, pb);
      });

  // creating convex hull
  size_t m = 1;
  for (size_t i = 2; i &lt; points.size(); i++) {
    while (ccw(points[m - 1], points[m], points[i]) &lt;= 0) {
      if (m &gt; 1) {
        m--;
        continue;
      } else if (i == points.size()) {
        break;
      } else {
        i++;
      }
    }
    m++;
    std::swap(points[i], points[m]);
  }
  return std::vector&lt;point&gt;(points.begin(), points.begin() + m + 1);
}

int main() {
  std::vector&lt;point&gt; points = {{-5, 2},
                               {5, 7},
                               {-6, -12},
                               {-14, -14},
                               {9, 9},
                               {-1, -1},
                               {-10, 11},
                               {-6, 15},
                               {-6, -8},
                               {15, -9},
                               {7, -7},
                               {-2, -9},
                               {6, -5},
                               {0, 14},
                               {2, 8}};
  std::cout &lt;&lt; &quot;original points are as follows:\n&quot; &lt;&lt; points;
  const std::vector&lt;point&gt; hull = graham_scan(points);
  std::cout &lt;&lt; &quot;points in hull are as follows:\n&quot; &lt;&lt; hull;
  return 0;
}
``````cpp
#include &lt;algorithm&gt;
#include &lt;cmath&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;

struct point {
  double x;
  double y;
};

std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const std::vector&lt;point&gt;&amp; points) {
  for (auto p : points) {
    os &lt;&lt; &quot;(&quot; &lt;&lt; p.x &lt;&lt; &quot;, &quot; &lt;&lt; p.y &lt;&lt; &quot;)\n&quot;;
  }
  return os;
}

double ccw(const point&amp; a, const point&amp; b, const point&amp; c) {
  return (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x);
}

double polar_angle(const point&amp; origin, const point&amp; p) {
  return std::atan2(p.y - origin.y, p.x - origin.x);
}

std::vector&lt;point&gt; graham_scan(std::vector&lt;point&gt;&amp; points) {
  // selecting lowest point as pivot
  size_t low_index = 0;
  for (size_t i = 1; i &lt; points.size(); i++) {
    if (points[i].y &lt; points[low_index].y) {
      low_index = i;
    }
  }
  std::swap(points[0], points[low_index]);
  point pivot = points[0];

  // sorting points by polar angle
  std::sort(
      points.begin() + 1,
      points.end(),
      [&amp;pivot](const point&amp; pa, const point&amp; pb) {
        return polar_angle(pivot, pa) &lt; polar_angle(pivot, pb);
      });

  // creating convex hull
  size_t m = 1;
  for (size_t i = 2; i &lt; points.size(); i++) {
    while (ccw(points[m - 1], points[m], points[i]) &lt;= 0) {
      if (m &gt; 1) {
        m--;
        continue;
      } else if (i == points.size()) {
        break;
      } else {
        i++;
      }
    }
    m++;
    std::swap(points[i], points[m]);
  }
  return std::vector&lt;point&gt;(points.begin(), points.begin() + m + 1);
}

int main() {
  std::vector&lt;point&gt; points = {{-5, 2},
                               {5, 7},
                               {-6, -12},
                               {-14, -14},
                               {9, 9},
                               {-1, -1},
                               {-10, 11},
                               {-6, 15},
                               {-6, -8},
                               {15, -9},
                               {7, -7},
                               {-2, -9},
                               {6, -5},
                               {0, 14},
                               {2, 8}};
  std::cout &lt;&lt; &quot;original points are as follows:\n&quot; &lt;&lt; points;
  const std::vector&lt;point&gt; hull = graham_scan(points);
  std::cout &lt;&lt; &quot;points in hull are as follows:\n&quot; &lt;&lt; hull;
  return 0;
}
</code></pre>
<p><a href="graham_scan/code/coconut/graham_scan.coco">import, lang=&quot;coconut&quot;</a></p>
<h2 id="license-26"><a class="header" href="#license-26">License</a></h2>
<h5 id="code-examples-24"><a class="header" href="#code-examples-24">Code Examples</a></h5>
<p>The code examples are licensed under the MIT license (found in <a href="https://github.com/algorithm-archivists/algorithm-archive/blob/master/LICENSE.md">LICENSE.md</a>).</p>
<h5 id="text-26"><a class="header" href="#text-26">Text</a></h5>
<p>The text of this chapter was written by <a href="https://github.com/leios">James Schloss</a> and is licensed under the <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</p>
<p><a href="https://creativecommons.org/licenses/by-sa/4.0/"><p><img  class="center" src="graham_scan/../cc/CC-BY-SA_icon.svg" /></p></a></p>
<h5 id="pull-requests-23"><a class="header" href="#pull-requests-23">Pull Requests</a></h5>
<p>After initial licensing (<a href="https://github.com/algorithm-archivists/algorithm-archive/pull/560">#560</a>), the following pull requests have modified the text or graphics of this chapter:</p>
<ul>
<li>none</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="what-makes-a-fourier-transform-fast"><a class="header" href="#what-makes-a-fourier-transform-fast">What Makes a Fourier Transform Fast?</a></h2>
<p>If there were ever an algorithm to radically change the landscape of computer science and engineering by making seemingly impossible problems possible, it would be the Fast Fourier Transform (FFT).
On the surface, the algorithm seems like a simple application of recursion, and in principle, that is exactly what it is; however, the Fourier Transform is no ordinary transform -- it allows researchers and engineers to easily bounce back and forth between real space and frequency space and is the heart of many physics and engineering applications.
From calculating superfluid vortex positions to super-resolution imaging, Fourier Transforms lay at the heart of many scientific disciplines and are essential to many algorithms we will cover later in this book.</p>
<p>Simply put, the Fourier Transform is a beautiful application of complex number systems; however, it would rarely be used today if not for the ability to quickly perform the operation with Fast Fourier Transform, first introduced by the great Frederick Gauss in 1805 and later independently discovered by James Cooley and John Tukey in 1965 {{ &quot;ct1965&quot; | cite }}.
Gauss (of course) already had too many things named after him and Cooley and Tukey both had cooler names, so the most common algorithm for FFTs today is known as the Cooley-Tukey algorithm.</p>
<h3 id="what-is-a-fourier-transform"><a class="header" href="#what-is-a-fourier-transform">What is a Fourier Transform?</a></h3>
<p>To an outsider, the Fourier Transform looks like a mathematical mess -- certainly a far cry from the heroic portal between two domains I have depicted it to be; however, like most things, it's not as bad as it initially appears to be.
So, here it is in all it's glory!</p>
<p>\( F(\xi) = \int_{-\infty} ^\infty f(x) e^{-2 \pi i x \xi} dx \)</p>
<p>and</p>
<p>\( f(x) = \int_{-\infty} ^\infty F(\xi) e^{2 \pi i \xi x} d\xi \)</p>
<p>Where \( F(\xi) \) represents a function in frequency space, \( \xi \) represents a value in frequency space, \( f(x) \) represents a function in real space, and \( x \) represents a value in the real space.
Note here that the only difference between the two exponential terms is a minus sign in the transformation to frequency space.
As I mentioned, this is not intuitive syntax, so please allow me to explain a bit.</p>
<p>Firstly, <strong>what does the Fourier Transform do?</strong></p>
<p>If we take a sum sinusoidal functions (like \( \sin(\omega t) \) or \( \cos(\omega t) \)), we might find a complicated mess of waves between \( \pm 1 \).
Each constituent wave can be described by only one value: \( \omega \).
So, instead of representing these curves as seen above, we could instead describe them as peaks in frequency space, as shown below.</p>
<p>
    <img  class="center" src="cooley_tukey/res/FT_example.png" style="width:70%" />
</p>
<p>This is what the Fourier Transform does!
After performing the transform, it is now much, much easier to understand precisely which frequencies are in our waveform, which is essential to most areas of signal processing.</p>
<p>Now, how does this relate to the transformations above?
Well, the easiest way is to substitute in the Euler's formula:</p>
<p>\( e^{2 \pi i \theta} = \cos(2 \pi \theta) + i \sin(2 \pi \theta) \)</p>
<p>This clearly turns our function in frequency space into:</p>
<p>\( F(\xi) = \int_{-\infty} ^\infty f(x) (\cos(-2 \pi x \xi) + i \sin(-2 \pi x \xi))dx \)</p>
<p>and our function in real space into:</p>
<p>\( f(x) = \int_{-\infty} ^\infty F(\xi) (\cos(2 \pi \xi x) + i \sin(2 \pi \xi x)) d\xi \)</p>
<p>Here, the \( \sin \) and \( \cos \) functions are clearly written in the formulas, so it looks much friendlier, right?
This means that a point in real space is defined by the integral over all space of it's corresponding frequency function multiplied by sinusoidal oscillations.</p>
<p>Truth be told, even after seeing this math, I still didn't understand Fourier Transforms.
Truth be told, I didn't understand it fully until I discretized real and frequency space to create the Discrete Fourier Transform (DFT), which is the only way to implement Fourier Transforms in code.</p>
<h3 id="what-is-a-discrete-fourier-transform"><a class="header" href="#what-is-a-discrete-fourier-transform">What is a Discrete Fourier Transform?</a></h3>
<p>In principle, the Discrete Fourier Transform (DFT) is simply the Fourier transform with summations instead of integrals:</p>
<p>\( X_k = \sum_{n=0}^{N-1} x_n \cdot e^{-2 \pi i k n / N} \)</p>
<p>and</p>
<p>\( x_n = \frac{1}{N} \sum_{k=0}^{N-1} X_k \cdot e^{2 \pi i k n / N} \)</p>
<p>Where \( X_n \) and \( x_n \) are sequences of \( N \) numbers in frequency and real space, respectively.
In principle, this is no easier to understand than the previous case!
For some reason, though, putting code to this transformation really helped me figure out what was actually going on.</p>
<pre><code class="language-julia">function DFT(x)
    N = length(x)

    # We want two vectors here for real space (n) and frequency space (k)
    n = 0:N-1
    k = n'
    transform_matrix = exp.(-2im*pi*n*k/N)
    return transform_matrix*x

end
</code></pre>
<pre><code class="language-c">void dft(double complex *X, const size_t N) {
    double complex tmp[N];
    for (size_t i = 0; i &lt; N; ++i) {
        tmp[i] = 0;
        for (size_t j = 0; j &lt; N; ++j) {
            tmp[i] += X[j] * cexp(-2.0 * M_PI * I * j * i / N);
        }
    }

    memcpy(X, tmp, N * sizeof(*X));
}
</code></pre>
<pre><code class="language-clojure">(defn dft
  &quot;take a vector of real numbers and return a vector of frequency
  space&quot;
  [vx]
  (let [len (count vx)]
     (matrix-mult
      (partition len
                 (for [n (range len)
                       k (range len)]
                   ;; expresion below is
                   ;; e^(n*k*2*pi*(1/len)*(-i))
                   (c/exp (c/* n k
                               2 Math/PI
                               (/ len)
                               (c/complex 0 -1)))))
      vx)))
</code></pre>
<pre><code class="language-cpp">template &lt;typename Iter&gt;
void dft(Iter X, Iter last) {
  const auto N = last - X;
  std::vector&lt;complex&gt; tmp(N);
  for (auto i = 0; i &lt; N; ++i) {
    for (auto j = 0; j &lt; N; ++j) {
      tmp[i] += X[j] * exp(complex(0, -2.0 * M_PI * i * j / N));
    }
  }
  std::copy(std::begin(tmp), std::end(tmp), X);
}
</code></pre>
<pre><code class="language-haskell">dft :: [Complex Double] -&gt; [Complex Double]
dft x = matMult dftMat x
  where
    n = length x
    w = exp $ (-2) * pi * (0 :+ 1) / fromIntegral n
    dftMat = [[w ^ (j * k) | j &lt;- [0 .. n - 1]] | k &lt;- [0 .. n - 1]]
    matMult m x = map (sum . zipWith (*) x) m
</code></pre>
<pre><code class="language-python">def dft(X):
    N = len(X)
    temp = [0] * N
    for i in range(N):
        for k in range(N):
            temp[i] += X[k] * exp(-2.0j * pi * i * k / N)
    return temp
</code></pre>
<pre><code class="language-asm-x64"># rdi - array ptr
# rsi - array size
dft:
  push   rbx
  push   r12
  push   r13
  push   r14
  push   r15
  mov    r12, rdi                    # Save parameters
  mov    r13, rsi
  sub    rsp, r13                    # Make a double complex array
  xor    r14, r14                    # Set index to 0
dft_loop_i:
  cmp    r14, r13                    # Check if index is equal to array size
  je     dft_end_i
  lea    rax, [rsp + r14]            # Set tmp array to zero at r14
  mov    QWORD PTR [rax], 0
  mov    QWORD PTR [rax + 8], 0
  xor    r15, r15                    # Set second index to 0
dft_loop_j:
  cmp    r15, r13                    # Check if the index is equal to array size
  je     dft_end_j
  movsd  xmm1, two_pi                # Calculate xmm1 = -2pi * i * j / N
  mov    rax, r14
  imul   rax, r15
  shr    rax, 4
  cvtsi2sdq xmm2, rax
  mulsd  xmm1, xmm2
  cvtsi2sdq xmm2, r13
  divsd  xmm1, xmm2
  pxor   xmm0, xmm0                  # Set xmm0 to 0
  call   cexp
  lea    rax, [r12 + r15]            # Calculate X[i] * cexp(-2pi * i * j / N)
  movsd  xmm2, QWORD PTR [rax]
  movsd  xmm3, QWORD PTR [rax + 8]
  call   __muldc3
  lea    rax, [rsp + r14]
  movsd  xmm6, QWORD PTR [rax]       # Sum to tmp array
  movsd  xmm7, QWORD PTR [rax + 8]
  addsd  xmm6, xmm0
  addsd  xmm7, xmm1
  movsd  QWORD PTR [rax], xmm6       # Save to tmp array
  movsd  QWORD PTR [rax + 8], xmm7
  add    r15, 16
  jmp    dft_loop_j
dft_end_j:
  add    r14, 16
  jmp    dft_loop_i
dft_end_i:
  mov    rdi, r12                    # Move tmp array to array ptr
  mov    rsi, rsp
  mov    rdx, r13
  call   memcpy
  add    rsp, r13
  pop    r15
  pop    r14
  pop    r13
  pop    r12
  pop    rbx
  ret
</code></pre>
<pre><code class="language-javascript">function dft(x) {
  const N = x.length;

  // Initialize an array with N elements, filled with 0s
  return Array(N)
    .fill(new Complex(0, 0))
    .map((temp, i) =&gt; {
      // Reduce x into the sum of x_k * exp(-2*sqrt(-1)*pi*i*k/N)
      return x.reduce((a, b, k) =&gt; {
        return a.add(b.mul(new Complex(0, (-2 * Math.PI * i * k) / N).exp()));
      }, new Complex(0, 0)); // Start accumulating from 0
    });
}
</code></pre>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn dft(x: &amp;[Complex&lt;f64&gt;]) -&gt; Vec&lt;Complex&lt;f64&gt;&gt; {
    let n = x.len();
    (0..n)
        .map(|i| {
            (0..n)
                .map(|k| {
                    x[k] * (Complex::new(0.0_f64, -2.0_f64) * PI * (i as f64) * (k as f64)
                        / (n as f64))
                        .exp()
                })
                .sum()
        })
        .collect()
}
<span class="boring">}
</span></code></pre></pre>
<pre><code class="language-lisp">(defun coefficient (time-index freq-index dft-len)
  &quot;Calculates a single twiddle factor for the Fourier Transform.&quot;
  (exp (- (/ (* #c(0 1) 2.0 pi time-index freq-index)
             dft-len))))

(defun dft (data)
  &quot;Performs the Discrete Fourier Transform&quot;
  (let ((dft-len (length data)))
    (loop for freq-index from 0 below dft-len collect
      (loop for time-index from 0 below dft-len sum
        (* (coefficient time-index freq-index dft-len) (elt data time-index))))))
</code></pre>
<p>In this function, we define <code>n</code> to be a set of integers from \( 0 \rightarrow N-1 \) and arrange them to be a column.
We then set <code>k</code> to be the same thing, but in a row.
This means that when we multiply them together, we get a matrix, but not just any matrix!
This matrix is the heart to the transformation itself!</p>
<pre><code>M = [1.0+0.0im  1.0+0.0im           1.0+0.0im          1.0+0.0im;
     1.0+0.0im  6.12323e-17-1.0im  -1.0-1.22465e-16im -1.83697e-16+1.0im;
     1.0+0.0im -1.0-1.22465e-16im   1.0+2.44929e-16im -1.0-3.67394e-16im;
     1.0+0.0im -1.83697e-16+1.0im  -1.0-3.67394e-16im  5.51091e-16-1.0im]
</code></pre>
<p>It was amazing to me when I saw the transform for what it truly was: an actual transformation matrix!
That said, the Discrete Fourier Transform is slow -- primarily because matrix multiplication is slow, and as mentioned before, slow code is not particularly useful.
So what was the trick that everyone used to go from a Discrete Fourier Transform to a <em>Fast</em> Fourier Transform?</p>
<p>Recursion!</p>
<h3 id="the-cooley-tukey-algorithm"><a class="header" href="#the-cooley-tukey-algorithm">The Cooley-Tukey Algorithm</a></h3>
<p>The problem with using a standard DFT is that it requires a large matrix multiplications and sums over all elements, which are prohibitively complex operations.
The Cooley-Tukey algorithm calculates the DFT directly with fewer summations and without matrix multiplications.
If necessary, DFTs can still be calculated directly at the early stages of the FFT calculation.
The trick to the Cooley-Tukey algorithm is recursion.
In particular, we split the matrix we wish to perform the FFT on into two parts: one for all elements with even indices and another for all odd indices.
We then proceed to split the array again and again until we have a manageable array size to perform a DFT (or similar FFT) on.
We can also perform a similar re-ordering by using a bit reversal scheme, where we output each array index's integer value in binary and flip it to find the new location of that element.
With recursion, we can reduce the complexity to \( \sim \mathcal{O}(n \log n) \), which is a feasible operation.</p>
<p>In the end, the code looks like:</p>
<pre><code class="language-julia">function cooley_tukey(x)
    N = length(x)

    if (N &gt; 2)
        x_odd = cooley_tukey(x[1:2:N])
        x_even = cooley_tukey(x[2:2:N])
    else
        x_odd = x[1]
        x_even = x[2]
    end
    n = 0:N-1
    half = div(N,2)
    factor = exp.(-2im*pi*n/N)
    return vcat(x_odd .+ x_even .* factor[1:half],
                x_odd .- x_even .* factor[1:half])

end
</code></pre>
<pre><code class="language-c">void cooley_tukey(double complex *X, const size_t N) {
    if (N &gt;= 2) {
        double complex tmp [N / 2];
        for (size_t i = 0; i &lt; N / 2; ++i) {
            tmp[i] = X[2*i + 1];
            X[i] = X[2*i];
        }
        for (size_t i = 0; i &lt; N / 2; ++i) {
            X[i + N / 2] = tmp[i];
        }

        cooley_tukey(X, N / 2);
        cooley_tukey(X + N / 2, N / 2);

        for (size_t i = 0; i &lt; N / 2; ++i) {
            X[i + N / 2] = X[i] - cexp(-2.0 * I * M_PI * i / N) * X[i + N / 2];
            X[i] -= (X[i + N / 2]-X[i]);
        }
    }
}
</code></pre>
<pre><code class="language-clojure">(defn fft [vx]
  (let [len (count vx)]
    (if (= len 1)
      vx
      ;;else
      (let [;; take values of vx in the even indices
            even-indices (keep-indexed #(if (even? %1) %2) vx)
            ;; take values in the odd indices
            odd-indices (keep-indexed #(if (odd? %1) %2) vx)
            ;; recursion
            even-fft (fft even-indices)
            odd-fft (fft odd-indices)
            ;; make a sequence of e^(-2pi*i*k/N) where N is the length
            ;; vx and k range from 0 to N/2
            omegas-half (map
                         (comp c/exp
                               (partial c/*
                                        (/ len)
                                        2 Math/PI
                                        (c/complex 0 -1)))
                         (range 0 (quot len 2)))
            ;; take the negative of the first sequence because
            ;; e^(-2pi*i*(k+N/2)/N=-e^(-2pi*i*k/N) where k ranges from
            ;; 0 to N/2 
            omegas-2half (map c/- omegas-half)
            mult-add (partial map #(c/+ %3 (c/* %1 %2)))]
        (concat (mult-add omegas-half odd-fft even-fft)
                (mult-add omegas-2half odd-fft even-fft))))))
</code></pre>
<pre><code class="language-cpp">template &lt;typename Iter&gt;
void cooley_tukey(Iter first, Iter last) {
  auto size = last - first;
  if (size &gt;= 2) {
    // split the range, with even indices going in the first half,
    // and odd indices going in the last half.
    auto temp = std::vector&lt;complex&gt;(size / 2);
    for (int i = 0; i &lt; size / 2; ++i) {
      temp[i] = first[i * 2 + 1];
      first[i] = first[i * 2];
    }
    for (int i = 0; i &lt; size / 2; ++i) {
      first[i + size / 2] = temp[i];
    }

    // recurse the splits and butterflies in each half of the range
    auto split = first + size / 2;
    cooley_tukey(first, split);
    cooley_tukey(split, last);

    // now combine each of those halves with the butterflies
    for (int k = 0; k &lt; size / 2; ++k) {
      auto w = std::exp(complex(0, -2.0 * pi * k / size));

      auto&amp; bottom = first[k];
      auto&amp; top = first[k + size / 2];
      top = bottom - w * top;
      bottom -= top - bottom;
    }
  }
}
</code></pre>
<pre><code class="language-haskell">fft :: [Complex Double] -&gt; [Complex Double]
fft x = fft' x
  where
    n = length x
    w0 = exp ((-2) * pi * (0 :+ 1) / fromIntegral n)
    w = M.fromList [(k % n, w0 ^ k) | k &lt;- [0 .. n - 1]]
    fft' [x] = [x]
    fft' x =
      let (evens, odds) = partition (even . fst) $ zip [0 ..] x
          e = fft' $ map snd evens
          o = fft' $ map snd odds
          x1 = zipWith3 (\e o k -&gt; e + o * w ! (k %n)) e o [0 ..]
          x2 = zipWith3 (\e o k -&gt; e - o * w ! (k %n)) e o [0 ..]
       in x1 ++ x2
</code></pre>
<pre><code class="language-python">def cooley_tukey(X):
    N = len(X)
    if N &lt;= 1:
        return X
    even = cooley_tukey(X[0::2])
    odd = cooley_tukey(X[1::2])

    temp = [i for i in range(N)]
    for k in range(N // 2):
        temp[k] = even[k] + exp(-2.0j * pi * k / N) * odd[k]
        temp[k + N // 2] = even[k] - exp(-2.0j * pi * k / N) * odd[k]
    return temp
</code></pre>
<pre><code class="language-asm-x64"># rdi - array ptr
# rsi - array size
cooley_tukey:
  cmp    rsi, 16                     # Check if size if greater then 1
  jle    cooley_tukey_return
  push   rbx
  push   r12
  push   r13
  push   r14
  push   r15
  mov    r12, rdi                    # Save parameters
  mov    r13, rsi
  mov    r14, rsi                    # Save N / 2
  shr    r14, 1
  sub    rsp, r14                    # Make a tmp array
  xor    r15, r15
  mov    rbx, r12
cooley_tukey_spliting:
  cmp    r15, r14
  je     cooley_tukey_split
  lea    rax, [r12 + 2 * r15]        # Moving all odd entries to the front of the array
  movaps xmm0, XMMWORD PTR [rax + 16]
  movaps xmm1, XMMWORD PTR [rax]
  movaps XMMWORD PTR [rsp + r15], xmm0
  movaps XMMWORD PTR [rbx], xmm1
  add    rbx, 16
  add    r15, 16
  jmp    cooley_tukey_spliting
cooley_tukey_split:
  mov    rax, rsp
  lea    rdi, [r12 + r13]
cooley_tukey_mov_data:
  cmp    rbx, rdi
  je     cooley_tukey_moved
  movaps xmm0, XMMWORD PTR [rax]
  movaps XMMWORD PTR [rbx], xmm0
  add    rbx, 16
  add    rax, 16
  jmp    cooley_tukey_mov_data
cooley_tukey_moved:
  add    rsp, r14
  mov    rdi, r12                   # Makking a recursive call
  mov    rsi, r14
  call   cooley_tukey
  lea    rdi, [r12 + r14]           # Makking a recursive call
  mov    rsi, r14
  call   cooley_tukey
  lea    rbx, [r12 + r14]
  mov    r14, rbx
  mov    r15, r12
cooley_tukey_loop:
  cmp    r15, rbx
  je     cooley_tukey_end
  pxor   xmm0, xmm0                 # Calculate cexp(-2.0 * I * M_PI * i / N)
  movsd  xmm1, two_pi
  mov    rax, r14
  sub    rax, rbx
  cvtsi2sdq xmm2, rax
  cvtsi2sdq xmm3, r13
  divsd  xmm2, xmm3
  mulsd  xmm1, xmm2
  call   cexp
  movq   xmm2, QWORD PTR [r14]      # Calculating X[i] - cexp() * X[i + N / 2]
  movq   xmm3, QWORD PTR [r14 + 8]
  call   __muldc3
  movq   xmm2, QWORD PTR [r15]
  movq   xmm3, QWORD PTR [r15 + 8]
  subsd  xmm2, xmm0
  subsd  xmm3, xmm1
  movq   QWORD PTR [r14], xmm2      # Save value in X[i + N / 2]
  movq   QWORD PTR [r14 + 8], xmm3
  movq   xmm0, QWORD PTR [r15]      # Calculating X[i] -= X[i + N / 2] - X[i]
  movq   xmm1, QWORD PTR [r15 + 8]
  subsd  xmm2, xmm0
  subsd  xmm3, xmm1
  subsd  xmm0, xmm2
  subsd  xmm1, xmm3
  movq   QWORD PTR [r15], xmm0
  movq   QWORD PTR [r15 + 8], xmm1
  add    r14, 16
  add    r15, 16
  jmp    cooley_tukey_loop
cooley_tukey_end:
  pop    r15
  pop    r14
  pop    r13
  pop    r12
  pop    rbx
cooley_tukey_return:
  ret
</code></pre>
<pre><code class="language-javascript">function cooley_tukey(x) {
  const N = x.length;
  const half = Math.floor(N / 2);
  if (N &lt;= 1) {
    return x;
  }

  // Extract even and odd indexed elements with remainder mod 2
  const evens = cooley_tukey(x.filter((_, idx) =&gt; !(idx % 2)));
  const odds = cooley_tukey(x.filter((_, idx) =&gt; idx % 2));

  // Fill an array with null values
  let temp = Array(N).fill(null);

  for (let i = 0; i &lt; half; i++) {
    const arg = odds[i].mul(new Complex(0, (-2 * Math.PI * i) / N).exp());

    temp[i] = evens[i].add(arg);
    temp[i + half] = evens[i].sub(arg);
  }

  return temp;
}
</code></pre>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn cooley_tukey(x: &amp;[Complex&lt;f64&gt;]) -&gt; Vec&lt;Complex&lt;f64&gt;&gt; {
    let n = x.len();
    if n &lt;= 1 {
        return x.to_owned();
    }
    let even = cooley_tukey(&amp;x.iter().step_by(2).cloned().collect::&lt;Vec&lt;_&gt;&gt;());
    let odd = cooley_tukey(&amp;x.iter().skip(1).step_by(2).cloned().collect::&lt;Vec&lt;_&gt;&gt;());

    let mut temp = vec![Complex::new(0.0_f64, 0.0_f64); n];
    for k in 0..(n / 2) {
        temp[k] = even[k]
            + (Complex::new(0.0_f64, -2.0_f64) * PI * (k as f64) / (n as f64)).exp() * odd[k];
        temp[k + n / 2] = even[k]
            - (Complex::new(0.0_f64, -2.0_f64) * PI * (k as f64) / (n as f64)).exp() * odd[k];
    }
    temp
}
<span class="boring">}
</span></code></pre></pre>
<pre><code class="language-lisp">(defun merge-sub-ffts (evens odds)
  &quot;Combines the FFTs of the even and odd indices.&quot;
  (let* ((fft-length (+ (length evens) (length odds)))
         ;; Calculate coefficients for the odd indices.
         (twiddle-factors (loop for i from 0 below (length odds)
                             collect (coefficient 1.0 i fft-length)))
         ;; Multiply values with coefficients.
         (odd-terms (mapcar #'* odds twiddle-factors)))
    ;; Combine the two FFTs.
    (concatenate 'list 
                 (mapcar #'+ evens odd-terms)
                 (mapcar #'- evens odd-terms))))

(defun cooley-tukey-rec (data)
  &quot;Performs the Fourier Transform using the recursive Cooley-Tukey method.&quot;
  (if (&lt;= (length data) 1)
      data
      (loop
        for i from 0 below (length data)
        ;; Split even and odd indexed elements into two seperate lists.
        if (evenp i)
          collect (elt data i) into evens
        else
          collect (elt data i) into odds
        finally
          ;; Calculate the Fourier Transform for the two smaller lists and
          ;; combine them into the Fourier Transform of the full input.
          (return (merge-sub-ffts (cooley-tukey-rec evens)
                                  (cooley-tukey-rec odds))))))
</code></pre>
<p>As a side note, we are enforcing that the array must be a power of 2 for the operation to work.
This is a limitation of the fact that we are using recursion and dividing the array in 2 every time; however, if your array is not a power of 2, you can simply pad the leftover space with 0's until your array is a power of 2.</p>
<p>The above method is a perfectly valid FFT; however, it is missing the pictorial heart and soul of the Cooley-Tukey algorithm: Butterfly Diagrams.</p>
<h3 id="butterfly-diagrams"><a class="header" href="#butterfly-diagrams">Butterfly Diagrams</a></h3>
<p>Butterfly Diagrams show where each element in the array goes before, during, and after the FFT.
As mentioned, the FFT must perform a DFT.
This means that even though we need to be careful about how we add elements together, we are still ultimately performing the following operation:</p>
<p>\( X_k = \sum_{n=0}^{N-1} x_n \cdot e^{-2 \pi i k n / N} \)</p>
<p>However, after shuffling the initial array (by bit reversing or recursive subdivision), we perform the matrix multiplication of the \( e^{-2 \pi k n / N} \) terms in pieces.
Basically, we split the array into a series of omega values:</p>
<p>\( \omega_N^k = e^{-2 \pi i k / N} \)</p>
<p>And at each step, we use the appropriate term.
For example, imagine we need to perform an FFT of an array of only 2 elements.
We can represent this addition with the following (radix-2) butterfly:</p>
<p>
    <img  class="center" src="cooley_tukey/res/radix-2screen_positive.jpg" style="width:60%" />
</p>
<p>Here, the diagram means the following:</p>
<p>\[
b_0 = a_0 + \omega_2^0 a_1 \\</p>
<p>b_1 = a_0 + \omega_2^1 a_1
\]</p>
<p>However, it turns out that the second half of our array of \( \omega \) values is always the negative of the first half, so \( \omega_2^0 = -\omega_2^1 \), so we can use the following butterfly diagram:</p>
<p>
    <img  class="center" src="cooley_tukey/res/radix-2screen.jpg" style="width:60%" />
</p>
<p>With the following equations:</p>
<p>\[
b_0 = a_0 + \omega_2^0 a_1 \\</p>
<p>b_1 = a_0 - \omega_2^0 a_1
\]</p>
<p>By swapping out the second \( \omega \) value in this way, we can save a good amount of space.
Now imagine we need to combine more elements.
In this case, we start with simple butterflies, as shown above, and then sum butterflies of butterflies.
For example, if we have 8 elements, this might look like this:</p>
<p>
    <img  class="center" src="cooley_tukey/res/radix-8screen.jpg" style="width:70%" />
</p>
<p>Note that we can perform a DFT directly before using any butterflies, if we so desire, but we need to be careful with how we shuffle our array if that's the case.
In the code snippet provided in the previous section, the subdivision was performed in the same function as the concatenation, so the ordering was always correct; however, if we were to re-order with bit-reversal, this might not be the case.</p>
<p>For example, take a look at the ordering of FFT (<a href="https://en.wikipedia.org/wiki/Butterfly_diagram">found on wikipedia</a>) that performs the DFT shortcut:</p>
<p>
    <img  class="center" src="cooley_tukey/res/butterfly_diagram.png" style="width:70%" />
</p>
<p>Here, the ordering of the array was simply divided into even and odd elements once, but they did not recursively divide the arrays of even and odd elements again because they knew they would perform a DFT soon thereafter.</p>
<p>Ultimately, that's all I want to say about Fourier Transforms for now, but this chapter still needs a good amount of work!
I'll definitely come back to this at some point, so let me know what you liked and didn't like and we can go from there!</p>
<h3 id="bibliography-7"><a class="header" href="#bibliography-7">Bibliography</a></h3>
<p>{% references %} {% endreferences %}</p>
<h2 id="example-code-13"><a class="header" href="#example-code-13">Example Code</a></h2>
<p>To be clear, the example code this time will be complicated and requires the following functions:</p>
<ul>
<li>An FFT library (either in-built or something like FFTW)</li>
<li>An approximation function to tell if two arrays are similar</li>
</ul>
<p>As mentioned in the text, the Cooley-Tukey algorithm may be implemented either recursively or non-recursively, with the recursive method being much easier to implement.
I would ask that you implement either the recursive or non-recursive methods (or both, if you feel so inclined).
If the language you want to write your implementation in is already used, please append your code to the already existing codebase.
As before, pull requests are favored.</p>
<p>Note: I implemented this in Julia because the code seems more straightforward in Julia; however, if you wish to write better Julia code or better code in your own language, please feel free to do so!
<strong>I do not claim that this is the most efficient way to implement the Cooley-Tukey method, so if you have a better way to do it, feel free to implement it that way!</strong></p>
<pre><code class="language-julia">using FFTW

#simple DFT function
function DFT(x)
    N = length(x)

    # We want two vectors here for real space (n) and frequency space (k)
    n = 0:N-1
    k = n'
    transform_matrix = exp.(-2im*pi*n*k/N)
    return transform_matrix*x

end

# Implementing the Cooley-Tukey Algorithm
function cooley_tukey(x)
    N = length(x)

    if (N &gt; 2)
        x_odd = cooley_tukey(x[1:2:N])
        x_even = cooley_tukey(x[2:2:N])
    else
        x_odd = x[1]
        x_even = x[2]
    end
    n = 0:N-1
    half = div(N,2)
    factor = exp.(-2im*pi*n/N)
    return vcat(x_odd .+ x_even .* factor[1:half],
                x_odd .- x_even .* factor[1:half])

end

function bitreverse(a::Array)
    # First, we need to find the necessary number of bits
    digits = convert(Int,ceil(log2(length(a))))

    indices = [i for i = 0:length(a)-1]

    bit_indices = []
    for i = 1:length(indices)
        push!(bit_indices, bitstring(indices[i]))
    end

    # Now stripping the unnecessary numbers
    for i = 1:length(bit_indices)
        bit_indices[i] = bit_indices[i][end-digits:end]
    end

    # Flipping the bits
    for i =1:length(bit_indices)
        bit_indices[i] = reverse(bit_indices[i])
    end

    # Replacing indices
    for i = 1:length(indices)
        indices[i] = 0
        for j = 1:digits
            indices[i] += 2^(j-1) * parse(Int, string(bit_indices[i][end-j]))
        end
       indices[i] += 1
    end

    b = [float(i) for i = 1:length(a)]
    for i = 1:length(indices)
        b[i] = a[indices[i]]
    end

    return b
end

function iterative_cooley_tukey(x)
    N = length(x)
    logN = convert(Int,ceil(log2(length(x))))
    bnum = div(N,2)
    stride = 0;

    x = bitreverse(x)

    z = [Complex(x[i]) for i = 1:length(x)]
    for i = 1:logN
       stride = div(N, bnum)
       for j = 0:bnum-1
           start_index = j*stride + 1
           y = butterfly(z[start_index:start_index + stride - 1])
           for k = 1:length(y)
               z[start_index+k-1] = y[k]
           end
       end
       bnum = div(bnum,2)
    end

    return z
end

function butterfly(x)
    N = length(x)
    half = div(N,2)
    n = [i for i = 0:N-1]
    half = div(N,2)
    factor = exp.(-2im*pi*n/N)

    y = [0 + 0.0im for i = 1:length(x)]

    for i = 1:half
        y[i] = x[i] + x[half+i]*factor[i]
        y[half+i] = x[i] - x[half+i]*factor[i]
    end

    return y
end

function main()
    x = rand(128)
    y = cooley_tukey(x)
    z = iterative_cooley_tukey(x)
    w = fft(x)
    if(isapprox(y, w))
        println(&quot;Recursive Cooley Tukey matches fft() from FFTW package.&quot;)
    end
    if(isapprox(z, w))
        println(&quot;Iterative Cooley Tukey matches fft() from FFTW package.&quot;)
    end
end

main()
</code></pre>
<pre><code class="language-c">#include &lt;complex.h&gt;
#include &lt;math.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;time.h&gt;
#include &lt;fftw3.h&gt;

void fft(double complex *x, int n) {
    double complex y[n];
    memset(y, 0, sizeof(y));
    fftw_plan p;

    p = fftw_plan_dft_1d(n, (fftw_complex*)x, (fftw_complex*)y,
                         FFTW_FORWARD, FFTW_ESTIMATE);

    fftw_execute(p);
    fftw_destroy_plan(p);

    for (size_t i = 0; i &lt; n; ++i) {
        x[i] = y[i] / sqrt((double)n);
    }
}

void dft(double complex *X, const size_t N) {
    double complex tmp[N];
    for (size_t i = 0; i &lt; N; ++i) {
        tmp[i] = 0;
        for (size_t j = 0; j &lt; N; ++j) {
            tmp[i] += X[j] * cexp(-2.0 * M_PI * I * j * i / N);
        }
    }

    memcpy(X, tmp, N * sizeof(*X));
}

void cooley_tukey(double complex *X, const size_t N) {
    if (N &gt;= 2) {
        double complex tmp [N / 2];
        for (size_t i = 0; i &lt; N / 2; ++i) {
            tmp[i] = X[2*i + 1];
            X[i] = X[2*i];
        }
        for (size_t i = 0; i &lt; N / 2; ++i) {
            X[i + N / 2] = tmp[i];
        }

        cooley_tukey(X, N / 2);
        cooley_tukey(X + N / 2, N / 2);

        for (size_t i = 0; i &lt; N / 2; ++i) {
            X[i + N / 2] = X[i] - cexp(-2.0 * I * M_PI * i / N) * X[i + N / 2];
            X[i] -= (X[i + N / 2]-X[i]);
        }
    }
}

void bit_reverse(double complex *X, size_t N) {
    for (int i = 0; i &lt; N; ++i) {
        int n = i;
        int a = i;
        int count = (int)log2((double)N) - 1;

        n &gt;&gt;= 1;
        while (n &gt; 0) {
            a = (a &lt;&lt; 1) | (n &amp; 1);
            count--;
            n &gt;&gt;= 1;
        }
        n = (a &lt;&lt; count) &amp; ((1 &lt;&lt; (int)log2((double)N)) - 1);

        if (n &gt; i) {
            double complex tmp = X[i];
            X[i] = X[n];
            X[n] = tmp;
        }
    }
}

void iterative_cooley_tukey(double complex *X, size_t N) {
    bit_reverse(X, N);

    for (int i = 1; i &lt;= log2((double)N); ++i) {
        int stride = pow(2, i);
        double complex w = cexp(-2.0 * I * M_PI / stride);
        for (size_t j = 0; j &lt; N; j += stride) {
            double complex v = 1.0;
            for (size_t k = 0; k &lt; stride / 2; ++k) {
                X[k + j + stride / 2] = X[k + j] - v * X[k + j + stride / 2];
                X[k + j] -= (X[k + j + stride / 2] - X[k + j]);
                v *= w;
            }
        }
    }
}

void approx(double complex *X, double complex *Y, size_t N) {
    for (size_t i = 0; i &lt; N; ++i) {
        if (cabs(X[i]) - cabs(Y[i]) &gt; 1E-5) {
            printf(&quot;This is not approximate.\n&quot;);
            return;
        }
    }
    printf(&quot;This is approximate.\n&quot;);
}

int main() {
    srand(time(NULL));
    double complex x[64], y[64], z[64];
    for (size_t i = 0; i &lt; 64; ++i) {
        x[i] = rand() / (double) RAND_MAX;
        y[i] = x[i];
        z[i] = x[i];
    }

    fft(x, 64);
    cooley_tukey(y, 64);
    iterative_cooley_tukey(z, 64);

    approx(x, y, 64);
    approx(x, z, 64);

    return 0;
}
</code></pre>
<pre><code class="language-clojure">(ns fft.core
  (:require [complex.core :as c]))
;; complex is a jar for complex numbers
;; https://github.com/alanforr/complex
;; add [complex &quot;0.1.11&quot;] to :dependencies in your project.clj
;; and run lein repl or lein deps in the terminal
(defn matrix-mult
  &quot;take a matrix m and a vector v which length is number of columns
  ,return a vector of applying dot-product between v and each row of
  m. the returned vector's length is the number of rows of m&quot;
  [m v]
  (mapv (comp (partial apply c/+)
              (partial map c/* v))
        m))
(defn dft
  &quot;take a vector of real numbers and return a vector of frequency
  space&quot;
  [vx]
  (let [len (count vx)]
     (matrix-mult
      (partition len
                 (for [n (range len)
                       k (range len)]
                   ;; expresion below is
                   ;; e^(n*k*2*pi*(1/len)*(-i))
                   (c/exp (c/* n k
                               2 Math/PI
                               (/ len)
                               (c/complex 0 -1)))))
      vx)))
(defn fft [vx]
  (let [len (count vx)]
    (if (= len 1)
      vx
      ;;else
      (let [;; take values of vx in the even indices
            even-indices (keep-indexed #(if (even? %1) %2) vx)
            ;; take values in the odd indices
            odd-indices (keep-indexed #(if (odd? %1) %2) vx)
            ;; recursion
            even-fft (fft even-indices)
            odd-fft (fft odd-indices)
            ;; make a sequence of e^(-2pi*i*k/N) where N is the length
            ;; vx and k range from 0 to N/2
            omegas-half (map
                         (comp c/exp
                               (partial c/*
                                        (/ len)
                                        2 Math/PI
                                        (c/complex 0 -1)))
                         (range 0 (quot len 2)))
            ;; take the negative of the first sequence because
            ;; e^(-2pi*i*(k+N/2)/N=-e^(-2pi*i*k/N) where k ranges from
            ;; 0 to N/2 
            omegas-2half (map c/- omegas-half)
            mult-add (partial map #(c/+ %3 (c/* %1 %2)))]
        (concat (mult-add omegas-half odd-fft even-fft)
                (mult-add omegas-2half odd-fft even-fft))))))
(defn -main [&amp; args]
    (let [vx [0 1 2 3]
          len (count vx)
          ;; calculate the next power of 2 after len
          ;; the reason behind this is to fill them with zeros for fft
          next-len (-&gt;&gt;
                    [len 2]
                    (map #(Math/log %))
                    (apply /)
                    Math/ceil
                    (Math/pow 2)
                    int)
          ;; add zeros at the end of vx
          complete-vx (into vx (repeat (- next-len len) 0))
          fft-cvx (fft complete-vx)
          dft-cvx (dft complete-vx)
          diffv (mapv c/- fft-cvx dft-cvx)]
    (println &quot;vx:&quot; vx)
    (println &quot;complete-vx:&quot; complete-vx)
    (println &quot;result from fft:&quot; (map c/stringify fft-cvx))
    (println &quot;result from dft:&quot; (map c/stringify dft-cvx))
    (println &quot;difference: &quot; (map c/stringify diffv))))
</code></pre>
<pre><code class="language-cpp">// written by Gathros, modernized by Nicole Mazzuca.

#include &lt;algorithm&gt;
#include &lt;array&gt;
#include &lt;complex&gt;
#include &lt;cstdint&gt;
#include &lt;vector&gt;

// These headers are for presentation not for the algorithm.
#include &lt;iomanip&gt;
#include &lt;iostream&gt;
#include &lt;random&gt;

using std::begin;
using std::end;
using std::swap;

using std::size_t;

using complex = std::complex&lt;double&gt;;
static const double pi = 3.14159265358979323846264338327950288419716;

template &lt;typename Iter&gt;
void dft(Iter X, Iter last) {
  const auto N = last - X;
  std::vector&lt;complex&gt; tmp(N);
  for (auto i = 0; i &lt; N; ++i) {
    for (auto j = 0; j &lt; N; ++j) {
      tmp[i] += X[j] * exp(complex(0, -2.0 * M_PI * i * j / N));
    }
  }
  std::copy(std::begin(tmp), std::end(tmp), X);
}

// `cooley_tukey` does the cooley-tukey algorithm, recursively
template &lt;typename Iter&gt;
void cooley_tukey(Iter first, Iter last) {
  auto size = last - first;
  if (size &gt;= 2) {
    // split the range, with even indices going in the first half,
    // and odd indices going in the last half.
    auto temp = std::vector&lt;complex&gt;(size / 2);
    for (int i = 0; i &lt; size / 2; ++i) {
      temp[i] = first[i * 2 + 1];
      first[i] = first[i * 2];
    }
    for (int i = 0; i &lt; size / 2; ++i) {
      first[i + size / 2] = temp[i];
    }

    // recurse the splits and butterflies in each half of the range
    auto split = first + size / 2;
    cooley_tukey(first, split);
    cooley_tukey(split, last);

    // now combine each of those halves with the butterflies
    for (int k = 0; k &lt; size / 2; ++k) {
      auto w = std::exp(complex(0, -2.0 * pi * k / size));

      auto&amp; bottom = first[k];
      auto&amp; top = first[k + size / 2];
      top = bottom - w * top;
      bottom -= top - bottom;
    }
  }
}

// note: (last - first) must be less than 2**32 - 1
template &lt;typename Iter&gt;
void sort_by_bit_reverse(Iter first, Iter last) {
  // sorts the range [first, last) in bit-reversed order,
  // by the method suggested by the FFT
  auto size = last - first;

  for (std::uint32_t i = 0; i &lt; size; ++i) {
    auto b = i;
    b = (((b &amp; 0xaaaaaaaa) &gt;&gt; 1) | ((b &amp; 0x55555555) &lt;&lt; 1));
    b = (((b &amp; 0xcccccccc) &gt;&gt; 2) | ((b &amp; 0x33333333) &lt;&lt; 2));
    b = (((b &amp; 0xf0f0f0f0) &gt;&gt; 4) | ((b &amp; 0x0f0f0f0f) &lt;&lt; 4));
    b = (((b &amp; 0xff00ff00) &gt;&gt; 8) | ((b &amp; 0x00ff00ff) &lt;&lt; 8));
    b = ((b &gt;&gt; 16) | (b &lt;&lt; 16)) &gt;&gt; (32 - std::uint32_t(log2(size)));
    if (b &gt; i) {
      swap(first[b], first[i]);
    }
  }
}

// `iterative_cooley_tukey` does the cooley-tukey algorithm iteratively
template &lt;typename Iter&gt;
void iterative_cooley_tukey(Iter first, Iter last) {
  sort_by_bit_reverse(first, last);

  // perform the butterfly on the range
  auto size = last - first;
  for (int stride = 2; stride &lt;= size; stride *= 2) {
    auto w = exp(complex(0, -2.0 * pi / stride));
    for (int j = 0; j &lt; size; j += stride) {
      auto v = complex(1.0);
      for (int k = 0; k &lt; stride / 2; k++) {
        first[k + j + stride / 2] =
            first[k + j] - v * first[k + j + stride / 2];
        first[k + j] -= (first[k + j + stride / 2] - first[k + j]);
        v *= w;
      }
    }
  }
}

int main() {
  // initalize the FFT inputs
  std::random_device random_device;
  std::mt19937 rng(random_device());
  std::uniform_real_distribution&lt;double&gt; distribution(0.0, 1.0);

  std::array&lt;complex, 64&gt; initial;
  std::generate(
      begin(initial), end(initial), [&amp;] { return distribution(rng); });

  auto recursive = initial;
  auto iterative = initial;

  // Preform an FFT on the arrays.
  cooley_tukey(begin(recursive), end(recursive));
  iterative_cooley_tukey(begin(iterative), end(iterative));

  // Check if the arrays are approximately equivalent
  std::cout &lt;&lt; std::right &lt;&lt; std::setw(16) &lt;&lt; &quot;idx&quot; &lt;&lt; std::setw(16) &lt;&lt; &quot;rec&quot;
            &lt;&lt; std::setw(16) &lt;&lt; &quot;it&quot; &lt;&lt; std::setw(16) &lt;&lt; &quot;subtracted&quot; &lt;&lt; '\n';
  for (size_t i = 0; i &lt; initial.size(); ++i) {
    auto rec = recursive[i];
    auto it = iterative[i];
    std::cout &lt;&lt; std::setw(16) &lt;&lt; i &lt;&lt; std::setw(16) &lt;&lt; std::abs(rec)
              &lt;&lt; std::setw(16) &lt;&lt; std::abs(it) &lt;&lt; std::setw(16)
              &lt;&lt; (std::abs(rec) - std::abs(it)) &lt;&lt; '\n';
  }
}
</code></pre>
<pre><code class="language-haskell">import Data.Complex
import Data.List (partition)
import Data.Map ((!))
import qualified Data.Map as M
import Data.Ratio

dft :: [Complex Double] -&gt; [Complex Double]
dft x = matMult dftMat x
  where
    n = length x
    w = exp $ (-2) * pi * (0 :+ 1) / fromIntegral n
    dftMat = [[w ^ (j * k) | j &lt;- [0 .. n - 1]] | k &lt;- [0 .. n - 1]]
    matMult m x = map (sum . zipWith (*) x) m

fft :: [Complex Double] -&gt; [Complex Double]
fft x = fft' x
  where
    n = length x
    w0 = exp ((-2) * pi * (0 :+ 1) / fromIntegral n)
    w = M.fromList [(k % n, w0 ^ k) | k &lt;- [0 .. n - 1]]
    fft' [x] = [x]
    fft' x =
      let (evens, odds) = partition (even . fst) $ zip [0 ..] x
          e = fft' $ map snd evens
          o = fft' $ map snd odds
          x1 = zipWith3 (\e o k -&gt; e + o * w ! (k %n)) e o [0 ..]
          x2 = zipWith3 (\e o k -&gt; e - o * w ! (k %n)) e o [0 ..]
       in x1 ++ x2

main = do
  print $ dft [0, 1, 2, 3]
  print $ fft [0, 1, 2, 3]
</code></pre>
<pre><code class="language-python">from random import random
from cmath import exp, pi
from math import log2


def dft(X):
    N = len(X)
    temp = [0] * N
    for i in range(N):
        for k in range(N):
            temp[i] += X[k] * exp(-2.0j * pi * i * k / N)
    return temp


def cooley_tukey(X):
    N = len(X)
    if N &lt;= 1:
        return X
    even = cooley_tukey(X[0::2])
    odd = cooley_tukey(X[1::2])

    temp = [i for i in range(N)]
    for k in range(N // 2):
        temp[k] = even[k] + exp(-2.0j * pi * k / N) * odd[k]
        temp[k + N // 2] = even[k] - exp(-2.0j * pi * k / N) * odd[k]
    return temp


def bit_reverse(X):
    N = len(X)
    temp = [i for i in range(N)]
    for k in range(N):
        b = sum(1 &lt;&lt; int(log2(N)) - 1 -
                i for i in range(int(log2(N))) if k &gt;&gt; i &amp; 1)
        temp[k] = X[b]
        temp[b] = X[k]
    return temp


def iterative_cooley_tukey(X):
    N = len(X)

    X = bit_reverse(X)

    for i in range(1, int(log2(N)) + 1):
        stride = 2 ** i
        w = exp(-2.0j * pi / stride)
        for j in range(0, N, stride):
            v = 1
            for k in range(stride // 2):
                X[k + j + stride // 2] = X[k + j] - v * X[k + j + stride // 2]
                X[k + j] -= X[k + j + stride // 2] - X[k + j]
                v *= w
    return X


X = []

for i in range(64):
    X.append(random())

Y = cooley_tukey(X)
Z = iterative_cooley_tukey(X)
T = dft(X)

print(all(abs([Y[i] - Z[i] for i in range(64)][j]) &lt; 1 for j in range(64)))
print(all(abs([Y[i] - T[i] for i in range(64)][j]) &lt; 1 for j in range(64)))
</code></pre>
<pre><code class="language-asm-x64">.intel_syntax noprefix

.section .rodata
  two:           .double 2.0
  one:           .double 1.0
  two_pi:        .double -6.28318530718
  rand_max:      .long 4290772992
                 .long 1105199103
  fmt:           .string &quot;%g\n&quot;

.section .text
  .global main
  .extern printf, memset, memcpy, srand, rand, time, cexp, __muldc3, cabs, log2

# rdi - array ptr
# rsi - array size
dft:
  push   rbx
  push   r12
  push   r13
  push   r14
  push   r15
  mov    r12, rdi                    # Save parameters
  mov    r13, rsi
  sub    rsp, r13                    # Make a double complex array
  xor    r14, r14                    # Set index to 0
dft_loop_i:
  cmp    r14, r13                    # Check if index is equal to array size
  je     dft_end_i
  lea    rax, [rsp + r14]            # Set tmp array to zero at r14
  mov    QWORD PTR [rax], 0
  mov    QWORD PTR [rax + 8], 0
  xor    r15, r15                    # Set second index to 0
dft_loop_j:
  cmp    r15, r13                    # Check if the index is equal to array size
  je     dft_end_j
  movsd  xmm1, two_pi                # Calculate xmm1 = -2pi * i * j / N
  mov    rax, r14
  imul   rax, r15
  shr    rax, 4
  cvtsi2sdq xmm2, rax
  mulsd  xmm1, xmm2
  cvtsi2sdq xmm2, r13
  divsd  xmm1, xmm2
  pxor   xmm0, xmm0                  # Set xmm0 to 0
  call   cexp
  lea    rax, [r12 + r15]            # Calculate X[i] * cexp(-2pi * i * j / N)
  movsd  xmm2, QWORD PTR [rax]
  movsd  xmm3, QWORD PTR [rax + 8]
  call   __muldc3
  lea    rax, [rsp + r14]
  movsd  xmm6, QWORD PTR [rax]       # Sum to tmp array
  movsd  xmm7, QWORD PTR [rax + 8]
  addsd  xmm6, xmm0
  addsd  xmm7, xmm1
  movsd  QWORD PTR [rax], xmm6       # Save to tmp array
  movsd  QWORD PTR [rax + 8], xmm7
  add    r15, 16
  jmp    dft_loop_j
dft_end_j:
  add    r14, 16
  jmp    dft_loop_i
dft_end_i:
  mov    rdi, r12                    # Move tmp array to array ptr
  mov    rsi, rsp
  mov    rdx, r13
  call   memcpy
  add    rsp, r13
  pop    r15
  pop    r14
  pop    r13
  pop    r12
  pop    rbx
  ret

# rdi - array ptr
# rsi - array size
cooley_tukey:
  cmp    rsi, 16                     # Check if size if greater then 1
  jle    cooley_tukey_return
  push   rbx
  push   r12
  push   r13
  push   r14
  push   r15
  mov    r12, rdi                    # Save parameters
  mov    r13, rsi
  mov    r14, rsi                    # Save N / 2
  shr    r14, 1
  sub    rsp, r14                    # Make a tmp array
  xor    r15, r15
  mov    rbx, r12
cooley_tukey_spliting:
  cmp    r15, r14
  je     cooley_tukey_split
  lea    rax, [r12 + 2 * r15]        # Moving all odd entries to the front of the array
  movaps xmm0, XMMWORD PTR [rax + 16]
  movaps xmm1, XMMWORD PTR [rax]
  movaps XMMWORD PTR [rsp + r15], xmm0
  movaps XMMWORD PTR [rbx], xmm1
  add    rbx, 16
  add    r15, 16
  jmp    cooley_tukey_spliting
cooley_tukey_split:
  mov    rax, rsp
  lea    rdi, [r12 + r13]
cooley_tukey_mov_data:
  cmp    rbx, rdi
  je     cooley_tukey_moved
  movaps xmm0, XMMWORD PTR [rax]
  movaps XMMWORD PTR [rbx], xmm0
  add    rbx, 16
  add    rax, 16
  jmp    cooley_tukey_mov_data
cooley_tukey_moved:
  add    rsp, r14
  mov    rdi, r12                   # Makking a recursive call
  mov    rsi, r14
  call   cooley_tukey
  lea    rdi, [r12 + r14]           # Makking a recursive call
  mov    rsi, r14
  call   cooley_tukey
  lea    rbx, [r12 + r14]
  mov    r14, rbx
  mov    r15, r12
cooley_tukey_loop:
  cmp    r15, rbx
  je     cooley_tukey_end
  pxor   xmm0, xmm0                 # Calculate cexp(-2.0 * I * M_PI * i / N)
  movsd  xmm1, two_pi
  mov    rax, r14
  sub    rax, rbx
  cvtsi2sdq xmm2, rax
  cvtsi2sdq xmm3, r13
  divsd  xmm2, xmm3
  mulsd  xmm1, xmm2
  call   cexp
  movq   xmm2, QWORD PTR [r14]      # Calculating X[i] - cexp() * X[i + N / 2]
  movq   xmm3, QWORD PTR [r14 + 8]
  call   __muldc3
  movq   xmm2, QWORD PTR [r15]
  movq   xmm3, QWORD PTR [r15 + 8]
  subsd  xmm2, xmm0
  subsd  xmm3, xmm1
  movq   QWORD PTR [r14], xmm2      # Save value in X[i + N / 2]
  movq   QWORD PTR [r14 + 8], xmm3
  movq   xmm0, QWORD PTR [r15]      # Calculating X[i] -= X[i + N / 2] - X[i]
  movq   xmm1, QWORD PTR [r15 + 8]
  subsd  xmm2, xmm0
  subsd  xmm3, xmm1
  subsd  xmm0, xmm2
  subsd  xmm1, xmm3
  movq   QWORD PTR [r15], xmm0
  movq   QWORD PTR [r15 + 8], xmm1
  add    r14, 16
  add    r15, 16
  jmp    cooley_tukey_loop
cooley_tukey_end:
  pop    r15
  pop    r14
  pop    r13
  pop    r12
  pop    rbx
cooley_tukey_return:
  ret

# rdi - array ptr
# rsi - array size
bit_reverse:
  push   rbx
  push   r12
  push   r13
  push   r14
  push   r15
  mov    r12, rdi                  # Save parameters
  mov    r13, rsi
  shr    r13, 4
  xor    r14, r14                  # Loop through all entries
bit_reverse_entries:
  cmp    r14, r13
  je     bit_reverse_return
  cvtsi2sdq xmm0, r13              # Calculating the number of bit in N
  call   log2
  cvttsd2si rcx, xmm0
  mov    rdi, 1                    # Calculating (1 &lt;&lt; log2(N)) - 1
  sal    edi, cl
  sub    edi, 1
  sub    ecx, 1
  mov    rax, r14
  mov    r15, r14
bit_reverse_loop:
  sar    r15                       # Check if r15 is 0
  je     bit_reverse_reversed
  sal    rax, 1                    # Calculating (rax &lt;&lt; 1) | (r15 &amp; 1)
  mov    rsi, r15
  and    rsi, 1
  or     rax, rsi
  sub    ecx, 1                    # Decrement bit count
  jmp    bit_reverse_loop
bit_reverse_reversed:
  sal    eax, cl                   # Calculate (rax &lt;&lt; rcx) &amp; (1 &lt;&lt; bit count)
  and    rax, rdi
  cmp    rax, r14                  # Check if rax is greater then r14
  jle    bit_reverse_no_swap       # If so then swap entries
  shl    rax, 4                    # Times index by 16 to get bytes to entry
  shl    r14, 4
  movaps xmm0, XMMWORD PTR [r12 + rax]
  movaps xmm1, XMMWORD PTR [r12 + r14]
  movaps XMMWORD PTR [r12 + rax], xmm1
  movaps XMMWORD PTR [r12 + r14], xmm0
  shr    r14, 4
bit_reverse_no_swap:
  add    r14, 1
  jmp    bit_reverse_entries
bit_reverse_return:
  pop    r15
  pop    r14
  pop    r13
  pop    r12
  pop    rbx
  ret

# rdi - array ptr
# rsi - array size
iterative_cooley_tukey:
  push   r12
  push   r13
  push   r14
  push   r15
  push   rbx
  sub    rsp, 48
  mov    r12, rdi
  mov    r13, rsi
  call   bit_reverse              # Bit reversing array
  sar    r13, 4                   # Calculate log2(N)
  cvtsi2sdq xmm0, r13
  call   log2
  cvttsd2si rax, xmm0
  mov    QWORD PTR [rsp], rax     # Save it to the stack
  mov    r14, 1
iter_ct_loop_i:
  cmp    r14, rax                 # Check if r14 is greater then log2(N)
  jg     iter_ct_end_i
  movsd  xmm0, two                # Calculate stride = 2^(r14)
  cvtsi2sdq xmm1, r14
  call   pow
  cvttsd2si r10, xmm0
  mov    QWORD PTR [rsp + 40], r10# move stride to stack
  movsd  xmm1, two_pi             # Calculating cexp(-2pi * I / stride)
  divsd  xmm1, xmm0
  pxor   xmm0, xmm0
  call   cexp
  movq   QWORD PTR [rsp + 8], xmm0  # Save it to stack
  movq   QWORD PTR [rsp + 16], xmm1
  xor    r15, r15
iter_ct_loop_j:
  cmp    r15, r13                 # Check if r15 is less then array size
  je     iter_ct_end_j
  movsd  xmm4, one                # Save 1 + 0i to stack
  pxor   xmm5, xmm5
  movsd  QWORD PTR [rsp + 24], xmm4
  movsd  QWORD PTR [rsp + 32], xmm5
  xor    rbx, rbx
  mov    rax, QWORD PTR [rsp + 40]# Calculate stride / 2
  sar    rax, 1
iter_ct_loop_k:
  cmp    rbx, rax                 # Check if rbx is less then stride / 2
  je     iter_ct_end_k
  mov    r8, r15                  # Saving pointers to X[k + j + stride / 2] and X[k + j]
  add    r8, rbx
  sal    r8, 4
  mov    r9, QWORD PTR [rsp + 40]
  sal    r9, 3
  add    r9, r8
  lea    r9, [r12 + r9]
  lea    r8, [r12 + r8]
  movsd  xmm0, QWORD PTR [r9]     # Calculate X[k + j] - v * X[k + j + stride / 2]
  movsd  xmm1, QWORD PTR [r9 + 8]
  movsd  xmm2, QWORD PTR [rsp + 24]
  movsd  xmm3, QWORD PTR [rsp + 32]
  call   __muldc3
  movsd  xmm2, QWORD PTR [r8]
  movsd  xmm3, QWORD PTR [r8 + 8]
  subsd  xmm2, xmm0
  subsd  xmm3, xmm1
  movsd  QWORD PTR [r9], xmm2     # Saving answer
  movsd  QWORD PTR [r9 + 8], xmm3
  movsd  xmm0, QWORD PTR [r8]     # Calculating X[k + j] - (X[k + j + stride / 2] - X[k + j])
  movsd  xmm1, QWORD PTR [r8 + 8]
  subsd  xmm2, xmm0
  subsd  xmm3, xmm1
  subsd  xmm0, xmm2
  subsd  xmm1, xmm3
  movsd  QWORD PTR [r8], xmm0     # Saving answer
  movsd  QWORD PTR [r8 + 8], xmm1
  movsd  xmm0, QWORD PTR [rsp + 24] # Calculating v * w
  movsd  xmm1, QWORD PTR [rsp + 32]
  movsd  xmm2, QWORD PTR [rsp + 8]
  movsd  xmm3, QWORD PTR [rsp + 16]
  call   __muldc3
  movsd  QWORD PTR [rsp + 24], xmm0 # Saving answer
  movsd  QWORD PTR [rsp + 32], xmm1
  add    rbx, 1
  mov    rax, QWORD PTR [rsp + 40]
  sar    rax, 1
  jmp    iter_ct_loop_k
iter_ct_end_k:
  add    r15, QWORD PTR [rsp + 40]
  jmp    iter_ct_loop_j
iter_ct_end_j:
  add    r14, 1
  mov    rax, QWORD PTR [rsp]
  jmp    iter_ct_loop_i
iter_ct_end_i:
  add    rsp, 48
  pop    rbx
  pop    r15
  pop    r14
  pop    r13
  pop    r12
  ret

# rdi - array a ptr
# rsi - array b ptr
# rdx - array size
approx:
  push   r12
  push   r13
  push   r14
  push   r15
  mov    r12, rdi
  mov    r13, rsi
  mov    r14, rdx
  lea    r15, [rdi + rdx]
  sub    rsp, 8
approx_loop:
  cmp    r12, r15
  je     approx_return
  movsd  xmm0, QWORD PTR[r13]
  movsd  xmm1, QWORD PTR[r13 + 8]
  call   cabs
  movsd  QWORD PTR [rsp], xmm0
  movsd  xmm0, QWORD PTR[r12]
  movsd  xmm1, QWORD PTR[r12 + 8]
  call   cabs
  movsd  xmm1, QWORD PTR [rsp]
  subsd  xmm0, xmm1
  mov    rdi, OFFSET fmt
  mov    rax, 1
  call   printf
  add    r12, 16
  add    r13, 16
  jmp    approx_loop
approx_return:
  add    rsp, 8
  pop    r15
  pop    r14
  pop    r13
  pop    r12
  ret

main:
  push   r12
  sub    rsp, 2048
  mov    rdi, 0
  call   time
  mov    edi, eax
  call   srand
  lea    r12, [rsp + 1024]
loop:
  cmp    r12, rsp
  je     end_loop
  sub    r12, 16
  call   rand
  cvtsi2sd xmm0, rax
  divsd  xmm0, rand_max
  lea    rax, [r12 + 1024]
  movsd  QWORD PTR [r12], xmm0
  movsd  QWORD PTR [rax], xmm0
  mov    QWORD PTR [r12 + 8], 0
  mov    QWORD PTR [rax + 8], 0
  jmp    loop
end_loop:
  mov    rdi, rsp
  mov    rsi, 1024
  call   iterative_cooley_tukey
  lea    rdi, [rsp + 1024]
  mov    rsi, 1024
  call   cooley_tukey
  mov    rdi, rsp
  lea    rsi, [rsp + 1024]
  mov    rdx, 1024
  call   approx
  xor    rax, rax
  add    rsp, 2048
  pop    r12
  ret


</code></pre>
<pre><code class="language-javascript">const Complex = require(&quot;complex.js&quot;);

function dft(x) {
  const N = x.length;

  // Initialize an array with N elements, filled with 0s
  return Array(N)
    .fill(new Complex(0, 0))
    .map((temp, i) =&gt; {
      // Reduce x into the sum of x_k * exp(-2*sqrt(-1)*pi*i*k/N)
      return x.reduce((a, b, k) =&gt; {
        return a.add(b.mul(new Complex(0, (-2 * Math.PI * i * k) / N).exp()));
      }, new Complex(0, 0)); // Start accumulating from 0
    });
}

function cooley_tukey(x) {
  const N = x.length;
  const half = Math.floor(N / 2);
  if (N &lt;= 1) {
    return x;
  }

  // Extract even and odd indexed elements with remainder mod 2
  const evens = cooley_tukey(x.filter((_, idx) =&gt; !(idx % 2)));
  const odds = cooley_tukey(x.filter((_, idx) =&gt; idx % 2));

  // Fill an array with null values
  let temp = Array(N).fill(null);

  for (let i = 0; i &lt; half; i++) {
    const arg = odds[i].mul(new Complex(0, (-2 * Math.PI * i) / N).exp());

    temp[i] = evens[i].add(arg);
    temp[i + half] = evens[i].sub(arg);
  }

  return temp;
}

function bit_reverse_idxs(n) {
  if (!n) {
    return [0];
  } else {
    const twice = bit_reverse_idxs(n - 1).map(x =&gt; 2 * x);
    return twice.concat(twice.map(x =&gt; x + 1));
  }
}

function bit_reverse(x) {
  const N = x.length;
  const indexes = bit_reverse_idxs(Math.log2(N));
  return x.map((_, i) =&gt; x[indexes[i]]);
}

// Assumes log_2(N) is an integer
function iterative_cooley_tukey(x) {
  const N = x.length;

  x = bit_reverse(x);

  for (let i = 1; i &lt;= Math.log2(N); i++) {
    const stride = 2 ** i;
    const half = stride / 2;
    const w = new Complex(0, (-2 * Math.PI) / stride).exp();
    for (let j = 0; j &lt; N; j += stride) {
      let v = new Complex(1, 0);
      for (let k = 0; k &lt; half; k++) {
        // perform butterfly multiplication
        x[k + j + half] = x[k + j].sub(v.mul(x[k + j + half]));
        x[k + j] = x[k + j].sub(x[k + j + half].sub(x[k + j]));
        // accumulate v as powers of w
        v = v.mul(w);
      }
    }
  }

  return x;
}

// Check if two arrays of complex numbers are approximately equal
function approx(x, y, tol = 1e-12) {
  let diff = 0;
  for (let i = 0; i &lt; x.length; i++) {
    diff += x[i].sub(y[i]).abs();
  }
  return diff &lt; tol;
}

const X = Array.from(Array(8), () =&gt; new Complex(Math.random(), 0));
const Y = cooley_tukey(X);
const Z = iterative_cooley_tukey(X);
const T = dft(X);

// Check if the calculations are correct within a small tolerance
console.log(&quot;Cooley tukey approximation is accurate: &quot;, approx(Y, T));
console.log(&quot;Iterative cooley tukey approximation is accurate: &quot;, approx(Z, T));
</code></pre>
<pre><pre class="playground"><code class="language-rust">extern crate rand;
extern crate rustfft;

use rand::prelude::*;
use rustfft::num_complex::Complex;
use rustfft::FFTplanner;
use std::f64::consts::PI;

// This is based on the Python and C implementations.

fn fft(x: &amp;[Complex&lt;f64&gt;]) -&gt; Vec&lt;Complex&lt;f64&gt;&gt; {
    let n = x.len();
    let mut new_x = x.to_vec();
    let mut y = vec![Complex::new(0.0_f64, 0.0_f64); n];

    let mut planner = FFTplanner::new(false);
    let this_fft = planner.plan_fft(n);
    this_fft.process(new_x.as_mut_slice(), y.as_mut_slice());

    // y.into_iter().map(|i| i / (n as f64).sqrt()).collect()
    y
}

fn dft(x: &amp;[Complex&lt;f64&gt;]) -&gt; Vec&lt;Complex&lt;f64&gt;&gt; {
    let n = x.len();
    (0..n)
        .map(|i| {
            (0..n)
                .map(|k| {
                    x[k] * (Complex::new(0.0_f64, -2.0_f64) * PI * (i as f64) * (k as f64)
                        / (n as f64))
                        .exp()
                })
                .sum()
        })
        .collect()
}

fn cooley_tukey(x: &amp;[Complex&lt;f64&gt;]) -&gt; Vec&lt;Complex&lt;f64&gt;&gt; {
    let n = x.len();
    if n &lt;= 1 {
        return x.to_owned();
    }
    let even = cooley_tukey(&amp;x.iter().step_by(2).cloned().collect::&lt;Vec&lt;_&gt;&gt;());
    let odd = cooley_tukey(&amp;x.iter().skip(1).step_by(2).cloned().collect::&lt;Vec&lt;_&gt;&gt;());

    let mut temp = vec![Complex::new(0.0_f64, 0.0_f64); n];
    for k in 0..(n / 2) {
        temp[k] = even[k]
            + (Complex::new(0.0_f64, -2.0_f64) * PI * (k as f64) / (n as f64)).exp() * odd[k];
        temp[k + n / 2] = even[k]
            - (Complex::new(0.0_f64, -2.0_f64) * PI * (k as f64) / (n as f64)).exp() * odd[k];
    }
    temp
}

fn bit_reverse(x: &amp;[Complex&lt;f64&gt;]) -&gt; Vec&lt;Complex&lt;f64&gt;&gt; {
    let n = x.len();
    let mut temp = vec![Complex::new(0.0_f64, 0.0_f64); n];
    for k in 0..n {
        let b: usize = (0..((n as f64).log2() as usize))
            .filter(|i| k &gt;&gt; i &amp; 1 != 0)
            .map(|i| 1 &lt;&lt; ((((n as f64).log2()) as usize) - 1 - i))
            .sum();
        temp[k] = x[b];
        temp[b] = x[k];
    }
    temp
}

fn iterative_cooley_tukey(x: &amp;[Complex&lt;f64&gt;]) -&gt; Vec&lt;Complex&lt;f64&gt;&gt; {
    let n = x.len();

    let mut new_x = bit_reverse(x);

    for i in 1..=((n as f64).log2() as usize) {
        let stride = 2_u128.pow(i as u32);
        let w = (Complex::new(0.0_f64, -2.0_f64) * PI / (stride as f64)).exp();
        for j in (0..n).step_by(stride as usize) {
            let mut v = Complex::new(1.0_f64, 0.0_f64);
            for k in 0..((stride / 2) as usize) {
                new_x[k + j + ((stride / 2) as usize)] =
                    new_x[k + j] - v * new_x[k + j + ((stride / 2) as usize)];
                new_x[k + j] =
                    new_x[k + j] - (new_x[k + j + ((stride / 2) as usize)] - new_x[k + j]);
                v *= w;
            }
        }
    }

    new_x
}

fn main() {
    let mut x = Vec::with_capacity(64);
    let mut rng = thread_rng();
    for _i in 0..64 {
        let real = rng.gen_range(0.0_f64, 1.0_f64);
        x.push(Complex::new(real, 0.0_f64));
    }
    let v = fft(&amp;x);
    let y = cooley_tukey(&amp;x);
    let z = iterative_cooley_tukey(&amp;x);
    let t = dft(&amp;x);

    println!(
        &quot;{}&quot;,
        v.iter().zip(y.iter()).all(|i| (i.0 - i.1).norm() &lt; 1.0)
    );
    println!(
        &quot;{}&quot;,
        v.iter().zip(z.iter()).all(|i| (i.0 - i.1).norm() &lt; 1.0)
    );
    println!(
        &quot;{}&quot;,
        v.iter()
            .zip(t.into_iter())
            .all(|i| (i.0 - i.1).norm() &lt; 1.0)
    );
}
</code></pre></pre>
<pre><code class="language-lisp">
(defun coefficient (time-index freq-index dft-len)
  &quot;Calculates a single twiddle factor for the Fourier Transform.&quot;
  (exp (- (/ (* #c(0 1) 2.0 pi time-index freq-index)
             dft-len))))

(defun dft (data)
  &quot;Performs the Discrete Fourier Transform&quot;
  (let ((dft-len (length data)))
    (loop for freq-index from 0 below dft-len collect
      (loop for time-index from 0 below dft-len sum
        (* (coefficient time-index freq-index dft-len) (elt data time-index))))))

(defun merge-sub-ffts (evens odds)
  &quot;Combines the FFTs of the even and odd indices.&quot;
  (let* ((fft-length (+ (length evens) (length odds)))
         ;; Calculate coefficients for the odd indices.
         (twiddle-factors (loop for i from 0 below (length odds)
                             collect (coefficient 1.0 i fft-length)))
         ;; Multiply values with coefficients.
         (odd-terms (mapcar #'* odds twiddle-factors)))
    ;; Combine the two FFTs.
    (concatenate 'list 
                 (mapcar #'+ evens odd-terms)
                 (mapcar #'- evens odd-terms))))

(defun cooley-tukey-rec (data)
  &quot;Performs the Fourier Transform using the recursive Cooley-Tukey method.&quot;
  (if (&lt;= (length data) 1)
      data
      (loop
        for i from 0 below (length data)
        ;; Split even and odd indexed elements into two seperate lists.
        if (evenp i)
          collect (elt data i) into evens
        else
          collect (elt data i) into odds
        finally
          ;; Calculate the Fourier Transform for the two smaller lists and
          ;; combine them into the Fourier Transform of the full input.
          (return (merge-sub-ffts (cooley-tukey-rec evens)
                                  (cooley-tukey-rec odds))))))

(defun reverse-bits (value num-bits)
  &quot;Reverses the bits of a value&quot;
  (if (= num-bits 1)
      value
      ;; Split bits into two parts.
      (let* ((num-low-bits (floor (/ num-bits 2))) 
             (num-high-bits (- num-bits num-low-bits))
             (bit-mask (- (expt 2 num-low-bits) 1))
             (lower-half (logand value bit-mask))
             (upper-half (ash value (- num-low-bits))))
        ;; Reverse the bits of each part, then swap the results.
        (logior (ash (reverse-bits lower-half num-low-bits) num-high-bits)
                (reverse-bits upper-half num-high-bits)))))

(defun bit-shuffle-indices (data)
  &quot;Rearanges the elements in a list according to their bit-reversed indices.&quot;
  (loop 
    with num-bits = (floor (log (length data) 2)) 
    for i from 0 below (length data)
    collect (elt data (reverse-bits i num-bits))))

(defun butterfly (a b coeff)
  &quot;Calculates a single butterfly.&quot;
  (values (+ a (* coeff b)) (- a (* coeff b))))

(defun butterfly-group (data start stride)
  &quot;Calculates a single group of butterflies.&quot;
  (dotimes (i stride)
    ;; Take two elements which are stride apart and perform a butterfly on them.
    (let* ((first-elt-index (+ start i))
           (second-elt-index (+ start i stride))
           (first-elt (elt data first-elt-index))
           (second-elt (elt data second-elt-index))
           (coeff (coefficient 1.0 i (* 2 stride))))
    (multiple-value-bind (sum difference) (butterfly first-elt second-elt coeff)
      ;; Write results back into the list.
      (setf (elt data first-elt-index) sum)
      (setf (elt data second-elt-index) difference)))))

(defun cooley-tukey-iter (data)
  &quot;Performs the Fourier Transform using the iterative Cooley-Tukey method.&quot;
  (loop
    ;; Bit-shuffle indices.
    with shuffled-data = (bit-shuffle-indices data)
    for stride = 1 then (* 2 stride)
    while (&lt; stride (length shuffled-data))
    do
      ;; Compute butterfly groups for the current stride.
      (loop for i from 0 below (length shuffled-data) by (* 2 stride) do
        (butterfly-group shuffled-data i stride))
    finally (return shuffled-data)))

(defun approx-eql (list1 list2)
  (let ((diffs (mapcar #'(lambda (e1 e2) (abs (- e1 e2)))
                       list1
                       list2)))
    (loop for d in diffs always (&lt; d 1e-9))))

(defun test-fft (data)
  (let ((dft-result (dft data))
        (rec-result (cooley-tukey-rec data))
        (iter-result (cooley-tukey-iter data)))
    (format T &quot;~&amp;DFT and recursive Cooley-Tukey approx. equal: ~a&quot; 
              (approx-eql dft-result rec-result))
    (format T &quot;~&amp;DFT and iterative Cooley-Tukey approx. equal: ~a&quot;
              (approx-eql dft-result iter-result))
    (format T &quot;~&amp;Recursive Cooley-Tukey and iterative Cooley-Tukey approx. equal: ~a&quot; 
              (approx-eql rec-result iter-result))))

(test-fft '(0.0 0.25 0.5 0.75 0.0 -0.25 -0.5 -0.75))
</code></pre>
<h2 id="license-27"><a class="header" href="#license-27">License</a></h2>
<h5 id="code-examples-25"><a class="header" href="#code-examples-25">Code Examples</a></h5>
<p>The code examples are licensed under the MIT license (found in <a href="https://github.com/algorithm-archivists/algorithm-archive/blob/master/LICENSE.md">LICENSE.md</a>).</p>
<h5 id="text-27"><a class="header" href="#text-27">Text</a></h5>
<p>The text of this chapter was written by <a href="https://github.com/leios">James Schloss</a> and is licensed under the <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</p>
<p><a href="https://creativecommons.org/licenses/by-sa/4.0/"><p><img  class="center" src="cooley_tukey/../cc/CC-BY-SA_icon.svg" /></p></a></p>
<h5 id="imagesgraphics-14"><a class="header" href="#imagesgraphics-14">Images/Graphics</a></h5>
<ul>
<li>The image &quot;<a href="cooley_tukey/res/FT_example.png">FTexample</a>&quot; was created by <a href="https://github.com/leios">James Schloss</a> and is licensed under the <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</li>
<li>The image &quot;<a href="cooley_tukey/res/radix-2screen_positive.jpg">radix2positive</a>&quot; was created by <a href="https://github.com/leios">James Schloss</a> and is licensed under the <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</li>
<li>The image &quot;<a href="cooley_tukey/res/radix-2screen.jpg">radix2</a>&quot; was created by <a href="https://github.com/leios">James Schloss</a> and is licensed under the <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</li>
<li>The image &quot;<a href="cooley_tukey/res/radix-8screen.jpg">radix8</a>&quot; was created by <a href="https://github.com/leios">James Schloss</a> and is licensed under the <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</li>
<li>The image &quot;<a href="https://en.wikipedia.org/wiki/Butterfly_diagram#/media/File:DIT-FFT-butterfly.png">DIT-FFT-butterfly</a>&quot; was created by Virens and is licensed under the <a href="https://creativecommons.org/licenses/by/3.0/">Creative Commons Attribution 3.0 Unported License</a>.</li>
</ul>
<h5 id="pull-requests-24"><a class="header" href="#pull-requests-24">Pull Requests</a></h5>
<p>After initial licensing (<a href="https://github.com/algorithm-archivists/algorithm-archive/pull/560">#560</a>), the following pull requests have modified the text or graphics of this chapter:</p>
<ul>
<li>none</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="decision-problems"><a class="header" href="#decision-problems">Decision Problems</a></h1>
<p>I'll be honest here: I am not sure what section to put these problems in, so for now, they are in <em>Computational Mathematics</em>, but that may change in the near future.
I'm also not sure whether we can classify these problems as <em>decision problems</em> at all; however, everything in this section is related to making informed decisions when assigning inputs to appropriate outputs.
For example, the Hungarian algorithm reads in a bunch of inputs (candidates for certain jobs or positions) and assigns each input to an output task while minimizing the cost associated with all inputs performing their designated task.</p>
<p>Overall, these problems come up all over the place and are certainly worth studying in their own right!</p>
<h2 id="license-28"><a class="header" href="#license-28">License</a></h2>
<h5 id="code-examples-26"><a class="header" href="#code-examples-26">Code Examples</a></h5>
<p>The code examples are licensed under the MIT license (found in <a href="https://github.com/algorithm-archivists/algorithm-archive/blob/master/LICENSE.md">LICENSE.md</a>).</p>
<h5 id="text-28"><a class="header" href="#text-28">Text</a></h5>
<p>The text of this chapter was written by <a href="https://github.com/leios">James Schloss</a> and is licensed under the <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</p>
<p><a href="https://creativecommons.org/licenses/by-sa/4.0/"><p><img  class="center" src="decision_problems/../cc/CC-BY-SA_icon.svg" /></p></a></p>
<h5 id="pull-requests-25"><a class="header" href="#pull-requests-25">Pull Requests</a></h5>
<p>After initial licensing (<a href="https://github.com/algorithm-archivists/algorithm-archive/pull/560">#560</a>), the following pull requests have modified the text or graphics of this chapter:</p>
<ul>
<li>none</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-stable-marriage-problem"><a class="header" href="#the-stable-marriage-problem">The Stable Marriage Problem</a></h1>
<p>Imagine you have two groups, each of size \( n \).
Each individual within a group has an internal ranking associated with all members of the opposing group.
The <em>Stable Matching Problem</em> attempts to unite both groups into stable pairs.
In this case, a set of pairs is considered stable if there are no pairs that like each other more than their current partners.
This doesn't mean that everyone gets their top choices, but if an individual prefers someone else who also prefers them back, the set of pairs is not stable.</p>
<p>Now, this is often told as a story.
One group is male, the other is female, and everyone gets married, hence the name the <em>Stable Marriage Problem</em>.
This problem is solved by the Gale-Shapley algorithm, which can be simply described as follows:</p>
<ol>
<li>All the men propose to their top choice of women.</li>
<li>The women become tentatively engaged to their top choice of the men who have proposed to them.</li>
<li>All rejected men propose to their next choice, and the women again select whichever man they prefer, possibly rejecting the one they were already engaged to.</li>
</ol>
<p>This process continues until all individuals are paired, which means that this algorithm guarantees stable matching and also has a \( \mathcal{O}(n^2) \) runtime.
To be clear, even though this algorithm seems conceptually simple, it is rather tricky to implement correctly.
I do not at all claim that the code provided here is efficient and we will definitely be coming back to this problem in the future when we have more tools under our belt.
I am incredibly interested to see what you guys do and how you implement the algorithm.</p>
<h2 id="video-explanation-8"><a class="header" href="#video-explanation-8">Video Explanation</a></h2>
<p>Here is a video describing the stable marriage problem:</p>
<div style="text-align:center">
<iframe width="560" height="315" src="https://www.youtube.com/embed/A7xRZQAQU8s" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
</div>
<h2 id="example-code-14"><a class="header" href="#example-code-14">Example Code</a></h2>
<pre><code class="language-ruby">class Person
    def initialize(id, name, prefs)
        @id      = id
        @name    = name
        @prefs   = prefs
        @partner = nil
        @choices = 0
    end

    def lonely?
        @partner.nil?
    end

    def propose(partners)
        unless self.lonely?
            raise '%s is not lonely!' % self.name
        end
        choice = @prefs[@choices]
        partners[choice].onPropose(self)
        @choices += 1
    end

    def to_s
      &quot;#{@name.rjust(20)}: #{self.lonely? &amp;&amp; &quot;Lonely&quot; || @partner.name}&quot;
    end

    def self.generate(size, prefix, r)
        Array.new(size){|i|
            Person.new(
                i,
                &quot;#{prefix} #{i}&quot;,
                (0 ... size).to_a.shuffle(random: r)
            )
        }
    end

    protected
    attr_reader :id, :name
    attr_writer :partner

    # Acts upon a given Proposal
    def onPropose(partner)
        unless self.lonely?
            offer = score(partner)
            current = score(@partner)
            return unless offer &gt; current 
            @partner.partner = nil
        end
        @partner = partner
        partner.partner = self
    end

    private
    # Determines the preference of a given partner
    def score(partner)
        return 0 if partner.nil?
        @prefs.size - @prefs.index(partner.id)
    end
end

# Deterministic Output, feel free to change seed
r = Random.new(42)

# Determines Output Columns
men = Person.generate(4, &quot;Man&quot;, r)
women = Person.generate(4, &quot;Woman&quot;, r)

# Assume no Name is longer than 20 characters
spacer = '-' * (20 * 2 + 2)

# Solve the Problem
1.step do |round|
    singles = men.select(&amp;:lonely?)
    singles.each do |m|
        m.propose(women)
    end

    break if singles.empty?

    puts &quot;Round #{round}&quot;
    puts spacer
    puts men, women
    puts spacer
end
</code></pre>
<pre><code class="language-julia">using Random

const mnames = [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;]
const wnames = [&quot;E&quot;, &quot;F&quot;, &quot;G&quot;, &quot;H&quot;]

const Preferences = Dict{String,Vector{String}}
const Pairs = Dict{String,String}

# Returns a name =&gt; preference list dictionary, in decreasing order of preference
function genpreferences(mannames::Vector{String}, womannames::Vector{String})
    men   = Dict(map(m -&gt; (m, shuffle(womannames)), mannames))
    women = Dict(map(w -&gt; (w, shuffle(mannames)), womannames))
    return men, women
end

# Returns if `person` prefers the `first` candidate over the `second` one.
# This translates to `first` appearing *sooner* in the preference list
prefers(prefs, person, first, second) =
    findfirst(m -&gt; m == first, prefs[person]) &lt;
    findfirst(m -&gt; m == second, prefs[person])

isfree(person, pairs) = !haskey(pairs, person)

function galeshapley(men::Preferences, women::Preferences)
    mentowomen = Dict{String,String}()
    womentomen = Dict{String,String}()
    while true
        bachelors = [m for m in keys(men) if isfree(m, mentowomen)]
        if length(bachelors) == 0
            return mentowomen, womentomen
        end

        for bachelor in bachelors
            for candidate in men[bachelor]
                if isfree(candidate, womentomen)
                    mentowomen[bachelor] = candidate
                    womentomen[candidate] = bachelor
                    break
                elseif prefers(women, candidate, bachelor, womentomen[candidate])
                    delete!(mentowomen, womentomen[candidate])
                    mentowomen[bachelor] = candidate
                    womentomen[candidate] = bachelor
                    break
                end
            end
        end
    end
end

function isstable(men::Preferences, women::Preferences, mentowomen::Pairs, womentoman::Pairs)
    for (husband, wife) in mentowomen
        for candidate in men[husband]
            if candidate != wife &amp;&amp;
               prefers(men, husband, candidate, wife) &amp;&amp;
               prefers(women, candidate, husband, womentoman[candidate])
                return false
            end
        end
    end
    return true
end

function main()
    men, women = genpreferences(mnames, wnames)
    mentowomen, womentomen = galeshapley(men, women)
    println(mentowomen)
    println(isstable(men, women, mentowomen, womentomen) ? &quot;Stable&quot; : &quot;Unstable&quot;)
end

main()
</code></pre>
<pre><code class="language-python"># Submitted by Marius Becker
# Updated by Amaras


from random import shuffle
from copy import copy
from string import ascii_uppercase, ascii_lowercase


def main():
    # Set this to however many men and women you want, up to 26
    num_pairs = 5

    # Create all Person objects
    men = [Person(name) for name in ascii_uppercase[:num_pairs]]
    women = [Person(name) for name in ascii_lowercase[:num_pairs]]

    # Set everyone's preferences
    for man in men:
        man.preference = copy(women)
        shuffle(man.preference)

    for woman in women:
        woman.preference = copy(men)
        shuffle(woman.preference)

    # Run the algorithm
    stable_marriage(men, women)

    # Print preferences and the result
    print('Preferences of the men:')
    for man in men:
        print(man)

    print()

    print('Preferences of the women:')
    for woman in women:
        print(woman)

    print('\n')

    print('The algorithm gave this solution:')
    for man in men:
        print(f'{man.name} + {man.partner.name}')


def stable_marriage(men, women):
    &quot;&quot;&quot;Finds pairs with stable marriages&quot;&quot;&quot;

    while True:
        # Let every man without a partner propose to a woman
        for man in men:
            if not man.has_partner:
                man.propose_to_next()

        # Let the women pick their favorites
        for woman in women:
            woman.pick_preferred()

        # Continue only when someone is still left without a partner
        if all((man.has_partner for man in men)):
            return


class Person:

    def __init__(self, name):
        self.name = name
        self.preference = []
        self.candidates = []
        self.pref_index = 0
        self._partner = None

    @property
    def next_choice(self):
        &quot;&quot;&quot;Return the next person in the own preference list&quot;&quot;&quot;
        try:
            return self.preference[self.pref_index]
        except IndexError:
            return None

    def propose_to_next(self):
        &quot;&quot;&quot;Propose to the next person in the own preference list&quot;&quot;&quot;
        person = self.next_choice
        person.candidates.append(self)
        self.pref_index += 1

    def pick_preferred(self):
        &quot;&quot;&quot;Pick a new partner or stay with the old one if they are preferred&quot;&quot;&quot;
        # Iterate own preferences in order
        for person in self.preference:
            # Pick the first person that's either a new candidate or the
            # current partner
            if person == self.partner:
                break
            elif person in self.candidates:
                self.partner = person
                break

        # Rejected candidates don't get a second chance
        self.candidates.clear()

    @property
    def partner(self):
        return self._partner

    # The call self.partner = person sets self._partner as person
    # However, since engagement is symmetrical, self._partner._partner
    # (which is then person._partner) also needs to be set to self
    @partner.setter
    def partner(self, person):
        &quot;&quot;&quot;Set a person as the new partner and sets the partner of that
        person as well&quot;&quot;&quot;

        # Do nothing if nothing would change
        if person != self._partner:
            # Remove self from current partner
            if self._partner is not None:
                self._partner._partner = None

            # Set own and the other person's partner
            self._partner = person
            if self._partner is not None:
                self._partner._partner = self

    # This allows use of self.has_partner instead of self.has_partner()
    @property
    def has_partner(self):
        &quot;&quot;&quot;Determine whether this person currently has a partner or not.&quot;&quot;&quot;
        return self.partner is not None

    # This allows the preferences to be printed more elegantly
    def __str__(self):
        return f'{self.name}: {&quot;, &quot;.join(p.name for p in self.preference)}'


if __name__ == '__main__':
    main()
</code></pre>
<pre><code class="language-haskell">import           Data.Map as M (Map, (!))
import qualified Data.Map as M
import           Data.List (elemIndex)
import           Control.Monad.State

stableMatching :: (Ord a, Ord b) =&gt; [(a, [b])] -&gt; [(b, [a])] -&gt; [(a, b)]
stableMatching men women = evalState (propose (M.fromList women) men) M.empty

propose :: (Ord a, Ord b) =&gt; Map b [a] -&gt;
                            [(a, [b])] -&gt;
                            State (Map b (a, [b])) [(a, b)]
propose _ [] = get &gt;&gt;=  return . map (\(w, (m,_)) -&gt; (m, w)) . M.assocs
propose women ((man, pref):bachelors) = do
  let theOne = head pref
  couples &lt;- get
  case M.lookup theOne couples of
    Nothing -&gt; do
      modify $ M.insert theOne (man, (tail pref))
      propose women bachelors
    Just (boyfriend, planB) -&gt; do
      let rank x = elemIndex x (women!theOne)
      if rank boyfriend &lt; rank man
        then propose women $ (man, tail pref): bachelors
        else do
          modify $ M.insert theOne (man, (tail pref)) . M.delete theOne
          propose women $ (boyfriend, planB): bachelors

main = do
  let aPref = [('A',&quot;YXZ&quot;), ('B',&quot;ZYX&quot;),('C', &quot;XZY&quot;)]
      bPref = [('X',&quot;BAC&quot;), ('Y',&quot;CBA&quot;),('Z', &quot;ACB&quot;)]
  print $ stableMatching aPref bPref
</code></pre>
<pre><code class="language-c">#include &lt;stdbool.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;time.h&gt;

struct person {
    int id;
    struct person *partner;
    size_t *prefers;
    size_t index;
};

void shuffle(size_t *array, size_t size) {
    for (size_t i = size - 1; i &gt; 0; --i) {
        size_t j = rand() % (i + 1);
        size_t tmp = array[i];
        array[i] = array[j];
        array[j] = tmp;
    }
}

void create_group(struct person *group, size_t size, bool are_men) {
    for (size_t i = 0; i &lt; size; ++i) {
        group[i].id = i;
        group[i].partner = NULL;
        group[i].prefers = (size_t*)malloc(sizeof(size_t) * size);
        group[i].index = 0;

        for (size_t j = 0; j &lt; size; ++j) {
            group[i].prefers[j] = j;
        }

        shuffle(group[i].prefers, size);
    }
}

bool prefers_partner(size_t *prefers, size_t partner, size_t id, size_t size) {
    for (size_t i = 0; i &lt; size; ++i) {
        if (prefers[i] == partner) {
            return true;
        } else if(prefers[i] == id) {
            return false;
        }
    }
}

void stable_marriage(struct person *men, struct person *women, size_t size) {
    struct person *bachelors[size];
    size_t bachelors_size = size;

    for (size_t i = 0; i &lt; size; ++i) {
        bachelors[i] = &amp;men[i];
    }

    while (bachelors_size &gt; 0) {
        struct person *man = bachelors[bachelors_size - 1];
        struct person *woman = &amp;women[man-&gt;prefers[man-&gt;index]];

        if (!woman-&gt;partner) {
            woman-&gt;partner = man;
            man-&gt;partner = woman;
            bachelors[--bachelors_size] = NULL;
        } else if (!prefers_partner(woman-&gt;prefers, woman-&gt;partner-&gt;id, man-&gt;id,
                                   size)) {

            woman-&gt;partner-&gt;index++;
            bachelors[bachelors_size - 1] = woman-&gt;partner;
            woman-&gt;partner = man;
            man-&gt;partner = woman;
        } else {
            man-&gt;index++;
        }
    }
}

void free_group(struct person *group, size_t size) {
    for (size_t i = 0; i &lt; size; ++i) {
        free(group[i].prefers);
    }
}

int main() {
    srand(time(NULL));

    struct person men[5], women[5];

    create_group(men, 5, true);
    create_group(women, 5, false);

    for (size_t i = 0; i &lt; 5; ++i) {
        printf(&quot;preferences of man %zu: &quot;, i);
        for (size_t j = 0; j &lt; 5; ++j) {
            printf(&quot;%zu &quot;, men[i].prefers[j]);
        }

        printf(&quot;\n&quot;);
    }

    printf(&quot;\n&quot;);

    for (size_t i = 0; i &lt; 5; ++i) {
        printf(&quot;preferences of woman %zu: &quot;, i);
        for (size_t j = 0; j &lt; 5; ++j) {
            printf(&quot;%zu &quot;, women[i].prefers[j]);
        }

        printf(&quot;\n&quot;);
    }

    stable_marriage(men, women, 5);

    printf(&quot;\n&quot;);

    for (size_t i = 0; i &lt; 5; ++i) {
        printf(&quot;the partner of man %zu is woman %d\n&quot;, i, men[i].partner-&gt;id);
    }

    free_group(men, 5);
    free_group(women, 5);
}
</code></pre>
<pre><code class="language-cpp">#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;iterator&gt;
#include &lt;numeric&gt;
#include &lt;random&gt;
#include &lt;vector&gt;

// this header is so that we can use `not` and `and` on MSVC
#include &lt;ciso646&gt;

#include &lt;cstddef&gt;

using std::size_t;

/*
  we use these to generate random numbers in this program.
  this makes the program simpler,
  by not having to pass around random number generators.
*/
static thread_local std::random_device global_random_device;
static thread_local std::mt19937 global_rng(global_random_device());

struct person {
  /*
    this is a poor person's std::optional,
    but since we're attempting to be compileable on C++14,
    we won't worry too much about it.
  */
  bool finished;
  size_t preference;

  std::vector&lt;size_t&gt; preference_list;
};

/*
  this function generates a list of people with size `number_of_partners`.

  each person's `preference_list` will be a randomly sorted list of
  the numbers in the range [0, number_of_partners),
  with no duplicates.
*/
std::vector&lt;person&gt; make_person_list(size_t number_of_partners) {
  auto random_pref_list = [&amp;] {
    std::vector&lt;size_t&gt; ret(number_of_partners);
    std::iota(begin(ret), end(ret), size_t(0));
    std::shuffle(begin(ret), end(ret), global_rng);

    return ret;
  };

  std::vector&lt;person&gt; ret;
  std::generate_n(std::back_inserter(ret), number_of_partners, [&amp;] {
    return person{false, 0, random_pref_list()};
  });

  return ret;
}

template &lt;typename LeadIter, typename FollowIter&gt;
void stable_match(LeadIter leads, LeadIter leads_end, FollowIter follows) {
  // for each index in the leads' preference list, we'll go through this
  size_t const number_of_partners = leads_end - leads;
  for (size_t proposal_index = 0; proposal_index &lt; number_of_partners;
       ++proposal_index) {
    /*
      each follow will get their own vector of proposals to them
      for each entry in the leads' proposal list

      if this weren't example code, this would likely go outside the loop
      to cut down on allocations
    */
    std::vector&lt;std::vector&lt;size_t&gt;&gt; proposals(number_of_partners);

    // for each lead, we'll make a proposal to their favorite follow
    for (size_t i = 0; i &lt; number_of_partners; ++i) {
      if (not leads[i].finished) {
        auto pref = leads[i].preference_list[proposal_index];
        proposals[pref].push_back(i);
      }
    }

    // for each follow, we'll look at their preference list
    for (size_t i = 0; i &lt; number_of_partners; ++i) {
      for (size_t pref : follows[i].preference_list) {
        for (size_t proposal : proposals[i]) {
          // and, if they were given a proposal, then they'll choose their
          // favorite here
          if (pref == proposal and not follows[i].finished) {
            follows[i].preference = pref;
            follows[i].finished = true;

            leads[pref].preference = i;
            leads[pref].finished = true;
          }
        }
      }
    }
  }
}

int main() {
  // these are the number of partners in each group
  size_t const number_of_partners = 5;

  // in this case, the leads shall propose to the follows
  auto leads = make_person_list(number_of_partners);
  auto follows = make_person_list(number_of_partners);

  stable_match(begin(leads), end(leads), begin(follows));

  // the happy marriages are announced to the console here :)
  for (size_t i = 0; i &lt; number_of_partners; ++i) {
    std::cout &lt;&lt; &quot;the partnership of lead &quot; &lt;&lt; i &lt;&lt; &quot; and follow &quot;
              &lt;&lt; leads[i].preference &lt;&lt; &quot; shall commence forthwith!\n&quot;;
  }
}
</code></pre>
<pre><code class="language-javascript">class Person {
  constructor(name) {
    this.name = name;
  }

  get hasFiance() {
    return !!this.fiance;
  }

  prefers(other) {
    return this.preferences.indexOf(other) &lt; this.preferences.indexOf(this.fiance);
  }

  engageTo(other) {
    if (other.hasFiance) {
      other.fiance.fiance = undefined;
    }

    this.fiance = other;
    other.fiance = this;
  }
}

function stableMarriage(guys, girls) {
  const bachelors = [...guys];
  while (bachelors.length &gt; 0) {
    const guy = bachelors.shift();
    for (const girl of guy.preferences) {
      if (!girl.hasFiance) {
        guy.engageTo(girl);
        break;
      } else if (girl.prefers(guy)) {
        bachelors.push(girl.fiance);
        guy.engageTo(girl);
        break;
      }
    }
  }
}

function shuffle(iterable) {
  const array = [...iterable];
  for (let i = array.length - 1; i &gt; 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [array[i], array[j]] = [array[j], array[i]];
  }
  return array;
}

const guys = [...&quot;ABCDE&quot;].map(name =&gt; new Person(name));
const girls = [...&quot;FGHIJ&quot;].map(name =&gt; new Person(name));

console.log(&quot;Guys&quot;);
for (const guy of guys) {
  guy.preferences = shuffle(girls);
  console.log(`${guy.name}: ${guy.preferences.map(p =&gt; p.name).join()}`)
}

console.log(&quot;\nGirls&quot;);
for (const girl of girls) {
  girl.preferences = shuffle(guys);
  console.log(`${girl.name}: ${girl.preferences.map(p =&gt; p.name).join()}`)
}

stableMarriage(guys, girls);

console.log(&quot;\nPairings&quot;);
for (const guy of guys) {
  console.log(`${guy.name}: ${guy.fiance.name}`);
}

</code></pre>
<p>{% sample lang=&quot;cs&quot; %}</p>
<h5 id="galeshapleyalgorithmcs"><a class="header" href="#galeshapleyalgorithmcs">GaleShapleyAlgorithm.cs</a></h5>
<p><a href="stable_marriage_problem/code/csharp/GaleShapleyAlgorithm.cs">import, lang:&quot;csharp&quot;</a></p>
<h5 id="personcs"><a class="header" href="#personcs">Person.cs</a></h5>
<p><a href="stable_marriage_problem/code/csharp/Person.cs">import, lang:&quot;csharp&quot;</a></p>
<h5 id="programcs-3"><a class="header" href="#programcs-3">Program.cs</a></h5>
<p><a href="stable_marriage_problem/code/csharp/Program.cs">import, lang:&quot;csharp&quot;</a></p>
<h5 id="listextensionscs"><a class="header" href="#listextensionscs">ListExtensions.cs</a></h5>
<p><a href="stable_marriage_problem/code/csharp/ListExtensions.cs">import, lang:&quot;csharp&quot;</a></p>
<pre><code class="language-java">import java.util.List;
import java.util.ArrayList;
import java.util.Collections;

class StableMarriage {

    /*
     * Use the stable marriage algorithm to find stable pairs from the
     * lists of men and women.
     */
    public static void findStableMarriages(List&lt;Woman&gt; women, List&lt;Man&gt; men) {
        // We might have more men/women than women/men. In this case, not everybody can
        // get a mate. We should aim to give every member of the less numerous gender a mate,
        // as this is always possible.
        List&lt;? extends Person&gt; leastCommonGender = women.size() &lt;= men.size() ? women : men;
        do {
            // Every single man proposes to a woman.
            for (Man man : men)
                if (man.isLonely())
                    man.propose();

            // The women pick their favorite suitor.
            for (Woman woman : women)
                woman.chooseMate();

            // End the process if everybody has a mate.
            if (!leastCommonGender.stream().anyMatch(Person::isLonely))
                break;

        } while (true);

        women.forEach(w -&gt; System.out.println(w + &quot; married to &quot; + w.getMate()));
    }

    public static void main(String[] args) {
        int nPairs = 5;
        List&lt;Woman&gt; women = new ArrayList&lt;&gt;();
        List&lt;Man&gt; men = new ArrayList&lt;&gt;();
        for (char i = 'A'; i &lt; 'A' + nPairs; ++i) {
            women.add(new Woman(&quot;&quot; + i));
            men.add(new Man(&quot;&quot; + i));
        }
        // Make the genders unbalanced:
        women.add(new Woman(&quot;X&quot;));

        women.forEach(w -&gt; {
            w.receiveOptions(men);
            System.out.println(w + &quot; prefers &quot; + w.getPreferredMates());
        });
        men.forEach(m -&gt; {
            m.receiveOptions(women);
            System.out.println(m + &quot; prefers &quot; + m.getPreferredMates());
        });

        findStableMarriages(women, men);
    }

}

class Person {
    private final String name;
    protected Person mate;
    protected List&lt;Person&gt; preferredMates;

    public Person(String name) {
        this.name = name;
    }

    public boolean isLonely() {
        return mate == null;
    }

    public void setMate(Person mate) {
        // Only set mates if there is a change.
        if (this.mate != mate) {
            // Remove old mates mate.
            if (this.mate != null)
                this.mate.mate = null;

            // Set the new mate.
            this.mate = mate;

            // If new mate is someone, update their mate.
            if (mate != null)
                mate.mate = this;
        }
    }

    public Person getMate() {
        return mate;
    }

    public void receiveOptions(List&lt;? extends Person&gt; mates) {
        // Preferences are subjective.
        preferredMates = new ArrayList&lt;&gt;(mates);
        Collections.shuffle(preferredMates);
    }

    public List&lt;Person&gt; getPreferredMates() {
        return preferredMates;
    }

    public String toString() {
        return getClass().getName() + &quot;(&quot; + name + &quot;)&quot;;
    }
}

class Woman extends Person {
    private List&lt;Man&gt; suitors = new ArrayList&lt;&gt;();

    public Woman(String name) {
        super(name);
    }

    public void recieveProposal(Man suitor) {
        suitors.add(suitor);
    }

    public void chooseMate() {
        for (Person mostDesired : preferredMates) {
            if (mostDesired == mate || suitors.contains(mostDesired)) {
                setMate(mostDesired);
                break;
            }
        }
    }
}

class Man extends Person {
    public Man(String name) {
        super(name);
    }

    public void propose() {
        if (!preferredMates.isEmpty()) {
            Woman fiance = (Woman) preferredMates.remove(0);
            fiance.recieveProposal(this);
        }
    }
}
</code></pre>
<pre><code class="language-php">&lt;?php
declare(strict_types=1);

class Person
{
    private $name;
    private $suitors = [];
    private $preferences = [];
    private $match;

    public function __construct($name)
    {
        $this-&gt;name = $name;
    }

    public function getName(): string
    {
        return $this-&gt;name;
    }

    public function setPreferences(array $preferences): void
    {
        $this-&gt;preferences = $preferences;
    }

    public function getMatch(): ?Person
    {
        return $this-&gt;match;
    }

    public function getPreferences(): array
    {
        return $this-&gt;preferences;
    }

    public function isSingle(): bool
    {
        return $this-&gt;match === null;
    }

    public function unmatch(): void
    {
        $this-&gt;match = null;
    }

    public function setMatch(Person $match): void
    {
        if ($this-&gt;match !== $match) {
            if ($this-&gt;match !== null) {
                $this-&gt;match-&gt;unmatch();
            }
            $this-&gt;match = $match;
            $match-&gt;setMatch($this);
        }
    }

    public function propose(): void
    {
        if (!empty($this-&gt;preferences)) {
            $fiance = array_shift($this-&gt;preferences);
            $fiance-&gt;receiveProposal($this);
        }
    }

    public function receiveProposal(Person $man): void
    {
        $this-&gt;suitors[] = $man;
    }

    public function chooseMatch(): void
    {
        foreach ($this-&gt;preferences as $preference) {
            if ($preference === $this-&gt;match || in_array($preference, $this-&gt;suitors)) {
                $this-&gt;setMatch($preference);
                break;
            }
        }

        $this-&gt;suitors = [];
    }

    public function __toString(): string
    {
        return $this-&gt;name;
    }
}

function stable_marriage(array $men, array $women): void
{
    do {
        foreach ($men as $man) {
            if ($man-&gt;isSingle()) {
                $man-&gt;propose();
            }
        }

        foreach ($women as $woman) {
            $woman-&gt;chooseMatch();
        }

        $unmarried = false;
        foreach ($women as $woman) {
            if ($woman-&gt;isSingle()) {
                $unmarried = true;
                break;
            }
        }

    } while ($unmarried);
}

$groupSize = 10;
$men = [];
$women = [];

for ($i = 1; $i &lt;= $groupSize; $i++) {
    $men[] = new Person(&quot;M${i}&quot;);
    $women[] = new Person(&quot;W${i}&quot;);
}

foreach ($men as $man) {
    $preferences = $women;
    shuffle($preferences);
    $man-&gt;setPreferences($preferences);
    printf('%s\'s choices: %s', $man-&gt;getName(), implode(',', $man-&gt;getPreferences()));
    echo PHP_EOL;
}
echo PHP_EOL;
foreach ($women as $woman) {
    $preferences = $men;
    shuffle($preferences);
    $woman-&gt;setPreferences($preferences);
    printf('%s\'s choices: %s', $woman-&gt;getName(), implode(',', $woman-&gt;getPreferences()));
    echo PHP_EOL;
}
echo PHP_EOL;

stable_marriage($men, $women);
foreach ($women as $woman) {
    printf('%s is married to %s', $woman, $woman-&gt;getMatch());
    echo PHP_EOL;
}
</code></pre>
<pre><code class="language-scala">import scala.collection.mutable._

object StableMarriage {

  var bachelors = Queue[Man]()

  case class Man(name: String, var preferences: List[Woman] = List()) {
    def propose(): Unit = preferences match {
      case woman :: remainingPreferences =&gt; {
        if (woman.prefers(this)) {
          bachelors ++= woman.fiance
          woman.fiance = Some(this)
        }
        else
          bachelors.enqueue(this)
        preferences = remainingPreferences
      }
      case _ =&gt;
    }
  }

  case class Woman(name: String, var preferences: List[Man] = List(), var fiance: Option[Man] = None) {
    def prefers(man: Man): Boolean =
      fiance match {
        case Some(otherMan) =&gt; preferences.indexOf(man) &lt; preferences.indexOf(otherMan)
        case _ =&gt; true //always prefer any man over nobody
      }
  }

  def findStableMatches(men: Man*): Unit = {
    bachelors = men.to[Queue]
    while (bachelors.nonEmpty)
      bachelors.dequeue.propose()
  }
}

object StableMarriageExample {

  val a = StableMarriage.Man(&quot;Adam&quot;)
  val b = StableMarriage.Man(&quot;Bart&quot;)
  val c = StableMarriage.Man(&quot;Colm&quot;)
  val x = StableMarriage.Woman(&quot;Xena&quot;)
  val y = StableMarriage.Woman(&quot;Yeva&quot;)
  val z = StableMarriage.Woman(&quot;Zara&quot;)

  a.preferences = List(y, x, z)
  b.preferences = List(y, z, x)
  c.preferences = List(x, z, y)
  x.preferences = List(b, a, c)
  y.preferences = List(c, a, b)
  z.preferences = List(a, c, b)


  def main(args: Array[String]): Unit = {

    StableMarriage.findStableMatches(a, b, c)

    List(x, y, z).foreach(
      w =&gt; Console.println(
        w.name
          + &quot; is married to &quot;
          + w.fiance.getOrElse(StableMarriage.Man(&quot;Nobody&quot;)).name))
  }

}
</code></pre>
<h2 id="license-29"><a class="header" href="#license-29">License</a></h2>
<h5 id="code-examples-27"><a class="header" href="#code-examples-27">Code Examples</a></h5>
<p>The code examples are licensed under the MIT license (found in <a href="https://github.com/algorithm-archivists/algorithm-archive/blob/master/LICENSE.md">LICENSE.md</a>).</p>
<h5 id="text-29"><a class="header" href="#text-29">Text</a></h5>
<p>The text of this chapter was written by <a href="https://github.com/leios">James Schloss</a> and is licensed under the <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</p>
<p><a href="https://creativecommons.org/licenses/by-sa/4.0/"><p><img  class="center" src="stable_marriage_problem/../cc/CC-BY-SA_icon.svg" /></p></a></p>
<h5 id="pull-requests-26"><a class="header" href="#pull-requests-26">Pull Requests</a></h5>
<p>After initial licensing (<a href="https://github.com/algorithm-archivists/algorithm-archive/pull/560">#560</a>), the following pull requests have modified the text or graphics of this chapter:</p>
<ul>
<li>none</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="physics-solvers"><a class="header" href="#physics-solvers">Physics Solvers</a></h1>
<p>There are certain algorithms that have been uniquely created to solve particular physical systems.
For example, the kinematic equation can be solved with Verlet integration and also with more general differential equation solvers.
In this section, we will place all algorithms and methods that are <em>specific</em> to physics and cannot be used in any other area.
It's worth noting that many algorithms used throughout the Archive can also be used to solve physics equations and physics lends itself more readily to computational methods than many other areas of scientific research, such as biology or chemistry.</p>
<p>In the future, we may also place several unique physical systems along with different methods to solve these systems.
For example, there are many different ways to solve the Schrdinger equation, heat equation, kinematic equation and several other systems that are unique to physics and there are benefits and drawbacks for solving certain physical systems in certain ways.</p>
<h2 id="license-30"><a class="header" href="#license-30">License</a></h2>
<h5 id="code-examples-28"><a class="header" href="#code-examples-28">Code Examples</a></h5>
<p>The code examples are licensed under the MIT license (found in <a href="https://github.com/algorithm-archivists/algorithm-archive/blob/master/LICENSE.md">LICENSE.md</a>).</p>
<h5 id="text-30"><a class="header" href="#text-30">Text</a></h5>
<p>The text of this chapter was written by <a href="https://github.com/leios">James Schloss</a> and is licensed under the <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</p>
<p><a href="https://creativecommons.org/licenses/by-sa/4.0/"><p><img  class="center" src="physics_solvers/../cc/CC-BY-SA_icon.svg" /></p></a></p>
<h5 id="pull-requests-27"><a class="header" href="#pull-requests-27">Pull Requests</a></h5>
<p>After initial licensing (<a href="https://github.com/algorithm-archivists/algorithm-archive/pull/560">#560</a>), the following pull requests have modified the text or graphics of this chapter:</p>
<ul>
<li>none</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="verlet-integration"><a class="header" href="#verlet-integration">Verlet Integration</a></h1>
<p>Verlet integration is essentially a solution to the kinematic equation for the motion of any object,</p>
<p>\[ x = x_0 + v_0t + \frac{1}{2}at^2 + \frac{1}{6}bt^3 + \cdots \]</p>
<p>where \( x \) is the position, \( v \) is the velocity, \( a \) is the acceleration, \( b \) is the often forgotten jerk term, and \( t \) is time. This equation is a central equation to almost every Newtonian physics solver and brings up a class of algorithms known as <em>force integrators</em>. One of the first force integrators to work with is <em>Verlet Integration</em>.</p>
<p>So, let's say we want to solve for the next timestep in \( x \). To a close approximation (actually performing a Taylor Series Expansion about \( x(t\pm \Delta t) \)), that might look like this:</p>
<p>\[ x(t+\Delta t) = x(t) + v(t)\Delta t + \frac{1}{2}a(t)\Delta t^2 + \frac{1}{6}b(t) \Delta t^3 + \mathcal{O}(\Delta t^4) \]</p>
<p>This means that if we need to find the next \( x \), we need the current \( x \), \( v \), \( a \), etc. However, because few people calculate the jerk term, our error is typically \( \mathcal{O}(\Delta t^3) \). That said, we can calculate \( x \) with less knowledge and higher accuracy if we play a trick! Let's say we want to calculate \( x \) of the <em>previous</em> timestep. Again, to a close approximation, that might look like this:</p>
<p>\[ x(t-\Delta t) = x(t) - v(t)\Delta t + \frac{1}{2}a(t)\Delta t^2 - \frac{1}{6}b(t) \Delta t^3 + \mathcal{O}(\Delta t^4) \]</p>
<p>Now, we have two equations to solve for two different timesteps in x, one of which we already have. If we add the two equations together and solve for \( x(t+\Delta t) \), we find that</p>
<p>\[ x(t+ \Delta t) = 2x(t) - x(t-\Delta t) + a(t)\Delta t^2 + \mathcal{O}(\Delta t^4) \]</p>
<p>So, this means we can find our next \( x \) simply by knowing our current \( x \), the \( x \) before that, and the acceleration! No velocity necessary! In addition, this drops the error to \( \mathcal{O}(\Delta t^4) \), which is great!
Here is what it looks like in code:</p>
<pre><code class="language-julia">function verlet(pos::Float64, acc::Float64, dt::Float64)
    prev_pos = pos
    time = 0.0

    while (pos &gt; 0)
        time += dt
        temp_pos = pos
        pos = pos * 2 - prev_pos + acc * dt * dt
        prev_pos = temp_pos
    end

    return time
end
</code></pre>
<pre><code class="language-cpp">double verlet(double pos, double acc, double dt) {

  double prev_pos = pos;
  double time = 0;

  while (pos &gt; 0) {
    time += dt;
    double next_pos = pos * 2 - prev_pos + acc * dt * dt;
    prev_pos = pos;
    pos = next_pos;
  }

  return time;
}
</code></pre>
<pre><code class="language-c">void verlet(double *time, double pos, double acc, double dt) {
    double prev_pos, temp_pos;
    prev_pos = pos;
    *time = 0.0;

    while (pos &gt; 0) {
        *time += dt;
        temp_pos = pos;
        pos = pos * 2 - prev_pos + acc * dt * dt;
        prev_pos = temp_pos;
    }
}
</code></pre>
<pre><code class="language-java">    static double verlet(double pos, double acc, double dt) {

      // Note that we are using a temp variable for the previous position
      double prev_pos, temp_pos, time;
      prev_pos = pos;
      time = 0;

      while (pos &gt; 0) {
            time += dt;
            temp_pos = pos;
            pos = pos*2 - prev_pos + acc * dt * dt;
            prev_pos = temp_pos;
        }

        return time;
    }
</code></pre>
<pre><code class="language-python">def verlet(pos, acc, dt):
    prev_pos = pos
    time = 0

    while pos &gt; 0:
        time += dt
        next_pos = pos * 2 - prev_pos + acc * dt * dt
        prev_pos, pos = pos, next_pos

    return time
</code></pre>
<pre><code class="language-haskell">type Method = Model -&gt; Time -&gt; Particle -&gt; Particle -&gt; Particle

verlet :: Method
verlet acc dt (xOld, _, _, _) (x, _, a, t) = (x', v', a', t + dt)
  where
    x' = 2 * x - xOld + a * dt ^ 2
    v' = 0
    a' = acc (x', v', a, t + dt)
</code></pre>
<pre><code class="language-javascript">function verlet(pos, acc, dt) {
  let prevPos = pos;
  let time = 0;
  let tempPos;

  while (pos &gt; 0) {
    time += dt;
    tempPos = pos;
    pos = pos * 2 - prevPos + acc * dt * dt;
    prevPos = tempPos;
  }

  return time;
}
</code></pre>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn verlet(mut pos: f64, acc: f64, dt: f64) -&gt; f64 {
    let mut prev_pos = pos;
    let mut time = 0.0;

    while pos &gt; 0.0 {
        time += dt;
        let temp_pos = pos;
        pos = pos * 2.0 - prev_pos + acc * dt * dt;
        prev_pos = temp_pos;
    }

    time
}
<span class="boring">}
</span></code></pre></pre>
<pre><code class="language-swift">func verlet(pos: Double, acc: Double, dt: Double) -&gt; Double {
    var pos = pos
    var temp_pos, time: Double
    var prev_pos = pos
    time = 0.0
    
    while (pos &gt; 0) {
        time += dt
        temp_pos = pos
        pos = pos*2 - prev_pos + acc * dt * dt
        prev_pos = temp_pos
    }
    
    return time
}
</code></pre>
<pre><code class="language-fortran">SUBROUTINE verlet(pos, acc, dt, time) 
    IMPLICIT NONE
    REAL(8), INTENT(INOUT) :: pos, acc, dt, time
    REAL(8)                :: prev_pos, next_pos


    prev_pos = pos
    time     = 0d0

    DO
        IF (pos &gt; 0d0) THEN
            time     = time + dt
            next_pos = pos * 2d0 - prev_pos + acc * dt ** 2
            prev_pos = pos
            pos      = next_pos
        ELSE
            EXIT
        END IF
    END DO
END SUBROUTINE verlet
</code></pre>
<pre><code class="language-ruby">def verlet(pos, acc, dt)

    prev_pos = pos
    time = 0
    while pos &gt; 0 do
        time += dt
        temp_pos = pos
        pos = pos*2 - prev_pos + acc * dt * dt
        prev_pos = temp_pos
    end

   return time

end
</code></pre>
<pre><code class="language-go">func verlet(pos, acc, dt float64) (time float64) {
	prevPos := pos
	time = 0

	for pos &gt; 0 {
		time += dt
		nextPos := pos*2 - prevPos + acc*dt*dt
		prevPos, pos = pos, nextPos
	}

	return
}
</code></pre>
<pre><code class="language-asm-x64"># xmm0 - pos
# xmm1 - acc
# xmm2 - dt
# RET xmm0 - time
verlet:
  pxor   xmm7, xmm7                  # Holds 0 for comparisons
  pxor   xmm3, xmm3                  # Holds time value
  comisd xmm0, xmm7                  # Check if pos is greater then 0.0
  jbe    verlet_return
  movsd  xmm6, xmm1                  # xmm6 = acc * dt * dt
  mulsd  xmm6, xmm2
  mulsd  xmm6, xmm2
  movsd  xmm5, xmm0                  # Holds previous position
verlet_loop:
  addsd  xmm3, xmm2                  # Adding dt to time
  movsd  xmm4, xmm0                  # Hold old value of posistion
  addsd  xmm0, xmm0                  # Calculating new position
  subsd  xmm0, xmm5
  addsd  xmm0, xmm6
  movsd  xmm5, xmm4
  comisd xmm0, xmm7                  # Check if position is greater then 0.0
  ja     verlet_loop
verlet_return:
  movsd  xmm0, xmm3                  # Saving time value
  ret
</code></pre>
<pre><code class="language-kotlin">fun verlet(_pos: Double, acc: Double, dt: Double): Double {
    var pos = _pos  // Since function parameter are val and can't be modified
    var prevPos = pos
    var time = 0.0

    while (pos &gt; 0) {
        time += dt
        val nextPos = pos * 2 - prevPos + acc * dt * dt
        prevPos = pos
        pos = nextPos
    }
    return time
}
</code></pre>
<pre><code class="language-nim">func verlet(pos_in, acc, dt: float): float =
  var
    pos: float = pos_in
    prevPos: float = pos
    time: float = 0.0
    tempPos: float

  while pos &gt; 0.0:
    time += dt
    tempPos = pos
    pos = pos * 2 - prevPos + acc * dt * dt
    prevPos = tempPos

  time
</code></pre>
<pre><code class="language-lisp">(defun verlet (pos acc dt)
  &quot;Integrates Newton's equation for motion while pos &gt; 0 using Verlet integration.&quot;
  (loop
    with prev-pos = pos
    for time = 0 then (incf time dt)
    while (&gt; pos 0)
    ;; The starting speed is assumed to be zero.
    do (psetf
         pos (+ (* pos 2) (- prev-pos) (* acc dt dt))
         prev-pos pos)
    finally (return time)))
</code></pre>
<p>Now, obviously this poses a problem; what if we want to calculate a term that requires velocity, like the kinetic energy, \( \frac{1}{2}mv^2 \)? In this case, we certainly cannot get rid of the velocity! Well, we can find the velocity to \( \mathcal{O}(\Delta t^2) \) accuracy by using the Stormer-Verlet method, which is the same as before, but we calculate velocity like so</p>
<p>\[ v(t) = \frac{x(t+\Delta t) - x(t-\Delta t)}{2\Delta t} + \mathcal{O}(\Delta t^2) \]</p>
<p>Note that the 2 in the denominator appears because we are going over 2 timesteps. It's essentially solving \( v=\frac{\Delta x}{\Delta t} \). In addition, we can calculate the velocity of the next timestep like so</p>
<p>\[ v(t+\Delta t) = \frac{x(t+\Delta t) - x(t)}{\Delta t} + \mathcal{O}(\Delta t) \]</p>
<p>However, the error for this is \( \mathcal{O}(\Delta t) \), which is quite poor, but it gets the job done in a pinch.  Here's what it looks like in code:</p>
<pre><code class="language-julia">function stormer_verlet(pos::Float64, acc::Float64, dt::Float64)
    prev_pos = pos
    time = 0.0
    vel = 0.0

    while (pos &gt; 0.0)
        time += dt
        temp_pos = pos
        pos = pos * 2 - prev_pos + acc * dt * dt
        prev_pos = temp_pos

        # Because acceleration is constant, velocity is straightforward
        vel += acc * dt
    end

    return time, vel
end
</code></pre>
<pre><code class="language-cpp">timestep stormer_verlet(double pos, double acc, double dt) {

  double prev_pos = pos;
  double time = 0;
  double vel = 0;
  while (pos &gt; 0) {
    time += dt;
    double next_pos = pos * 2 - prev_pos + acc * dt * dt;
    prev_pos = pos;
    pos = next_pos;

    // The acceleration is constant, so the velocity is
    // straightforward
    vel += acc * dt;
  }

  return timestep { time, vel };
}
</code></pre>
<pre><code class="language-c">void stormer_verlet(double *time, double *vel,
                    double pos, double acc, double dt) {
    double prev_pos, temp_pos;
    prev_pos = pos;
    *vel = 0.0;
    *time = 0.0;

    while (pos &gt; 0) {
        *time += dt;
        temp_pos = pos;
        pos = pos * 2 - prev_pos + acc * dt * dt;
        prev_pos = temp_pos;

        *vel += acc * dt;
    }
}
</code></pre>
<pre><code class="language-java">    static VerletValues stormer_verlet(double pos, double acc, double dt) {

        // Note that we are using a temp variable for the previous position
        double prev_pos, temp_pos, time, vel;
        prev_pos = pos;
        vel = 0;
        time = 0;
        while (pos &gt; 0) {
            time += dt;
            temp_pos = pos;
            pos = pos*2 - prev_pos + acc * dt * dt;
            prev_pos = temp_pos;

            // The acceleration is constant, so the velocity is straightforward
             vel += acc*dt;
        }
      
       return new VerletValues(time, vel);
    }
</code></pre>
<pre><code class="language-python">def stormer_verlet(pos, acc, dt):
    prev_pos = pos
    time = 0
    vel = 0

    while pos &gt; 0:
        time += dt
        next_pos = pos * 2 - prev_pos + acc * dt * dt
        prev_pos, pos = pos, next_pos
        vel += acc * dt

    return time, vel
</code></pre>
<pre><code class="language-haskell">stormerVerlet :: Method
stormerVerlet acc dt (xOld, _, _, _) (x, _, a, t) = (x', v', a', t + dt)
  where
    x' = 2 * x - xOld + a * dt ^ 2
    v' = (x' - x) / dt
    a' = acc (x', v', a, t + dt)
</code></pre>
<pre><code class="language-javascript">function stormerVerlet(pos, acc, dt) {
  let prevPos = pos;
  let time = 0;
  let vel = 0;
  let tempPos;

  while (pos &gt; 0) {
    time += dt;
    tempPos = pos;
    pos = pos * 2 - prevPos + acc * dt * dt;
    prevPos = tempPos;

    vel += acc * dt;
  }

  return { time, vel };
}
</code></pre>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn stormer_verlet(mut pos: f64, acc: f64, dt: f64) -&gt; (f64, f64) {
    let mut prev_pos = pos;
    let mut time = 0.0;
    let mut vel = 0.0;

    while pos &gt; 0.0 {
        time += dt;
        let temp_pos = pos;
        pos = pos * 2.0 - prev_pos + acc * dt * dt;
        prev_pos = temp_pos;

        // Because acceleration is constant, velocity is
        // straightforward
        vel += acc * dt;
    }

    (time, vel)
}
<span class="boring">}
</span></code></pre></pre>
<pre><code class="language-swift">func stormerVerlet(pos: Double, acc: Double, dt: Double) -&gt; (time: Double, vel: Double) {
    var pos = pos
    var temp_pos, time, vel: Double
    var prev_pos = pos
    vel = 0
    time = 0
    
    while (pos &gt; 0) {
        time += dt
        temp_pos = pos
        pos = pos*2 - prev_pos + acc * dt * dt
        prev_pos = temp_pos
        
        vel += acc*dt
    }
    
    return (time:time, vel:vel)
}
</code></pre>
<pre><code class="language-fortran">SUBROUTINE stormer_verlet(pos, acc, dt, time, vel) 
    IMPLICIT NONE
    REAL(8), INTENT(INOUT) :: pos, acc, dt, time, vel
    REAL(8)                :: prev_pos, next_pos

    prev_pos = pos 
    time     = 0d0
    vel      = 0d0

    DO
        IF (pos &gt; 0d0) THEN
            time     = time + dt
            next_pos = pos * 2 - prev_pos + acc * dt ** 2
            prev_pos = pos
            pos      = next_pos
            vel      = vel + acc * dt
        ELSE
            EXIT
        END IF
    END DO
END SUBROUTINE stormer_verlet 
</code></pre>
<pre><code class="language-ruby">def stormer_verlet(pos, acc, dt)

    prev_pos = pos
    vel = 0
    time = 0
    while pos &gt; 0 do
        time += dt
        temp_pos = pos
        pos = pos*2 - prev_pos + acc * dt * dt
        prev_pos = temp_pos

        vel += acc*dt
    end

   return time, vel

end
</code></pre>
<pre><code class="language-go">func stormerVerlet(pos, acc, dt float64) (time, vel float64) {
	prevPos := pos
	time, vel = 0, 0

	for pos &gt; 0 {
		time += dt
		vel += acc * dt
		nextPos := pos*2 - prevPos + acc*dt*dt
		prevPos, pos = pos, nextPos
	}

	return
}
</code></pre>
<pre><code class="language-asm-x64"># xmm0 - pos
# xmm1 - acc
# xmm2 - dt
# RET xmm0 - time
# RET xmm1 - velocity
stormer_verlet:
  pxor   xmm7, xmm7                  # Holds 0 for comparisons
  pxor   xmm3, xmm3                  # Holds time value
  comisd xmm0, xmm7                  # Check if pos is greater then 0.0
  jbe    stormer_verlet_return
  movsd  xmm6, xmm1                  # xmm6 = acc * dt * dt
  mulsd  xmm6, xmm2
  mulsd  xmm6, xmm2
  movsd  xmm5, xmm0                  # Holds previous position
stormer_verlet_loop:
  addsd  xmm3, xmm2                  # Adding dt to time
  movsd  xmm4, xmm0                  # Hold old value of posistion
  addsd  xmm0, xmm0                  # Calculating new position
  subsd  xmm0, xmm5
  addsd  xmm0, xmm6
  movsd  xmm5, xmm4
  comisd xmm0, xmm7                  # Check if position is greater then 0.0
  ja     stormer_verlet_loop
stormer_verlet_return:
  movsd  xmm0, xmm3                  # Saving time and velocity
  mulsd  xmm3, xmm1
  movsd  xmm1, xmm3
  ret
</code></pre>
<pre><code class="language-kotlin">fun stormerVerlet(_pos: Double, acc: Double, dt: Double): VerletValues {
    var pos = _pos
    var prevPos = pos
    var time = 0.0
    var vel = 0.0
    while (pos &gt; 0) {
        time += dt
        val nextPos = pos * 2 - prevPos + acc * dt * dt
        prevPos = pos
        pos = nextPos
        vel += acc * dt
    }
    return VerletValues(time, vel)
}
</code></pre>
<pre><code class="language-nim">func stormerVerlet(pos_in, acc, dt: float): (float, float) =
  var
    pos: float = pos_in
    prevPos: float = pos
    time: float = 0.0
    vel: float = 0.0
    tempPos: float

  while pos &gt; 0.0:
    time += dt
    tempPos = pos
    pos = pos * 2 - prevPos + acc * dt * dt
    prevPos = tempPos

    vel += acc * dt

  (time, vel)
</code></pre>
<pre><code class="language-lisp">(defun stormer-verlet (pos acc dt)
  &quot;Integrates Newton's equation for motion while pos &gt; 0 using the Stormer-Verlet method.&quot;
  (loop
    with prev-pos = pos
    for time = 0 then (incf time dt)
    for vel = 0 then (incf vel (* acc dt))
    while (&gt; pos 0)
    ;; Variables are changed simultaneously by 'psetf', so there's no need for a temporary variable.
    do (psetf
         pos (+ (* pos 2) (- prev-pos) (* acc dt dt))
         prev-pos pos)
    finally (return (list time vel))))
</code></pre>
<p>Now, let's say we actually need the velocity to calculate out next timestep. Well, in this case, we simply cannot use the above approximation and instead need to use the <em>Velocity Verlet</em> algorithm.</p>
<h1 id="velocity-verlet"><a class="header" href="#velocity-verlet">Velocity Verlet</a></h1>
<p>In some ways, this algorithm is even simpler than above. We can calculate everything like</p>
<p>\[
\begin{align}
x(t+\Delta t) &amp;=x(t) + v(t)\Delta t + \frac{1}{2}a(t)\Delta t^2 \\
a(t+\Delta t) &amp;= f(x(t+\Delta t)) \\
v(t+\Delta t) &amp;= v(t) + \frac{1}{2}(a(t) + a(t+\Delta t))\Delta t
\end{align}
\]</p>
<p>which is literally the kinematic equation above, solving for \( x \), \( v \), and \( a \) every timestep. You can also split up the equations like so</p>
<p>\[
\begin{align}
v(t+\frac{1}{2}\Delta t) &amp;= v(t) + \frac{1}{2}a(t)\Delta t \\
x(t+\Delta t) &amp;=x(t) + v(t+\frac{1}{2}\Delta t)\Delta t \\
a(t+\Delta t) &amp;= f(x(t+\Delta t)) \\
v(t+\Delta t) &amp;= v(t+\frac{1}{2}\Delta t) + \frac{1}{2}a(t+\Delta t)\Delta t
\end{align}
\]</p>
<p>Here is the velocity Verlet method in code:</p>
<pre><code class="language-julia">function velocity_verlet(pos::Float64, acc::Float64, dt::Float64)
    prev_pos = pos
    time = 0.0
    vel = 0.0

    while (pos &gt; 0.0)
        time += dt
        pos += vel * dt + 0.5 * acc * dt * dt;
        vel += acc * dt;
    end

    return time, vel
end
</code></pre>
<pre><code class="language-cpp">timestep velocity_verlet(double pos, double acc, double dt) {

  double time = 0;
  double vel = 0;
  while (pos &gt; 0) {
    time += dt;
    pos += vel * dt + 0.5 * acc * dt * dt;
    vel += acc * dt;
  }

  return timestep { time, vel };
}
</code></pre>
<pre><code class="language-c">void velocity_verlet(double *time, double *vel,
                     double pos, double acc, double dt) {
    *vel = 0.0;
    *time = 0.0;

    while (pos &gt; 0) {
        *time += dt;
        pos += (*vel) * dt + 0.5 * acc * dt * dt;
        *vel += acc * dt;
    }
}
</code></pre>
<pre><code class="language-java">    static VerletValues velocity_verlet(double pos, double acc, double dt) {

        // Note that we are using a temp variable for the previous position
        double time, vel;
        vel = 0;
        time = 0;
        while (pos &gt; 0) {
            time += dt;
            pos += vel*dt + 0.5*acc * dt * dt;
            vel += acc*dt;
        }
        return new VerletValues(time, vel);
    }
</code></pre>
<pre><code class="language-python">def velocity_verlet(pos, acc, dt):
    time = 0
    vel = 0

    while pos &gt; 0:
        time += dt
        pos += vel * dt + 0.5 * acc * dt * dt
        vel += acc * dt

    return time, vel
</code></pre>
<pre><code class="language-haskell">velocityVerlet :: Method
velocityVerlet acc dt (xOld, _, aOld, _) (x, v, a, t) = (x', v', a', t + dt)
  where
    x' = 2 * x - xOld + a * dt ^ 2
    v' = v + 0.5 * (aOld + a) * dt
    a' = acc (x', v', a, t + dt)
</code></pre>
<pre><code class="language-javascript">function velocityVerlet(pos, acc, dt) {
  let time = 0;
  let vel = 0;

  while (pos &gt; 0) {
    time += dt;
    pos += vel * dt + 0.5 * acc * dt * dt;
    vel += acc * dt;
  }

  return { time, vel };
}
</code></pre>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn velocity_verlet(mut pos: f64, acc: f64, dt: f64) -&gt; (f64, f64) {
    let mut time = 0.0;
    let mut vel = 0.0;

    while pos &gt; 0.0 {
        time += dt;
        pos += vel * dt + 0.5 * acc * dt * dt;
        vel += acc * dt;
    }

    (time, vel)
}
<span class="boring">}
</span></code></pre></pre>
<pre><code class="language-swift">func velocityVerlet(pos: Double, acc: Double, dt: Double) -&gt; (time: Double, vel: Double) {
    var pos = pos
    var time, vel : Double
    vel = 0
    time = 0
    
    while (pos &gt; 0) {
        time += dt
        pos += vel*dt + 0.5*acc * dt * dt
        vel += acc*dt
    }
    
    return (time:time, vel:vel)
}
</code></pre>
<pre><code class="language-fortran">SUBROUTINE velocity_verlet(pos, acc, dt, time, vel) 
    IMPLICIT NONE
    REAL(8), INTENT(INOUT) :: pos, acc, dt, time, vel

    time     = 0d0
    vel      = 0d0

    DO
        IF (pos &gt; 0d0) THEN
            time = time + dt
            pos  = pos + vel * dt + 0.5d0 * acc * dt ** 2 
            vel  = vel + acc * dt
        ELSE
            EXIT
        END IF
    END DO
END SUBROUTINE velocity_verlet 
</code></pre>
<pre><code class="language-ruby">def velocity_verlet(pos, acc, dt)

    vel = 0
    time = 0
    while pos &gt; 0 do
        time += dt
        pos += vel*dt + 0.5*acc * dt * dt
        vel += acc*dt
    end

   return time, vel

end
</code></pre>
<pre><code class="language-go">func velocityVerlet(pos, acc, dt float64) (time, vel float64) {
	time, vel = 0, 0

	for pos &gt; 0 {
		time += dt
		pos += vel*dt + .5*acc*dt*dt
		vel += acc * dt
	}

	return
}
</code></pre>
<pre><code class="language-asm-x64"># xmm0 - pos
# xmm1 - acc
# xmm2 - dt
# RET xmm0 - time
# RET xmm1 - velocity
velocity_verlet:
  pxor   xmm7, xmm7                  # Holds 0 for comparisons
  pxor   xmm3, xmm3                  # Holds the velocity value
  pxor   xmm4, xmm4                  # Holds the time value
  comisd xmm0, xmm7                  # Check if pos is greater then 0.0
  jbe    velocity_verlet_return
  movsd  xmm5, half                  # xmm5 = 0.5 * dt * dt * acc
  mulsd  xmm5, xmm2
  mulsd  xmm5, xmm2
  mulsd  xmm5, xmm1
velocity_verlet_loop:
  movsd  xmm6, xmm3                  # Move velocity into register
  mulsd  xmm6, xmm2                  # Calculate new position
  addsd  xmm6, xmm5
  addsd  xmm0, xmm6
  addsd  xmm4, xmm2                  # Incrementing time
  movsd  xmm3, xmm4                  # Updating velocity
  mulsd  xmm3, xmm1
  comisd xmm0, xmm7
  ja     velocity_verlet_loop
velocity_verlet_return:
  movsd  xmm0, xmm4                  # Saving time and velocity
  movsd  xmm1, xmm3
  ret
</code></pre>
<pre><code class="language-kotlin">fun velocityVerlet(_pos: Double, acc: Double, dt: Double): VerletValues {
    var pos = _pos
    var time = 0.0
    var vel = 0.0
    while (pos &gt; 0) {
        time += dt
        pos += vel * dt + 0.5 * acc * dt * dt
        vel += acc * dt
    }
    return VerletValues(time, vel)
}
</code></pre>
<pre><code class="language-nim">func velocityVerlet(pos_in, acc, dt: float): (float, float) =
  var
    pos: float = pos_in
    time: float = 0.0
    vel: float = 0.0

  while pos &gt; 0.0:
    time += dt
    pos += vel * dt + 0.5 * acc * dt * dt
    vel += acc * dt

  (time, vel)
</code></pre>
<pre><code class="language-lisp">(defun velocity-verlet (pos acc dt)
  &quot;Integrates Newton's equation for motion while pos &gt; 0 using the velocity in calculations.&quot;
  (loop
    for time = 0 then (incf time dt)
    for vel = 0 then (incf vel (* acc dt))
    for p = pos then (incf p (+ (* vel dt) (* 0.5 acc dt dt)))
    while (&gt; p 0)
    finally (return (list time vel))))
</code></pre>
<p>Even though this method is more widely used than the simple Verlet method mentioned above, it unforunately has an error term of \( \mathcal{O}(\Delta t^2) \), which is two orders of magnitude worse. That said, if you want to have a simulaton with many objects that depend on one another --- like a gravity simulation --- the Velocity Verlet algorithm is a handy choice; however, you may have to play further tricks to allow everything to scale appropriately. These types of simulatons are sometimes called <em>n-body</em> simulations and one such trick is the Barnes-Hut algorithm, which cuts the complexity of n-body simulations from \( \sim \mathcal{O}(n^2) \) to \( \sim \mathcal{O}(n\log(n)) \).</p>
<h2 id="video-explanation-9"><a class="header" href="#video-explanation-9">Video Explanation</a></h2>
<p>Here is a video describing Verlet integration:</p>
<div style="text-align:center">
<iframe width="560" height="315" src="https://www.youtube.com/embed/g55QvpAev0I" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
</div>
<h2 id="example-code-15"><a class="header" href="#example-code-15">Example Code</a></h2>
<p>Both of these methods work simply by iterating timestep-by-timestep and can be written straightforwardly in any language. For reference, here are snippets of code that use both the classic and velocity Verlet methods to find the time it takes for a ball to hit the ground after being dropped from a given height.</p>
<pre><code class="language-julia">function verlet(pos::Float64, acc::Float64, dt::Float64)
    prev_pos = pos
    time = 0.0

    while (pos &gt; 0)
        time += dt
        temp_pos = pos
        pos = pos * 2 - prev_pos + acc * dt * dt
        prev_pos = temp_pos
    end

    return time
end

function stormer_verlet(pos::Float64, acc::Float64, dt::Float64)
    prev_pos = pos
    time = 0.0
    vel = 0.0

    while (pos &gt; 0.0)
        time += dt
        temp_pos = pos
        pos = pos * 2 - prev_pos + acc * dt * dt
        prev_pos = temp_pos

        # Because acceleration is constant, velocity is straightforward
        vel += acc * dt
    end

    return time, vel
end

function velocity_verlet(pos::Float64, acc::Float64, dt::Float64)
    prev_pos = pos
    time = 0.0
    vel = 0.0

    while (pos &gt; 0.0)
        time += dt
        pos += vel * dt + 0.5 * acc * dt * dt;
        vel += acc * dt;
    end

    return time, vel
end

function main()
    time = verlet(5.0, -10.0, 0.01);
    println(&quot;[#]\nTime for Verlet integration is:&quot;)
    println(&quot;$(time)&quot;)

    time, vel = stormer_verlet(5.0, -10.0, 0.01);
    println(&quot;[#]\nTime for Stormer Verlet integration is:&quot;)
    println(&quot;$(time)&quot;)
    println(&quot;[#]\nVelocity for Stormer Verlet integration is:&quot;)
    println(&quot;$(vel)&quot;)
    
    time, vel = velocity_verlet(5.0, -10.0, 0.01);
    println(&quot;[#]\nTime for velocity Verlet integration is:&quot;)
    println(&quot;$(time)&quot;)
    println(&quot;[#]\nVelocity for velocity Verlet integration is:&quot;)
    println(&quot;$(vel)&quot;)

end

main()
</code></pre>
<pre><code class="language-cpp">#include &lt;iomanip&gt;
#include &lt;iostream&gt;

struct timestep {
  double time;
  double vel;
};

double verlet(double pos, double acc, double dt) {

  double prev_pos = pos;
  double time = 0;

  while (pos &gt; 0) {
    time += dt;
    double next_pos = pos * 2 - prev_pos + acc * dt * dt;
    prev_pos = pos;
    pos = next_pos;
  }

  return time;
}

timestep stormer_verlet(double pos, double acc, double dt) {

  double prev_pos = pos;
  double time = 0;
  double vel = 0;
  while (pos &gt; 0) {
    time += dt;
    double next_pos = pos * 2 - prev_pos + acc * dt * dt;
    prev_pos = pos;
    pos = next_pos;

    // The acceleration is constant, so the velocity is
    // straightforward
    vel += acc * dt;
  }

  return timestep { time, vel };
}

timestep velocity_verlet(double pos, double acc, double dt) {

  double time = 0;
  double vel = 0;
  while (pos &gt; 0) {
    time += dt;
    pos += vel * dt + 0.5 * acc * dt * dt;
    vel += acc * dt;
  }

  return timestep { time, vel };
}

int main() {
  std::cout &lt;&lt; std::fixed &lt;&lt; std::setprecision(8);

  // Note that depending on the simulation, you might want to have the
  // Verlet loop outside.

  // For example, if your acceleration chages as a function of time,
  // you might need to also change the acceleration to be read into
  // each of these functions.

  double time = verlet(5.0, -10, 0.01);
  std::cout &lt;&lt; &quot;[#]\nTime for Verlet integration is:\n&quot; \
            &lt;&lt; time &lt;&lt; std::endl;

  timestep timestep_sv = stormer_verlet(5.0, -10, 0.01);
  std::cout &lt;&lt; &quot;[#]\nTime for Stormer Verlet integration is:\n&quot; \
            &lt;&lt; timestep_sv.time &lt;&lt; std::endl;
  std::cout &lt;&lt; &quot;[#]\nVelocity for Stormer Verlet integration is:\n&quot; \
            &lt;&lt; timestep_sv.vel &lt;&lt; std::endl;

  timestep timestep_vv = velocity_verlet(5.0, -10, 0.01);
  std::cout &lt;&lt; &quot;[#]\nTime for velocity Verlet integration is:\n&quot; \
            &lt;&lt; timestep_vv.time &lt;&lt; std::endl;
  std::cout &lt;&lt; &quot;[#]\nVelocity for velocity Verlet integration is:\n&quot; \
            &lt;&lt; timestep_vv.vel &lt;&lt; std::endl;

  return 0;

}
</code></pre>
<pre><code class="language-c">#include &lt;stdio.h&gt;

void verlet(double *time, double pos, double acc, double dt) {
    double prev_pos, temp_pos;
    prev_pos = pos;
    *time = 0.0;

    while (pos &gt; 0) {
        *time += dt;
        temp_pos = pos;
        pos = pos * 2 - prev_pos + acc * dt * dt;
        prev_pos = temp_pos;
    }
}

void stormer_verlet(double *time, double *vel,
                    double pos, double acc, double dt) {
    double prev_pos, temp_pos;
    prev_pos = pos;
    *vel = 0.0;
    *time = 0.0;

    while (pos &gt; 0) {
        *time += dt;
        temp_pos = pos;
        pos = pos * 2 - prev_pos + acc * dt * dt;
        prev_pos = temp_pos;

        *vel += acc * dt;
    }
}

void velocity_verlet(double *time, double *vel,
                     double pos, double acc, double dt) {
    *vel = 0.0;
    *time = 0.0;

    while (pos &gt; 0) {
        *time += dt;
        pos += (*vel) * dt + 0.5 * acc * dt * dt;
        *vel += acc * dt;
    }
}

int main() {
    double time, vel;

    verlet(&amp;time, 5.0, -10, 0.01);
    printf(&quot;[#]\nTime for Verlet integration is:\n&quot;);
    printf(&quot;%lf\n&quot;, time);

    stormer_verlet(&amp;time, &amp;vel, 5.0, -10, 0.01);
    printf(&quot;[#]\nTime for Stormer Verlet integration is:\n&quot;);
    printf(&quot;%lf\n&quot;, time);
    printf(&quot;[#]\nVelocity for Stormer Verlet integration is:\n&quot;);
    printf(&quot;%lf\n&quot;, vel);

    velocity_verlet(&amp;time, &amp;vel, 5.0, -10, 0.01);
    printf(&quot;[#]\nTime for velocity Verlet integration is:\n&quot;);
    printf(&quot;%lf\n&quot;, time);
    printf(&quot;[#]\nVelocity for Stormer Verlet integration is:\n&quot;);
    printf(&quot;%lf\n&quot;, vel);

    return 0;
}
</code></pre>
<pre><code class="language-java">public class Verlet {
    
    private static class VerletValues {
        public double time;
        public double vel;
    
        public VerletValues(double time, double vel) {
            this.time = time;
            this.vel = vel;
        }
    }
    

    static double verlet(double pos, double acc, double dt) {

      // Note that we are using a temp variable for the previous position
      double prev_pos, temp_pos, time;
      prev_pos = pos;
      time = 0;

      while (pos &gt; 0) {
            time += dt;
            temp_pos = pos;
            pos = pos*2 - prev_pos + acc * dt * dt;
            prev_pos = temp_pos;
        }

        return time;
    }
  
    static VerletValues stormer_verlet(double pos, double acc, double dt) {

        // Note that we are using a temp variable for the previous position
        double prev_pos, temp_pos, time, vel;
        prev_pos = pos;
        vel = 0;
        time = 0;
        while (pos &gt; 0) {
            time += dt;
            temp_pos = pos;
            pos = pos*2 - prev_pos + acc * dt * dt;
            prev_pos = temp_pos;

            // The acceleration is constant, so the velocity is straightforward
             vel += acc*dt;
        }
      
       return new VerletValues(time, vel);
    }

    static VerletValues velocity_verlet(double pos, double acc, double dt) {

        // Note that we are using a temp variable for the previous position
        double time, vel;
        vel = 0;
        time = 0;
        while (pos &gt; 0) {
            time += dt;
            pos += vel*dt + 0.5*acc * dt * dt;
            vel += acc*dt;
        }
        return new VerletValues(time, vel);
    }

    public static void main(String[] args) {

        double verletTime = verlet(5.0, -10, 0.01);
        System.out.println(&quot;[#]\nTime for Verlet integration is:&quot;);
        System.out.println(verletTime);
      
        VerletValues stormerVerlet = stormer_verlet(5.0, -10, 0.01);
        System.out.println(&quot;[#]\nTime for Stormer Verlet integration is:&quot;);
        System.out.println(stormerVerlet.time);
        System.out.println(&quot;[#]\nVelocity for Stormer Verlet integration is:&quot;);
        System.out.println(stormerVerlet.vel);
        
        VerletValues velocityVerlet = velocity_verlet(5.0, -10, 0.01);
        System.out.println(&quot;[#]\nTime for velocity Verlet integration is:&quot;);
        System.out.println(velocityVerlet.time);
        System.out.println(&quot;[#]\nVelocity for velocity Verlet integration is:&quot;);
        System.out.println(velocityVerlet.vel);
        
    }
}
</code></pre>
<pre><code class="language-python">def verlet(pos, acc, dt):
    prev_pos = pos
    time = 0

    while pos &gt; 0:
        time += dt
        next_pos = pos * 2 - prev_pos + acc * dt * dt
        prev_pos, pos = pos, next_pos

    return time

def stormer_verlet(pos, acc, dt):
    prev_pos = pos
    time = 0
    vel = 0

    while pos &gt; 0:
        time += dt
        next_pos = pos * 2 - prev_pos + acc * dt * dt
        prev_pos, pos = pos, next_pos
        vel += acc * dt

    return time, vel

def velocity_verlet(pos, acc, dt):
    time = 0
    vel = 0

    while pos &gt; 0:
        time += dt
        pos += vel * dt + 0.5 * acc * dt * dt
        vel += acc * dt

    return time, vel

def main():
    time = verlet(5, -10, 0.01)
    print(&quot;[#]\nTime for Verlet integration is:&quot;)
    print(&quot;{:.10f}&quot;.format(time))

    time, vel = stormer_verlet(5, -10, 0.01)
    print(&quot;[#]\nTime for Stormer Verlet integration is:&quot;)
    print(&quot;{:.10f}&quot;.format(time))
    print(&quot;[#]\nVelocity for Stormer Verlet integration is:&quot;)
    print(&quot;{:.10f}&quot;.format(vel))

    time, vel = velocity_verlet(5, -10, 0.01)
    print(&quot;[#]\nTime for velocity Verlet integration is:&quot;)
    print(&quot;{:.10f}&quot;.format(time))
    print(&quot;[#]\nVelocity for velocity Verlet integration is:&quot;)
    print(&quot;{:.10f}&quot;.format(vel))


if __name__ == '__main__':
    main()
</code></pre>
<pre><code class="language-haskell">-- submitted by Jie
type Time = Double

type Position = Double

type Speed = Double

type Acceleration = Double

type Particle = (Position, Speed, Acceleration, Time)

type Model = Particle -&gt; Acceleration

type Method = Model -&gt; Time -&gt; Particle -&gt; Particle -&gt; Particle

verlet :: Method
verlet acc dt (xOld, _, _, _) (x, _, a, t) = (x', v', a', t + dt)
  where
    x' = 2 * x - xOld + a * dt ^ 2
    v' = 0
    a' = acc (x', v', a, t + dt)

stormerVerlet :: Method
stormerVerlet acc dt (xOld, _, _, _) (x, _, a, t) = (x', v', a', t + dt)
  where
    x' = 2 * x - xOld + a * dt ^ 2
    v' = (x' - x) / dt
    a' = acc (x', v', a, t + dt)

velocityVerlet :: Method
velocityVerlet acc dt (xOld, _, aOld, _) (x, v, a, t) = (x', v', a', t + dt)
  where
    x' = 2 * x - xOld + a * dt ^ 2
    v' = v + 0.5 * (aOld + a) * dt
    a' = acc (x', v', a, t + dt)

trajectory :: Method -&gt; Model -&gt; Time -&gt; Particle -&gt; [Particle]
trajectory method acc dt p0@(x, v, a, t0) = traj
  where
    traj = p0 : p1 : zipWith (method acc dt) traj (tail traj)
    p1 = (x', v', acc (x', v', a, t0 + dt), t0 + dt)
    x' = x + v * dt + 0.5 * a * dt ^ 2
    v' = v + a * dt

main :: IO ()
main = do
  let p0 = (5, 0, -10, 0)
      dt = 0.001
      freefall _ = -10
      aboveGround (x, _, _, _) = x &gt; 0
      timeVelocity m =
        let (_, v, _, t) = last $ takeWhile aboveGround $ trajectory m freefall dt p0
         in (show t, show v)

  putStrLn &quot;[#]\nTime for Verlet integration is:&quot;
  putStrLn $ fst $ timeVelocity verlet
  putStrLn &quot;[#]\nTime for Stormer Verlet integration is:&quot;
  putStrLn $ fst $ timeVelocity stormerVerlet
  putStrLn &quot;[#]\nVelocity for Stormer Verlet integration is:&quot;
  putStrLn $ snd $ timeVelocity stormerVerlet
  putStrLn &quot;[#]\nTime for velocity Verlet integration is:&quot;
  putStrLn $ fst $ timeVelocity velocityVerlet
  putStrLn &quot;[#]\nVelocity for velocity Verlet integration is:&quot;
  putStrLn $ snd $ timeVelocity velocityVerlet
</code></pre>
<pre><code class="language-javascript">function verlet(pos, acc, dt) {
  let prevPos = pos;
  let time = 0;
  let tempPos;

  while (pos &gt; 0) {
    time += dt;
    tempPos = pos;
    pos = pos * 2 - prevPos + acc * dt * dt;
    prevPos = tempPos;
  }

  return time;
}

function stormerVerlet(pos, acc, dt) {
  let prevPos = pos;
  let time = 0;
  let vel = 0;
  let tempPos;

  while (pos &gt; 0) {
    time += dt;
    tempPos = pos;
    pos = pos * 2 - prevPos + acc * dt * dt;
    prevPos = tempPos;

    vel += acc * dt;
  }

  return { time, vel };
}

function velocityVerlet(pos, acc, dt) {
  let time = 0;
  let vel = 0;

  while (pos &gt; 0) {
    time += dt;
    pos += vel * dt + 0.5 * acc * dt * dt;
    vel += acc * dt;
  }

  return { time, vel };
}

const time = verlet(5, -10, 0.01);
console.log(`[#]\nTime for Verlet integration is:`);
console.log(`${time}`);

const stormer = stormerVerlet(5, -10, 0.01);
console.log(`[#]\nTime for Stormer Verlet integration is:`);
console.log(`${stormer.time}`);
console.log(`[#]\nVelocity for Stormer Verlet integration is:`);
console.log(`${stormer.vel}`);

const velocity = velocityVerlet(5, -10, 0.01);
console.log(`[#]\nTime for velocity Verlet integration is:`);
console.log(`${velocity.time}`);
console.log(`[#]\nVelocity for velocity Verlet integration is:`);
console.log(`${velocity.vel}`);
</code></pre>
<pre><pre class="playground"><code class="language-rust">fn verlet(mut pos: f64, acc: f64, dt: f64) -&gt; f64 {
    let mut prev_pos = pos;
    let mut time = 0.0;

    while pos &gt; 0.0 {
        time += dt;
        let temp_pos = pos;
        pos = pos * 2.0 - prev_pos + acc * dt * dt;
        prev_pos = temp_pos;
    }

    time
}

fn stormer_verlet(mut pos: f64, acc: f64, dt: f64) -&gt; (f64, f64) {
    let mut prev_pos = pos;
    let mut time = 0.0;
    let mut vel = 0.0;

    while pos &gt; 0.0 {
        time += dt;
        let temp_pos = pos;
        pos = pos * 2.0 - prev_pos + acc * dt * dt;
        prev_pos = temp_pos;

        // Because acceleration is constant, velocity is
        // straightforward
        vel += acc * dt;
    }

    (time, vel)
}

fn velocity_verlet(mut pos: f64, acc: f64, dt: f64) -&gt; (f64, f64) {
    let mut time = 0.0;
    let mut vel = 0.0;

    while pos &gt; 0.0 {
        time += dt;
        pos += vel * dt + 0.5 * acc * dt * dt;
        vel += acc * dt;
    }

    (time, vel)
}

fn main() {
    let time_v = verlet(5.0, -10.0, 0.01);
    let (time_sv, vel_sv) = stormer_verlet(5.0, -10.0, 0.01);
    let (time_vv, vel_vv) = velocity_verlet(5.0, -10.0, 0.01);

    println!(&quot;[#]\nTime for Verlet integration is:&quot;);
    println!(&quot;{}&quot;, time_v);
    
    println!(&quot;[#]\nTime for Stormer Verlet integration is:&quot;);
    println!(&quot;{}&quot;, time_sv);
    println!(&quot;[#]\nVelocity for Stormer Verlet integration is:&quot;);
    println!(&quot;{}&quot;, vel_sv);
    
    println!(&quot;[#]\nTime for velocity Verlet integration is:&quot;);
    println!(&quot;{}&quot;, time_vv);
    println!(&quot;[#]\nVelocity for velocity Verlet integration is:&quot;);
    println!(&quot;{}&quot;, vel_vv);
}
</code></pre></pre>
<pre><code class="language-swift">func verlet(pos: Double, acc: Double, dt: Double) -&gt; Double {
    var pos = pos
    var temp_pos, time: Double
    var prev_pos = pos
    time = 0.0
    
    while (pos &gt; 0) {
        time += dt
        temp_pos = pos
        pos = pos*2 - prev_pos + acc * dt * dt
        prev_pos = temp_pos
    }
    
    return time
}

func stormerVerlet(pos: Double, acc: Double, dt: Double) -&gt; (time: Double, vel: Double) {
    var pos = pos
    var temp_pos, time, vel: Double
    var prev_pos = pos
    vel = 0
    time = 0
    
    while (pos &gt; 0) {
        time += dt
        temp_pos = pos
        pos = pos*2 - prev_pos + acc * dt * dt
        prev_pos = temp_pos
        
        vel += acc*dt
    }
    
    return (time:time, vel:vel)
}

func velocityVerlet(pos: Double, acc: Double, dt: Double) -&gt; (time: Double, vel: Double) {
    var pos = pos
    var time, vel : Double
    vel = 0
    time = 0
    
    while (pos &gt; 0) {
        time += dt
        pos += vel*dt + 0.5*acc * dt * dt
        vel += acc*dt
    }
    
    return (time:time, vel:vel)
}

func main() {
    let verletTime = verlet(pos: 5.0, acc: -10.0, dt: 0.01)
    print(&quot;[#]\nTime for Verlet integration is:&quot;)
    print(&quot;\(verletTime)&quot;)
    
    let stormer = stormerVerlet(pos: 5.0, acc: -10.0, dt: 0.01);
    print(&quot;[#]\nTime for Stormer Verlet integration is:&quot;)
    print(&quot;\(stormer.time)&quot;)
    print(&quot;[#]\nVelocity for Stormer Verlet integration is:&quot;)
    print(&quot;\(stormer.vel)&quot;)
    
    let velVerlet = velocityVerlet(pos: 5.0, acc: -10, dt: 0.01)
    print(&quot;[#]\nTime for velocity Verlet integration is:&quot;)
    print(&quot;\(velVerlet.time)&quot;)
    print(&quot;[#]\nVelocity for velocity Verlet integration is:&quot;)
    print(&quot;\(velVerlet.vel)&quot;)
}

main()
</code></pre>
<pre><code class="language-fortran">SUBROUTINE verlet(pos, acc, dt, time) 
    IMPLICIT NONE
    REAL(8), INTENT(INOUT) :: pos, acc, dt, time
    REAL(8)                :: prev_pos, next_pos


    prev_pos = pos
    time     = 0d0

    DO
        IF (pos &gt; 0d0) THEN
            time     = time + dt
            next_pos = pos * 2d0 - prev_pos + acc * dt ** 2
            prev_pos = pos
            pos      = next_pos
        ELSE
            EXIT
        END IF
    END DO
END SUBROUTINE verlet

SUBROUTINE stormer_verlet(pos, acc, dt, time, vel) 
    IMPLICIT NONE
    REAL(8), INTENT(INOUT) :: pos, acc, dt, time, vel
    REAL(8)                :: prev_pos, next_pos

    prev_pos = pos 
    time     = 0d0
    vel      = 0d0

    DO
        IF (pos &gt; 0d0) THEN
            time     = time + dt
            next_pos = pos * 2 - prev_pos + acc * dt ** 2
            prev_pos = pos
            pos      = next_pos
            vel      = vel + acc * dt
        ELSE
            EXIT
        END IF
    END DO
END SUBROUTINE stormer_verlet 

SUBROUTINE velocity_verlet(pos, acc, dt, time, vel) 
    IMPLICIT NONE
    REAL(8), INTENT(INOUT) :: pos, acc, dt, time, vel

    time     = 0d0
    vel      = 0d0

    DO
        IF (pos &gt; 0d0) THEN
            time = time + dt
            pos  = pos + vel * dt + 0.5d0 * acc * dt ** 2 
            vel  = vel + acc * dt
        ELSE
            EXIT
        END IF
    END DO
END SUBROUTINE velocity_verlet 

PROGRAM verlet_integration

    IMPLICIT NONE 
    REAL(8) :: pos,acc, dt, time, vel
    
    INTERFACE
        SUBROUTINE verlet(pos, acc, dt, time)
        REAL(8), INTENT(INOUT) :: pos, acc, dt, time
        REAL(8)                :: prev_pos, next_pos
        END SUBROUTINE
    END INTERFACE 
    
    INTERFACE 
        SUBROUTINE stormer_verlet(pos, acc, dt, time, vel) 
            REAL(8), INTENT(INOUT) :: pos, acc, dt, time, vel
            REAL(8)                :: prev_pos, next_pos
        END SUBROUTINE 
    END INTERFACE 
    
    INTERFACE 
        SUBROUTINE velocity_verlet(pos, acc, dt, time, vel) 
            REAL(8), INTENT(INOUT) :: pos, acc, dt, time, vel
            REAL(8)                :: prev_pos, next_pos 
        END SUBROUTINE 
    END INTERFACE 
    
    pos = 5d0
    acc = -10d0
    dt  = 0.01d0
    ! Verlet 
    CALL verlet(pos, acc, dt, time)
    
    WRITE(*,*) '[#]'
    WRITE(*,*) 'Time for Verlet integration:'
    WRITE(*,*) time 
    
    ! stormer Verlet 
    pos = 5d0
    CALL stormer_verlet(pos, acc, dt, time, vel)
    
    WRITE(*,*) '[#]'
    WRITE(*,*) 'Time for Stormer Verlet integration:'
    WRITE(*,*) time
    WRITE(*,*) '[#]'
    WRITE(*,*) 'Velocity for Stormer Verlet integration:'
    WRITE(*,*) vel
    
    
    
    ! Velocity Verlet
    pos = 5d0
    CALL velocity_verlet(pos, acc, dt, time, vel)
    
    WRITE(*,*) '[#]'
    WRITE(*,*) 'Time for velocity Verlet integration:'
    WRITE(*,*) time
    WRITE(*,*) '[#]'
    WRITE(*,*) 'Velocity for velocity Verlet integration:'
    WRITE(*,*) vel

END PROGRAM verlet_integration
</code></pre>
<pre><code class="language-ruby">def verlet(pos, acc, dt)

    prev_pos = pos
    time = 0
    while pos &gt; 0 do
        time += dt
        temp_pos = pos
        pos = pos*2 - prev_pos + acc * dt * dt
        prev_pos = temp_pos
    end

   return time

end

def stormer_verlet(pos, acc, dt)

    prev_pos = pos
    vel = 0
    time = 0
    while pos &gt; 0 do
        time += dt
        temp_pos = pos
        pos = pos*2 - prev_pos + acc * dt * dt
        prev_pos = temp_pos

        vel += acc*dt
    end

   return time, vel

end

def velocity_verlet(pos, acc, dt)

    vel = 0
    time = 0
    while pos &gt; 0 do
        time += dt
        pos += vel*dt + 0.5*acc * dt * dt
        vel += acc*dt
    end

   return time, vel

end

puts &quot;[#]\nTime for Verlet integration is:&quot;
p verlet(5.0, -10, 0.01)

time, vel = stormer_verlet(5.0, -10, 0.01)
puts &quot;[#]\nTime for Stormer Verlet integration is:&quot;
p time
puts &quot;[#]\nVelocity for Stormer Verlet integration is:&quot;
p vel

time, vel = velocity_verlet(5.0, -10, 0.01)
puts &quot;[#]\nTime for velocity Verlet integration is:&quot;
p time
puts &quot;[#]\nVelocity for velocity Verlet integration is:&quot;
p vel
</code></pre>
<pre><code class="language-go">package main

import &quot;fmt&quot;

func verlet(pos, acc, dt float64) (time float64) {
	prevPos := pos
	time = 0

	for pos &gt; 0 {
		time += dt
		nextPos := pos*2 - prevPos + acc*dt*dt
		prevPos, pos = pos, nextPos
	}

	return
}

func stormerVerlet(pos, acc, dt float64) (time, vel float64) {
	prevPos := pos
	time, vel = 0, 0

	for pos &gt; 0 {
		time += dt
		vel += acc * dt
		nextPos := pos*2 - prevPos + acc*dt*dt
		prevPos, pos = pos, nextPos
	}

	return
}

func velocityVerlet(pos, acc, dt float64) (time, vel float64) {
	time, vel = 0, 0

	for pos &gt; 0 {
		time += dt
		pos += vel*dt + .5*acc*dt*dt
		vel += acc * dt
	}

	return
}

func main() {
	time := verlet(5., -10., .01)
	fmt.Println(&quot;[#]\nTime for Verlet integration is:&quot;)
	fmt.Println(time)

	time, vel := stormerVerlet(5., -10., .01)
	fmt.Println(&quot;[#]\nTime for Stormer Verlet integration is:&quot;)
	fmt.Println(time)
	fmt.Println(&quot;[#]\nVelocity for Stormer Verlet integration is:&quot;)
	fmt.Println(vel)
	
	time, vel = velocityVerlet(5., -10., .01)
	fmt.Println(&quot;[#]\nTime for velocity Verlet integration is:&quot;)
	fmt.Println(time)
	fmt.Println(&quot;[#]\nVelocity for velocity Verlet integration is:&quot;)
	fmt.Println(vel)
}
</code></pre>
<pre><code class="language-asm-x64">.intel_syntax noprefix

.section .rodata
  zero:          .double 0.0
  two:           .double 2.0
  half:          .double 0.5
  verlet_fmt:    .string &quot;[#]\nTime for Verlet integration is:\n%lf\n&quot;
  stormer_fmt:   .string &quot;[#]\nTime for Stormer Verlet Integration is:\n%lf\n[#]\nVelocity for Stormer Verlet Integration is:\n%lf\n&quot;
  velocity_fmt:  .string &quot;[#]\nTime for Velocity Verlet Integration is:\n%lf\n[#]\nVelocity for Velocity Verlet Integration is:\n%lf\n&quot;
  pos:           .double 5.0
  acc:           .double -10.0
  dt:            .double 0.01

.section .text
  .global main
  .extern printf

# xmm0 - pos
# xmm1 - acc
# xmm2 - dt
# RET xmm0 - time
verlet:
  pxor   xmm7, xmm7                  # Holds 0 for comparisons
  pxor   xmm3, xmm3                  # Holds time value
  comisd xmm0, xmm7                  # Check if pos is greater then 0.0
  jbe    verlet_return
  movsd  xmm6, xmm1                  # xmm6 = acc * dt * dt
  mulsd  xmm6, xmm2
  mulsd  xmm6, xmm2
  movsd  xmm5, xmm0                  # Holds previous position
verlet_loop:
  addsd  xmm3, xmm2                  # Adding dt to time
  movsd  xmm4, xmm0                  # Hold old value of posistion
  addsd  xmm0, xmm0                  # Calculating new position
  subsd  xmm0, xmm5
  addsd  xmm0, xmm6
  movsd  xmm5, xmm4
  comisd xmm0, xmm7                  # Check if position is greater then 0.0
  ja     verlet_loop
verlet_return:
  movsd  xmm0, xmm3                  # Saving time value
  ret

# xmm0 - pos
# xmm1 - acc
# xmm2 - dt
# RET xmm0 - time
# RET xmm1 - velocity
stormer_verlet:
  pxor   xmm7, xmm7                  # Holds 0 for comparisons
  pxor   xmm3, xmm3                  # Holds time value
  comisd xmm0, xmm7                  # Check if pos is greater then 0.0
  jbe    stormer_verlet_return
  movsd  xmm6, xmm1                  # xmm6 = acc * dt * dt
  mulsd  xmm6, xmm2
  mulsd  xmm6, xmm2
  movsd  xmm5, xmm0                  # Holds previous position
stormer_verlet_loop:
  addsd  xmm3, xmm2                  # Adding dt to time
  movsd  xmm4, xmm0                  # Hold old value of posistion
  addsd  xmm0, xmm0                  # Calculating new position
  subsd  xmm0, xmm5
  addsd  xmm0, xmm6
  movsd  xmm5, xmm4
  comisd xmm0, xmm7                  # Check if position is greater then 0.0
  ja     stormer_verlet_loop
stormer_verlet_return:
  movsd  xmm0, xmm3                  # Saving time and velocity
  mulsd  xmm3, xmm1
  movsd  xmm1, xmm3
  ret

# xmm0 - pos
# xmm1 - acc
# xmm2 - dt
# RET xmm0 - time
# RET xmm1 - velocity
velocity_verlet:
  pxor   xmm7, xmm7                  # Holds 0 for comparisons
  pxor   xmm3, xmm3                  # Holds the velocity value
  pxor   xmm4, xmm4                  # Holds the time value
  comisd xmm0, xmm7                  # Check if pos is greater then 0.0
  jbe    velocity_verlet_return
  movsd  xmm5, half                  # xmm5 = 0.5 * dt * dt * acc
  mulsd  xmm5, xmm2
  mulsd  xmm5, xmm2
  mulsd  xmm5, xmm1
velocity_verlet_loop:
  movsd  xmm6, xmm3                  # Move velocity into register
  mulsd  xmm6, xmm2                  # Calculate new position
  addsd  xmm6, xmm5
  addsd  xmm0, xmm6
  addsd  xmm4, xmm2                  # Incrementing time
  movsd  xmm3, xmm4                  # Updating velocity
  mulsd  xmm3, xmm1
  comisd xmm0, xmm7
  ja     velocity_verlet_loop
velocity_verlet_return:
  movsd  xmm0, xmm4                  # Saving time and velocity
  movsd  xmm1, xmm3
  ret

main:
  push   rbp
  movsd  xmm0, pos                   # Calling verlet
  movsd  xmm1, acc
  movsd  xmm2, dt
  call   verlet
  mov    rdi, OFFSET verlet_fmt      # Print output
  mov    rax, 1
  call   printf
  movsd  xmm0, pos                   # Calling stormer_verlet
  movsd  xmm1, acc
  movsd  xmm2, dt
  call   stormer_verlet
  mov    rdi, OFFSET stormer_fmt     # Print output
  mov    rax, 1
  call   printf
  movsd  xmm0, pos                   # Calling velocity_verlet
  movsd  xmm1, acc
  movsd  xmm2, dt
  call   velocity_verlet
  mov    rdi, OFFSET velocity_fmt    # Print output
  mov    rax, 1
  call   printf
  pop    rbp
  xor    rax, rax                      # Set exit code to 0
  ret

</code></pre>
<pre><code class="language-kotlin">data class VerletValues(val time: Double, val vel: Double)

fun verlet(_pos: Double, acc: Double, dt: Double): Double {
    var pos = _pos  // Since function parameter are val and can't be modified
    var prevPos = pos
    var time = 0.0

    while (pos &gt; 0) {
        time += dt
        val nextPos = pos * 2 - prevPos + acc * dt * dt
        prevPos = pos
        pos = nextPos
    }
    return time
}

fun stormerVerlet(_pos: Double, acc: Double, dt: Double): VerletValues {
    var pos = _pos
    var prevPos = pos
    var time = 0.0
    var vel = 0.0
    while (pos &gt; 0) {
        time += dt
        val nextPos = pos * 2 - prevPos + acc * dt * dt
        prevPos = pos
        pos = nextPos
        vel += acc * dt
    }
    return VerletValues(time, vel)
}

fun velocityVerlet(_pos: Double, acc: Double, dt: Double): VerletValues {
    var pos = _pos
    var time = 0.0
    var vel = 0.0
    while (pos &gt; 0) {
        time += dt
        pos += vel * dt + 0.5 * acc * dt * dt
        vel += acc * dt
    }
    return VerletValues(time, vel)
}

fun main(args: Array&lt;String&gt;) {
    val verletTime = verlet(5.0, -10.0, 0.01)
    println(&quot;[#]\nTime for Verlet integration is:&quot;)
    println(&quot;$verletTime&quot;)

    val stormerVerlet = stormerVerlet(5.0, -10.0, 0.01)
    println(&quot;[#]\nTime for Stormer Verlet integration is:&quot;)
    println(&quot;${stormerVerlet.time}&quot;)
    println(&quot;[#]\nVelocity for Stormer Verlet integration is:&quot;)
    println(&quot;${stormerVerlet.vel}&quot;)

    val velocityVerlet = velocityVerlet(5.0, -10.0, 0.01)
    println(&quot;[#]\nTime for Velocity Verlet integration is:&quot;)
    println(&quot;${velocityVerlet.time}&quot;)
    println(&quot;[#]\nVelocity for Velocity Verlet integration is:&quot;)
    println(&quot;${velocityVerlet.vel}&quot;)
}
</code></pre>
<pre><code class="language-nim">func verlet(pos_in, acc, dt: float): float =
  var
    pos: float = pos_in
    prevPos: float = pos
    time: float = 0.0
    tempPos: float

  while pos &gt; 0.0:
    time += dt
    tempPos = pos
    pos = pos * 2 - prevPos + acc * dt * dt
    prevPos = tempPos

  time

func stormerVerlet(pos_in, acc, dt: float): (float, float) =
  var
    pos: float = pos_in
    prevPos: float = pos
    time: float = 0.0
    vel: float = 0.0
    tempPos: float

  while pos &gt; 0.0:
    time += dt
    tempPos = pos
    pos = pos * 2 - prevPos + acc * dt * dt
    prevPos = tempPos

    vel += acc * dt

  (time, vel)

func velocityVerlet(pos_in, acc, dt: float): (float, float) =
  var
    pos: float = pos_in
    time: float = 0.0
    vel: float = 0.0

  while pos &gt; 0.0:
    time += dt
    pos += vel * dt + 0.5 * acc * dt * dt
    vel += acc * dt

  (time, vel)

when isMainModule:
  let timeV = verlet(5.0, -10.0, 0.01)
  echo &quot;[#]\nTime for Verlet integration is:&quot;
  echo timeV

  let (timeSV, velSV) = stormerVerlet(5.0, -10.0, 0.01)
  echo &quot;[#]\nTime for Stormer Verlet integration is:&quot;
  echo timeSV
  echo &quot;[#]\nVelocity for Stormer Verlet integration is:&quot;
  echo velSV

  let (timeVV, velVV) = velocityVerlet(5.0, -10.0, 0.01)
  echo &quot;[#]\nTime for velocity Verlet integration is:&quot;
  echo timeVV
  echo &quot;[#]\nVelocity for velocity Verlet integration is:&quot;
  echo velVV
</code></pre>
<pre><code class="language-lisp">;;;; Verlet integration implementation in Common Lisp

(defun verlet (pos acc dt)
  &quot;Integrates Newton's equation for motion while pos &gt; 0 using Verlet integration.&quot;
  (loop
    with prev-pos = pos
    for time = 0 then (incf time dt)
    while (&gt; pos 0)
    ;; The starting speed is assumed to be zero.
    do (psetf
         pos (+ (* pos 2) (- prev-pos) (* acc dt dt))
         prev-pos pos)
    finally (return time)))

(defun stormer-verlet (pos acc dt)
  &quot;Integrates Newton's equation for motion while pos &gt; 0 using the Stormer-Verlet method.&quot;
  (loop
    with prev-pos = pos
    for time = 0 then (incf time dt)
    for vel = 0 then (incf vel (* acc dt))
    while (&gt; pos 0)
    ;; Variables are changed simultaneously by 'psetf', so there's no need for a temporary variable.
    do (psetf
         pos (+ (* pos 2) (- prev-pos) (* acc dt dt))
         prev-pos pos)
    finally (return (list time vel))))

(defun velocity-verlet (pos acc dt)
  &quot;Integrates Newton's equation for motion while pos &gt; 0 using the velocity in calculations.&quot;
  (loop
    for time = 0 then (incf time dt)
    for vel = 0 then (incf vel (* acc dt))
    for p = pos then (incf p (+ (* vel dt) (* 0.5 acc dt dt)))
    while (&gt; p 0)
    finally (return (list time vel))))

(format T &quot;[#]~%Time for Verlet integration:~%&quot;)
(format T &quot;~d~%&quot; (verlet 5 -10 0.01))

(defvar stormer-verlet-result (stormer-verlet 5 -10 0.01))
(format T &quot;[#]~%Time for Stormer Verlet integration is:~%&quot;)
(format T &quot;~d~%&quot; (first stormer-verlet-result))
(format T &quot;[#]~%Velocity for Stormer Verlet integration is:~%&quot;)
(format T &quot;~d~%&quot; (second stormer-verlet-result))

(defvar velocity-verlet-result (velocity-verlet 5 -10 0.01))
(format T &quot;[#]~%Time for velocity Verlet integration is:~%&quot;)
(format T &quot;~d~%&quot; (first velocity-verlet-result))
(format T &quot;[#]~%Velocity for velocity Verlet integration is:~%&quot;)
(format T &quot;~d~%&quot; (second velocity-verlet-result))
</code></pre>
<h2 id="license-31"><a class="header" href="#license-31">License</a></h2>
<h5 id="code-examples-29"><a class="header" href="#code-examples-29">Code Examples</a></h5>
<p>The code examples are licensed under the MIT license (found in <a href="https://github.com/algorithm-archivists/algorithm-archive/blob/master/LICENSE.md">LICENSE.md</a>).</p>
<h5 id="text-31"><a class="header" href="#text-31">Text</a></h5>
<p>The text of this chapter was written by <a href="https://github.com/leios">James Schloss</a> and is licensed under the <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</p>
<p><a href="https://creativecommons.org/licenses/by-sa/4.0/"><p><img  class="center" src="verlet_integration/../cc/CC-BY-SA_icon.svg" /></p></a></p>
<h5 id="pull-requests-28"><a class="header" href="#pull-requests-28">Pull Requests</a></h5>
<p>After initial licensing (<a href="https://github.com/algorithm-archivists/algorithm-archive/pull/560">#560</a>), the following pull requests have modified the text or graphics of this chapter:</p>
<ul>
<li>none</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="quantum-systems"><a class="header" href="#quantum-systems">Quantum Systems</a></h1>
<p>As I am sure you have heard, the quantum world is weird.
As you deal with progressively smaller and smaller systems, at some point, it becomes less accurate to describe objects as particles.
Instead, it is better to describe objects as probability densities.
These densities are easiest to understand in terms of <em>wavefunctions</em>, which are complex functions characterizing a quantum system's behavior.</p>
<p>Again, this is pretty common knowledge; however, there is a distinct lack of readable literature on how to simulate quantum systems, even though there are numerous methods for exactly that!
This section will deal with the computation of quantum states with classical machines.
Now, I know what you are thinking, &quot;Wait. Why are we simulating quantum systems on classical computers? Why not simulate it with some sort of experiment or with quantum computers?&quot;
Well, here's where the notation gets really sticky.</p>
<p>There is a clear difference between quantum computers and quantum simulators.
A <em>quantum computer</em> is the quantum analog to a classical computer, replacing bits with qubits by using quantum information theory.
Quantum computers are usually thought of as a way to use quantum mechanics to eventually solve real-world problems with new quantum algorithms.
Both Grover's and Shor's algorithms are good examples of cases where quantum computation could greatly change the landscape of modern computation as we know it!</p>
<p><em>Quantum simulators</em> on the other hand are quantum systems used to better understand quantum mechanics.
These will often come in the form of experimental quantum systems that express quantum behavior and allow us to better understand other areas of quantum systems.
In other words, quantum simulators are general techniques to study quantum systems on quantum hardware; however, quantum computers are quantum hardware used for the explicit purpose of quantum computation with qubits.
Because supercomputers are not great at performing quantum computations, certain quantum simulators exist as a building block for quantum computation.
A <em>universal quantum simulator</em> is often called a quantum computer for this reason.</p>
<p>The truth is that quantum simulators are hard to make in laboratories, so simulating quantum systems on classical hardware is as good as we can do in most cases.
This section is devoted to all the different methods currently used to solve complex quantum systems, so let's start with the Schrdinger Equation, which has many different formulations.
Here is the easiest one to explain:</p>
<p>\[ i \hbar \frac{\partial \Psi(\mathbf{r},t)}{\partial t} = \left[-\frac{\hbar^2}{2m} \nabla^2 + V(\mathbf{r},t) \right] \Psi(\mathbf{r},t) \]</p>
<p>Where \( \Psi(\mathbf{r},t) \) is a quantum wavefunction, \( V(\mathbf{r},t) \) is a <em>trapping potential</em>, \( \nabla^2 \) is a <em>Laplacian</em>, \( \mathbf{r} \) is some sort of spatial component, and \( t \) is time.
There is a lot to take in here; however, it's ultimately just some time derivative on the left-hand side and a spatial derivative (with some extra steps) on the right-hand side.
In this way, it isn't too different from the diffusion (heat) equation:</p>
<p>\[ \frac{\partial\phi(\mathbf{r},t)}{\partial t} = D \nabla^2 \phi(\mathbf{r},t) \]</p>
<p>where \( D \) is some positive definite matrix and \( \phi(\mathbf{r},t) \) is the density (or temperature) of the system.
In fact, this is why one of the most common types of quantum simulation is sometimes called  <em>diffusion Monte Carlo</em>.
There really isn't that much of a difference between the two systems in terms of how they are simulated on classical hardware... but we are getting ahead of ourselves.
For now, let's talk about how quantum mechanics differs from classical mechanics and how we can use this to our advantage.</p>
<h2 id="probability-density"><a class="header" href="#probability-density">Probability Density</a></h2>
<p>Quantum mechanics works fundamentally differently than classical mechanics in physics.
The wavefunction can be thought of as a set of all possible states for an object to be in, where there is some probability for the particle to be found in each state.
This means that it is not possible to say that a particle is at a particular location, and instead we often say that it could be at any location with probability, as shown in the <em>probability density</em>:</p>
<p>\[ P(\mathbf{r}, t) = |\Psi(\mathbf{r},t)|^2 = \Psi(\mathbf{r},t)^{*}\Psi(\mathbf{r},t) \]</p>
<p>Here, there are 2 things to note:</p>
<ol>
<li>The absolute value squared of a complex parameter \( \Psi(\mathbf{r},t) \) is a dot product (inner product) between a complex function and it's Hermitian conjugate. This means the value will always be real, while the wavefunction, itself, might not be.</li>
<li>As you have probably heard, once a wavefunction is observed it collapses onto a single state. This can be simply interpreted as absolute knowledge of the particle's location. A probability density doesn't make sense if we know where the particle is!</li>
</ol>
<p>Now, to be clear: the probabilities must all sum to 1, or (more formally):</p>
<p>\[ \int_{-\infty}^{+\infty}|\Psi(\mathbf{r},t)|^2 d\mathbf{r} = 1 \]</p>
<p>This simply means that the probability of finding our quantum particle <em>somewhere in real space</em> is 1.
In other words, our particle must exist somewhere in the known universe.</p>
<p>As another note: Just like position space can be parameterized by a position vector \( \textbf{x} \), wavefunctions can also be parameterized by a <em>wave</em> vector \( \textbf{k} \) in frequency space.
Any wavevector \( \textbf{k} \) has the same units as reciprocal space and is thus analogous to angular frequency \( \omega \).
Often times, the wavevector space is called <em>momentum</em> space, which makes sense when considering the de Broglie formula:</p>
<p>\[ p = \frac{h}{\lambda} = \frac{2 \pi h}{2 \pi \lambda} = \hbar k \]</p>
<p>where \( h \) is Planck's constant and \( \lambda \) is the wavelength.
This means that we can ultimately move between position and momentum space by using <a href="quantum_systems/../../algorithms/cooley_tukey/cooley_tukey.html">Fourier Transforms</a>, which is incredibly useful in a number of cases!</p>
<p>Even though the relation between position and momentum space is an essential cornerstone of understanding modern quantum mechanics, it is difficult to understand at a fundamental level.
Position space and momentum space are related by a Fourier transform; however, the rather hand-wavey argument above might not have been convincing enough and it does not offer any intuitive description of <em>why</em> the Fourier transform comes into this discussion at all.
The easiest way to understand this might be to look at the <em>Heisenberg uncertainty principle</em>, which is a fundamental relation between position and momentum space.</p>
<h2 id="heisenberg-uncertainty-principle"><a class="header" href="#heisenberg-uncertainty-principle">Heisenberg Uncertainty Principle</a></h2>
<p>Simply put, the Heisenberg uncertainty principle states that we cannot definitely know both the position and momentum of a quantum particle.
In particular, it says:</p>
<p>\[ \sigma_x \sigma_p \geq \frac{\hbar}{2} \]</p>
<p>where \( \hbar \) is Planck's constant and \( \sigma_q = \sqrt{\frac{1}{N}\sum_{i=1}^{N}(q_i-\mu)^2} \).
In this case, \( \sigma \) is the standard deviation, \( \mu \) is the statistical mean of your distribution, \( N \) is the number of points sampled, \( q_i \) is the value for each point \( i \), and \( q \) stands for \( r \) or \( p \).
Ultimately, this means that if we have a higher precision in position space, we will have a lower precision in momentum space.
The converse is also true: a higher precision in momentum space will lead to a lower precision in position space.</p>
<p>This makes the most sense if we imagine having a Gaussian-like probability density (\( |\Psi(x)|^2 \)) in position space, which will provide a Gaussian-like density when in momentum space.
Here, we see that if we have a broader distribution in one space, we must have a thinner distribution in the opposite space, as shown here:</p>
<p>
    <img  class="center" src="quantum_systems/res/gaussian.gif" style="width:70%" />
</p>
<p>Because the density can be interpreted as &quot;the probability of finding a quantum particle at any provided location in position (\( x_i \)) or momentum (\( k_i \)) space, the interpretation is clear: the more we understand about a particle's position, the less we understand about it's momentum.
This is a powerful statement and should be given some thought.</p>
<p>To me, the most interesting part of this description is not the physical interpretation, but the fact that this act of transforming between larger and smaller Gaussians is precisely what Fourier transforms do!
This further strengthens our argument from before.
Position and momentum space are related by the Fourier transform!</p>
<p>This is the heart of several algorithms for simulating quantum systems, including the <a href="quantum_systems/../../algorithms/split-operator_method/split-operator_method">Split-operator method</a>.</p>
<p>At least for me, I found this description to be intuitive, but not complete.
There is still something missing from the picture that should be described in more depth, and to do that, we need to dive deeper into the heart of quantum mechanics and into <em>Hamiltonians</em>.</p>
<h2 id="hamiltonian"><a class="header" href="#hamiltonian">Hamiltonian</a></h2>
<p>Here is the Schrdinger equation again:</p>
<p>\[ i \hbar \frac{\partial \Psi(\mathbf{r},t)}{\partial t} = \left[-\frac{\hbar^2}{2m} \nabla^2 + V(\mathbf{r},t) \right] \Psi(\mathbf{r},t) \]</p>
<p>We described it in the initial section of this chapter.
For the most part, when we are trying to solve this equation the left-hand side does not change.
It's always \( i \hbar \frac{\partial \Psi(\mathbf{r},t)}{\partial t} \).
On the other hand, the right-hand side can change a lot depending on the situation.
That is to say that we can easily simplify the Schrdinger equation by using a mathematical formalism known as the <em>Hamiltonian</em>.</p>
<p>To be clear, Hamiltonian mechanics is not a quantum-specific idea.
It's everywhere in statistical physics and is often taught in classical physics courses as an analogue to another notational form known as Lagrangian mechanics.
For simplicity, we will restrict our discussion here to interpreting Hamiltonians physically.
We can basically say that the Hamiltonian is a measure of the energy of our quantum system.
More specifically, we can say that the Hamiltonian is a set of energy <em>operators</em> that act on our wavefunction.</p>
<p>In the case of a 1D particle in a harmonic trap, we might use the following definitions:</p>
<p>\[
\begin{align}
\hat H &amp;= \hat T + \hat V \\
\hat T &amp;= \frac{p^2}{2m} \\
\hat V &amp;= \frac{1}{2}\omega x^2
\end{align}
\]</p>
<p>where \( p = -i\hbar \nabla \) is the <em>momentum operator</em> and \( \omega \) is the <em>trapping frequency</em> indicating how confined our quantum system will be.
In this case, \( \hat T \) is an operator that works on our wavefunction in momentum space, while \( \hat V \) acts in position space.
Both of these are operators.
That is to say that they <em>operate</em> on our quantum system by transforming it in some way.
Ultimately, this means that the operators are not meant to be interpreted on their own without acting on some other object, in this case, the wavefunction \( \Psi(x) \).</p>
<p>In the end, we can update our Schrdinger equation to be</p>
<p>\[ i \hbar \frac{\partial \Psi(\mathbf{r},t)}{\partial t} = \hat H \Psi(\mathbf{r},t) \]</p>
<p>Which is a lot cleaner and more general.
Now, the Schrdinger equation can solve any quantum system so long as it can be written in terms of Hamiltonian mechanics!</p>
<p>When looking at the operators, it is clear that the \( \hat V \) operator is in position space.
We can clearly see that it operates as a function of \( x \).
That said, it is not immediately obvious why the \( \hat T \) is in momentum space.
This is not an easy question to answer, but it is definitely important and will be covered in more depth when we discuss spectral methods.</p>
<p>For now, we will blanketly say</p>
<p>\[ \frac{\partial f}{\partial x} = \mathcal{F}^{-1}\left( 2\pi i k \mathcal{F}\left( f \right)\right) \]</p>
<p>In other words, we can derive a function by performing a Fourier transform on the function, multiplying by some momentum-space grid, and then inverse-transforming it back.
Because this operation inherently involves a transform into momentum space before transformation, it is a momentum-space operator.</p>
<p>This is the most intuitive reasoning I can find; however, I am sure there are more intuitive explanations of why the derivatives are always momentum-space operations.
This section will be updated further when we discuss spectral methods, but if you have better descriptions, please let me know!</p>
<h2 id="bra-ket-notation"><a class="header" href="#bra-ket-notation">Bra Ket Notation</a></h2>
<p>Unfortunately, the interpretation of quantum simulation is rather tricky and is sometimes easier to understand with slightly different notation.
This notation is called <em>braket</em> notation, where a <em>ket</em> looks like this:</p>
<p>\[ \lvert A \rangle \]</p>
<p>and basically describes \( A \) as a column vector.
The <em>bra</em> represents the Hermitian conjugate of the ket and looks like this:</p>
<p>\[ \langle B \rvert \]</p>
<p>The ket is often represented as a row vector for \( B \).
Because of this, \(  \langle B \rvert A \rangle  \) represents the inner product of the two vectors and \(  \lvert A \rangle \langle B \rvert  \) represents the outer product.
Now, to this point, the braket notation does not have any particularly quantum-like features; however, it becomes useful when describing actual quantum phenomenon.
For example, if we want to indicate the probability of a wavefunction \( \psi \) collapsing onto state \( \phi \), we might write: \( \langle \phi \rvert \psi \rangle \), which is precisely the same as the probability density defined above.</p>
<p>Now that we have a basic understanding of the notation, we should go through several other important quantum mechanical ideas and properties.</p>
<h2 id="eigenstates"><a class="header" href="#eigenstates">Eigenstates</a></h2>
<p>As mentioned, the wavefunction \( \Psi(x) \) is complex and has both real and imaginary parts; however, there are certain states that are exclusively real.
These states are <em>eigenstates</em> of the system, and are often described as the constituent states that make up all other possible wavefunctions.
In other words,</p>
<p>\[ \lvert \Psi(x)\rangle = \sum_i c_i \lvert \Psi_i \rangle \]</p>
<p>Where \( c_i \) is some constant describing <em>how much</em> of a given eigenstate \( i \) is in the full wavefunction.
As you might expect, all of the \( c_i \)'s should sum to 1.</p>
<h2 id="energy-calculations"><a class="header" href="#energy-calculations">Energy Calculations</a></h2>
<p>When it comes to quantum systems, there is no quantity more important than energy.
Basically, every eigenstate of the system has a different energy associated with it, and you can find this energy with a simple calculation:</p>
<p>\[ E = \langle \Psi \lvert \hat H \lvert \Psi \rangle \]</p>
<p>Which can be done rather trivially in code by finding the conjugate of the wavefunction and multiplying it with another wavefunction after operation in position and momentum space.
This ultimately looks like this:</p>
<pre><code class="language-julia">
</code></pre>
<pre><code class="language-haskell">
</code></pre>
<pre><code class="language-c">
</code></pre>
<pre><code class="language-cpp">
</code></pre>
<pre><code class="language-python">
</code></pre>
<p>This calculation will be used in many different simulations of quantum systems to check our results.
In the end, many quantum simulations are focused on the <em>ground</em> state, which is the lowest energy state (\( \Psi_0 \)); however, sometimes higher energy states are desired.</p>
<h2 id="the-future"><a class="header" href="#the-future">The Future</a></h2>
<p>As we proceed to add new algorithms to simulate quantum systems, I will add more and more notation to this section; however, there are already huge textbooks out there related to understanding and studying quantum systems.
We don't want to re-invent the wheel here.
Instead, we want to focus on an area that is often not considered with too much detail: algorithms and methods researchers use to ascertain new knowledge about quantum mechanics, like the split-operator method, DMRG, quantum Monte Carlo, exact diagonalization, and many more.</p>
<p>Quantum mechanics is one of those areas of physics that really does push the boundary of human knowledge in a number of different areas and computing is one of those areas.
In fact, <a href="quantum_systems/../quantum_information/quantum_information.html">quantum information theory</a> is currently set to be the next innovation to radically change the landscape of modern computation as we know it!
Of course, because of the large-scale effects that this will likely have on the industry, it deserved it's own section.</p>
<p>As always, if there is something that you feel is missing from this section, please feel free to contact me or create an issue on GitHub and we'll get to it as soon as we can!</p>
<h2 id="license-32"><a class="header" href="#license-32">License</a></h2>
<h5 id="code-examples-30"><a class="header" href="#code-examples-30">Code Examples</a></h5>
<p>The code examples are licensed under the MIT license (found in <a href="https://github.com/algorithm-archivists/algorithm-archive/blob/master/LICENSE.md">LICENSE.md</a>).</p>
<h5 id="text-32"><a class="header" href="#text-32">Text</a></h5>
<p>The text of this chapter was written by <a href="https://github.com/leios">James Schloss</a> and is licensed under the <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</p>
<p><a href="https://creativecommons.org/licenses/by-sa/4.0/"><p><img  class="center" src="quantum_systems/../cc/CC-BY-SA_icon.svg" /></p></a></p>
<h5 id="imagesgraphics-15"><a class="header" href="#imagesgraphics-15">Images/Graphics</a></h5>
<ul>
<li>The animation &quot;<a href="quantum_systems/res/gaussian.gif">FTgaussian</a>&quot; was created by <a href="https://github.com/leios">James Schloss</a> and is licensed under the <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</li>
</ul>
<h5 id="pull-requests-29"><a class="header" href="#pull-requests-29">Pull Requests</a></h5>
<p>After initial licensing (<a href="https://github.com/algorithm-archivists/algorithm-archive/pull/560">#560</a>), the following pull requests have modified the text or graphics of this chapter:</p>
<ul>
<li>none</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-split-operator-method"><a class="header" href="#the-split-operator-method">The Split-Operator Method</a></h1>
<p>The Split-Operator Method (also called the Split-Step Method), was actually the primary method I used to solve the Schrdinger equation during my PhD.
It is one of the simplest and fastest methods for this purpose and is widely used throughout modern quantum research in the area, in particular when dealing with the Non-linear Schrdinger Equation (NLSE):</p>
<p>\[ i \hbar \frac{\partial \Psi(\mathbf{r},t)}{\partial t} = \left[-\frac{\hbar^2}{2m}\nabla^2 + V(\mathbf{r}) + g|\Psi(\mathbf{r},t)|^2 \right] \Psi(\mathbf{r},t), \]</p>
<p>which follows from the notation provided in the <a href="split-operator_method/../quantum_systems/quantum_systems.html">quantum systems</a> chapter: \( \Psi(\mathbf{r},t) \) is a quantum wave-function with spatial (\( \mathbf{r} \)) and time (\( t \)) dependence, \( \nabla^2 \) is a Laplacian, and \( V(\mathbf{r}) \) is a potential of some sort (like \( \omega x^2 \) or something).
In this case, we also add an interaction term \( g \) next to a nonlinear \( |\Psi(\mathbf{r},t)|^2 \) term.
This is the system I studied for most of my PhD (granted, we played a few tricks with parallelization and such, so it was <em>slightly</em> more complicated).</p>
<p>At its heart, the split-op method is nothing more than a pseudo-spectral differential equation solver... That is to say, it solves the Schrdinger equation with <a href="split-operator_method/../cooley_tukey/cooley_tukey.html">FFTs</a>.
In fact, there is a large class of spectral and pseudo-spectral methods used to solve a number of different physical systems, and we'll definitely be covering those in the future.
As mentioned in the <a href="split-operator_method/../quantum_systems/quantum_systems.html">quantum systems</a> section, we can represent a quantum wavefunction in momentum space, which is parameterized with the wavevector \( k \).
In the Hamiltonian shown above, we can split our system into position space components, \( \hat{H}_r = \left[V(\mathbf{r}) + g|\Psi(\mathbf{r},t)|^2 \right] \Psi(\mathbf{r},t) \), and momentum space components, \( \hat{H}_k = \left[-\frac{\hbar^2}{2m}\nabla^2 \right]\Psi(\mathbf{r},t) \).
I'll be honest, I didn't know what notation to use for \( \hat H_r \) because \( p \) is used to describe momentum.
I settled on \( r \) for <em>real space</em>, but that is somewhat notationally ambiguous.
In addition, \( k \) will indicate momentum space because it is a sum of all wavevectors, typically notated as \( k \).
Bad notation aside, let's continue.</p>
<p>If we assume a somewhat general solution to our quantum system:</p>
<p>\[ \Psi(\mathbf{r},t + dt) = \left[e^{-\frac{i\hat{H}dt}{\hbar}}\right]\Psi(\mathbf{r},t) = \left[e^{-\frac{i(\hat{H}_r + \hat{H}_k)dt}{\hbar}}\right]\Psi(\mathbf{r},t) \]</p>
<p>and assume we are simulating our system by a series of small timesteps (\( dt \)), we can perform similar splitting by using the Baker-Campbell-Housdorff formula:</p>
<p>\[ \Psi(\mathbf{r},t+dt) = \left[e^{-\frac{i\hat{H}_rdt}{\hbar}}e^{-\frac{i\hat{H}_kdt}{\hbar}}e^{-\frac{[i\hat{H}_r, i\hat{H}_k]dt^2}{2}}\right]\Psi(\mathbf{r},t) \]</p>
<p>This accrues a small amount of error (\( dt^2 \)) related to the commutation of the real and momentum-space components of the Hamiltonian.
This is a relatively large error and that's not okay.
In order to change the \( dt^2 \) error to \( dt^3 \), we can split the system by performing a half-step in position space before doing a full-step in momentum space, through a process called <em>Strang Splitting</em> like so:</p>
<p>\[ \Psi(\mathbf{r},t+dt) = \left[e^{-\frac{i\hat{H}_rdt}{2\hbar}}e^{-\frac{i\hat{H}_kdt}{\hbar}}e^{-\frac{i\hat{H}_rdt}{2\hbar}} \right]\Psi(\mathbf{r},t) + \mathcal{O}(dt^3) \]</p>
<p>We can then address each part of this solution in chunks, first in position space, then in momentum space, then in position space again by using <a href="split-operator_method/../cooley_tukey/cooley_tukey.html">Fourier Transforms</a>.
Which looks something like this:</p>
<p>\[ \Psi(\mathcal{r}, t+dt) = \left[\hat{U}_r\left(\frac{dt}{2}\right)\mathcal{F}^{-1}\left[\hat{U}_k(dt) \mathcal{F} \left[\hat{U}_r\left(\frac{dt}{2}\right) \Psi(\mathbf{r},t) \right] \right] \right] + \mathcal{O}(dt^3) \]</p>
<p>where \( \hat{U}_r = e^{-\frac{i\hat{H}_rdt}{\hbar}} \), \( \hat{U}_k = e^{-\frac{i\hat{H}_kdt}{\hbar}} \), and \( \mathcal{F} \) and \( \mathcal{F}^{-1} \) indicate forward and inverse Fourier Transforms.
Here's a flowchart of what we are looking for every timestep:</p>
<p>
    <img  class="center" src="split-operator_method/res/split_op_method.svg" style="width:70%" />
</p>
<p>For the most part, that's it:</p>
<ol>
<li>Multiply the wavefunction in real space with the real-space operator.</li>
<li>Flip to momentum space with a Fourier transform.</li>
<li>Multiply the momentum-space wavefunction by the momentum-space operator.</li>
<li>Flip to position space with an inverse Fourier transform.</li>
<li>Repeat 1-4 until satisfied.</li>
</ol>
<p>If we guess that our initial wavefunction is Gaussian-like and is slightly offset from the center or the trap, this should allow us to see our wavefunction &quot;sloshing&quot; back and forth in our trap, like so:</p>
<p>
    <img  class="center" src="split-operator_method/res/real_time.gif" style="width:70%" />
</p>
<p>As a small concession, using this method enforces periodic boundary conditions, where the wavefunction will simply slide from one side of your simulation box to the other, but that's fine for most cases.
In fact, for many cases (such as large-scale turbulence models) it's ideal.</p>
<p>That said, there is more to the story.
As we mentioned in the <a href="split-operator_method/../quantum_systems/quantum_systems.html">quantum systems</a> section, many simulations of quantum systems desire to find the ground state of our system.
The split-operator method can be used for that too!
If we run this simulation in <em>imaginary time</em>, by simply setting \( \tau = it \) and stepping through \( \tau \) instead of \( t \), we will no longer see an &quot;real-world&quot; example of how the atoms should behave, but will instead see an exponential decay of higher-energy states.
If we run the simulation for long enough with a small enough timestep, all higher energy states will vanish.
This means that we can find the ground state of our system by running the simulation in imaginary time, which is an incredibly useful feature!
If we run the same simulation as above in imaginary time, we should see our wavefunction smoothly move to the center of our trap (the lowest energy position), like so:</p>
<p>
    <img  class="center" src="split-operator_method/res/imaginary_time.gif" style="width:70%" />
</p>
<h2 id="the-algorithm"><a class="header" href="#the-algorithm">The Algorithm</a></h2>
<p>Luckily, the code in this case is pretty straightforward.
As a note before starting, we will be using normalized units in this simulation where \( \hbar = c = 1 \).
These units are often called <em>natural</em> units.
Many of you (<em>cough</em> experimentalists <em>cough</em>) will probably think that these units are completely unphysical, and they are; however, they allow us to output fractions and whole numbers.
For example, if we are trying to find the energy of the ground state of atoms in a simple harmonic oscillator, we know it should be \( \frac{1}{2}\hbar \omega \), where \( \omega \) is the coefficient in front of the \( x^2 \) term known as the <em>frequency</em> of the trap.
If we were to calculate the energy in real units, our simulation would output \( 5.272859 \times 10^{-35} \), which is hard to interpret.
By instead using natural units, we get precisely \( \frac{1}{2} \) and we know that those are in units of \( \hbar\omega \).
There is no doubt that it makes the simulation easier to understand (albeit a little misleading in the end).</p>
<p>Regardless, we first need to set all the initial parameters, including the initial grids in real and momentum space:</p>
<pre><code class="language-julia">struct Param
    xmax::Float64
    res::Int64
    dt::Float64
    timesteps::Int64
    dx::Float64
    x::Vector{Float64}
    dk::Float64
    k::Vector{Float64}
    im_time::Bool

    Param() = new(10.0, 512, 0.05, 1000, 2 * 10.0/512,
                  Vector{Float64}(-10.0 + 10.0/512 : 20.0/512 : 10.0),
                  pi / 10.0,
                  Vector{Float64}(vcat(0:512/2 - 1, -512/2 : -1) * pi/10.0),
                  false)
    Param(xmax::Float64, res::Int64, dt::Float64, timesteps::Int64,
          im_val::Bool) = new(
              xmax, res, dt, timesteps,
              2*xmax/res, Vector{Float64}(-xmax+xmax/res:2*xmax/res:xmax),
              pi/xmax, Vector{Float64}(vcat(0:res/2-1, -res/2:-1)*pi/(xmax)),
              im_val
          )
end
</code></pre>
<pre><code class="language-c">struct params {
    double xmax;
    unsigned int res;
    double dt;
    unsigned int timesteps;
    double dx;
    double *x;
    double dk;
    double *k;
    bool im_time;
};
</code></pre>
<p><a href="split-operator_method/code/c/split_op.c">import:52-73, lang:&quot;c&quot;</a></p>
<pre><code class="language-cpp">using complex = std::complex&lt;double&gt;;
using vector_real = std::vector&lt;double&gt;;
using vector_complex = std::vector&lt;complex&gt;;

struct Params {
    Params(double _xmax, unsigned int _res, double _dt, unsigned int _timesteps, bool im) {
        xmax = _xmax;
        res = _res;
        dt = _dt;
        timesteps = _timesteps;
        dx = 2.0 * xmax / res;
        x.reserve(res);
        dk = M_PI / xmax;
        k.reserve(res);
        im_time = im;

        for (size_t i = 0; i &lt; res; ++i) {
            x.emplace_back(xmax / res - xmax + i * (2.0 * xmax / res));
            if (i &lt; res / 2) {
                k.push_back(i * M_PI / xmax);
            } else {
                k.push_back((static_cast&lt;double&gt;(i) - res) * M_PI / xmax);
            }
        }
    }

    double xmax;
    unsigned int res;
    double dt;
    unsigned int timesteps;
    double dx;
    vector_real x;
    double dk;
    vector_real k;
    bool im_time;
};
</code></pre>
<pre><code class="language-python">class Param:
    &quot;&quot;&quot;Container for holding all simulation parameters.&quot;&quot;&quot;
    def __init__(self,
                 xmax: float,
                 res: int,
                 dt: float,
                 timesteps: int,
                 im_time: bool) -&gt; None:

        self.xmax = xmax
        self.res = res
        self.dt = dt
        self.timesteps = timesteps
        self.im_time = im_time

        self.dx = 2 * xmax / res
        self.x = np.arange(-xmax + xmax / res, xmax, self.dx)
        self.dk = pi / xmax
        self.k = np.concatenate((np.arange(0, res / 2),
                                 np.arange(-res / 2, 0))) * self.dk
</code></pre>
<pre><code class="language-haskell">data Parameters = Parameters
  { xmax :: Double
  , res :: Int
  , dt :: Double
  , timesteps :: Int
  , dx :: Double
  , x :: Vector
  , dk :: Double
  , ks :: Vector
  , imTime :: Bool
  }

defaultParameters :: Parameters
defaultParameters = makeParameters 10 512 0.01 1000 True

makeParameters :: Double -&gt; Int -&gt; Double -&gt; Int -&gt; Bool -&gt; Parameters
makeParameters xmax res dt timesteps imTime =
  let fi = fromIntegral
      rng = (0, res - 1)
      ks = [0 .. div res 2 - 1] ++ [-div res 2 .. -1]
   in Parameters
        xmax
        res
        dt
        timesteps
        (2 * xmax / fi res)
        (listArray rng $
         map (\n -&gt; xmax * (-1 + 2 * fi n / fi res) :+ 0) [1 .. res])
        (pi / xmax)
        (listArray rng $ map ((:+ 0) . (pi / xmax *) . fi) ks)
        imTime
</code></pre>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Parameters {
    xmax: f64,
    res: usize,
    dt: f64,
    timesteps: usize,
    dx: f64,
    x: Vec&lt;f64&gt;,
    dk: f64,
    k: Vec&lt;f64&gt;,
    im_time: bool,
}

impl Parameters {
    pub fn new(xmax: f64, res: usize, dt: f64, timesteps: usize, im_time: bool) -&gt; Parameters {
        let dx = 2.0_f64 * xmax / (res as f64);
        let mut x: Vec&lt;f64&gt; = Vec::with_capacity(res);
        let dk = PI / xmax;
        let mut k: Vec&lt;f64&gt; = Vec::with_capacity(res);
        for i in 0..res {
            x.push(xmax / (res as f64) - xmax + (i as f64) * dx);
            match i {
                i if (i &lt; res / 2) =&gt; k.push((i as f64) * PI / xmax),
                _ =&gt; k.push(((i as f64) - (res as f64)) * PI / xmax),
            }
        }
        Parameters {
            xmax,
            res,
            dt,
            timesteps,
            im_time,
            dx,
            x,
            dk,
            k,
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>As a note, when we generate our grid in momentum space <code>k</code>, we need to split the grid into two lines, one that is going from <code>0</code> to <code>-kmax</code> and is then discontinuous and goes from <code>kmax</code> to <code>0</code>.
This is simply because the FFT will naturally assume that the <code>0</code> in our grid is at the left side of the simulation, so we shift k-space to match this expectation.
Also, for this code we will be using notation to what we used above: <code>opr.R</code> will be the real space operators and <code>opr.K</code> will be the momentum space operators.
There is another Boolean value here called <code>im_time</code>, which is for imaginary time evolution.</p>
<p>Afterwards, we turn them into operators:</p>
<pre><code class="language-julia">mutable struct Operators
    V::Vector{Complex{Float64}}
    R::Vector{Complex{Float64}}
    K::Vector{Complex{Float64}}
    wfc::Vector{Complex{Float64}}

    Operators(res) = new(zeros(res),
                         zeros(res),
                         zeros(res),
                         zeros(res))
end

# Function to initialize the wfc and potential
function init(par::Param, voffset::Float64, wfcoffset::Float64)
    opr = Operators(length(par.x))
    opr.V = 0.5 * (par.x .- voffset).^2
    opr.wfc = exp.(-(par.x .- wfcoffset).^2/2)
    if (par.im_time)
        opr.K = exp.(-0.5*par.k.^2*par.dt)
        opr.R = exp.(-0.5*opr.V*par.dt)
    else
        opr.K = exp.(-im*0.5*par.k.^2*par.dt)
        opr.R = exp.(-im*0.5*opr.V*par.dt)
    end

    return opr
end
</code></pre>
<pre><code class="language-c">struct operators {
    size_t size;
    double complex *v;
    double complex *pe;
    double complex *ke;
    double complex *wfc;
};
</code></pre>
<p><a href="split-operator_method/code/c/split_op.c">import:75-96, lang:&quot;c&quot;</a></p>
<pre><code class="language-cpp">struct Operators {
public:
    Operators(Params &amp;par, double voffset,
              double wfcoffset) {
        size = par.res;
        v.reserve(size);
        pe.reserve(size);
        ke.reserve(size);
        wfc.reserve(size);

        for (size_t i = 0; i &lt; size; ++i) {
            v.push_back(0.5 * pow(par.x[i] - voffset, 2));
            wfc.push_back(exp(-pow(par.x[i] - wfcoffset, 2) / 2.0));

            if (par.im_time) {
                ke.push_back(exp(-0.5 * par.dt * pow(par.k[i], 2)));
                pe.push_back(exp(-0.5 * par.dt * v[i]));
            } else {
                ke.push_back(exp(-0.5 * par.dt * pow(par.k[i], 2) * complex(0.0, 1.0)));
                pe.push_back(exp(-0.5 * par.dt * v[i] * complex(0.0, 1.0)));
            }
        }
    }

    size_t size;
    vector_complex v;
    vector_complex pe;
    vector_complex ke;
    vector_complex wfc;
};
</code></pre>
<pre><code class="language-python">class Operators:
    &quot;&quot;&quot;Container for holding operators and wavefunction coefficients.&quot;&quot;&quot;
    def __init__(self, res: int) -&gt; None:

        self.V = np.empty(res, dtype=complex)
        self.R = np.empty(res, dtype=complex)
        self.K = np.empty(res, dtype=complex)
        self.wfc = np.empty(res, dtype=complex)


def init(par: Param, voffset: float, wfcoffset: float) -&gt; Operators:
    &quot;&quot;&quot;Initialize the wavefunction coefficients and the potential.&quot;&quot;&quot;
    opr = Operators(len(par.x))
    opr.V = 0.5 * (par.x - voffset) ** 2
    opr.wfc = np.exp(-((par.x - wfcoffset) ** 2) / 2, dtype=complex)
    if par.im_time:
        opr.K = np.exp(-0.5 * (par.k ** 2) * par.dt)
        opr.R = np.exp(-0.5 * opr.V * par.dt)
    else:
        opr.K = np.exp(-0.5 * (par.k ** 2) * par.dt * 1j)
        opr.R = np.exp(-0.5 * opr.V * par.dt * 1j)
    return opr
</code></pre>
<pre><code class="language-haskell">data Operators = Operators
  { v :: Vector
  , rStep :: Vector
  , kStep :: Vector
  , wfc :: Vector
  }

makeOperators :: Parameters -&gt; Complex Double -&gt; Complex Double -&gt; Operators
makeOperators param v0 wfc0 =
  let rng = (0, res param - 1)
      time
        | imTime param = dt param :+ 0
        | otherwise = 0 :+ dt param
      v = liftArray (\x -&gt; 0.5 * (x - v0) ^ 2) (x param)
      rStep = liftArray (\x -&gt; exp (-0.5 * time * x)) v
      kStep = liftArray (\k -&gt; exp (-0.5 * time * k ^ 2)) (ks param)
      wfc = liftArray (\x -&gt; exp (-(x - wfc0) ^ 2 / 2)) (x param)
   in Operators v rStep kStep (normalize (dx param) wfc)
</code></pre>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Operators {
    v: Vec&lt;Complex&lt;f64&gt;&gt;,
    pe: Vec&lt;Complex&lt;f64&gt;&gt;,
    ke: Vec&lt;Complex&lt;f64&gt;&gt;,
    wfc: Vec&lt;Complex&lt;f64&gt;&gt;,
}

impl Operators {
    pub fn new(par: &amp;Parameters, v_offset: f64, wfc_offset: f64) -&gt; Operators {
        let mut v: Vec&lt;Complex&lt;f64&gt;&gt; = Vec::with_capacity(par.res);
        let mut pe: Vec&lt;Complex&lt;f64&gt;&gt; = Vec::with_capacity(par.res);
        let mut ke: Vec&lt;Complex&lt;f64&gt;&gt; = Vec::with_capacity(par.res);
        let mut wfc: Vec&lt;Complex&lt;f64&gt;&gt; = Vec::with_capacity(par.res);

        for i in 0..par.res {
            v.push(Complex::new(
                0.5_f64 * (par.x[i] - v_offset).powi(2),
                0.0_f64,
            ));
            wfc.push(Complex::new(
                (-((par.x[i] - wfc_offset).powi(2)) / 2.0_f64).exp(),
                0.0_f64,
            ));
            if par.im_time {
                ke.push(Complex::new(
                    (-0.5_f64 * par.dt * par.k[i].powi(2)).exp(),
                    0.0_f64,
                ));
                pe.push(Complex::new((-0.5_f64 * par.dt * v[i].re).exp(), 0.0_f64));
            } else {
                ke.push(Complex::new(
                    0.0_f64,
                    (-0.5_f64 * par.dt * par.k[i].powi(2)).exp(),
                ));
                pe.push(Complex::new(0.0_f64, (-0.5_f64 * par.dt * v[i].re).exp()));
            }
        }
        Operators { v, pe, ke, wfc }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Here, we use a standard harmonic potential for the atoms to sit in and a Gaussian distribution for an initial guess for the probability distribution.
If we give either the trap or the atoms a slight offset (so the Gaussian distribution of atoms does not <em>quite</em> rest at the bottom of the \( x^2 \) potential, we can see the atoms moving back and forth in the potential as we move the simulation forward in time.
This means that we can easily see the dynamics of our quantum system!
If we run the simulation in imaginary time, we will see the Gaussian distribution of atoms move towards the center of the potential, which is the location with the lowest energy.
Both of these have been shown in the figures above.</p>
<p>The final step is to do the iteration, itself.</p>
<pre><code class="language-julia">function split_op!(par::Param, opr::Operators)

    for i = 1:par.timesteps
        # Half-step in real space
        opr.wfc = opr.wfc .* opr.R

        # fft to momentum space
        opr.wfc = fft(opr.wfc)

        # Full step in momentum space
        opr.wfc = opr.wfc .* opr.K

        # ifft back
        opr.wfc = ifft(opr.wfc)

        # final half-step in real space
        opr.wfc = opr.wfc .* opr.R

        # density for plotting and potential
        density = abs2.(opr.wfc)

        # renormalizing for imaginary time
        if (par.im_time)
            renorm_factor = sum(density) * par.dx

            for j = 1:length(opr.wfc)
                opr.wfc[j] /= sqrt(renorm_factor)
            end
        end

        # Outputting data to file. Plotting can also be done in a similar way
        # This is set to output exactly 100 files, no matter how many timesteps
        if ((i-1) % div(par.timesteps, 100) == 0)
            outfile = open(&quot;output&quot; * string(lpad(string(i-1), 5, string(0)))
                                    * &quot;.dat&quot;,&quot;w&quot;)

            # Outputting for gnuplot. Any plotter will do.
            for j = 1:length(density)
                write(outfile, string(par.x[j]) * &quot;\t&quot;
                               * string(density[j]) * &quot;\t&quot;
                               * string(real(opr.V[j])) * &quot;\n&quot;)
            end

            close(outfile)
            println(&quot;Outputting step: &quot;, i)
        end
    end
end
</code></pre>
<pre><code class="language-c">void split_op(struct params par, struct operators opr) {
    double density[opr.size];

    for (size_t i = 0; i &lt; par.timesteps; ++i) {
        for (size_t j = 0; j &lt; opr.size; ++j) {
            opr.wfc[j] *= opr.pe[j];
        }

        fft(opr.wfc, opr.size, false);

        for (size_t j = 0; j &lt; opr.size; ++j) {
            opr.wfc[j] *= opr.ke[j];
        }

        fft(opr.wfc, opr.size, true);

        for (size_t j = 0; j &lt; opr.size; ++j) {
            opr.wfc[j] *= opr.pe[j];
        }

        for (size_t j = 0; j &lt; opr.size; ++j) {
            density[j] = pow(cabs(opr.wfc[j]), 2);
        }

        if (par.im_time) {
            double sum = 0;

            for (size_t j = 0; j &lt; opr.size; ++j) {
                sum += density[j];
            }

            sum *= par.dx;

            for (size_t j = 0; j &lt; opr.size; ++j) {
                opr.wfc[j] /= sqrt(sum);
            }
        }

        // Writing data into a file in the format of:
        // index, density, real potential.
        char filename[256];
        sprintf(filename, &quot;output%lu.dat&quot;, i);
        FILE *fp = fopen(filename, &quot;w&quot;);

        for (int i = 0; i &lt; opr.size; ++i) {
            fprintf(fp, &quot;%d\t%f\t%f\n&quot;, i, density[i], creal(opr.v[i]));
        }

        fclose(fp);
    }
}
</code></pre>
<pre><code class="language-cpp">void split_op(Params &amp;par, Operators &amp;opr) {
    double density[opr.size];

    for (size_t i = 0; i &lt; par.timesteps; ++i) {
        for (size_t j = 0; j &lt; opr.size; ++j) {
            opr.wfc[j] *= opr.pe[j];
        }

        fft(opr.wfc, false);

        for (size_t j = 0; j &lt; opr.size; ++j) {
            opr.wfc[j] *= opr.ke[j];
        }

        fft(opr.wfc, true);

        for (size_t j = 0; j &lt; opr.size; ++j) {
            opr.wfc[j] *= opr.pe[j];
        }

        for (size_t j = 0; j &lt; opr.size; ++j) {
            density[j] = pow(abs(opr.wfc[j]), 2);
        }

        if (par.im_time) {
            double sum = 0;

            for (size_t j = 0; j &lt; opr.size; ++j) {
                sum += density[j];
            }

            sum *= par.dx;

            for (size_t j = 0; j &lt; opr.size; ++j) {
                opr.wfc[j] /= sqrt(sum);
            }
        }

        // Writing data into a file in the format of:
        // index, density, real potential.
        std::stringstream filename_stream;
        filename_stream &lt;&lt; &quot;output&quot; &lt;&lt; i &lt;&lt; &quot;.dat&quot;;

        std::ofstream fstream = std::ofstream(filename_stream.str());

        if (fstream) {
            for (int i = 0; i &lt; opr.size; ++i) {
                std::stringstream data_stream;

                data_stream &lt;&lt; i &lt;&lt; &quot;\t&quot; &lt;&lt; density[i] &lt;&lt; &quot;\t&quot; &lt;&lt; real(opr.v[i]) &lt;&lt; &quot;\n&quot;;

                fstream.write(data_stream.str().c_str(), data_stream.str().length());
            }
        }

        fstream.close();
    }
}
</code></pre>
<pre><code class="language-python">def split_op(par: Param, opr: Operators) -&gt; None:

    for i in range(par.timesteps):

        # Half-step in real space
        opr.wfc *= opr.R

        # FFT to momentum space
        opr.wfc = np.fft.fft(opr.wfc)

        # Full step in momentum space
        opr.wfc *= opr.K

        # iFFT back
        opr.wfc = np.fft.ifft(opr.wfc)

        # Final half-step in real space
        opr.wfc *= opr.R

        # Density for plotting and potential
        density = np.abs(opr.wfc) ** 2

        # Renormalizing for imaginary time
        if par.im_time:
            renorm_factor = sum(density) * par.dx
            opr.wfc /= sqrt(renorm_factor)

        # Outputting data to file. Plotting can also be done in a
        # similar way. This is set to output exactly 100 files, no
        # matter how many timesteps were specified.
        if i % (par.timesteps // 100) == 0:
            filename = &quot;output{}.dat&quot;.format(str(i).rjust(5, str(0)))
            with open(filename, &quot;w&quot;) as outfile:
                # Outputting for gnuplot. Any plotter will do.
                for j in range(len(density)):
                    template = &quot;{}\t{}\t{}\n&quot;.format
                    line = template(par.x[j], density[j].real, opr.V[j].real)
                    outfile.write(line)
            print(&quot;Outputting step: &quot;, i + 1)
</code></pre>
<pre><code class="language-haskell">evolve :: Parameters -&gt; Operators -&gt; [Operators]
evolve param op@(Operators _ rStep kStep _) = iterate splitop op
  where
    splitop op = op {wfc = wfc' op}
    wfc' = norm . (rStep .*) . idft . (kStep .*) . dft . (rStep .*) . wfc
    norm = if imTime param then normalize (dx param) else id
</code></pre>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn split_op(par: &amp;Parameters, opr: &amp;mut Operators) {
    let mut density: Vec&lt;f64&gt;;

    for i in 0..par.timesteps {
        for j in 0..par.res {
            opr.wfc[j] *= opr.pe[j];
        }

        fft(&amp;mut opr.wfc, false);

        for j in 0..par.res {
            opr.wfc[j] *= opr.ke[j];
        }

        fft(&amp;mut opr.wfc, true);

        for j in 0..par.res {
            opr.wfc[j] *= opr.pe[j];
        }

        density = opr.wfc.iter().map(|x| x.norm().powi(2)).collect();

        if par.im_time {
            let sum = density.iter().sum::&lt;f64&gt;() * par.dx;

            for j in 0..par.res {
                opr.wfc[j] /= sum.sqrt();
            }
        }

        // Writing data into a file in the format of:
        // index, density, real potential.
        let path_name = format!(&quot;output{}.dat&quot;, i);
        let path = Path::new(&amp;path_name);
        let display = path.display();

        let mut file = match File::create(&amp;path) {
            Err(why) =&gt; panic!(&quot;Couldn't create {}: {}&quot;, display, why),
            Ok(good) =&gt; good,
        };

        for j in 0..par.res {
            if let Err(why) = writeln!(file, &quot;{}\t{}\t{}&quot;, j, density[j], opr.v[j].re) {
                panic!(&quot;Couldn't write to {}: {}&quot;, display, why)
            }
            if let Err(why) = file.flush() {
                panic!(&quot;Couldn't flush {}: {}&quot;, display, why)
            }
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>And that's it.</p>
<p>There is something a bit odd about the simulation in imaginary time, though.
Basically, in imaginary time, we see an exponential decay of all the higher energy states, which means we are technically losing a large amount of our wavefunction density every timestep!
To solve this issue, we <em>renormalize</em> by enforcing that \( \int_{-\infty}^{+\infty}\Psi^\ast\Psi dx = 1 \).
As you can see from the code, this involves summing the density, multiplying that sum by <code>dx</code>, and then dividing each element in the wavefunction by the <code>sqrt()</code> of that value.</p>
<p>The Split-Operator method is one of the most commonly used quantum simulation algorithms because of how straightforward it is to code and how quickly you can start really digging into the physics of the simulation results!</p>
<h2 id="video-explanation-10"><a class="header" href="#video-explanation-10">Video Explanation</a></h2>
<p>Here is a video describing the split-operator method:</p>
<div style="text-align:center">
<iframe width="560" height="315" src="https://www.youtube.com/embed/BBt8EugN03Q" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
</div>
<h2 id="example-code-16"><a class="header" href="#example-code-16">Example Code</a></h2>
<p>This example code is a simulation of a Gaussian distribution of atoms slightly offset in a harmonic trap in imaginary time.
So long as the code is written appropriately, this means that the atoms should move towards the center of the trap and the energy should decay to \( \frac{1}{2}\hbar\omega \), which will be simply \( \frac{1}{2} \) in this simulation.
Checking to make sure your code can output the correct energy for a harmonic trap is a good test to make sure it is all working under-the-hood before simulating systems with more complicated Hamiltonians.</p>
<pre><code class="language-julia">#------------split_op.jl-------------------------------------------------------#
#
# Plotting: to plot individual timesteps, use gnuplot like so:
#               p &quot;output00000.dat&quot; u 1:2 w l
#               rep &quot;output00000.dat&quot; u 1:3 w l
#
#------------------------------------------------------------------------------#

using FFTW

struct Param
    xmax::Float64
    res::Int64
    dt::Float64
    timesteps::Int64
    dx::Float64
    x::Vector{Float64}
    dk::Float64
    k::Vector{Float64}
    im_time::Bool

    Param() = new(10.0, 512, 0.05, 1000, 2 * 10.0/512,
                  Vector{Float64}(-10.0 + 10.0/512 : 20.0/512 : 10.0),
                  pi / 10.0,
                  Vector{Float64}(vcat(0:512/2 - 1, -512/2 : -1) * pi/10.0),
                  false)
    Param(xmax::Float64, res::Int64, dt::Float64, timesteps::Int64,
          im_val::Bool) = new(
              xmax, res, dt, timesteps,
              2*xmax/res, Vector{Float64}(-xmax+xmax/res:2*xmax/res:xmax),
              pi/xmax, Vector{Float64}(vcat(0:res/2-1, -res/2:-1)*pi/(xmax)),
              im_val
          )
end

mutable struct Operators
    V::Vector{Complex{Float64}}
    R::Vector{Complex{Float64}}
    K::Vector{Complex{Float64}}
    wfc::Vector{Complex{Float64}}

    Operators(res) = new(zeros(res),
                         zeros(res),
                         zeros(res),
                         zeros(res))
end

# Function to initialize the wfc and potential
function init(par::Param, voffset::Float64, wfcoffset::Float64)
    opr = Operators(length(par.x))
    opr.V = 0.5 * (par.x .- voffset).^2
    opr.wfc = exp.(-(par.x .- wfcoffset).^2/2)
    if (par.im_time)
        opr.K = exp.(-0.5*par.k.^2*par.dt)
        opr.R = exp.(-0.5*opr.V*par.dt)
    else
        opr.K = exp.(-im*0.5*par.k.^2*par.dt)
        opr.R = exp.(-im*0.5*opr.V*par.dt)
    end

    return opr
end

# Function for the split-operator loop
function split_op!(par::Param, opr::Operators)

    for i = 1:par.timesteps
        # Half-step in real space
        opr.wfc = opr.wfc .* opr.R

        # fft to momentum space
        opr.wfc = fft(opr.wfc)

        # Full step in momentum space
        opr.wfc = opr.wfc .* opr.K

        # ifft back
        opr.wfc = ifft(opr.wfc)

        # final half-step in real space
        opr.wfc = opr.wfc .* opr.R

        # density for plotting and potential
        density = abs2.(opr.wfc)

        # renormalizing for imaginary time
        if (par.im_time)
            renorm_factor = sum(density) * par.dx

            for j = 1:length(opr.wfc)
                opr.wfc[j] /= sqrt(renorm_factor)
            end
        end

        # Outputting data to file. Plotting can also be done in a similar way
        # This is set to output exactly 100 files, no matter how many timesteps
        if ((i-1) % div(par.timesteps, 100) == 0)
            outfile = open(&quot;output&quot; * string(lpad(string(i-1), 5, string(0)))
                                    * &quot;.dat&quot;,&quot;w&quot;)

            # Outputting for gnuplot. Any plotter will do.
            for j = 1:length(density)
                write(outfile, string(par.x[j]) * &quot;\t&quot;
                               * string(density[j]) * &quot;\t&quot;
                               * string(real(opr.V[j])) * &quot;\n&quot;)
            end

            close(outfile)
            println(&quot;Outputting step: &quot;, i)
        end
    end
end

# We are calculating the energy to check &lt;Psi|H|Psi&gt;
function calculate_energy(par, opr)
    # Creating real, momentum, and conjugate wavefunctions
    wfc_r = opr.wfc
    wfc_k = fft(wfc_r)
    wfc_c = conj(wfc_r)

    # Finding the momentum and real-space energy terms
    energy_k = 0.5*wfc_c.*ifft((par.k.^2) .* wfc_k)
    energy_r = wfc_c.*opr.V .* wfc_r

    # Integrating over all space
    energy_final = 0
    for i = 1:length(energy_k)
        energy_final += real(energy_k[i] + energy_r[i])
    end

    return energy_final*par.dx
end

# main function
function main()
    par = Param(5.0, 256, 0.05, 100, true)

    # Starting wavefunction slightly offset so we can see it change
    opr = init(par, 0.0, -1.00)
    split_op!(par, opr)

    energy = calculate_energy(par, opr)
    println(&quot;Energy is: &quot;, energy)
end

main()
</code></pre>
<pre><code class="language-c">#include &lt;complex.h&gt;
#include &lt;stdbool.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;math.h&gt;

// Using fftw3 library.
#include &lt;fftw3.h&gt;

struct params {
    double xmax;
    unsigned int res;
    double dt;
    unsigned int timesteps;
    double dx;
    double *x;
    double dk;
    double *k;
    bool im_time;
};

struct operators {
    size_t size;
    double complex *v;
    double complex *pe;
    double complex *ke;
    double complex *wfc;
};

void fft(double complex *x, int n, bool inverse) {
    double complex y[n];
    memset(y, 0, sizeof(y));
    fftw_plan p;

    if (inverse) {
        p = fftw_plan_dft_1d(n, (fftw_complex*)x, (fftw_complex*)y,
                             FFTW_BACKWARD, FFTW_ESTIMATE);
    } else {
        p = fftw_plan_dft_1d(n, (fftw_complex*)x, (fftw_complex*)y,
                             FFTW_FORWARD, FFTW_ESTIMATE);
    }

    fftw_execute(p);
    fftw_destroy_plan(p);

    for (size_t i = 0; i &lt; n; ++i) {
        x[i] = y[i] / sqrt((double)n);
    }
}

void init_params(struct params *par, double xmax, unsigned int res, double dt,
                 unsigned int timesteps, bool im) {

    par-&gt;xmax = xmax;
    par-&gt;res = res;
    par-&gt;dt = dt;
    par-&gt;timesteps = timesteps;
    par-&gt;dx = 2.0 * xmax / res;
    par-&gt;x = malloc(sizeof(double) * res);
    par-&gt;dk = M_PI / xmax;
    par-&gt;k = malloc(sizeof(double) * res);
    par-&gt;im_time = im;

    for (size_t i = 0; i &lt; res; ++i) {
        par-&gt;x[i] = xmax / res - xmax + i * (2.0 * xmax / res);
        if (i &lt; res / 2) {
            par-&gt;k[i] = i * M_PI / xmax;
        } else {
            par-&gt;k[i] = ((double)i - res) * M_PI / xmax;
        }
    }
}

void init_operators(struct operators *opr, struct params par, double voffset,
                    double wfcoffset) {

    opr-&gt;size = par.res;
    opr-&gt;v = malloc(sizeof(double complex) * par.res);
    opr-&gt;pe = malloc(sizeof(double complex) * par.res);
    opr-&gt;ke = malloc(sizeof(double complex) * par.res);
    opr-&gt;wfc = malloc(sizeof(double complex) * par.res);

    for (size_t i = 0; i &lt; par.res; ++i) {
        opr-&gt;v[i] = 0.5 * cpow(par.x[i] - voffset, 2);
        opr-&gt;wfc[i] = cexp(-cpow(par.x[i] - wfcoffset, 2) / 2.0);

        if (par.im_time) {
            opr-&gt;ke[i] = cexp(-0.5 * par.dt * cpow(par.k[i], 2));
            opr-&gt;pe[i] = cexp(-0.5 * par.dt * opr-&gt;v[i]);
        } else {
            opr-&gt;ke[i] = cexp(-0.5 * par.dt * cpow(par.k[i], 2) * I);
            opr-&gt;pe[i] = cexp(-0.5 * par.dt * opr-&gt;v[i] * I);
        }
    }
}

void split_op(struct params par, struct operators opr) {
    double density[opr.size];

    for (size_t i = 0; i &lt; par.timesteps; ++i) {
        for (size_t j = 0; j &lt; opr.size; ++j) {
            opr.wfc[j] *= opr.pe[j];
        }

        fft(opr.wfc, opr.size, false);

        for (size_t j = 0; j &lt; opr.size; ++j) {
            opr.wfc[j] *= opr.ke[j];
        }

        fft(opr.wfc, opr.size, true);

        for (size_t j = 0; j &lt; opr.size; ++j) {
            opr.wfc[j] *= opr.pe[j];
        }

        for (size_t j = 0; j &lt; opr.size; ++j) {
            density[j] = pow(cabs(opr.wfc[j]), 2);
        }

        if (par.im_time) {
            double sum = 0;

            for (size_t j = 0; j &lt; opr.size; ++j) {
                sum += density[j];
            }

            sum *= par.dx;

            for (size_t j = 0; j &lt; opr.size; ++j) {
                opr.wfc[j] /= sqrt(sum);
            }
        }

        // Writing data into a file in the format of:
        // index, density, real potential.
        char filename[256];
        sprintf(filename, &quot;output%lu.dat&quot;, i);
        FILE *fp = fopen(filename, &quot;w&quot;);

        for (int i = 0; i &lt; opr.size; ++i) {
            fprintf(fp, &quot;%d\t%f\t%f\n&quot;, i, density[i], creal(opr.v[i]));
        }

        fclose(fp);
    }
}

double calculate_energy(struct params par, struct operators opr) {
    double complex wfc_r[opr.size];
    double complex wfc_k[opr.size];
    double complex wfc_c[opr.size];
    memcpy(wfc_r, opr.wfc, sizeof(wfc_r));

    memcpy(wfc_k, opr.wfc, sizeof(wfc_k));
    fft(wfc_k, opr.size, false);

    for (size_t i = 0; i &lt; opr.size; ++i) {
        wfc_c[i] = conj(wfc_r[i]);
    }

    double complex energy_k[opr.size];
    double complex energy_r[opr.size];

    for (size_t i = 0; i &lt; opr.size; ++i) {
        energy_k[i] = wfc_k[i] * cpow(par.k[i] + 0.0*I, 2);
    }

    fft(energy_k, opr.size, true);

    for (size_t i = 0; i &lt; opr.size; ++i) {
        energy_k[i] *= 0.5 * wfc_c[i];
        energy_r[i] = wfc_c[i] * opr.v[i] * wfc_r[i];
    }

    double energy_final = 0;

    for (size_t i = 0; i &lt; opr.size; ++i) {
        energy_final += creal(energy_k[i] + energy_r[i]);
    }

    return energy_final * par.dx;
}

void free_params(struct params par) {
    free(par.x);
    free(par.k);
}

void free_operators(struct operators opr) {
    free(opr.v);
    free(opr.pe);
    free(opr.ke);
    free(opr.wfc);
}

int main() {
    struct params par;
    struct operators opr;

    init_params(&amp;par, 5.0, 256, 0.05, 100, true);
    init_operators(&amp;opr, par, 0.0, -1.0);

    split_op(par, opr);

    printf(&quot;the energy is %f\n&quot;, calculate_energy(par, opr));

    free_params(par);
    free_operators(opr);

    return 0;
}
</code></pre>
<pre><code class="language-cpp">#include &lt;complex&gt;
#include &lt;vector&gt;
#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;fstream&gt;

// Using fftw3 library.
#include &lt;fftw3.h&gt;

#ifndef M_PI
#define M_PI 3.14159265358979323846
#endif

using complex = std::complex&lt;double&gt;;
using vector_real = std::vector&lt;double&gt;;
using vector_complex = std::vector&lt;complex&gt;;

struct Params {
    Params(double _xmax, unsigned int _res, double _dt, unsigned int _timesteps, bool im) {
        xmax = _xmax;
        res = _res;
        dt = _dt;
        timesteps = _timesteps;
        dx = 2.0 * xmax / res;
        x.reserve(res);
        dk = M_PI / xmax;
        k.reserve(res);
        im_time = im;

        for (size_t i = 0; i &lt; res; ++i) {
            x.emplace_back(xmax / res - xmax + i * (2.0 * xmax / res));
            if (i &lt; res / 2) {
                k.push_back(i * M_PI / xmax);
            } else {
                k.push_back((static_cast&lt;double&gt;(i) - res) * M_PI / xmax);
            }
        }
    }

    double xmax;
    unsigned int res;
    double dt;
    unsigned int timesteps;
    double dx;
    vector_real x;
    double dk;
    vector_real k;
    bool im_time;
};

struct Operators {
public:
    Operators(Params &amp;par, double voffset,
              double wfcoffset) {
        size = par.res;
        v.reserve(size);
        pe.reserve(size);
        ke.reserve(size);
        wfc.reserve(size);

        for (size_t i = 0; i &lt; size; ++i) {
            v.push_back(0.5 * pow(par.x[i] - voffset, 2));
            wfc.push_back(exp(-pow(par.x[i] - wfcoffset, 2) / 2.0));

            if (par.im_time) {
                ke.push_back(exp(-0.5 * par.dt * pow(par.k[i], 2)));
                pe.push_back(exp(-0.5 * par.dt * v[i]));
            } else {
                ke.push_back(exp(-0.5 * par.dt * pow(par.k[i], 2) * complex(0.0, 1.0)));
                pe.push_back(exp(-0.5 * par.dt * v[i] * complex(0.0, 1.0)));
            }
        }
    }

    size_t size;
    vector_complex v;
    vector_complex pe;
    vector_complex ke;
    vector_complex wfc;
};

void fft(vector_complex &amp;x, bool inverse) {
    std::vector&lt;std::complex&lt;double&gt;&gt; y(x.size(), std::complex&lt;double&gt;(0.0, 0.0));
    fftw_plan p;

    fftw_complex *in = reinterpret_cast&lt;fftw_complex*&gt;(x.data());
    fftw_complex *out = reinterpret_cast&lt;fftw_complex*&gt;(y.data());
    p = fftw_plan_dft_1d(x.size(), in, out,
                         (inverse ? FFTW_BACKWARD : FFTW_FORWARD), FFTW_ESTIMATE);

    fftw_execute(p);
    fftw_destroy_plan(p);

    for (size_t i = 0; i &lt; x.size(); ++i) {
        x[i] = y[i] / sqrt(static_cast&lt;double&gt;(x.size()));
    }
}

void split_op(Params &amp;par, Operators &amp;opr) {
    double density[opr.size];

    for (size_t i = 0; i &lt; par.timesteps; ++i) {
        for (size_t j = 0; j &lt; opr.size; ++j) {
            opr.wfc[j] *= opr.pe[j];
        }

        fft(opr.wfc, false);

        for (size_t j = 0; j &lt; opr.size; ++j) {
            opr.wfc[j] *= opr.ke[j];
        }

        fft(opr.wfc, true);

        for (size_t j = 0; j &lt; opr.size; ++j) {
            opr.wfc[j] *= opr.pe[j];
        }

        for (size_t j = 0; j &lt; opr.size; ++j) {
            density[j] = pow(abs(opr.wfc[j]), 2);
        }

        if (par.im_time) {
            double sum = 0;

            for (size_t j = 0; j &lt; opr.size; ++j) {
                sum += density[j];
            }

            sum *= par.dx;

            for (size_t j = 0; j &lt; opr.size; ++j) {
                opr.wfc[j] /= sqrt(sum);
            }
        }

        // Writing data into a file in the format of:
        // index, density, real potential.
        std::stringstream filename_stream;
        filename_stream &lt;&lt; &quot;output&quot; &lt;&lt; i &lt;&lt; &quot;.dat&quot;;

        std::ofstream fstream = std::ofstream(filename_stream.str());

        if (fstream) {
            for (int i = 0; i &lt; opr.size; ++i) {
                std::stringstream data_stream;

                data_stream &lt;&lt; i &lt;&lt; &quot;\t&quot; &lt;&lt; density[i] &lt;&lt; &quot;\t&quot; &lt;&lt; real(opr.v[i]) &lt;&lt; &quot;\n&quot;;

                fstream.write(data_stream.str().c_str(), data_stream.str().length());
            }
        }

        fstream.close();
    }
}

double calculate_energy(Params &amp;par, Operators &amp;opr) {
    vector_complex wfc_r(opr.wfc);
    vector_complex wfc_k(opr.wfc);
    vector_complex wfc_c(opr.size);
    fft(wfc_k, false);

    for (size_t i = 0; i &lt; opr.size; ++i) {
        wfc_c[i] = conj(wfc_r[i]);
    }

    vector_complex energy_k(opr.size);
    vector_complex energy_r(opr.size);

    for (size_t i = 0; i &lt; opr.size; ++i) {
        energy_k[i] = wfc_k[i] * pow(complex(par.k[i], 0.0), 2);
    }

    fft(energy_k, true);

    for (size_t i = 0; i &lt; opr.size; ++i) {
        energy_k[i] *= 0.5 * wfc_c[i];
        energy_r[i] = wfc_c[i] * opr.v[i] * wfc_r[i];
    }

    double energy_final = 0;

    for (size_t i = 0; i &lt; opr.size; ++i) {
        energy_final += real(energy_k[i] + energy_r[i]);
    }

    return energy_final * par.dx;
}

int main() {
    Params par = Params(5.0, 256, 0.05, 100, true);
    Operators opr = Operators(par, 0.0, -1.0);

    split_op(par, opr);

    std::cout &lt;&lt; &quot;The energy is &quot; &lt;&lt; calculate_energy(par, opr) &lt;&lt; &quot;\n&quot;;

    return 0;
}
</code></pre>
<pre><code class="language-python">from math import pi
from math import sqrt

import numpy as np


class Param:
    &quot;&quot;&quot;Container for holding all simulation parameters.&quot;&quot;&quot;
    def __init__(self,
                 xmax: float,
                 res: int,
                 dt: float,
                 timesteps: int,
                 im_time: bool) -&gt; None:

        self.xmax = xmax
        self.res = res
        self.dt = dt
        self.timesteps = timesteps
        self.im_time = im_time

        self.dx = 2 * xmax / res
        self.x = np.arange(-xmax + xmax / res, xmax, self.dx)
        self.dk = pi / xmax
        self.k = np.concatenate((np.arange(0, res / 2),
                                 np.arange(-res / 2, 0))) * self.dk


class Operators:
    &quot;&quot;&quot;Container for holding operators and wavefunction coefficients.&quot;&quot;&quot;
    def __init__(self, res: int) -&gt; None:

        self.V = np.empty(res, dtype=complex)
        self.R = np.empty(res, dtype=complex)
        self.K = np.empty(res, dtype=complex)
        self.wfc = np.empty(res, dtype=complex)


def init(par: Param, voffset: float, wfcoffset: float) -&gt; Operators:
    &quot;&quot;&quot;Initialize the wavefunction coefficients and the potential.&quot;&quot;&quot;
    opr = Operators(len(par.x))
    opr.V = 0.5 * (par.x - voffset) ** 2
    opr.wfc = np.exp(-((par.x - wfcoffset) ** 2) / 2, dtype=complex)
    if par.im_time:
        opr.K = np.exp(-0.5 * (par.k ** 2) * par.dt)
        opr.R = np.exp(-0.5 * opr.V * par.dt)
    else:
        opr.K = np.exp(-0.5 * (par.k ** 2) * par.dt * 1j)
        opr.R = np.exp(-0.5 * opr.V * par.dt * 1j)
    return opr


def split_op(par: Param, opr: Operators) -&gt; None:

    for i in range(par.timesteps):

        # Half-step in real space
        opr.wfc *= opr.R

        # FFT to momentum space
        opr.wfc = np.fft.fft(opr.wfc)

        # Full step in momentum space
        opr.wfc *= opr.K

        # iFFT back
        opr.wfc = np.fft.ifft(opr.wfc)

        # Final half-step in real space
        opr.wfc *= opr.R

        # Density for plotting and potential
        density = np.abs(opr.wfc) ** 2

        # Renormalizing for imaginary time
        if par.im_time:
            renorm_factor = sum(density) * par.dx
            opr.wfc /= sqrt(renorm_factor)

        # Outputting data to file. Plotting can also be done in a
        # similar way. This is set to output exactly 100 files, no
        # matter how many timesteps were specified.
        if i % (par.timesteps // 100) == 0:
            filename = &quot;output{}.dat&quot;.format(str(i).rjust(5, str(0)))
            with open(filename, &quot;w&quot;) as outfile:
                # Outputting for gnuplot. Any plotter will do.
                for j in range(len(density)):
                    template = &quot;{}\t{}\t{}\n&quot;.format
                    line = template(par.x[j], density[j].real, opr.V[j].real)
                    outfile.write(line)
            print(&quot;Outputting step: &quot;, i + 1)


def calculate_energy(par: Param, opr: Operators) -&gt; float:
    &quot;&quot;&quot;Calculate the energy &lt;Psi|H|Psi&gt;.&quot;&quot;&quot;
    # Creating real, momentum, and conjugate wavefunctions.
    wfc_r = opr.wfc
    wfc_k = np.fft.fft(wfc_r)
    wfc_c = np.conj(wfc_r)

    # Finding the momentum and real-space energy terms
    energy_k = 0.5 * wfc_c * np.fft.ifft((par.k ** 2) * wfc_k)
    energy_r = wfc_c * opr.V * wfc_r

    # Integrating over all space
    energy_final = sum(energy_k + energy_r).real

    return energy_final * par.dx


def main() -&gt; None:
    par = Param(5.0, 256, 0.05, 100, True)

    # Starting wavefunction slightly offset so we can see it change
    opr = init(par, 0.0, -1.00)
    split_op(par, opr)

    energy = calculate_energy(par, opr)
    print(&quot;Energy is: &quot;, energy)


if __name__ == &quot;__main__&quot;:
    main()
</code></pre>
<pre><code class="language-haskell">import Data.Array.CArray
import Data.Complex
import Data.List (intercalate, transpose)
import Math.FFT (dft, idft)

type Vector = CArray Int (Complex Double)

(.*), (.+) :: Vector -&gt; Vector -&gt; Vector
a .* b = liftArray2 (*) a b
a .+ b = liftArray2 (+) a b

normalize :: Double -&gt; Vector -&gt; Vector
normalize dx v =
  let factor = 1 / sqrt dx / norm2 v :+ 0
   in liftArray (factor *) v

data Parameters = Parameters
  { xmax :: Double
  , res :: Int
  , dt :: Double
  , timesteps :: Int
  , dx :: Double
  , x :: Vector
  , dk :: Double
  , ks :: Vector
  , imTime :: Bool
  }

defaultParameters :: Parameters
defaultParameters = makeParameters 10 512 0.01 1000 True

makeParameters :: Double -&gt; Int -&gt; Double -&gt; Int -&gt; Bool -&gt; Parameters
makeParameters xmax res dt timesteps imTime =
  let fi = fromIntegral
      rng = (0, res - 1)
      ks = [0 .. div res 2 - 1] ++ [-div res 2 .. -1]
   in Parameters
        xmax
        res
        dt
        timesteps
        (2 * xmax / fi res)
        (listArray rng $
         map (\n -&gt; xmax * (-1 + 2 * fi n / fi res) :+ 0) [1 .. res])
        (pi / xmax)
        (listArray rng $ map ((:+ 0) . (pi / xmax *) . fi) ks)
        imTime

data Operators = Operators
  { v :: Vector
  , rStep :: Vector
  , kStep :: Vector
  , wfc :: Vector
  }

makeOperators :: Parameters -&gt; Complex Double -&gt; Complex Double -&gt; Operators
makeOperators param v0 wfc0 =
  let rng = (0, res param - 1)
      time
        | imTime param = dt param :+ 0
        | otherwise = 0 :+ dt param
      v = liftArray (\x -&gt; 0.5 * (x - v0) ^ 2) (x param)
      rStep = liftArray (\x -&gt; exp (-0.5 * time * x)) v
      kStep = liftArray (\k -&gt; exp (-0.5 * time * k ^ 2)) (ks param)
      wfc = liftArray (\x -&gt; exp (-(x - wfc0) ^ 2 / 2)) (x param)
   in Operators v rStep kStep (normalize (dx param) wfc)

evolve :: Parameters -&gt; Operators -&gt; [Operators]
evolve param op@(Operators _ rStep kStep _) = iterate splitop op
  where
    splitop op = op {wfc = wfc' op}
    wfc' = norm . (rStep .*) . idft . (kStep .*) . dft . (rStep .*) . wfc
    norm = if imTime param then normalize (dx param) else id

calculateEnergy :: Parameters -&gt; Operators -&gt; Double
calculateEnergy param ops = (* dx param) . sum . map realPart $ elems totalE
  where
    totalE = potentialE .+ kineticE
    potentialE = wfcConj .* v ops .* wfc ops
    kineticOp = liftArray ((/ 2) . (^ 2)) (ks param)
    kineticE = wfcConj .* idft (kineticOp .* dft (wfc ops))
    wfcConj = liftArray conjugate $ wfc ops

-- Use gnuplot to make an animated  GIF using ../gnuplot/plot_output.plt
-- $ gnuplot -e &quot;folder='../haskell'&quot; plot_output.plt
printEvolution :: Parameters -&gt; [Operators] -&gt; IO ()
printEvolution param =
  mapM_ (export . (format &lt;$&gt;)) . zip [0 ..] . take 100 . skip
  where
    skip (x:xs) = x : skip (drop (div (timesteps param) 100 - 1) xs)
    format (Operators v _ _ wfc) =
      let density = liftArray ((^ 2) . abs) wfc
          values = map (map (show . realPart) . elems) [x param, density, v]
       in intercalate &quot;\n&quot; $ map (intercalate &quot;\t&quot;) $ transpose values
    export (i, f) = writeFile (&quot;output&quot; ++ pad (show i) ++ &quot;.dat&quot;) f
    pad n = replicate (5 - length n) '0' ++ n

main :: IO ()
main = do
  let p = defaultParameters
      o = makeOperators p 0 4
      evol = evolve p o
  print $ calculateEnergy p (evol !! timesteps p)
  printEvolution p evol
</code></pre>
<pre><pre class="playground"><code class="language-rust">extern crate num;
extern crate rustfft;

use num::complex::Complex;
use rustfft::FFTplanner;
use std::f64::consts::PI;
use std::fs::File;
use std::io::Write;
use std::path::Path;

// This implementation is based on the C and C++ implementations.

#[derive(Clone)]
struct Parameters {
    xmax: f64,
    res: usize,
    dt: f64,
    timesteps: usize,
    dx: f64,
    x: Vec&lt;f64&gt;,
    dk: f64,
    k: Vec&lt;f64&gt;,
    im_time: bool,
}

impl Parameters {
    pub fn new(xmax: f64, res: usize, dt: f64, timesteps: usize, im_time: bool) -&gt; Parameters {
        let dx = 2.0_f64 * xmax / (res as f64);
        let mut x: Vec&lt;f64&gt; = Vec::with_capacity(res);
        let dk = PI / xmax;
        let mut k: Vec&lt;f64&gt; = Vec::with_capacity(res);
        for i in 0..res {
            x.push(xmax / (res as f64) - xmax + (i as f64) * dx);
            match i {
                i if (i &lt; res / 2) =&gt; k.push((i as f64) * PI / xmax),
                _ =&gt; k.push(((i as f64) - (res as f64)) * PI / xmax),
            }
        }
        Parameters {
            xmax,
            res,
            dt,
            timesteps,
            im_time,
            dx,
            x,
            dk,
            k,
        }
    }
}

struct Operators {
    v: Vec&lt;Complex&lt;f64&gt;&gt;,
    pe: Vec&lt;Complex&lt;f64&gt;&gt;,
    ke: Vec&lt;Complex&lt;f64&gt;&gt;,
    wfc: Vec&lt;Complex&lt;f64&gt;&gt;,
}

impl Operators {
    pub fn new(par: &amp;Parameters, v_offset: f64, wfc_offset: f64) -&gt; Operators {
        let mut v: Vec&lt;Complex&lt;f64&gt;&gt; = Vec::with_capacity(par.res);
        let mut pe: Vec&lt;Complex&lt;f64&gt;&gt; = Vec::with_capacity(par.res);
        let mut ke: Vec&lt;Complex&lt;f64&gt;&gt; = Vec::with_capacity(par.res);
        let mut wfc: Vec&lt;Complex&lt;f64&gt;&gt; = Vec::with_capacity(par.res);

        for i in 0..par.res {
            v.push(Complex::new(
                0.5_f64 * (par.x[i] - v_offset).powi(2),
                0.0_f64,
            ));
            wfc.push(Complex::new(
                (-((par.x[i] - wfc_offset).powi(2)) / 2.0_f64).exp(),
                0.0_f64,
            ));
            if par.im_time {
                ke.push(Complex::new(
                    (-0.5_f64 * par.dt * par.k[i].powi(2)).exp(),
                    0.0_f64,
                ));
                pe.push(Complex::new((-0.5_f64 * par.dt * v[i].re).exp(), 0.0_f64));
            } else {
                ke.push(Complex::new(
                    0.0_f64,
                    (-0.5_f64 * par.dt * par.k[i].powi(2)).exp(),
                ));
                pe.push(Complex::new(0.0_f64, (-0.5_f64 * par.dt * v[i].re).exp()));
            }
        }
        Operators { v, pe, ke, wfc }
    }
}

fn fft(x: &amp;mut Vec&lt;Complex&lt;f64&gt;&gt;, inverse: bool) {
    let mut y = vec![Complex::new(0.0_f64, 0.0_f64); x.len()];
    let mut p = FFTplanner::new(inverse);
    let fft = p.plan_fft(x.len());
    fft.process(x, &amp;mut y);

    for i in 0..x.len() {
        x[i] = y[i] / (x.len() as f64).sqrt();
    }
}

fn split_op(par: &amp;Parameters, opr: &amp;mut Operators) {
    let mut density: Vec&lt;f64&gt;;

    for i in 0..par.timesteps {
        for j in 0..par.res {
            opr.wfc[j] *= opr.pe[j];
        }

        fft(&amp;mut opr.wfc, false);

        for j in 0..par.res {
            opr.wfc[j] *= opr.ke[j];
        }

        fft(&amp;mut opr.wfc, true);

        for j in 0..par.res {
            opr.wfc[j] *= opr.pe[j];
        }

        density = opr.wfc.iter().map(|x| x.norm().powi(2)).collect();

        if par.im_time {
            let sum = density.iter().sum::&lt;f64&gt;() * par.dx;

            for j in 0..par.res {
                opr.wfc[j] /= sum.sqrt();
            }
        }

        // Writing data into a file in the format of:
        // index, density, real potential.
        let path_name = format!(&quot;output{}.dat&quot;, i);
        let path = Path::new(&amp;path_name);
        let display = path.display();

        let mut file = match File::create(&amp;path) {
            Err(why) =&gt; panic!(&quot;Couldn't create {}: {}&quot;, display, why),
            Ok(good) =&gt; good,
        };

        for j in 0..par.res {
            if let Err(why) = writeln!(file, &quot;{}\t{}\t{}&quot;, j, density[j], opr.v[j].re) {
                panic!(&quot;Couldn't write to {}: {}&quot;, display, why)
            }
            if let Err(why) = file.flush() {
                panic!(&quot;Couldn't flush {}: {}&quot;, display, why)
            }
        }
    }
}

fn calculate_energy(par: &amp;Parameters, opr: &amp;Operators) -&gt; f64 {
    let wfc_r = opr.wfc.clone();
    let mut wfc_k = opr.wfc.clone();
    let mut wfc_c = vec![Complex::new(0.0_f64, 0.0_f64); par.res];

    fft(&amp;mut wfc_k, false);

    for i in 0..par.res {
        wfc_c[i] = wfc_r[i].conj();
    }

    let mut energy_k = vec![Complex::new(0.0_f64, 0.0_f64); par.res];
    let mut energy_r = vec![Complex::new(0.0_f64, 0.0_f64); par.res];

    for i in 0..par.res {
        energy_k[i] = wfc_k[i] * Complex::new(par.k[i], 0.0_f64).powi(2);
    }

    fft(&amp;mut energy_k, true);

    for i in 0..par.res {
        energy_k[i] *= wfc_c[i].scale(0.5_f64);
        energy_r[i] = wfc_c[i] * opr.v[i] * wfc_r[i];
    }

    let energy_final = energy_k
        .into_iter()
        .zip(energy_r.into_iter())
        .fold(0.0_f64, |acc, x| acc + (x.0 + x.1).re);

    energy_final * par.dx
}

fn main() {
    let par = Parameters::new(5.0, 256, 0.05, 100, true);
    let mut opr = Operators::new(&amp;par, 0.0, -1.0);

    split_op(&amp;par, &amp;mut opr);

    println!(&quot;The energy is {}&quot;, calculate_energy(&amp;par, &amp;opr));
}
</code></pre></pre>
<h2 id="license-33"><a class="header" href="#license-33">License</a></h2>
<h5 id="code-examples-31"><a class="header" href="#code-examples-31">Code Examples</a></h5>
<p>The code examples are licensed under the MIT license (found in <a href="https://github.com/algorithm-archivists/algorithm-archive/blob/master/LICENSE.md">LICENSE.md</a>).</p>
<h5 id="text-33"><a class="header" href="#text-33">Text</a></h5>
<p>The text of this chapter was written by <a href="https://github.com/leios">James Schloss</a> and is licensed under the <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</p>
<p><a href="https://creativecommons.org/licenses/by-sa/4.0/"><p><img  class="center" src="split-operator_method/../cc/CC-BY-SA_icon.svg" /></p></a></p>
<h5 id="imagesgraphics-16"><a class="header" href="#imagesgraphics-16">Images/Graphics</a></h5>
<ul>
<li>The image &quot;<a href="split-operator_method/res/split_op_method.svg">split_op_method</a>&quot; was created by <a href="https://github.com/julianschacher">Julian Schacher</a> and is licensed under the <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</li>
<li>The animation &quot;<a href="split-operator_method/res/real_time.gif">realsplitop</a>&quot; was created by <a href="https://github.com/leios">James Schloss</a> and is licensed under the <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</li>
<li>The animation &quot;<a href="split-operator_method/res/imaginary_time.gif">imaginarysplitop</a>&quot; was created by <a href="https://github.com/leios">James Schloss</a> and is licensed under the <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</li>
</ul>
<h5 id="pull-requests-30"><a class="header" href="#pull-requests-30">Pull Requests</a></h5>
<p>After initial licensing (<a href="https://github.com/algorithm-archivists/algorithm-archive/pull/560">#560</a>), the following pull requests have modified the text or graphics of this chapter:</p>
<ul>
<li>none</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="data-compression"><a class="header" href="#data-compression">Data Compression</a></h1>
<p>I'll be honest, data compression used to be an incredibly hot topic, but kids these days usually have incredibly powerful devices that do not seem to be memory-limited at all.
Because of this, it seems odd to talk about data compression as a field of intense debate and development.
It would naively seem that better hardware means that there are less restrictions on programmers and less of a need to search for new and unique ways to compress their data; however, this is far from the case.</p>
<p>That said, there will always be new devices on the market that require minimizing data storage.
In fact, some of the most revolutionary algorithms and methods in existence today fall in the category of data compression.
From lossless data compression with <a href="data_compression/../huffman_encoding/huffman_encoding.html">Huffman encoding</a> to genetic compression algorithms and machine learning, there is a lot to learn about this field, and we'll go through it piece-by-piece.</p>
<p>All that said, no discussion about data compression is complete without first discussing the information, itself -- specifically how information is represented in computer systems.
Now, we've discussed this in some depth before with <a href="data_compression/../../principles_of_code/building_blocks/bitlogic.html">bitlogic</a>, but there is much more to the story than what we let on before.
Let's start with a working definition of information:</p>
<p><em>Information is a representation of certainty.</em></p>
<p>This might seem like a silly, hand-wavey definition, but hear me out.
If I am uncertain about something, I will ask a question.
The answer to this question could be any number of things, but it will contain information from an individual with some level of certainty.
For example, let's pretend you have been furiously coding for months in your mother's basement (it happens).
At some point, you realize you haven't gone outside and are completely unaware of the day, month, or even year!
As your mother slips food under your door one day, you reach out to her and ask, &quot;What's it like outside today?&quot;
Overjoyed at the prospect of her child finally leaving their room, your mother might say, &quot;It's bright, sunny and warm. A perfect day to go outside and relax!&quot;
This provides you a lot of information, and to some degree of certainty you can conclude it is summer.</p>
<p>Of course, after this interaction you do not acknowledge your mother's existence after her answer and go back to coding.
You have the information you need.
No reason to overcomplicate things with further human contact.</p>
<p>See, information is defined in a number of different places for a number of different reasons, so for our purposes, we will define the unit of information to be the <em>bit</em>, a simple binary 1 or 0.
Taking the example mentioned before (assuming you can take your mother at face-value), you were provided 3 true statements:</p>
<ol>
<li>It is bright</li>
<li>It is sunny</li>
<li>It is warm</li>
</ol>
<p>With this information, you assumed that it was probably summer.
Unfortunately, your assumption about it being summer is not information.
It might be a logical conclusion, but it was not provided as a &quot;fact.&quot;
This is an important distinction between what we might colloquially describe as information and what information theory requires.
Information theory works with measurements -- binary absolutes.</p>
<p>Now, we can clearly say that <em>with some probability</em> it is summer, but this is a different story altogether, which we will undoubtedly discuss in the future.
For now, let's talk about a simple representation of information on computer systems.
Imagine you have a simple alphabet with only 2 characters in it, <em>a</em> and <em>b</em>.
In this case, there are plenty of ways you can represent these characters in bits, but the most obvious way might look like this:</p>
<table><thead><tr><th>Character</th><th>Bit Representation</th></tr></thead><tbody>
<tr><td><em>a</em></td><td>0</td></tr>
<tr><td><em>b</em></td><td>1</td></tr>
</tbody></table>
<p>So long as you don't add any new characters to the mix, this is a perfectly valid set of codewords.
If you get the bitstring 0111101, you can easily decode it as <em>abbbbab</em>.</p>
<p>But what if you wanted to add a third character, <em>c</em>?
Well, it's clear that <em>c</em> cannot be either 0 or 1, but because of the way we have defined the set of codewords above, it actually cannot be <em>any combination</em> of 0 or 1 either.
For example, if we defined <em>c</em> to be 01 and we were provided the bitstring 0111101, we could interpret this string as either <em>abbbbab</em> or <em>cbbbc</em>!
Now, we could use context or other information provided to distinguish these two possible cases, but it is clear that we need to think more deeply about our set of codewords in this case.</p>
<p>First, let's think a bit about decoding.
For our purposes, we do not want to think when decoding.
No matter what the bitstring is that we need to decode, we want to be able to read bit-by-bit until we find a match in our set of codewords and move on.
Basically, we do not want any ambiguity in our set of codewords.
The code for <em>c</em> should not contain the code for <em>a</em> or <em>b</em>!
In this way, our set of codewords should be <em>prefix-free</em>.
No word should appear as a prefix to another word.</p>
<p>If we wanted a good, prefix-free set of codewords for 4 characters (<em>a</em>, <em>b</em>, <em>c</em>, and <em>d</em>), it might look like this:</p>
<table><thead><tr><th>Character</th><th>Bit Representation</th></tr></thead><tbody>
<tr><td><em>a</em></td><td>00</td></tr>
<tr><td><em>b</em></td><td>01</td></tr>
<tr><td><em>c</em></td><td>10</td></tr>
<tr><td><em>d</em></td><td>11</td></tr>
</tbody></table>
<p>We can decode any even bitstring with this set.
0100101010110100 is <em>bacccdba</em>.
This is great, but now we have another question: given a string of characters, can we construct a set of codewords that <em>minimizes</em> the number of bits in its corresponding bitstring?</p>
<p><em>This is the heart of data compression!</em></p>
<p>First things first, let's define a simple measure for how compressed the data is.
Let's take the following set of characters: <em>abbcccdddd</em>.
If we were to put all the letters in a bag and pull one out at random, we would have the following probabilities of pulling out any of the letters:</p>
<table><thead><tr><th>Character</th><th>Probability</th></tr></thead><tbody>
<tr><td><em>a</em></td><td>.1</td></tr>
<tr><td><em>b</em></td><td>.2</td></tr>
<tr><td><em>c</em></td><td>.3</td></tr>
<tr><td><em>d</em></td><td>.4</td></tr>
</tbody></table>
<p>This basically means that we are far more likely to pull out a <em>d</em> than an <em>a</em>, and if we are trying to minimize the length of our encoded bitstring, the length of the bit representation for <em>d</em> should probably be shorter than the bit representation for <em>a</em>.
Ultimately, to compress our encoded bitstring, we want to minimize the following quantity:</p>
<p>\[ L(C(W)) = \sum_{i=0}^{n}w_i\times \text{length}(c_i) \]</p>
<p>Where \( C \) is the characters of our alphabet and \( c_i \) is codeword for a single character, \( W \) is related to the probability of pulling that character out of a bag and \( w_i \) is an individual probability of getting a specific character, and \( L \) is a vague, unitless quantity to determine the overall length and is usually used to determine compression ratios.
To show how this works, let's consider encoding the word <em>abbcccdddd</em> with two different alphabets:</p>
<table><thead><tr><th>Character</th><th>Probability</th><th>Bit Representation 1</th><th>Bit Representation 2</th></tr></thead><tbody>
<tr><td><em>a</em></td><td>.1</td><td>00</td><td>000</td></tr>
<tr><td><em>b</em></td><td>.2</td><td>01</td><td>001</td></tr>
<tr><td><em>c</em></td><td>.3</td><td>10</td><td>01</td></tr>
<tr><td><em>d</em></td><td>.4</td><td>11</td><td>1</td></tr>
</tbody></table>
<p>In this case:</p>
<p>\[
\begin{align}
L_1 &amp;= 0.1\times 2 + 0.2 \times 2 + 0.3 \times 2 + 0.4 \times 2 = 2 \\
L_2 &amp;= 0.1\times 3 + 0.2 \times 3 + 0.3 \times 2 + 0.4 \times 1 = 1.9
\end{align}
\]</p>
<p>Here, it's clear that \( L_2 &lt; L_1 \), and thus the second set of codewords compresses our data more than the first.
This measure can be used as a direct test of certain simple data compression techniques, notably those created by Shannon, Fano, and <a href="data_compression/../huffman_encoding/huffman_encoding.html">Huffman</a>, which will be covered soon!</p>
<h2 id="license-34"><a class="header" href="#license-34">License</a></h2>
<h5 id="code-examples-32"><a class="header" href="#code-examples-32">Code Examples</a></h5>
<p>The code examples are licensed under the MIT license (found in <a href="https://github.com/algorithm-archivists/algorithm-archive/blob/master/LICENSE.md">LICENSE.md</a>).</p>
<h5 id="text-34"><a class="header" href="#text-34">Text</a></h5>
<p>The text of this chapter was written by <a href="https://github.com/leios">James Schloss</a> and is licensed under the <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</p>
<p><a href="https://creativecommons.org/licenses/by-sa/4.0/"><p><img  class="center" src="data_compression/../cc/CC-BY-SA_icon.svg" /></p></a></p>
<h5 id="pull-requests-31"><a class="header" href="#pull-requests-31">Pull Requests</a></h5>
<p>After initial licensing (<a href="https://github.com/algorithm-archivists/algorithm-archive/pull/560">#560</a>), the following pull requests have modified the text or graphics of this chapter:</p>
<ul>
<li>none</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="huffman-encoding"><a class="header" href="#huffman-encoding">Huffman Encoding</a></h1>
<p>If there were ever a data compression method to take the world by storm, it would be Huffman encoding.
In fact, this was the method that got me into computational methods to begin with.
I distinctly remember sitting in my data compression class and talking about the great information theorist Claude Shannon and Robert Fano, when suddenly my professor introduced a new kid to the mix: David Huffman.
He managed to rip the heart out of the methods described by leaders of the field and create a data compression method that was easier to understand and implement, while also providing more robust results, and apparently this was all done for a school project!</p>
<p>It was in that moment, I knew I would never amount to anything.
I have since accepted that fact and moved on.</p>
<p>Huffman encoding follows from the problem described in the <a href="huffman_encoding/../data_compression/data_compression.html">Data Compression</a> section.
We have a string that we want to encode into bits.
Huffman encoding ensures that our encoded bitstring is as small as possible without losing any information.
Because it is both lossless and guarantees the smallest possible bit length, it outright replaces both Shannon and Shannon-Fano encoding in most cases, which is a little weird because the method was devised while Huffman was taking a course from Fano, himself!</p>
<p>The idea is somewhat straightforward in principle, but a little difficult to code in practice.
By creating a binary tree of the input alphabet, every branch can be provided a unique bit representation simply by assigning a binary value to each child and reading to a character in a leaf node if starting from the root node.</p>
<p>So now the question is: how do we create a binary tree?
Well, here we build it from the bottom up like so:</p>
<ol>
<li>Order all characters according to the frequency they appear in the input bitstring, with the most frequent character at the top of the list. Be sure to keep track of the frequencies, too!</li>
<li>Add the smallest two values together to create a new node with a new frequency.</li>
<li>Keep doing step 2 until the tree is complete.</li>
<li>Read the tree backwards from the root node and concatenate the final bitstring codeword. Keep all codewords and put them into your final set of codewords (sometimes called a codebook)</li>
<li>Encode your phrase with the codebook.</li>
</ol>
<p>And that's it.
Here's an image of what this might look like for the phrase <code>bibbity_bobbity</code>:</p>
<p>
    <img  class="center" src="huffman_encoding/res/huffman_tree.png" style="width:70%" />
</p>
<p>This will create a codebook that looks like this:</p>
<table><thead><tr><th>Character</th><th>Bit Representation</th></tr></thead><tbody>
<tr><td><em>b</em></td><td>0</td></tr>
<tr><td><em>i</em></td><td>100</td></tr>
<tr><td><em>t</em></td><td>101</td></tr>
<tr><td><em>y</em></td><td>110</td></tr>
<tr><td><em>o</em></td><td>1110</td></tr>
<tr><td>___</td><td>1111</td></tr>
</tbody></table>
<p>and <code>bibbity_bobbity</code> becomes <code>01000010010111011110111000100101110</code>.
As mentioned this uses the minimum number of bits possible for encoding.
The fact that this algorithm is both conceptually simple and provably useful is rather extraordinary to me and is why Huffman encoding will always hold a special place in my heart.</p>
<h2 id="video-explanation-11"><a class="header" href="#video-explanation-11">Video Explanation</a></h2>
<p>Here is a quick video explanation for Huffman encoding:</p>
<div style="text-align:center">
<iframe width="560" height="315" src="https://www.youtube.com/embed/wHyUxTc2Ohk" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
</div>
<h2 id="example-code-17"><a class="header" href="#example-code-17">Example Code</a></h2>
<p>In code, this can be a little tricky. It requires a method to continually sort the nodes as you add more and more nodes to the system.
The most straightforward way to do this in some languages is with a priority queue, but depending on the language, this might be more or less appropriate.
In addition, to read the tree backwards, some sort of <a href="huffman_encoding/../tree_traversal/tree_traversal.html">Depth First Search</a> needs to be implemented.
Whether you use a stack or straight-up recursion also depends on the language, but the recursive method is a little easier to understand in most cases.</p>
<pre><code class="language-julia">using Test

# This is for the PriorityQueue
using DataStructures

struct Leaf
    weight::Int64
    key::Char
end

struct Branch
    right::Union{Leaf, Branch}
    left::Union{Leaf, Branch}
    weight::Int64
end

const Node = Union{Leaf, Branch}

function codebook_recurse!(leaf::Leaf, code::String,
                          dict::Dict{Char,String})
    dict[leaf.key] = code
end

function codebook_recurse!(branch::Branch, code::String,
                          dict::Dict{Char,String})
    codebook_recurse!(branch.left, string(code, &quot;1&quot;), dict)
    codebook_recurse!(branch.right, string(code, &quot;0&quot;), dict)
end

# This will depth-first search through the tree
# to create bitstrings for each character.
# Note: Any depth-first search method will work
# This outputs encoding Dict to be used for encoding
function create_codebook(n::Node)
    codebook = Dict{Char,String}()
    if isa(n, Leaf)
        codebook[n.key]=&quot;0&quot;
    else
        codebook_recurse!(n, &quot;&quot;, codebook)
    end
    return codebook
end

# This outputs huffman tree to generate dictionary for encoding
function create_tree(phrase::String)

    # creating weights
    weights = PriorityQueue()
    for i in phrase
        temp_string = string(i)
        if (haskey(weights, temp_string))
            weights[temp_string] += 1
        else
            weights[temp_string] = 1
        end
    end

    # Creating all nodes to iterate through
    nodes = PriorityQueue{Node, Int64}()
    while(length(weights) &gt; 0)
        weight = peek(weights)[2]
        key = dequeue!(weights)[1]
        temp_node = Leaf(weight, key)
        enqueue!(nodes, temp_node, weight)
    end

    while(length(nodes) &gt; 1)
        node1 = dequeue!(nodes)
        node2 = dequeue!(nodes)
        temp_node = Branch(node1, node2, node1.weight + node2.weight)
        enqueue!(nodes, temp_node, temp_node.weight)
    end

    huffman_tree = dequeue!(nodes)
    return huffman_tree

end

function encode(codebook::Dict{Char, String}, phrase::String)
    final_bitstring = &quot;&quot;
    for i in phrase
        final_bitstring = final_bitstring * codebook[i]
    end

    return final_bitstring
end

function decode(huffman_tree::Node, bitstring::String)
    current = huffman_tree
    final_string = &quot;&quot;
    for i in bitstring
        if isa(huffman_tree, Branch)
            if (i == '1')
                current = current.left
            else
                current = current.right
            end

            if (!isa(current, Branch))
                final_string *= string(current.key)
                current = huffman_tree
            end
        else
            final_string *= string(huffman_tree.key)
        end
    end

    return final_string
end

function two_pass_huffman(phrase::String)
    huffman_tree = create_tree(phrase)
    codebook = create_codebook(huffman_tree)
    bitstring = encode(codebook, phrase)
    final_string = decode(huffman_tree, bitstring)
    return final_string
end

@testset &quot;b-string tests&quot; begin
    @test two_pass_huffman(&quot;b&quot;) == &quot;b&quot;
    @test two_pass_huffman(&quot;bbbbbbbb&quot;) == &quot;bbbbbbbb&quot;
    @test two_pass_huffman(&quot;bibbity bobbity&quot;) == &quot;bibbity bobbity&quot;
end
``````julia
using Test

# This is for the PriorityQueue
using DataStructures

struct Leaf
    weight::Int64
    key::Char
end

struct Branch
    right::Union{Leaf, Branch}
    left::Union{Leaf, Branch}
    weight::Int64
end

const Node = Union{Leaf, Branch}

function codebook_recurse!(leaf::Leaf, code::String,
                          dict::Dict{Char,String})
    dict[leaf.key] = code
end

function codebook_recurse!(branch::Branch, code::String,
                          dict::Dict{Char,String})
    codebook_recurse!(branch.left, string(code, &quot;1&quot;), dict)
    codebook_recurse!(branch.right, string(code, &quot;0&quot;), dict)
end

# This will depth-first search through the tree
# to create bitstrings for each character.
# Note: Any depth-first search method will work
# This outputs encoding Dict to be used for encoding
function create_codebook(n::Node)
    codebook = Dict{Char,String}()
    if isa(n, Leaf)
        codebook[n.key]=&quot;0&quot;
    else
        codebook_recurse!(n, &quot;&quot;, codebook)
    end
    return codebook
end

# This outputs huffman tree to generate dictionary for encoding
function create_tree(phrase::String)

    # creating weights
    weights = PriorityQueue()
    for i in phrase
        temp_string = string(i)
        if (haskey(weights, temp_string))
            weights[temp_string] += 1
        else
            weights[temp_string] = 1
        end
    end

    # Creating all nodes to iterate through
    nodes = PriorityQueue{Node, Int64}()
    while(length(weights) &gt; 0)
        weight = peek(weights)[2]
        key = dequeue!(weights)[1]
        temp_node = Leaf(weight, key)
        enqueue!(nodes, temp_node, weight)
    end

    while(length(nodes) &gt; 1)
        node1 = dequeue!(nodes)
        node2 = dequeue!(nodes)
        temp_node = Branch(node1, node2, node1.weight + node2.weight)
        enqueue!(nodes, temp_node, temp_node.weight)
    end

    huffman_tree = dequeue!(nodes)
    return huffman_tree

end

function encode(codebook::Dict{Char, String}, phrase::String)
    final_bitstring = &quot;&quot;
    for i in phrase
        final_bitstring = final_bitstring * codebook[i]
    end

    return final_bitstring
end

function decode(huffman_tree::Node, bitstring::String)
    current = huffman_tree
    final_string = &quot;&quot;
    for i in bitstring
        if isa(huffman_tree, Branch)
            if (i == '1')
                current = current.left
            else
                current = current.right
            end

            if (!isa(current, Branch))
                final_string *= string(current.key)
                current = huffman_tree
            end
        else
            final_string *= string(huffman_tree.key)
        end
    end

    return final_string
end

function two_pass_huffman(phrase::String)
    huffman_tree = create_tree(phrase)
    codebook = create_codebook(huffman_tree)
    bitstring = encode(codebook, phrase)
    final_string = decode(huffman_tree, bitstring)
    return final_string
end

@testset &quot;b-string tests&quot; begin
    @test two_pass_huffman(&quot;b&quot;) == &quot;b&quot;
    @test two_pass_huffman(&quot;bbbbbbbb&quot;) == &quot;bbbbbbbb&quot;
    @test two_pass_huffman(&quot;bibbity bobbity&quot;) == &quot;bibbity bobbity&quot;
end
``````julia
using Test

# This is for the PriorityQueue
using DataStructures

struct Leaf
    weight::Int64
    key::Char
end

struct Branch
    right::Union{Leaf, Branch}
    left::Union{Leaf, Branch}
    weight::Int64
end

const Node = Union{Leaf, Branch}

function codebook_recurse!(leaf::Leaf, code::String,
                          dict::Dict{Char,String})
    dict[leaf.key] = code
end

function codebook_recurse!(branch::Branch, code::String,
                          dict::Dict{Char,String})
    codebook_recurse!(branch.left, string(code, &quot;1&quot;), dict)
    codebook_recurse!(branch.right, string(code, &quot;0&quot;), dict)
end

# This will depth-first search through the tree
# to create bitstrings for each character.
# Note: Any depth-first search method will work
# This outputs encoding Dict to be used for encoding
function create_codebook(n::Node)
    codebook = Dict{Char,String}()
    if isa(n, Leaf)
        codebook[n.key]=&quot;0&quot;
    else
        codebook_recurse!(n, &quot;&quot;, codebook)
    end
    return codebook
end

# This outputs huffman tree to generate dictionary for encoding
function create_tree(phrase::String)

    # creating weights
    weights = PriorityQueue()
    for i in phrase
        temp_string = string(i)
        if (haskey(weights, temp_string))
            weights[temp_string] += 1
        else
            weights[temp_string] = 1
        end
    end

    # Creating all nodes to iterate through
    nodes = PriorityQueue{Node, Int64}()
    while(length(weights) &gt; 0)
        weight = peek(weights)[2]
        key = dequeue!(weights)[1]
        temp_node = Leaf(weight, key)
        enqueue!(nodes, temp_node, weight)
    end

    while(length(nodes) &gt; 1)
        node1 = dequeue!(nodes)
        node2 = dequeue!(nodes)
        temp_node = Branch(node1, node2, node1.weight + node2.weight)
        enqueue!(nodes, temp_node, temp_node.weight)
    end

    huffman_tree = dequeue!(nodes)
    return huffman_tree

end

function encode(codebook::Dict{Char, String}, phrase::String)
    final_bitstring = &quot;&quot;
    for i in phrase
        final_bitstring = final_bitstring * codebook[i]
    end

    return final_bitstring
end

function decode(huffman_tree::Node, bitstring::String)
    current = huffman_tree
    final_string = &quot;&quot;
    for i in bitstring
        if isa(huffman_tree, Branch)
            if (i == '1')
                current = current.left
            else
                current = current.right
            end

            if (!isa(current, Branch))
                final_string *= string(current.key)
                current = huffman_tree
            end
        else
            final_string *= string(huffman_tree.key)
        end
    end

    return final_string
end

function two_pass_huffman(phrase::String)
    huffman_tree = create_tree(phrase)
    codebook = create_codebook(huffman_tree)
    bitstring = encode(codebook, phrase)
    final_string = decode(huffman_tree, bitstring)
    return final_string
end

@testset &quot;b-string tests&quot; begin
    @test two_pass_huffman(&quot;b&quot;) == &quot;b&quot;
    @test two_pass_huffman(&quot;bbbbbbbb&quot;) == &quot;bbbbbbbb&quot;
    @test two_pass_huffman(&quot;bibbity bobbity&quot;) == &quot;bibbity bobbity&quot;
end
```m```julia
using Test

# This is for the PriorityQueue
using DataStructures

struct Leaf
    weight::Int64
    key::Char
end

struct Branch
    right::Union{Leaf, Branch}
    left::Union{Leaf, Branch}
    weight::Int64
end

const Node = Union{Leaf, Branch}

function codebook_recurse!(leaf::Leaf, code::String,
                          dict::Dict{Char,String})
    dict[leaf.key] = code
end

function codebook_recurse!(branch::Branch, code::String,
                          dict::Dict{Char,String})
    codebook_recurse!(branch.left, string(code, &quot;1&quot;), dict)
    codebook_recurse!(branch.right, string(code, &quot;0&quot;), dict)
end

# This will depth-first search through the tree
# to create bitstrings for each character.
# Note: Any depth-first search method will work
# This outputs encoding Dict to be used for encoding
function create_codebook(n::Node)
    codebook = Dict{Char,String}()
    if isa(n, Leaf)
        codebook[n.key]=&quot;0&quot;
    else
        codebook_recurse!(n, &quot;&quot;, codebook)
    end
    return codebook
end

# This outputs huffman tree to generate dictionary for encoding
function create_tree(phrase::String)

    # creating weights
    weights = PriorityQueue()
    for i in phrase
        temp_string = string(i)
        if (haskey(weights, temp_string))
            weights[temp_string] += 1
        else
            weights[temp_string] = 1
        end
    end

    # Creating all nodes to iterate through
    nodes = PriorityQueue{Node, Int64}()
    while(length(weights) &gt; 0)
        weight = peek(weights)[2]
        key = dequeue!(weights)[1]
        temp_node = Leaf(weight, key)
        enqueue!(nodes, temp_node, weight)
    end

    while(length(nodes) &gt; 1)
        node1 = dequeue!(nodes)
        node2 = dequeue!(nodes)
        temp_node = Branch(node1, node2, node1.weight + node2.weight)
        enqueue!(nodes, temp_node, temp_node.weight)
    end

    huffman_tree = dequeue!(nodes)
    return huffman_tree

end

function encode(codebook::Dict{Char, String}, phrase::String)
    final_bitstring = &quot;&quot;
    for i in phrase
        final_bitstring = final_bitstring * codebook[i]
    end

    return final_bitstring
end

function decode(huffman_tree::Node, bitstring::String)
    current = huffman_tree
    final_string = &quot;&quot;
    for i in bitstring
        if isa(huffman_tree, Branch)
            if (i == '1')
                current = current.left
            else
                current = current.right
            end

            if (!isa(current, Branch))
                final_string *= string(current.key)
                current = huffman_tree
            end
        else
            final_string *= string(huffman_tree.key)
        end
    end

    return final_string
end

function two_pass_huffman(phrase::String)
    huffman_tree = create_tree(phrase)
    codebook = create_codebook(huffman_tree)
    bitstring = encode(codebook, phrase)
    final_string = decode(huffman_tree, bitstring)
    return final_string
end

@testset &quot;b-string tests&quot; begin
    @test two_pass_huffman(&quot;b&quot;) == &quot;b&quot;
    @test two_pass_huffman(&quot;bbbbbbbb&quot;) == &quot;bbbbbbbb&quot;
    @test two_pass_huffman(&quot;bibbity bobbity&quot;) == &quot;bibbity bobbity&quot;
end
</code></pre>
<p><a href="huffman_encoding/code/c/huffman.c">import, lang:&quot;c&quot;</a>
{% sample lang=&quot;hs&quot; %}
<a href="huffman_encoding/code/haskell/huffman.hs">import, lang:&quot;haskell&quot;</a>
{% sample lang=&quot;cs&quot; %}</p>
<h5 id="huffmancodingcs"><a class="header" href="#huffmancodingcs">HuffmanCoding.cs</a></h5>
<p><a href="huffman_encoding/code/csharp/HuffmanCoding.cs">import, lang:&quot;csharp&quot;</a></p>
<h5 id="programcs-4"><a class="header" href="#programcs-4">Program.cs</a></h5>
<p><a href="huffman_encoding/code/csharp/Program.cs">import, lang:&quot;csharp&quot;</a></p>
<pre><code class="language-lua">local function frequency_array(str)
  -- Collect all frequency values into a dict
  local map = {}
  for c in str:gmatch(&quot;.&quot;) do -- Iterate over each character in str
    map[c] = (map[c] or 0) + 1 -- Increment map[c] (default 0) by 1
  end

  -- We have a dict of frequencies but we want it in a sorted list
  -- Dump each key value pair into an array
  local arr = {}
  for k, v in pairs(map) do
    arr[#arr + 1] = {k, v}
  end
  table.sort(arr, function(a, b) return a[2] &gt; b[2] end) -- Sort by frequency descending
  return arr
end

local function build_huffman_tree(message)

  if #message == 0 then return end

  local freq = frequency_array(message)

  while #freq &gt; 1 do -- Repeat until we have only 1 node

    -- Take two of the least frequent nodes
    local node1, node2 = table.remove(freq), table.remove(freq)

        -- Group node values in first index, and sum of node frequencies in second
    local node3 = { {node1[1], node2[1] }, node1[2] + node2[2] }

    local i = 1
    while i &lt;= #freq and freq[i][2] &lt;= node3[2] do -- Sorted insertion, faster than inserting then sorting again
      i = i + 1
    end

    table.insert(freq, i, node3)
  end

  return freq[1][1] -- Return value of only element in freq array
end

local function _create_codebook(node, codebook, code)
  if not node then
    return
  elseif type(node) == &quot;string&quot; then
    codebook[node] = code -- if node is a leaf then add it to codebook
  else
    _create_codebook(node[1], codebook, code .. &quot;0&quot;) -- Left side
    _create_codebook(node[2], codebook, code .. &quot;1&quot;) -- Right side
  end
end

local function create_codebook(tree)
  local codebook = {}
  _create_codebook(tree, codebook, &quot;&quot;)
  return codebook
end

local function huffman_encode(codebook, message)
  local encoded_chars = {}
  for c in message:gmatch(&quot;.&quot;) do -- Iterate over each character in message
    encoded_chars[#encoded_chars + 1] = codebook[c]
  end
  return table.concat(encoded_chars) -- table.concat to avoid slow string bufferin
end

local function _huffman_decode(node, bitstring, i)
  if type(node) == &quot;string&quot; then
    return node, i -- If it's a leaf node then return the value along with the next bit to read
  end
  if bitstring:sub(i, i) == &quot;0&quot; then
    return _huffman_decode(node[1], bitstring, i + 1) -- If it's 0 traverse down the left side
  elseif bitstring:sub(i, i) == &quot;1&quot; then
    return _huffman_decode(node[2], bitstring, i + 1) -- If it's 1 traverse down the right side
  end
end

local function huffman_decode(tree, bitstring)
  -- i is the current position in the bitstring, we can track which bit we are to look at next without using string.sub
  local decoded_chars, i = {}, 1
  while i &lt;= #bitstring do
    decoded_chars[#decoded_chars + 1], i = _huffman_decode(tree, bitstring, i)
  end

  return table.concat(decoded_chars)
end

local message = &quot;bibbity_bobbity&quot;

local tree = build_huffman_tree(message)
local codebook = create_codebook(tree)

local bitstring = huffman_encode(codebook, message)
print(&quot;Encoded: &quot; .. bitstring)

print(&quot;Decoded: &quot; .. huffman_decode(tree, bitstring))
</code></pre>
<pre><code class="language-cpp">#include &lt;algorithm&gt;
#include &lt;array&gt;
#include &lt;bitset&gt;
#include &lt;cassert&gt;
#include &lt;cctype&gt;
#include &lt;cstddef&gt;
#include &lt;limits&gt;
#include &lt;memory&gt;
#include &lt;string&gt;
#include &lt;utility&gt;
#include &lt;vector&gt;

#include &lt;iostream&gt;

using std::begin;
using std::end;

namespace huffman {

[[noreturn]] inline void unreachable() {
  std::cerr &lt;&lt; &quot;this should never happen\n&quot;;
  std::abort();
}

// --- interface ---
class codebook {
  struct node {
    int frequency;

    node(int freq) : frequency(freq) {}
    virtual ~node() = 0;
  };

  // never null
  using node_ptr = std::unique_ptr&lt;node const&gt;;
  using bitstring = std::vector&lt;bool&gt;;

  // this is a flatmap between char and a bitstring
  // there should only ever be one character with a given
  // value at any time.
  using encoder_t = std::vector&lt;std::pair&lt;char, bitstring&gt;&gt;;

  struct leaf final : node {
    char key;

    leaf(int freq, char key) : node(freq), key(key) {}
  };

  struct branch final : node {
    node_ptr lhs;
    node_ptr rhs;

    branch(node_ptr lhs, node_ptr rhs)
        : node(lhs-&gt;frequency + rhs-&gt;frequency), lhs(std::move(lhs)),
          rhs(std::move(rhs)) {}
  };

  // this allows us to share [codebook]s among encoded strings
  struct data {
    node_ptr decoder;
    encoder_t encoder;
  };
  std::shared_ptr&lt;data const&gt; underlying_;

public:
  template &lt;typename Iter&gt;
  codebook(Iter const first, Iter const last);

  template &lt;typename Iter&gt;
  std::vector&lt;bool&gt; encode(Iter first, Iter last) const;

  template &lt;typename Iter&gt;
  std::string decode(Iter first, Iter last) const;
};

struct encoded_string {
  codebook codes;
  std::vector&lt;bool&gt; string;

  explicit encoded_string(std::string const&amp; s)
      : codes(begin(s), end(s)), string(codes.encode(begin(s), end(s))) {}

  encoded_string(codebook codes, std::string const&amp; s)
      : codes(codes), string(codes.encode(begin(s), end(s))) {}

  std::string decoded() const {
    return codes.decode(begin(string), end(string));
  }
};

// --- implementation ---
inline codebook::node::~node() {}

inline std::vector&lt;bool&gt; with_new_bit(std::vector&lt;bool&gt; bits, bool b) {
  bits.push_back(b);
  return bits;
}

template &lt;typename Iter&gt;
codebook::codebook(Iter const first, Iter const last) {
  struct helper {
    static node_ptr make_decoder(Iter const first, Iter const last) {
      // in this part of the function, we build up a frequency list
      // sorted by frequency, descending
      auto freq = std::vector&lt;leaf&gt;();

      std::for_each(first, last, [&amp;freq](char c) {
        auto const it = std::find_if(
            begin(freq), end(freq), [c](auto const&amp; p) { return p.key == c; });
        if (it != end(freq)) {
          // it's already in the list
          it-&gt;frequency += 1;
        } else {
          // it's not already in the list
          freq.emplace_back(1, c);
        }
      });

      if (freq.empty()) {
        throw std::invalid_argument(&quot;attempted to codebook an empty range&quot;);
      }

      std::sort(begin(freq), end(freq), [](auto const&amp; lhs, auto const&amp; rhs) {
        return lhs.frequency &gt; rhs.frequency;
      });

      auto ret = std::vector&lt;std::unique_ptr&lt;node&gt;&gt;();
      std::transform(
          begin(freq), end(freq), std::back_inserter(ret), [](auto const l) {
            return std::make_unique&lt;leaf&gt;(l);
          });

      while (ret.size() &gt; 1) {
        auto rhs = std::move(ret.back());
        ret.pop_back();
        auto lhs = std::move(ret.back());
        ret.pop_back();

        auto new_node =
            std::make_unique&lt;branch&gt;(std::move(lhs), std::move(rhs));
        auto const new_freq = new_node-&gt;frequency;

        // look for the first element with a smaller frequency
        auto const it =
            std::find_if(begin(ret), end(ret), [new_freq](auto const&amp; n) {
              return n-&gt;frequency &lt; new_freq;
            });
        // and insert the new_node before that element
        ret.insert(it, std::move(new_node));
        // in this way, we keep the list sorted by frequency
      }

      return std::move(ret.back());
    }

    static void
    encoder_rec(node const* cur, std::vector&lt;bool&gt; bits, encoder_t&amp; out) {
      if (auto l = dynamic_cast&lt;leaf const*&gt;(cur)) {
        out.push_back(std::make_pair(l-&gt;key, std::move(bits)));
      } else if (auto b = dynamic_cast&lt;branch const*&gt;(cur)) {
        encoder_rec(b-&gt;lhs.get(), with_new_bit(bits, 0), out);
        encoder_rec(b-&gt;rhs.get(), with_new_bit(std::move(bits), 1), out);
      } else {
        unreachable();
      }
    }

    static encoder_t make_encoder(node const&amp; decoder) {
      auto ret = encoder_t();

      encoder_rec(&amp;decoder, std::vector&lt;bool&gt;(), ret);

      return ret;
    }
  };

  auto decoder = helper::make_decoder(first, last);
  auto encoder = helper::make_encoder(*decoder);
  underlying_ = std::make_shared&lt;data const&gt;(
      data{std::move(decoder), std::move(encoder)});
}

template &lt;typename Iter&gt;
std::vector&lt;bool&gt; codebook::encode(Iter const first, Iter const last) const {
  std::vector&lt;bool&gt; ret;

  auto&amp; encoder = underlying_-&gt;encoder;
  std::for_each(first, last, [&amp;ret, &amp;encoder](char c) {
    auto const it =
        std::find_if(begin(encoder), end(encoder), [c](auto const&amp; p) {
          return p.first == c;
        });
    if (it != end(encoder)) {
      auto const&amp; code = it-&gt;second;
      std::copy(begin(code), end(code), std::back_inserter(ret));
    } else {
      throw std::invalid_argument(
          &quot;The range has a character which was not in the huffman set&quot;);
    }
  });

  return ret;
}

template &lt;typename Iter&gt;
std::string codebook::decode(Iter const first, Iter const last) const {
  std::string ret;

  node const* const top = underlying_-&gt;decoder.get();

  // returns a pair:
  // the second member is the decoded character
  // the first member is the place we've gotten to in the range
  // i.e., if [0] is an 'a', and we have
  // [it, last) = { 0, 1, 1, 0 }
  // we return (it', 'a') such that
  // [it', last) = { 1, 1, 0 }
  auto decode_single =
      [top](Iter it, Iter const last) -&gt; std::pair&lt;Iter, char&gt; {
    node const* current_node = top;

    for (; it != last; ++it) {
      if (auto l = dynamic_cast&lt;leaf const*&gt;(current_node)) {
        return std::make_pair(it, l-&gt;key);
      } else if (auto b = dynamic_cast&lt;branch const*&gt;(current_node)) {
        if (*it) {
          current_node = b-&gt;rhs.get();
        } else {
          current_node = b-&gt;lhs.get();
        }
      } else {
        unreachable();
      }
    }

    if (auto l = dynamic_cast&lt;leaf const*&gt;(current_node)) {
      return std::make_pair(last, l-&gt;key);
    } else {
      throw std::invalid_argument(
          &quot;The range was not encoded with this huffman set&quot;);
    }
  };

  for (auto it = first; it != last;) {
    auto p = decode_single(it, last);
    it = p.first;
    ret.push_back(p.second);
  }

  return ret;
}

} // namespace huffman

int main() {
  std::string to_be_encoded = R&quot;(bibbity bobbity)&quot;;

  auto encoded = huffman::encoded_string(to_be_encoded);

  std::cout &lt;&lt; &quot;Encoded, the string looks like: &quot;;
  for (bool b : encoded.string) {
    std::cout &lt;&lt; b;
  }
  std::cout &lt;&lt; &quot;\nand decoded, the string looks like: &quot; &lt;&lt; encoded.decoded();
  std::cout &lt;&lt; &quot;\n\nAs opposed to the original, which is &quot;
            &lt;&lt; to_be_encoded.size() * 8 &lt;&lt; &quot; bits, the encoded has size &quot;
            &lt;&lt; encoded.string.size() &lt;&lt; &quot;.\n&quot;;
}
``````cpp
#include &lt;algorithm&gt;
#include &lt;array&gt;
#include &lt;bitset&gt;
#include &lt;cassert&gt;
#include &lt;cctype&gt;
#include &lt;cstddef&gt;
#include &lt;limits&gt;
#include &lt;memory&gt;
#include &lt;string&gt;
#include &lt;utility&gt;
#include &lt;vector&gt;

#include &lt;iostream&gt;

using std::begin;
using std::end;

namespace huffman {

[[noreturn]] inline void unreachable() {
  std::cerr &lt;&lt; &quot;this should never happen\n&quot;;
  std::abort();
}

// --- interface ---
class codebook {
  struct node {
    int frequency;

    node(int freq) : frequency(freq) {}
    virtual ~node() = 0;
  };

  // never null
  using node_ptr = std::unique_ptr&lt;node const&gt;;
  using bitstring = std::vector&lt;bool&gt;;

  // this is a flatmap between char and a bitstring
  // there should only ever be one character with a given
  // value at any time.
  using encoder_t = std::vector&lt;std::pair&lt;char, bitstring&gt;&gt;;

  struct leaf final : node {
    char key;

    leaf(int freq, char key) : node(freq), key(key) {}
  };

  struct branch final : node {
    node_ptr lhs;
    node_ptr rhs;

    branch(node_ptr lhs, node_ptr rhs)
        : node(lhs-&gt;frequency + rhs-&gt;frequency), lhs(std::move(lhs)),
          rhs(std::move(rhs)) {}
  };

  // this allows us to share [codebook]s among encoded strings
  struct data {
    node_ptr decoder;
    encoder_t encoder;
  };
  std::shared_ptr&lt;data const&gt; underlying_;

public:
  template &lt;typename Iter&gt;
  codebook(Iter const first, Iter const last);

  template &lt;typename Iter&gt;
  std::vector&lt;bool&gt; encode(Iter first, Iter last) const;

  template &lt;typename Iter&gt;
  std::string decode(Iter first, Iter last) const;
};

struct encoded_string {
  codebook codes;
  std::vector&lt;bool&gt; string;

  explicit encoded_string(std::string const&amp; s)
      : codes(begin(s), end(s)), string(codes.encode(begin(s), end(s))) {}

  encoded_string(codebook codes, std::string const&amp; s)
      : codes(codes), string(codes.encode(begin(s), end(s))) {}

  std::string decoded() const {
    return codes.decode(begin(string), end(string));
  }
};

// --- implementation ---
inline codebook::node::~node() {}

inline std::vector&lt;bool&gt; with_new_bit(std::vector&lt;bool&gt; bits, bool b) {
  bits.push_back(b);
  return bits;
}

template &lt;typename Iter&gt;
codebook::codebook(Iter const first, Iter const last) {
  struct helper {
    static node_ptr make_decoder(Iter const first, Iter const last) {
      // in this part of the function, we build up a frequency list
      // sorted by frequency, descending
      auto freq = std::vector&lt;leaf&gt;();

      std::for_each(first, last, [&amp;freq](char c) {
        auto const it = std::find_if(
            begin(freq), end(freq), [c](auto const&amp; p) { return p.key == c; });
        if (it != end(freq)) {
          // it's already in the list
          it-&gt;frequency += 1;
        } else {
          // it's not already in the list
          freq.emplace_back(1, c);
        }
      });

      if (freq.empty()) {
        throw std::invalid_argument(&quot;attempted to codebook an empty range&quot;);
      }

      std::sort(begin(freq), end(freq), [](auto const&amp; lhs, auto const&amp; rhs) {
        return lhs.frequency &gt; rhs.frequency;
      });

      auto ret = std::vector&lt;std::unique_ptr&lt;node&gt;&gt;();
      std::transform(
          begin(freq), end(freq), std::back_inserter(ret), [](auto const l) {
            return std::make_unique&lt;leaf&gt;(l);
          });

      while (ret.size() &gt; 1) {
        auto rhs = std::move(ret.back());
        ret.pop_back();
        auto lhs = std::move(ret.back());
        ret.pop_back();

        auto new_node =
            std::make_unique&lt;branch&gt;(std::move(lhs), std::move(rhs));
        auto const new_freq = new_node-&gt;frequency;

        // look for the first element with a smaller frequency
        auto const it =
            std::find_if(begin(ret), end(ret), [new_freq](auto const&amp; n) {
              return n-&gt;frequency &lt; new_freq;
            });
        // and insert the new_node before that element
        ret.insert(it, std::move(new_node));
        // in this way, we keep the list sorted by frequency
      }

      return std::move(ret.back());
    }

    static void
    encoder_rec(node const* cur, std::vector&lt;bool&gt; bits, encoder_t&amp; out) {
      if (auto l = dynamic_cast&lt;leaf const*&gt;(cur)) {
        out.push_back(std::make_pair(l-&gt;key, std::move(bits)));
      } else if (auto b = dynamic_cast&lt;branch const*&gt;(cur)) {
        encoder_rec(b-&gt;lhs.get(), with_new_bit(bits, 0), out);
        encoder_rec(b-&gt;rhs.get(), with_new_bit(std::move(bits), 1), out);
      } else {
        unreachable();
      }
    }

    static encoder_t make_encoder(node const&amp; decoder) {
      auto ret = encoder_t();

      encoder_rec(&amp;decoder, std::vector&lt;bool&gt;(), ret);

      return ret;
    }
  };

  auto decoder = helper::make_decoder(first, last);
  auto encoder = helper::make_encoder(*decoder);
  underlying_ = std::make_shared&lt;data const&gt;(
      data{std::move(decoder), std::move(encoder)});
}

template &lt;typename Iter&gt;
std::vector&lt;bool&gt; codebook::encode(Iter const first, Iter const last) const {
  std::vector&lt;bool&gt; ret;

  auto&amp; encoder = underlying_-&gt;encoder;
  std::for_each(first, last, [&amp;ret, &amp;encoder](char c) {
    auto const it =
        std::find_if(begin(encoder), end(encoder), [c](auto const&amp; p) {
          return p.first == c;
        });
    if (it != end(encoder)) {
      auto const&amp; code = it-&gt;second;
      std::copy(begin(code), end(code), std::back_inserter(ret));
    } else {
      throw std::invalid_argument(
          &quot;The range has a character which was not in the huffman set&quot;);
    }
  });

  return ret;
}

template &lt;typename Iter&gt;
std::string codebook::decode(Iter const first, Iter const last) const {
  std::string ret;

  node const* const top = underlying_-&gt;decoder.get();

  // returns a pair:
  // the second member is the decoded character
  // the first member is the place we've gotten to in the range
  // i.e., if [0] is an 'a', and we have
  // [it, last) = { 0, 1, 1, 0 }
  // we return (it', 'a') such that
  // [it', last) = { 1, 1, 0 }
  auto decode_single =
      [top](Iter it, Iter const last) -&gt; std::pair&lt;Iter, char&gt; {
    node const* current_node = top;

    for (; it != last; ++it) {
      if (auto l = dynamic_cast&lt;leaf const*&gt;(current_node)) {
        return std::make_pair(it, l-&gt;key);
      } else if (auto b = dynamic_cast&lt;branch const*&gt;(current_node)) {
        if (*it) {
          current_node = b-&gt;rhs.get();
        } else {
          current_node = b-&gt;lhs.get();
        }
      } else {
        unreachable();
      }
    }

    if (auto l = dynamic_cast&lt;leaf const*&gt;(current_node)) {
      return std::make_pair(last, l-&gt;key);
    } else {
      throw std::invalid_argument(
          &quot;The range was not encoded with this huffman set&quot;);
    }
  };

  for (auto it = first; it != last;) {
    auto p = decode_single(it, last);
    it = p.first;
    ret.push_back(p.second);
  }

  return ret;
}

} // namespace huffman

int main() {
  std::string to_be_encoded = R&quot;(bibbity bobbity)&quot;;

  auto encoded = huffman::encoded_string(to_be_encoded);

  std::cout &lt;&lt; &quot;Encoded, the string looks like: &quot;;
  for (bool b : encoded.string) {
    std::cout &lt;&lt; b;
  }
  std::cout &lt;&lt; &quot;\nand decoded, the string looks like: &quot; &lt;&lt; encoded.decoded();
  std::cout &lt;&lt; &quot;\n\nAs opposed to the original, which is &quot;
            &lt;&lt; to_be_encoded.size() * 8 &lt;&lt; &quot; bits, the encoded has size &quot;
            &lt;&lt; encoded.string.size() &lt;&lt; &quot;.\n&quot;;
}
``````cpp
#include &lt;algorithm&gt;
#include &lt;array&gt;
#include &lt;bitset&gt;
#include &lt;cassert&gt;
#include &lt;cctype&gt;
#include &lt;cstddef&gt;
#include &lt;limits&gt;
#include &lt;memory&gt;
#include &lt;string&gt;
#include &lt;utility&gt;
#include &lt;vector&gt;

#include &lt;iostream&gt;

using std::begin;
using std::end;

namespace huffman {

[[noreturn]] inline void unreachable() {
  std::cerr &lt;&lt; &quot;this should never happen\n&quot;;
  std::abort();
}

// --- interface ---
class codebook {
  struct node {
    int frequency;

    node(int freq) : frequency(freq) {}
    virtual ~node() = 0;
  };

  // never null
  using node_ptr = std::unique_ptr&lt;node const&gt;;
  using bitstring = std::vector&lt;bool&gt;;

  // this is a flatmap between char and a bitstring
  // there should only ever be one character with a given
  // value at any time.
  using encoder_t = std::vector&lt;std::pair&lt;char, bitstring&gt;&gt;;

  struct leaf final : node {
    char key;

    leaf(int freq, char key) : node(freq), key(key) {}
  };

  struct branch final : node {
    node_ptr lhs;
    node_ptr rhs;

    branch(node_ptr lhs, node_ptr rhs)
        : node(lhs-&gt;frequency + rhs-&gt;frequency), lhs(std::move(lhs)),
          rhs(std::move(rhs)) {}
  };

  // this allows us to share [codebook]s among encoded strings
  struct data {
    node_ptr decoder;
    encoder_t encoder;
  };
  std::shared_ptr&lt;data const&gt; underlying_;

public:
  template &lt;typename Iter&gt;
  codebook(Iter const first, Iter const last);

  template &lt;typename Iter&gt;
  std::vector&lt;bool&gt; encode(Iter first, Iter last) const;

  template &lt;typename Iter&gt;
  std::string decode(Iter first, Iter last) const;
};

struct encoded_string {
  codebook codes;
  std::vector&lt;bool&gt; string;

  explicit encoded_string(std::string const&amp; s)
      : codes(begin(s), end(s)), string(codes.encode(begin(s), end(s))) {}

  encoded_string(codebook codes, std::string const&amp; s)
      : codes(codes), string(codes.encode(begin(s), end(s))) {}

  std::string decoded() const {
    return codes.decode(begin(string), end(string));
  }
};

// --- implementation ---
inline codebook::node::~node() {}

inline std::vector&lt;bool&gt; with_new_bit(std::vector&lt;bool&gt; bits, bool b) {
  bits.push_back(b);
  return bits;
}

template &lt;typename Iter&gt;
codebook::codebook(Iter const first, Iter const last) {
  struct helper {
    static node_ptr make_decoder(Iter const first, Iter const last) {
      // in this part of the function, we build up a frequency list
      // sorted by frequency, descending
      auto freq = std::vector&lt;leaf&gt;();

      std::for_each(first, last, [&amp;freq](char c) {
        auto const it = std::find_if(
            begin(freq), end(freq), [c](auto const&amp; p) { return p.key == c; });
        if (it != end(freq)) {
          // it's already in the list
          it-&gt;frequency += 1;
        } else {
          // it's not already in the list
          freq.emplace_back(1, c);
        }
      });

      if (freq.empty()) {
        throw std::invalid_argument(&quot;attempted to codebook an empty range&quot;);
      }

      std::sort(begin(freq), end(freq), [](auto const&amp; lhs, auto const&amp; rhs) {
        return lhs.frequency &gt; rhs.frequency;
      });

      auto ret = std::vector&lt;std::unique_ptr&lt;node&gt;&gt;();
      std::transform(
          begin(freq), end(freq), std::back_inserter(ret), [](auto const l) {
            return std::make_unique&lt;leaf&gt;(l);
          });

      while (ret.size() &gt; 1) {
        auto rhs = std::move(ret.back());
        ret.pop_back();
        auto lhs = std::move(ret.back());
        ret.pop_back();

        auto new_node =
            std::make_unique&lt;branch&gt;(std::move(lhs), std::move(rhs));
        auto const new_freq = new_node-&gt;frequency;

        // look for the first element with a smaller frequency
        auto const it =
            std::find_if(begin(ret), end(ret), [new_freq](auto const&amp; n) {
              return n-&gt;frequency &lt; new_freq;
            });
        // and insert the new_node before that element
        ret.insert(it, std::move(new_node));
        // in this way, we keep the list sorted by frequency
      }

      return std::move(ret.back());
    }

    static void
    encoder_rec(node const* cur, std::vector&lt;bool&gt; bits, encoder_t&amp; out) {
      if (auto l = dynamic_cast&lt;leaf const*&gt;(cur)) {
        out.push_back(std::make_pair(l-&gt;key, std::move(bits)));
      } else if (auto b = dynamic_cast&lt;branch const*&gt;(cur)) {
        encoder_rec(b-&gt;lhs.get(), with_new_bit(bits, 0), out);
        encoder_rec(b-&gt;rhs.get(), with_new_bit(std::move(bits), 1), out);
      } else {
        unreachable();
      }
    }

    static encoder_t make_encoder(node const&amp; decoder) {
      auto ret = encoder_t();

      encoder_rec(&amp;decoder, std::vector&lt;bool&gt;(), ret);

      return ret;
    }
  };

  auto decoder = helper::make_decoder(first, last);
  auto encoder = helper::make_encoder(*decoder);
  underlying_ = std::make_shared&lt;data const&gt;(
      data{std::move(decoder), std::move(encoder)});
}

template &lt;typename Iter&gt;
std::vector&lt;bool&gt; codebook::encode(Iter const first, Iter const last) const {
  std::vector&lt;bool&gt; ret;

  auto&amp; encoder = underlying_-&gt;encoder;
  std::for_each(first, last, [&amp;ret, &amp;encoder](char c) {
    auto const it =
        std::find_if(begin(encoder), end(encoder), [c](auto const&amp; p) {
          return p.first == c;
        });
    if (it != end(encoder)) {
      auto const&amp; code = it-&gt;second;
      std::copy(begin(code), end(code), std::back_inserter(ret));
    } else {
      throw std::invalid_argument(
          &quot;The range has a character which was not in the huffman set&quot;);
    }
  });

  return ret;
}

template &lt;typename Iter&gt;
std::string codebook::decode(Iter const first, Iter const last) const {
  std::string ret;

  node const* const top = underlying_-&gt;decoder.get();

  // returns a pair:
  // the second member is the decoded character
  // the first member is the place we've gotten to in the range
  // i.e., if [0] is an 'a', and we have
  // [it, last) = { 0, 1, 1, 0 }
  // we return (it', 'a') such that
  // [it', last) = { 1, 1, 0 }
  auto decode_single =
      [top](Iter it, Iter const last) -&gt; std::pair&lt;Iter, char&gt; {
    node const* current_node = top;

    for (; it != last; ++it) {
      if (auto l = dynamic_cast&lt;leaf const*&gt;(current_node)) {
        return std::make_pair(it, l-&gt;key);
      } else if (auto b = dynamic_cast&lt;branch const*&gt;(current_node)) {
        if (*it) {
          current_node = b-&gt;rhs.get();
        } else {
          current_node = b-&gt;lhs.get();
        }
      } else {
        unreachable();
      }
    }

    if (auto l = dynamic_cast&lt;leaf const*&gt;(current_node)) {
      return std::make_pair(last, l-&gt;key);
    } else {
      throw std::invalid_argument(
          &quot;The range was not encoded with this huffman set&quot;);
    }
  };

  for (auto it = first; it != last;) {
    auto p = decode_single(it, last);
    it = p.first;
    ret.push_back(p.second);
  }

  return ret;
}

} // namespace huffman

int main() {
  std::string to_be_encoded = R&quot;(bibbity bobbity)&quot;;

  auto encoded = huffman::encoded_string(to_be_encoded);

  std::cout &lt;&lt; &quot;Encoded, the string looks like: &quot;;
  for (bool b : encoded.string) {
    std::cout &lt;&lt; b;
  }
  std::cout &lt;&lt; &quot;\nand decoded, the string looks like: &quot; &lt;&lt; encoded.decoded();
  std::cout &lt;&lt; &quot;\n\nAs opposed to the original, which is &quot;
            &lt;&lt; to_be_encoded.size() * 8 &lt;&lt; &quot; bits, the encoded has size &quot;
            &lt;&lt; encoded.string.size() &lt;&lt; &quot;.\n&quot;;
}
```l```cpp
#include &lt;algorithm&gt;
#include &lt;array&gt;
#include &lt;bitset&gt;
#include &lt;cassert&gt;
#include &lt;cctype&gt;
#include &lt;cstddef&gt;
#include &lt;limits&gt;
#include &lt;memory&gt;
#include &lt;string&gt;
#include &lt;utility&gt;
#include &lt;vector&gt;

#include &lt;iostream&gt;

using std::begin;
using std::end;

namespace huffman {

[[noreturn]] inline void unreachable() {
  std::cerr &lt;&lt; &quot;this should never happen\n&quot;;
  std::abort();
}

// --- interface ---
class codebook {
  struct node {
    int frequency;

    node(int freq) : frequency(freq) {}
    virtual ~node() = 0;
  };

  // never null
  using node_ptr = std::unique_ptr&lt;node const&gt;;
  using bitstring = std::vector&lt;bool&gt;;

  // this is a flatmap between char and a bitstring
  // there should only ever be one character with a given
  // value at any time.
  using encoder_t = std::vector&lt;std::pair&lt;char, bitstring&gt;&gt;;

  struct leaf final : node {
    char key;

    leaf(int freq, char key) : node(freq), key(key) {}
  };

  struct branch final : node {
    node_ptr lhs;
    node_ptr rhs;

    branch(node_ptr lhs, node_ptr rhs)
        : node(lhs-&gt;frequency + rhs-&gt;frequency), lhs(std::move(lhs)),
          rhs(std::move(rhs)) {}
  };

  // this allows us to share [codebook]s among encoded strings
  struct data {
    node_ptr decoder;
    encoder_t encoder;
  };
  std::shared_ptr&lt;data const&gt; underlying_;

public:
  template &lt;typename Iter&gt;
  codebook(Iter const first, Iter const last);

  template &lt;typename Iter&gt;
  std::vector&lt;bool&gt; encode(Iter first, Iter last) const;

  template &lt;typename Iter&gt;
  std::string decode(Iter first, Iter last) const;
};

struct encoded_string {
  codebook codes;
  std::vector&lt;bool&gt; string;

  explicit encoded_string(std::string const&amp; s)
      : codes(begin(s), end(s)), string(codes.encode(begin(s), end(s))) {}

  encoded_string(codebook codes, std::string const&amp; s)
      : codes(codes), string(codes.encode(begin(s), end(s))) {}

  std::string decoded() const {
    return codes.decode(begin(string), end(string));
  }
};

// --- implementation ---
inline codebook::node::~node() {}

inline std::vector&lt;bool&gt; with_new_bit(std::vector&lt;bool&gt; bits, bool b) {
  bits.push_back(b);
  return bits;
}

template &lt;typename Iter&gt;
codebook::codebook(Iter const first, Iter const last) {
  struct helper {
    static node_ptr make_decoder(Iter const first, Iter const last) {
      // in this part of the function, we build up a frequency list
      // sorted by frequency, descending
      auto freq = std::vector&lt;leaf&gt;();

      std::for_each(first, last, [&amp;freq](char c) {
        auto const it = std::find_if(
            begin(freq), end(freq), [c](auto const&amp; p) { return p.key == c; });
        if (it != end(freq)) {
          // it's already in the list
          it-&gt;frequency += 1;
        } else {
          // it's not already in the list
          freq.emplace_back(1, c);
        }
      });

      if (freq.empty()) {
        throw std::invalid_argument(&quot;attempted to codebook an empty range&quot;);
      }

      std::sort(begin(freq), end(freq), [](auto const&amp; lhs, auto const&amp; rhs) {
        return lhs.frequency &gt; rhs.frequency;
      });

      auto ret = std::vector&lt;std::unique_ptr&lt;node&gt;&gt;();
      std::transform(
          begin(freq), end(freq), std::back_inserter(ret), [](auto const l) {
            return std::make_unique&lt;leaf&gt;(l);
          });

      while (ret.size() &gt; 1) {
        auto rhs = std::move(ret.back());
        ret.pop_back();
        auto lhs = std::move(ret.back());
        ret.pop_back();

        auto new_node =
            std::make_unique&lt;branch&gt;(std::move(lhs), std::move(rhs));
        auto const new_freq = new_node-&gt;frequency;

        // look for the first element with a smaller frequency
        auto const it =
            std::find_if(begin(ret), end(ret), [new_freq](auto const&amp; n) {
              return n-&gt;frequency &lt; new_freq;
            });
        // and insert the new_node before that element
        ret.insert(it, std::move(new_node));
        // in this way, we keep the list sorted by frequency
      }

      return std::move(ret.back());
    }

    static void
    encoder_rec(node const* cur, std::vector&lt;bool&gt; bits, encoder_t&amp; out) {
      if (auto l = dynamic_cast&lt;leaf const*&gt;(cur)) {
        out.push_back(std::make_pair(l-&gt;key, std::move(bits)));
      } else if (auto b = dynamic_cast&lt;branch const*&gt;(cur)) {
        encoder_rec(b-&gt;lhs.get(), with_new_bit(bits, 0), out);
        encoder_rec(b-&gt;rhs.get(), with_new_bit(std::move(bits), 1), out);
      } else {
        unreachable();
      }
    }

    static encoder_t make_encoder(node const&amp; decoder) {
      auto ret = encoder_t();

      encoder_rec(&amp;decoder, std::vector&lt;bool&gt;(), ret);

      return ret;
    }
  };

  auto decoder = helper::make_decoder(first, last);
  auto encoder = helper::make_encoder(*decoder);
  underlying_ = std::make_shared&lt;data const&gt;(
      data{std::move(decoder), std::move(encoder)});
}

template &lt;typename Iter&gt;
std::vector&lt;bool&gt; codebook::encode(Iter const first, Iter const last) const {
  std::vector&lt;bool&gt; ret;

  auto&amp; encoder = underlying_-&gt;encoder;
  std::for_each(first, last, [&amp;ret, &amp;encoder](char c) {
    auto const it =
        std::find_if(begin(encoder), end(encoder), [c](auto const&amp; p) {
          return p.first == c;
        });
    if (it != end(encoder)) {
      auto const&amp; code = it-&gt;second;
      std::copy(begin(code), end(code), std::back_inserter(ret));
    } else {
      throw std::invalid_argument(
          &quot;The range has a character which was not in the huffman set&quot;);
    }
  });

  return ret;
}

template &lt;typename Iter&gt;
std::string codebook::decode(Iter const first, Iter const last) const {
  std::string ret;

  node const* const top = underlying_-&gt;decoder.get();

  // returns a pair:
  // the second member is the decoded character
  // the first member is the place we've gotten to in the range
  // i.e., if [0] is an 'a', and we have
  // [it, last) = { 0, 1, 1, 0 }
  // we return (it', 'a') such that
  // [it', last) = { 1, 1, 0 }
  auto decode_single =
      [top](Iter it, Iter const last) -&gt; std::pair&lt;Iter, char&gt; {
    node const* current_node = top;

    for (; it != last; ++it) {
      if (auto l = dynamic_cast&lt;leaf const*&gt;(current_node)) {
        return std::make_pair(it, l-&gt;key);
      } else if (auto b = dynamic_cast&lt;branch const*&gt;(current_node)) {
        if (*it) {
          current_node = b-&gt;rhs.get();
        } else {
          current_node = b-&gt;lhs.get();
        }
      } else {
        unreachable();
      }
    }

    if (auto l = dynamic_cast&lt;leaf const*&gt;(current_node)) {
      return std::make_pair(last, l-&gt;key);
    } else {
      throw std::invalid_argument(
          &quot;The range was not encoded with this huffman set&quot;);
    }
  };

  for (auto it = first; it != last;) {
    auto p = decode_single(it, last);
    it = p.first;
    ret.push_back(p.second);
  }

  return ret;
}

} // namespace huffman

int main() {
  std::string to_be_encoded = R&quot;(bibbity bobbity)&quot;;

  auto encoded = huffman::encoded_string(to_be_encoded);

  std::cout &lt;&lt; &quot;Encoded, the string looks like: &quot;;
  for (bool b : encoded.string) {
    std::cout &lt;&lt; b;
  }
  std::cout &lt;&lt; &quot;\nand decoded, the string looks like: &quot; &lt;&lt; encoded.decoded();
  std::cout &lt;&lt; &quot;\n\nAs opposed to the original, which is &quot;
            &lt;&lt; to_be_encoded.size() * 8 &lt;&lt; &quot; bits, the encoded has size &quot;
            &lt;&lt; encoded.string.size() &lt;&lt; &quot;.\n&quot;;
}
``````cpp
#include &lt;algorithm&gt;
#include &lt;array&gt;
#include &lt;bitset&gt;
#include &lt;cassert&gt;
#include &lt;cctype&gt;
#include &lt;cstddef&gt;
#include &lt;limits&gt;
#include &lt;memory&gt;
#include &lt;string&gt;
#include &lt;utility&gt;
#include &lt;vector&gt;

#include &lt;iostream&gt;

using std::begin;
using std::end;

namespace huffman {

[[noreturn]] inline void unreachable() {
  std::cerr &lt;&lt; &quot;this should never happen\n&quot;;
  std::abort();
}

// --- interface ---
class codebook {
  struct node {
    int frequency;

    node(int freq) : frequency(freq) {}
    virtual ~node() = 0;
  };

  // never null
  using node_ptr = std::unique_ptr&lt;node const&gt;;
  using bitstring = std::vector&lt;bool&gt;;

  // this is a flatmap between char and a bitstring
  // there should only ever be one character with a given
  // value at any time.
  using encoder_t = std::vector&lt;std::pair&lt;char, bitstring&gt;&gt;;

  struct leaf final : node {
    char key;

    leaf(int freq, char key) : node(freq), key(key) {}
  };

  struct branch final : node {
    node_ptr lhs;
    node_ptr rhs;

    branch(node_ptr lhs, node_ptr rhs)
        : node(lhs-&gt;frequency + rhs-&gt;frequency), lhs(std::move(lhs)),
          rhs(std::move(rhs)) {}
  };

  // this allows us to share [codebook]s among encoded strings
  struct data {
    node_ptr decoder;
    encoder_t encoder;
  };
  std::shared_ptr&lt;data const&gt; underlying_;

public:
  template &lt;typename Iter&gt;
  codebook(Iter const first, Iter const last);

  template &lt;typename Iter&gt;
  std::vector&lt;bool&gt; encode(Iter first, Iter last) const;

  template &lt;typename Iter&gt;
  std::string decode(Iter first, Iter last) const;
};

struct encoded_string {
  codebook codes;
  std::vector&lt;bool&gt; string;

  explicit encoded_string(std::string const&amp; s)
      : codes(begin(s), end(s)), string(codes.encode(begin(s), end(s))) {}

  encoded_string(codebook codes, std::string const&amp; s)
      : codes(codes), string(codes.encode(begin(s), end(s))) {}

  std::string decoded() const {
    return codes.decode(begin(string), end(string));
  }
};

// --- implementation ---
inline codebook::node::~node() {}

inline std::vector&lt;bool&gt; with_new_bit(std::vector&lt;bool&gt; bits, bool b) {
  bits.push_back(b);
  return bits;
}

template &lt;typename Iter&gt;
codebook::codebook(Iter const first, Iter const last) {
  struct helper {
    static node_ptr make_decoder(Iter const first, Iter const last) {
      // in this part of the function, we build up a frequency list
      // sorted by frequency, descending
      auto freq = std::vector&lt;leaf&gt;();

      std::for_each(first, last, [&amp;freq](char c) {
        auto const it = std::find_if(
            begin(freq), end(freq), [c](auto const&amp; p) { return p.key == c; });
        if (it != end(freq)) {
          // it's already in the list
          it-&gt;frequency += 1;
        } else {
          // it's not already in the list
          freq.emplace_back(1, c);
        }
      });

      if (freq.empty()) {
        throw std::invalid_argument(&quot;attempted to codebook an empty range&quot;);
      }

      std::sort(begin(freq), end(freq), [](auto const&amp; lhs, auto const&amp; rhs) {
        return lhs.frequency &gt; rhs.frequency;
      });

      auto ret = std::vector&lt;std::unique_ptr&lt;node&gt;&gt;();
      std::transform(
          begin(freq), end(freq), std::back_inserter(ret), [](auto const l) {
            return std::make_unique&lt;leaf&gt;(l);
          });

      while (ret.size() &gt; 1) {
        auto rhs = std::move(ret.back());
        ret.pop_back();
        auto lhs = std::move(ret.back());
        ret.pop_back();

        auto new_node =
            std::make_unique&lt;branch&gt;(std::move(lhs), std::move(rhs));
        auto const new_freq = new_node-&gt;frequency;

        // look for the first element with a smaller frequency
        auto const it =
            std::find_if(begin(ret), end(ret), [new_freq](auto const&amp; n) {
              return n-&gt;frequency &lt; new_freq;
            });
        // and insert the new_node before that element
        ret.insert(it, std::move(new_node));
        // in this way, we keep the list sorted by frequency
      }

      return std::move(ret.back());
    }

    static void
    encoder_rec(node const* cur, std::vector&lt;bool&gt; bits, encoder_t&amp; out) {
      if (auto l = dynamic_cast&lt;leaf const*&gt;(cur)) {
        out.push_back(std::make_pair(l-&gt;key, std::move(bits)));
      } else if (auto b = dynamic_cast&lt;branch const*&gt;(cur)) {
        encoder_rec(b-&gt;lhs.get(), with_new_bit(bits, 0), out);
        encoder_rec(b-&gt;rhs.get(), with_new_bit(std::move(bits), 1), out);
      } else {
        unreachable();
      }
    }

    static encoder_t make_encoder(node const&amp; decoder) {
      auto ret = encoder_t();

      encoder_rec(&amp;decoder, std::vector&lt;bool&gt;(), ret);

      return ret;
    }
  };

  auto decoder = helper::make_decoder(first, last);
  auto encoder = helper::make_encoder(*decoder);
  underlying_ = std::make_shared&lt;data const&gt;(
      data{std::move(decoder), std::move(encoder)});
}

template &lt;typename Iter&gt;
std::vector&lt;bool&gt; codebook::encode(Iter const first, Iter const last) const {
  std::vector&lt;bool&gt; ret;

  auto&amp; encoder = underlying_-&gt;encoder;
  std::for_each(first, last, [&amp;ret, &amp;encoder](char c) {
    auto const it =
        std::find_if(begin(encoder), end(encoder), [c](auto const&amp; p) {
          return p.first == c;
        });
    if (it != end(encoder)) {
      auto const&amp; code = it-&gt;second;
      std::copy(begin(code), end(code), std::back_inserter(ret));
    } else {
      throw std::invalid_argument(
          &quot;The range has a character which was not in the huffman set&quot;);
    }
  });

  return ret;
}

template &lt;typename Iter&gt;
std::string codebook::decode(Iter const first, Iter const last) const {
  std::string ret;

  node const* const top = underlying_-&gt;decoder.get();

  // returns a pair:
  // the second member is the decoded character
  // the first member is the place we've gotten to in the range
  // i.e., if [0] is an 'a', and we have
  // [it, last) = { 0, 1, 1, 0 }
  // we return (it', 'a') such that
  // [it', last) = { 1, 1, 0 }
  auto decode_single =
      [top](Iter it, Iter const last) -&gt; std::pair&lt;Iter, char&gt; {
    node const* current_node = top;

    for (; it != last; ++it) {
      if (auto l = dynamic_cast&lt;leaf const*&gt;(current_node)) {
        return std::make_pair(it, l-&gt;key);
      } else if (auto b = dynamic_cast&lt;branch const*&gt;(current_node)) {
        if (*it) {
          current_node = b-&gt;rhs.get();
        } else {
          current_node = b-&gt;lhs.get();
        }
      } else {
        unreachable();
      }
    }

    if (auto l = dynamic_cast&lt;leaf const*&gt;(current_node)) {
      return std::make_pair(last, l-&gt;key);
    } else {
      throw std::invalid_argument(
          &quot;The range was not encoded with this huffman set&quot;);
    }
  };

  for (auto it = first; it != last;) {
    auto p = decode_single(it, last);
    it = p.first;
    ret.push_back(p.second);
  }

  return ret;
}

} // namespace huffman

int main() {
  std::string to_be_encoded = R&quot;(bibbity bobbity)&quot;;

  auto encoded = huffman::encoded_string(to_be_encoded);

  std::cout &lt;&lt; &quot;Encoded, the string looks like: &quot;;
  for (bool b : encoded.string) {
    std::cout &lt;&lt; b;
  }
  std::cout &lt;&lt; &quot;\nand decoded, the string looks like: &quot; &lt;&lt; encoded.decoded();
  std::cout &lt;&lt; &quot;\n\nAs opposed to the original, which is &quot;
            &lt;&lt; to_be_encoded.size() * 8 &lt;&lt; &quot; bits, the encoded has size &quot;
            &lt;&lt; encoded.string.size() &lt;&lt; &quot;.\n&quot;;
}
```y```cpp
#include &lt;algorithm&gt;
#include &lt;array&gt;
#include &lt;bitset&gt;
#include &lt;cassert&gt;
#include &lt;cctype&gt;
#include &lt;cstddef&gt;
#include &lt;limits&gt;
#include &lt;memory&gt;
#include &lt;string&gt;
#include &lt;utility&gt;
#include &lt;vector&gt;

#include &lt;iostream&gt;

using std::begin;
using std::end;

namespace huffman {

[[noreturn]] inline void unreachable() {
  std::cerr &lt;&lt; &quot;this should never happen\n&quot;;
  std::abort();
}

// --- interface ---
class codebook {
  struct node {
    int frequency;

    node(int freq) : frequency(freq) {}
    virtual ~node() = 0;
  };

  // never null
  using node_ptr = std::unique_ptr&lt;node const&gt;;
  using bitstring = std::vector&lt;bool&gt;;

  // this is a flatmap between char and a bitstring
  // there should only ever be one character with a given
  // value at any time.
  using encoder_t = std::vector&lt;std::pair&lt;char, bitstring&gt;&gt;;

  struct leaf final : node {
    char key;

    leaf(int freq, char key) : node(freq), key(key) {}
  };

  struct branch final : node {
    node_ptr lhs;
    node_ptr rhs;

    branch(node_ptr lhs, node_ptr rhs)
        : node(lhs-&gt;frequency + rhs-&gt;frequency), lhs(std::move(lhs)),
          rhs(std::move(rhs)) {}
  };

  // this allows us to share [codebook]s among encoded strings
  struct data {
    node_ptr decoder;
    encoder_t encoder;
  };
  std::shared_ptr&lt;data const&gt; underlying_;

public:
  template &lt;typename Iter&gt;
  codebook(Iter const first, Iter const last);

  template &lt;typename Iter&gt;
  std::vector&lt;bool&gt; encode(Iter first, Iter last) const;

  template &lt;typename Iter&gt;
  std::string decode(Iter first, Iter last) const;
};

struct encoded_string {
  codebook codes;
  std::vector&lt;bool&gt; string;

  explicit encoded_string(std::string const&amp; s)
      : codes(begin(s), end(s)), string(codes.encode(begin(s), end(s))) {}

  encoded_string(codebook codes, std::string const&amp; s)
      : codes(codes), string(codes.encode(begin(s), end(s))) {}

  std::string decoded() const {
    return codes.decode(begin(string), end(string));
  }
};

// --- implementation ---
inline codebook::node::~node() {}

inline std::vector&lt;bool&gt; with_new_bit(std::vector&lt;bool&gt; bits, bool b) {
  bits.push_back(b);
  return bits;
}

template &lt;typename Iter&gt;
codebook::codebook(Iter const first, Iter const last) {
  struct helper {
    static node_ptr make_decoder(Iter const first, Iter const last) {
      // in this part of the function, we build up a frequency list
      // sorted by frequency, descending
      auto freq = std::vector&lt;leaf&gt;();

      std::for_each(first, last, [&amp;freq](char c) {
        auto const it = std::find_if(
            begin(freq), end(freq), [c](auto const&amp; p) { return p.key == c; });
        if (it != end(freq)) {
          // it's already in the list
          it-&gt;frequency += 1;
        } else {
          // it's not already in the list
          freq.emplace_back(1, c);
        }
      });

      if (freq.empty()) {
        throw std::invalid_argument(&quot;attempted to codebook an empty range&quot;);
      }

      std::sort(begin(freq), end(freq), [](auto const&amp; lhs, auto const&amp; rhs) {
        return lhs.frequency &gt; rhs.frequency;
      });

      auto ret = std::vector&lt;std::unique_ptr&lt;node&gt;&gt;();
      std::transform(
          begin(freq), end(freq), std::back_inserter(ret), [](auto const l) {
            return std::make_unique&lt;leaf&gt;(l);
          });

      while (ret.size() &gt; 1) {
        auto rhs = std::move(ret.back());
        ret.pop_back();
        auto lhs = std::move(ret.back());
        ret.pop_back();

        auto new_node =
            std::make_unique&lt;branch&gt;(std::move(lhs), std::move(rhs));
        auto const new_freq = new_node-&gt;frequency;

        // look for the first element with a smaller frequency
        auto const it =
            std::find_if(begin(ret), end(ret), [new_freq](auto const&amp; n) {
              return n-&gt;frequency &lt; new_freq;
            });
        // and insert the new_node before that element
        ret.insert(it, std::move(new_node));
        // in this way, we keep the list sorted by frequency
      }

      return std::move(ret.back());
    }

    static void
    encoder_rec(node const* cur, std::vector&lt;bool&gt; bits, encoder_t&amp; out) {
      if (auto l = dynamic_cast&lt;leaf const*&gt;(cur)) {
        out.push_back(std::make_pair(l-&gt;key, std::move(bits)));
      } else if (auto b = dynamic_cast&lt;branch const*&gt;(cur)) {
        encoder_rec(b-&gt;lhs.get(), with_new_bit(bits, 0), out);
        encoder_rec(b-&gt;rhs.get(), with_new_bit(std::move(bits), 1), out);
      } else {
        unreachable();
      }
    }

    static encoder_t make_encoder(node const&amp; decoder) {
      auto ret = encoder_t();

      encoder_rec(&amp;decoder, std::vector&lt;bool&gt;(), ret);

      return ret;
    }
  };

  auto decoder = helper::make_decoder(first, last);
  auto encoder = helper::make_encoder(*decoder);
  underlying_ = std::make_shared&lt;data const&gt;(
      data{std::move(decoder), std::move(encoder)});
}

template &lt;typename Iter&gt;
std::vector&lt;bool&gt; codebook::encode(Iter const first, Iter const last) const {
  std::vector&lt;bool&gt; ret;

  auto&amp; encoder = underlying_-&gt;encoder;
  std::for_each(first, last, [&amp;ret, &amp;encoder](char c) {
    auto const it =
        std::find_if(begin(encoder), end(encoder), [c](auto const&amp; p) {
          return p.first == c;
        });
    if (it != end(encoder)) {
      auto const&amp; code = it-&gt;second;
      std::copy(begin(code), end(code), std::back_inserter(ret));
    } else {
      throw std::invalid_argument(
          &quot;The range has a character which was not in the huffman set&quot;);
    }
  });

  return ret;
}

template &lt;typename Iter&gt;
std::string codebook::decode(Iter const first, Iter const last) const {
  std::string ret;

  node const* const top = underlying_-&gt;decoder.get();

  // returns a pair:
  // the second member is the decoded character
  // the first member is the place we've gotten to in the range
  // i.e., if [0] is an 'a', and we have
  // [it, last) = { 0, 1, 1, 0 }
  // we return (it', 'a') such that
  // [it', last) = { 1, 1, 0 }
  auto decode_single =
      [top](Iter it, Iter const last) -&gt; std::pair&lt;Iter, char&gt; {
    node const* current_node = top;

    for (; it != last; ++it) {
      if (auto l = dynamic_cast&lt;leaf const*&gt;(current_node)) {
        return std::make_pair(it, l-&gt;key);
      } else if (auto b = dynamic_cast&lt;branch const*&gt;(current_node)) {
        if (*it) {
          current_node = b-&gt;rhs.get();
        } else {
          current_node = b-&gt;lhs.get();
        }
      } else {
        unreachable();
      }
    }

    if (auto l = dynamic_cast&lt;leaf const*&gt;(current_node)) {
      return std::make_pair(last, l-&gt;key);
    } else {
      throw std::invalid_argument(
          &quot;The range was not encoded with this huffman set&quot;);
    }
  };

  for (auto it = first; it != last;) {
    auto p = decode_single(it, last);
    it = p.first;
    ret.push_back(p.second);
  }

  return ret;
}

} // namespace huffman

int main() {
  std::string to_be_encoded = R&quot;(bibbity bobbity)&quot;;

  auto encoded = huffman::encoded_string(to_be_encoded);

  std::cout &lt;&lt; &quot;Encoded, the string looks like: &quot;;
  for (bool b : encoded.string) {
    std::cout &lt;&lt; b;
  }
  std::cout &lt;&lt; &quot;\nand decoded, the string looks like: &quot; &lt;&lt; encoded.decoded();
  std::cout &lt;&lt; &quot;\n\nAs opposed to the original, which is &quot;
            &lt;&lt; to_be_encoded.size() * 8 &lt;&lt; &quot; bits, the encoded has size &quot;
            &lt;&lt; encoded.string.size() &lt;&lt; &quot;.\n&quot;;
}
``````cpp
#include &lt;algorithm&gt;
#include &lt;array&gt;
#include &lt;bitset&gt;
#include &lt;cassert&gt;
#include &lt;cctype&gt;
#include &lt;cstddef&gt;
#include &lt;limits&gt;
#include &lt;memory&gt;
#include &lt;string&gt;
#include &lt;utility&gt;
#include &lt;vector&gt;

#include &lt;iostream&gt;

using std::begin;
using std::end;

namespace huffman {

[[noreturn]] inline void unreachable() {
  std::cerr &lt;&lt; &quot;this should never happen\n&quot;;
  std::abort();
}

// --- interface ---
class codebook {
  struct node {
    int frequency;

    node(int freq) : frequency(freq) {}
    virtual ~node() = 0;
  };

  // never null
  using node_ptr = std::unique_ptr&lt;node const&gt;;
  using bitstring = std::vector&lt;bool&gt;;

  // this is a flatmap between char and a bitstring
  // there should only ever be one character with a given
  // value at any time.
  using encoder_t = std::vector&lt;std::pair&lt;char, bitstring&gt;&gt;;

  struct leaf final : node {
    char key;

    leaf(int freq, char key) : node(freq), key(key) {}
  };

  struct branch final : node {
    node_ptr lhs;
    node_ptr rhs;

    branch(node_ptr lhs, node_ptr rhs)
        : node(lhs-&gt;frequency + rhs-&gt;frequency), lhs(std::move(lhs)),
          rhs(std::move(rhs)) {}
  };

  // this allows us to share [codebook]s among encoded strings
  struct data {
    node_ptr decoder;
    encoder_t encoder;
  };
  std::shared_ptr&lt;data const&gt; underlying_;

public:
  template &lt;typename Iter&gt;
  codebook(Iter const first, Iter const last);

  template &lt;typename Iter&gt;
  std::vector&lt;bool&gt; encode(Iter first, Iter last) const;

  template &lt;typename Iter&gt;
  std::string decode(Iter first, Iter last) const;
};

struct encoded_string {
  codebook codes;
  std::vector&lt;bool&gt; string;

  explicit encoded_string(std::string const&amp; s)
      : codes(begin(s), end(s)), string(codes.encode(begin(s), end(s))) {}

  encoded_string(codebook codes, std::string const&amp; s)
      : codes(codes), string(codes.encode(begin(s), end(s))) {}

  std::string decoded() const {
    return codes.decode(begin(string), end(string));
  }
};

// --- implementation ---
inline codebook::node::~node() {}

inline std::vector&lt;bool&gt; with_new_bit(std::vector&lt;bool&gt; bits, bool b) {
  bits.push_back(b);
  return bits;
}

template &lt;typename Iter&gt;
codebook::codebook(Iter const first, Iter const last) {
  struct helper {
    static node_ptr make_decoder(Iter const first, Iter const last) {
      // in this part of the function, we build up a frequency list
      // sorted by frequency, descending
      auto freq = std::vector&lt;leaf&gt;();

      std::for_each(first, last, [&amp;freq](char c) {
        auto const it = std::find_if(
            begin(freq), end(freq), [c](auto const&amp; p) { return p.key == c; });
        if (it != end(freq)) {
          // it's already in the list
          it-&gt;frequency += 1;
        } else {
          // it's not already in the list
          freq.emplace_back(1, c);
        }
      });

      if (freq.empty()) {
        throw std::invalid_argument(&quot;attempted to codebook an empty range&quot;);
      }

      std::sort(begin(freq), end(freq), [](auto const&amp; lhs, auto const&amp; rhs) {
        return lhs.frequency &gt; rhs.frequency;
      });

      auto ret = std::vector&lt;std::unique_ptr&lt;node&gt;&gt;();
      std::transform(
          begin(freq), end(freq), std::back_inserter(ret), [](auto const l) {
            return std::make_unique&lt;leaf&gt;(l);
          });

      while (ret.size() &gt; 1) {
        auto rhs = std::move(ret.back());
        ret.pop_back();
        auto lhs = std::move(ret.back());
        ret.pop_back();

        auto new_node =
            std::make_unique&lt;branch&gt;(std::move(lhs), std::move(rhs));
        auto const new_freq = new_node-&gt;frequency;

        // look for the first element with a smaller frequency
        auto const it =
            std::find_if(begin(ret), end(ret), [new_freq](auto const&amp; n) {
              return n-&gt;frequency &lt; new_freq;
            });
        // and insert the new_node before that element
        ret.insert(it, std::move(new_node));
        // in this way, we keep the list sorted by frequency
      }

      return std::move(ret.back());
    }

    static void
    encoder_rec(node const* cur, std::vector&lt;bool&gt; bits, encoder_t&amp; out) {
      if (auto l = dynamic_cast&lt;leaf const*&gt;(cur)) {
        out.push_back(std::make_pair(l-&gt;key, std::move(bits)));
      } else if (auto b = dynamic_cast&lt;branch const*&gt;(cur)) {
        encoder_rec(b-&gt;lhs.get(), with_new_bit(bits, 0), out);
        encoder_rec(b-&gt;rhs.get(), with_new_bit(std::move(bits), 1), out);
      } else {
        unreachable();
      }
    }

    static encoder_t make_encoder(node const&amp; decoder) {
      auto ret = encoder_t();

      encoder_rec(&amp;decoder, std::vector&lt;bool&gt;(), ret);

      return ret;
    }
  };

  auto decoder = helper::make_decoder(first, last);
  auto encoder = helper::make_encoder(*decoder);
  underlying_ = std::make_shared&lt;data const&gt;(
      data{std::move(decoder), std::move(encoder)});
}

template &lt;typename Iter&gt;
std::vector&lt;bool&gt; codebook::encode(Iter const first, Iter const last) const {
  std::vector&lt;bool&gt; ret;

  auto&amp; encoder = underlying_-&gt;encoder;
  std::for_each(first, last, [&amp;ret, &amp;encoder](char c) {
    auto const it =
        std::find_if(begin(encoder), end(encoder), [c](auto const&amp; p) {
          return p.first == c;
        });
    if (it != end(encoder)) {
      auto const&amp; code = it-&gt;second;
      std::copy(begin(code), end(code), std::back_inserter(ret));
    } else {
      throw std::invalid_argument(
          &quot;The range has a character which was not in the huffman set&quot;);
    }
  });

  return ret;
}

template &lt;typename Iter&gt;
std::string codebook::decode(Iter const first, Iter const last) const {
  std::string ret;

  node const* const top = underlying_-&gt;decoder.get();

  // returns a pair:
  // the second member is the decoded character
  // the first member is the place we've gotten to in the range
  // i.e., if [0] is an 'a', and we have
  // [it, last) = { 0, 1, 1, 0 }
  // we return (it', 'a') such that
  // [it', last) = { 1, 1, 0 }
  auto decode_single =
      [top](Iter it, Iter const last) -&gt; std::pair&lt;Iter, char&gt; {
    node const* current_node = top;

    for (; it != last; ++it) {
      if (auto l = dynamic_cast&lt;leaf const*&gt;(current_node)) {
        return std::make_pair(it, l-&gt;key);
      } else if (auto b = dynamic_cast&lt;branch const*&gt;(current_node)) {
        if (*it) {
          current_node = b-&gt;rhs.get();
        } else {
          current_node = b-&gt;lhs.get();
        }
      } else {
        unreachable();
      }
    }

    if (auto l = dynamic_cast&lt;leaf const*&gt;(current_node)) {
      return std::make_pair(last, l-&gt;key);
    } else {
      throw std::invalid_argument(
          &quot;The range was not encoded with this huffman set&quot;);
    }
  };

  for (auto it = first; it != last;) {
    auto p = decode_single(it, last);
    it = p.first;
    ret.push_back(p.second);
  }

  return ret;
}

} // namespace huffman

int main() {
  std::string to_be_encoded = R&quot;(bibbity bobbity)&quot;;

  auto encoded = huffman::encoded_string(to_be_encoded);

  std::cout &lt;&lt; &quot;Encoded, the string looks like: &quot;;
  for (bool b : encoded.string) {
    std::cout &lt;&lt; b;
  }
  std::cout &lt;&lt; &quot;\nand decoded, the string looks like: &quot; &lt;&lt; encoded.decoded();
  std::cout &lt;&lt; &quot;\n\nAs opposed to the original, which is &quot;
            &lt;&lt; to_be_encoded.size() * 8 &lt;&lt; &quot; bits, the encoded has size &quot;
            &lt;&lt; encoded.string.size() &lt;&lt; &quot;.\n&quot;;
}
```m```cpp
#include &lt;algorithm&gt;
#include &lt;array&gt;
#include &lt;bitset&gt;
#include &lt;cassert&gt;
#include &lt;cctype&gt;
#include &lt;cstddef&gt;
#include &lt;limits&gt;
#include &lt;memory&gt;
#include &lt;string&gt;
#include &lt;utility&gt;
#include &lt;vector&gt;

#include &lt;iostream&gt;

using std::begin;
using std::end;

namespace huffman {

[[noreturn]] inline void unreachable() {
  std::cerr &lt;&lt; &quot;this should never happen\n&quot;;
  std::abort();
}

// --- interface ---
class codebook {
  struct node {
    int frequency;

    node(int freq) : frequency(freq) {}
    virtual ~node() = 0;
  };

  // never null
  using node_ptr = std::unique_ptr&lt;node const&gt;;
  using bitstring = std::vector&lt;bool&gt;;

  // this is a flatmap between char and a bitstring
  // there should only ever be one character with a given
  // value at any time.
  using encoder_t = std::vector&lt;std::pair&lt;char, bitstring&gt;&gt;;

  struct leaf final : node {
    char key;

    leaf(int freq, char key) : node(freq), key(key) {}
  };

  struct branch final : node {
    node_ptr lhs;
    node_ptr rhs;

    branch(node_ptr lhs, node_ptr rhs)
        : node(lhs-&gt;frequency + rhs-&gt;frequency), lhs(std::move(lhs)),
          rhs(std::move(rhs)) {}
  };

  // this allows us to share [codebook]s among encoded strings
  struct data {
    node_ptr decoder;
    encoder_t encoder;
  };
  std::shared_ptr&lt;data const&gt; underlying_;

public:
  template &lt;typename Iter&gt;
  codebook(Iter const first, Iter const last);

  template &lt;typename Iter&gt;
  std::vector&lt;bool&gt; encode(Iter first, Iter last) const;

  template &lt;typename Iter&gt;
  std::string decode(Iter first, Iter last) const;
};

struct encoded_string {
  codebook codes;
  std::vector&lt;bool&gt; string;

  explicit encoded_string(std::string const&amp; s)
      : codes(begin(s), end(s)), string(codes.encode(begin(s), end(s))) {}

  encoded_string(codebook codes, std::string const&amp; s)
      : codes(codes), string(codes.encode(begin(s), end(s))) {}

  std::string decoded() const {
    return codes.decode(begin(string), end(string));
  }
};

// --- implementation ---
inline codebook::node::~node() {}

inline std::vector&lt;bool&gt; with_new_bit(std::vector&lt;bool&gt; bits, bool b) {
  bits.push_back(b);
  return bits;
}

template &lt;typename Iter&gt;
codebook::codebook(Iter const first, Iter const last) {
  struct helper {
    static node_ptr make_decoder(Iter const first, Iter const last) {
      // in this part of the function, we build up a frequency list
      // sorted by frequency, descending
      auto freq = std::vector&lt;leaf&gt;();

      std::for_each(first, last, [&amp;freq](char c) {
        auto const it = std::find_if(
            begin(freq), end(freq), [c](auto const&amp; p) { return p.key == c; });
        if (it != end(freq)) {
          // it's already in the list
          it-&gt;frequency += 1;
        } else {
          // it's not already in the list
          freq.emplace_back(1, c);
        }
      });

      if (freq.empty()) {
        throw std::invalid_argument(&quot;attempted to codebook an empty range&quot;);
      }

      std::sort(begin(freq), end(freq), [](auto const&amp; lhs, auto const&amp; rhs) {
        return lhs.frequency &gt; rhs.frequency;
      });

      auto ret = std::vector&lt;std::unique_ptr&lt;node&gt;&gt;();
      std::transform(
          begin(freq), end(freq), std::back_inserter(ret), [](auto const l) {
            return std::make_unique&lt;leaf&gt;(l);
          });

      while (ret.size() &gt; 1) {
        auto rhs = std::move(ret.back());
        ret.pop_back();
        auto lhs = std::move(ret.back());
        ret.pop_back();

        auto new_node =
            std::make_unique&lt;branch&gt;(std::move(lhs), std::move(rhs));
        auto const new_freq = new_node-&gt;frequency;

        // look for the first element with a smaller frequency
        auto const it =
            std::find_if(begin(ret), end(ret), [new_freq](auto const&amp; n) {
              return n-&gt;frequency &lt; new_freq;
            });
        // and insert the new_node before that element
        ret.insert(it, std::move(new_node));
        // in this way, we keep the list sorted by frequency
      }

      return std::move(ret.back());
    }

    static void
    encoder_rec(node const* cur, std::vector&lt;bool&gt; bits, encoder_t&amp; out) {
      if (auto l = dynamic_cast&lt;leaf const*&gt;(cur)) {
        out.push_back(std::make_pair(l-&gt;key, std::move(bits)));
      } else if (auto b = dynamic_cast&lt;branch const*&gt;(cur)) {
        encoder_rec(b-&gt;lhs.get(), with_new_bit(bits, 0), out);
        encoder_rec(b-&gt;rhs.get(), with_new_bit(std::move(bits), 1), out);
      } else {
        unreachable();
      }
    }

    static encoder_t make_encoder(node const&amp; decoder) {
      auto ret = encoder_t();

      encoder_rec(&amp;decoder, std::vector&lt;bool&gt;(), ret);

      return ret;
    }
  };

  auto decoder = helper::make_decoder(first, last);
  auto encoder = helper::make_encoder(*decoder);
  underlying_ = std::make_shared&lt;data const&gt;(
      data{std::move(decoder), std::move(encoder)});
}

template &lt;typename Iter&gt;
std::vector&lt;bool&gt; codebook::encode(Iter const first, Iter const last) const {
  std::vector&lt;bool&gt; ret;

  auto&amp; encoder = underlying_-&gt;encoder;
  std::for_each(first, last, [&amp;ret, &amp;encoder](char c) {
    auto const it =
        std::find_if(begin(encoder), end(encoder), [c](auto const&amp; p) {
          return p.first == c;
        });
    if (it != end(encoder)) {
      auto const&amp; code = it-&gt;second;
      std::copy(begin(code), end(code), std::back_inserter(ret));
    } else {
      throw std::invalid_argument(
          &quot;The range has a character which was not in the huffman set&quot;);
    }
  });

  return ret;
}

template &lt;typename Iter&gt;
std::string codebook::decode(Iter const first, Iter const last) const {
  std::string ret;

  node const* const top = underlying_-&gt;decoder.get();

  // returns a pair:
  // the second member is the decoded character
  // the first member is the place we've gotten to in the range
  // i.e., if [0] is an 'a', and we have
  // [it, last) = { 0, 1, 1, 0 }
  // we return (it', 'a') such that
  // [it', last) = { 1, 1, 0 }
  auto decode_single =
      [top](Iter it, Iter const last) -&gt; std::pair&lt;Iter, char&gt; {
    node const* current_node = top;

    for (; it != last; ++it) {
      if (auto l = dynamic_cast&lt;leaf const*&gt;(current_node)) {
        return std::make_pair(it, l-&gt;key);
      } else if (auto b = dynamic_cast&lt;branch const*&gt;(current_node)) {
        if (*it) {
          current_node = b-&gt;rhs.get();
        } else {
          current_node = b-&gt;lhs.get();
        }
      } else {
        unreachable();
      }
    }

    if (auto l = dynamic_cast&lt;leaf const*&gt;(current_node)) {
      return std::make_pair(last, l-&gt;key);
    } else {
      throw std::invalid_argument(
          &quot;The range was not encoded with this huffman set&quot;);
    }
  };

  for (auto it = first; it != last;) {
    auto p = decode_single(it, last);
    it = p.first;
    ret.push_back(p.second);
  }

  return ret;
}

} // namespace huffman

int main() {
  std::string to_be_encoded = R&quot;(bibbity bobbity)&quot;;

  auto encoded = huffman::encoded_string(to_be_encoded);

  std::cout &lt;&lt; &quot;Encoded, the string looks like: &quot;;
  for (bool b : encoded.string) {
    std::cout &lt;&lt; b;
  }
  std::cout &lt;&lt; &quot;\nand decoded, the string looks like: &quot; &lt;&lt; encoded.decoded();
  std::cout &lt;&lt; &quot;\n\nAs opposed to the original, which is &quot;
            &lt;&lt; to_be_encoded.size() * 8 &lt;&lt; &quot; bits, the encoded has size &quot;
            &lt;&lt; encoded.string.size() &lt;&lt; &quot;.\n&quot;;
}
</code></pre>
<p><a href="huffman_encoding/code/java/huffman.java">import, lang:&quot;java&quot;</a>
{% sample lang=&quot;go&quot; %}
<a href="huffman_encoding/code/go/huffman.go">import, lang:&quot;go&quot;</a>
{% sample lang=&quot;asm-x64&quot; %}
<a href="huffman_encoding/code/asm-x64/huffman.s">import, lang:&quot;asm-x64&quot;</a>
{% sample lang=&quot;scala&quot; %}
<a href="huffman_encoding/code/scala/huffman_encoding.scala">import, lang:&quot;scala&quot;</a>
{% sample lang=&quot;scratch&quot; %}
The code snippet was taken from this <a href="https://scratch.mit.edu/projects/389604255/">scratch project</a></p>
<p>
    <img  class="center" src="huffman_encoding/code/scratch/huffman.svg" width="700" />
</p>
```coconut
from collections import Counter, deque
from bisect import bisect
<p>class Tree</p>
<p>data Empty() from Tree
data Leaf(char, n is int) from Tree:
def <strong>str</strong>(self):
return f'Leaf({self.char}, {self.n})'</p>
<pre><code>__repr__ = __str__
</code></pre>
<p>data Node(left is Tree, right is Tree) from Tree:
def <strong>str</strong>(self):
return f'Node({str(self.left)}, {str(self.right)})'
<strong>repr</strong> = <strong>str</strong></p>
<p>def weight(Tree()) = 0
addpattern def weight(Leaf(char, n)) = n
addpattern def weight(Node(left, right)) = weight(left) + weight(right)</p>
<p>def build_huffman_tree(message):</p>
<pre><code># get sorted list of character and frequency pairs
frequencies = Counter(message)
trees = frequencies.most_common() |&gt; map$(t -&gt; Leaf(*t)) |&gt; reversed |&gt; deque

if not trees:
    return Empty()

# while there is more than one tree
while len(trees) &gt; 1:

    # pop off the two trees of least weight from the trees list
    tree_left = trees.popleft()
    tree_right = trees.popleft()

    # combine the nodes and add back to the nodes list
    new_tree = Node(tree_left, tree_right)

    # find the first tree that has a weight smaller than new_weight
    # and returns its index in the list.
    # If no such tree can be found, use len(trees) instead to append
    index = bisect(trees |&gt; map$(weight) |&gt; list, weight(new_tree))

    # insert the new tree there
    trees.insert(index, new_tree)

huffman_tree = trees[0]
return huffman_tree
</code></pre>
<p>def build_codebook(Empty(), code='') = []
addpattern def build_codebook(Leaf(char, n), code='') = [(char, code)]
addpattern def build_codebook(Node(left, right), code='') = 
build_codebook(left, code+'0') + build_codebook(right, code+'1')</p>
<p>def huffman_encode(codebook, message):</p>
<pre><code>if len(codebook) == 1:
    return '0' * len(message)

# build a char -&gt; code dictionary
forward_dict = dict(codebook)

return ''.join(message |&gt; map$(forward_dict[]))
</code></pre>
<p>def huffman_decode(codebook, encoded_message):</p>
<pre><code>decoded_message = []
key = ''

if not codebook:
    return ''
elif len(codebook) == 1:
    return codebook[0][0] * len(encoded_message)

# build a code -&gt; char dictionary
inverse_dict = dict((v, k) for k, v in codebook)

# for each bit in the encoding
# if the bit is in the dictionary, replace the bit with the paired
# character else look at the bit and the following bits together
# until a match occurs move to the next bit not yet looked at.
if encoded_message == '':
    return inverse_dict['']

for bit in encoded_message:
    key += bit
    if key in inverse_dict:
        decoded_message.append(inverse_dict[key])
        key = ''

return ''.join(decoded_message)
</code></pre>
<p>if <strong>name</strong> == '<strong>main</strong>':
# test example
message = 'bibbity_bobbity'
tree = build_huffman_tree(message)
codebook = build_codebook(tree)
encoded_message = huffman_encode(codebook, message)
decoded_message = huffman_decode(codebook, encoded_message)</p>
<pre><code>print('message:', message)
print('huffman tree:', tree)
print('codebook:', codebook)
print('encoded message:', encoded_message)
print('decoded message:', decoded_message)

# prints the following:
#
#  message: bibbity_bobbity
#  huffman_tree: Node(Leaf(b, 6), Node(Node(Leaf(y, 2), Leaf(t, 2)),
#                     Node(Node(Leaf(o, 1), Leaf(_, 1)), Leaf(i, 3))))
#  codebook: [('b', '0'), ('y', '100'), ('t', '101'),
#             ('o', '1100'), ('_', '1101'), ('i', '111')]
#  encoded_message: 01110011110110011010110000111101100
#  decoded_message: bibbity_bobbity
</code></pre>
<pre><code>



## License

##### Code Examples

The code examples are licensed under the MIT license (found in [LICENSE.md](https://github.com/algorithm-archivists/algorithm-archive/blob/master/LICENSE.md)).

##### Text

The text of this chapter was written by [James Schloss](https://github.com/leios) and is licensed under the [Creative Commons Attribution-ShareAlike 4.0 International License](https://creativecommons.org/licenses/by-sa/4.0/legalcode).

[&lt;p&gt;&lt;img  class=&quot;center&quot; src=&quot;../cc/CC-BY-SA_icon.svg&quot; /&gt;&lt;/p&gt;](https://creativecommons.org/licenses/by-sa/4.0/)

##### Images/Graphics
- The image &quot;[huffman_tree](res/huffman_tree.png)&quot; was created by [Julian Schacher](https://github.com/julianschacher) and is licensed under the [Creative Commons Attribution-ShareAlike 4.0 International License](https://creativecommons.org/licenses/by-sa/4.0/legalcode).

##### Pull Requests

After initial licensing ([#560](https://github.com/algorithm-archivists/algorithm-archive/pull/560)), the following pull requests have modified the text or graphics of this chapter:
- none
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="computer-graphics"><a class="header" href="#computer-graphics">Computer Graphics</a></h1>
<p>Of all areas of computer science research, none have had more of an immediate impact on multimedia than computer graphics.
This sub-field is distinctly different than computational science in that it focuses on the <em>appearance</em> of realistic details, instead of computing those details precisely.
Where a computational scientist might spend years writing software that runs on the fastest computers known to man to simulate climate, the computer graphics researcher might apply machine learning to create fluid simulations that look good enough to the untrained eye.
In the end, the computational scientist will have a plot and the computer graphics researcher will have a beautifully rendered simulation.</p>
<p>Though I may have painted computer graphics to be a bit hand-wavey, that could not be further from the truth!
Instead, I would argue that this field of research provides the closest approximation to realistic visualizations that desktop hardware can currently support.
Many art and video game studios are interested in telling a complete story via computational media, and this simply would not be possible without the rigorous efforts of researchers from around the world.
This is why Pixar hires researchers and will actively publish their findings after their movies are released.</p>
<p>Though the boundary between computer science research fields is a bit vague, for the purposes of the Algorithm Archive, we will broadly classify computer graphics as anything with direct applications to images or fields that can be represented as images.
Convolutions, for example, would not be considered part of computer graphics because they are used widely in all areas of computer science research; however, Canny edge detection will be.
We will also be covering a wide range of applications that are used for rendering high-resolution graphics and computational art.</p>
<p>As with all sections to the Algorithm Archive, this is a work in progress and subject to change, so feel free to let me know what you think!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="flood-fill"><a class="header" href="#flood-fill">Flood Fill</a></h1>
<p>Flood fill is a method that is surprisingly useful in a large number of different situations and keeps finding me wherever I go.
When I was completing my PhD, I had an idea to track superfluid vortices by using flood fill as a way to help mask out unnecessary features of the simulation.
When I was making a terminal game, I thought of creating an animation that was just flood fill in disguise.
When I decided to play minesweeper or Go with my girlfriend, flood fill was used in both!</p>
<p>Flood fill is probably most commonly known as the &quot;Bucket Fill&quot; application in most art programs {{ &quot;gimp_bucket&quot; | cite }}.
It's usually indicated by an icon that looks like a bucket and is known to fill in any enclosed area, as shown below:</p>
<p>
    <img  class="center" src="flood_fill/res/example.png" style="width:100%" />
</p>
<p>Because flood fill is incredibly common, there are a large number of variations to the method, some of which are more optimal than others.
For this chapter, we will cover the basics: how to fill a domain in a quick and dirty way.
In subsequent chapters, we will continue our journey by creating more and more efficient flood fill methods, including scanline-based and fixed memory methods {{ &quot;torbert2016&quot; | cite }}.</p>
<p>I have decided to split the chapter up for a few important reasons:</p>
<ol>
<li>I did not want to flood the Algorithm Archive with flood fill methods all at the same time.
I feel it's worth letting each chapter sit for a bit while we savor it's unique flavor.</li>
<li>Many users are implementing versions of each algorithm in their own languages and it is difficult to review and submit code for chapters with a lot of code chunks.
Several sub-chapters with less code is easier for everyone.</li>
<li>I am kinda under a time-constraint right now and wanted to make sure we regularly get content into the Algorithm Archive.</li>
</ol>
<p>So, without further a-do, let's hop right into it!</p>
<h2 id="what-does-flood-fill-do"><a class="header" href="#what-does-flood-fill-do">What does flood fill do?</a></h2>
<p>Flood fill is essentially composed of 2 parts:</p>
<ol>
<li>Determining the extents of the domain to fill</li>
<li>Walking through all elements within a domain and changing some property</li>
</ol>
<p>For the purposes of this chapter, we will be using a set of floating-point values that range from 0 to 1 instead of a color-space like RGB.
Though bucket fill is always used in art programs in some sort of color space, flood fill is more general and can be used in a space with any type of element.
As such, it makes sense to use a simpler element type so we can better understand the method.</p>
<p>So how do we go about finding the extents of the domain to fill?</p>
<p>Here, a domain will be defined as any connected set of elements in an \( n \)-dimensional space whose values do not vary beyond a predefined threshold.
As an example, if we take a circle embedded into a 2-dimensional grid, we have 3 separate domains:</p>
<ol>
<li>Inside the circle where all elements are 0.</li>
<li>The circle, itself, where the elements are set to 0.75.</li>
<li>Outside the circle where all elements are similarly 0.</li>
</ol>
<p>
    <img  class="center" src="flood_fill/res/simple_circle.png" style="width:70%" />
</p>
<p>Though there are some more complicated ways to determine the extents of the domain, we will not focus on this aspect of the flood fill method for the remainder of this chapter and instead leave it for subsequent chapters.
So now we will focus on the process of walking through each element in the domain and changing some property.</p>
<h2 id="domain-traversal"><a class="header" href="#domain-traversal">Domain traversal</a></h2>
<p>As before, the simplest example to work with is that of an image, where each element in our domain is a single pixel.
Here, we can connect each pixel to all other pixels in its vicinity, like so:</p>
<p>
    <img  class="center" src="flood_fill/res/grid_1.png" style="width:70%" />
</p>
<p>In this image, a border is shown between each individual pixel and a grid is superimposed to show how each pixel is connected to its neighbors.
This means that each element has 4 neighbors: north, south, east, and west.
We could also include northeast, southeast, southwest, and northwest if we wanted to do an 8-way fill, but we will restrict the discussion to the 4-way fill for now, as the method is essentially the same and slightly easier to understand with fewer elements to worry about.</p>
<p>By connecting each pixel to its neighbors in this way, the flood fill operation becomes a process of graph traversal, not too dissimilar from the <a href="flood_fill/../tree_traversal/tree_traversal.html">tree traversal</a> methods described before.
This means that after selecting our initial location, we can then traverse through all elements in either a depth-first or breadth-first fashion.
We will be covering the following this chapter:</p>
<ol>
<li>Finding all neighbors</li>
<li>Depth-first node traversal</li>
<li>Breadth-first node traversal and small-scale optimizations</li>
</ol>
<p>So let's start by discussing how we might go about finding the neighbors to fill.</p>
<h3 id="finding-all-neighbors"><a class="header" href="#finding-all-neighbors">Finding all neighbors</a></h3>
<p>The first step of this method is to query the location of all possible neighbors.
At first glance, this seems rather straightforward.
One simply needs to look up, down, left, and right of the current location and add those elements to the list of neighbors if they are:</p>
<ol>
<li>On the canvas</li>
<li>Have a value <em>close enough</em> to the old value we would like to replace</li>
</ol>
<p>In code, this might look like this:</p>
<pre><code class="language-julia">function find_neighbors(canvas, loc::CartesianIndex, old_val, new_val)
    
    # Finding north, south, east, west neighbors
    possible_neighbors = [loc + CartesianIndex(0, 1),
                          loc + CartesianIndex(1, 0),
                          loc + CartesianIndex(0, -1),
                          loc + CartesianIndex(-1, 0)]

    # Exclusing neighbors that should not be colored
    neighbors =  []
    for possible_neighbor in possible_neighbors
        if inbounds(size(canvas), possible_neighbor) &amp;&amp;
           canvas[possible_neighbor] == old_val
            push!(neighbors, possible_neighbor)
        end
    end

    return neighbors
end
</code></pre>
<pre><code class="language-c">int find_neighbors(struct canvas c, struct point p, int old_val, int new_val,
        struct point *neighbors) {
    int cnt = 0;
    struct point points[4] = {
        {p.x, p.y + 1},
        {p.x + 1, p.y},
        {p.x, p.y - 1},
        {p.x - 1, p.y}
    };

    for (int i = 0; i &lt; 4; ++i) {
        if (inbounds(points[i], c) &amp;&amp;
                c.data[points[i].x + c.max_x * points[i].y] == old_val) {
            neighbors[cnt++] = points[i];
        }
    }

    return cnt;
}
</code></pre>
<pre><code class="language-cpp">auto find_neighbors(
    std::vector&lt;std::vector&lt;float&gt;&gt; const&amp; grid,
    CartesianIndex loc,
    float old_value,
    float /* new_value */) {

  const std::vector&lt;CartesianIndex&gt; possible_neighbors{
      {loc[0], loc[1] + 1},
      {loc[0] + 1, loc[1]},
      {loc[0], loc[1] - 1},
      {loc[0] - 1, loc[1]}};

  std::vector&lt;CartesianIndex&gt; neighbors;

  for (auto const&amp; possible_neighbor : possible_neighbors) {
    const auto size = CartesianIndex{
        static_cast&lt;int&gt;(grid[0].size()), static_cast&lt;int&gt;(grid.size())};
    const auto x = static_cast&lt;std::size_t&gt;(possible_neighbor[0]);
    const auto y = static_cast&lt;std::size_t&gt;(possible_neighbor[1]);
    if (inbounds(size, possible_neighbor) &amp;&amp; grid[x][y] == old_value) {
      neighbors.push_back(possible_neighbor);
    }
  }

  return neighbors;
}
</code></pre>
<pre><code class="language-python">def find_neighbors(canvas, p, old_val, new_val):
    # north, south, east, west neighbors
    possible_neighbors = [
        Point(p.x, p.y+1),
        Point(p.x+1, p.y),
        Point(p.x-1, p.y),
        Point(p.x, p.y-1)
    ]

    # exclude the neighbors that go out of bounds and should not be colored
    neighbors = []
    for possible_neighbor in possible_neighbors:
        if inbounds(canvas.shape, possible_neighbor):
            if canvas[possible_neighbor] == old_val:
                neighbors.append(possible_neighbor)
    return neighbors
``````python
def find_neighbors(canvas, p, old_val, new_val):
    # north, south, east, west neighbors
    possible_neighbors = [
        Point(p.x, p.y+1),
        Point(p.x+1, p.y),
        Point(p.x-1, p.y),
        Point(p.x, p.y-1)
    ]

    # exclude the neighbors that go out of bounds and should not be colored
    neighbors = []
    for possible_neighbor in possible_neighbors:
        if inbounds(canvas.shape, possible_neighbor):
            if canvas[possible_neighbor] == old_val:
                neighbors.append(possible_neighbor)
    return neighbors
</code></pre>
<p><a href="flood_fill/code/coconut/flood_fill.coco">import:15-19, lang=&quot;coconut&quot;</a></p>
<p>This code is set up to return a vector of elements to then use for subsequent sections.</p>
<h3 id="depth-first-node-traversal"><a class="header" href="#depth-first-node-traversal">Depth-first node traversal</a></h3>
<p>Now that we have the ability to find all neighboring elements, we can proceed to traverse through those nodes in the most straightforward way: recursion.</p>
<p>In code, it might look like this:</p>
<pre><code class="language-julia">function recursive_fill!(canvas, loc::CartesianIndex, old_val, new_val)

    if (old_val == new_val)
        return
    end

    canvas[loc] = new_val

    possible_neighbors = find_neighbors(canvas, loc, old_val, new_val)
    for possible_neighbor in possible_neighbors
        recursive_fill!(canvas, possible_neighbor, old_val, new_val)
    end
end
</code></pre>
<pre><code class="language-c">void recursive_fill(struct canvas c, struct point p, int old_val,
        int new_val) {

    if (old_val == new_val) {
        return;
    }

    c.data[p.x + c.max_x * p.y] = new_val;

    struct point neighbors[4];
    int cnt = find_neighbors(c, p, old_val, new_val, neighbors);

    for (int i = 0; i &lt; cnt; ++i) {
        recursive_fill(c, neighbors[i], old_val, new_val);
    }
}
</code></pre>
<pre><code class="language-cpp">void recursive_fill(
    std::vector&lt;std::vector&lt;float&gt;&gt;&amp; grid,
    CartesianIndex loc,
    float old_value,
    float new_value) {
  if (old_value == new_value) {
    return;
  }

  const auto x = static_cast&lt;std::size_t&gt;(loc[0]);
  const auto y = static_cast&lt;std::size_t&gt;(loc[1]);

  grid[x][y] = new_value;

  const auto possible_neighbors = find_neighbors(grid, loc, old_value, new_value);
  for (auto const&amp; possible_neighbor : possible_neighbors) {
    recursive_fill(grid, possible_neighbor, old_value, new_value);
  }
}
</code></pre>
<pre><code class="language-python">def recursive_fill(canvas, p, old_val, new_val):
    if old_val == new_val:
        return

    canvas[p] = new_val

    neighbors = find_neighbors(canvas, p, old_val, new_val)
    for neighbor in neighbors:
        recursive_fill(canvas, neighbor, old_val, new_val)
</code></pre>
<pre><code class="language-coconut">        return

    canvas[location] = new_value
    # consume is important here, because otherwise, the recursive function is not called again
    consume(
        find_neighbours(canvas, location, old_value)
        |&gt; map$(recursive_fill$(canvas, ?, old_value, new_value))
    )


</code></pre>
<p>The above code continues recursing through available neighbors as long as neighbors exist, and this should work so long as we are adding the correct set of neighbors.</p>
<p>Additionally, it is possible to do the same type of traversal by managing a stack, like so:</p>
<pre><code class="language-julia">function stack_fill!(canvas, loc::CartesianIndex, old_val, new_val)
    if new_val == old_val
        return
    end

    s = Stack{CartesianIndex}()
    push!(s, loc)

    while length(s) &gt; 0
        current_loc = pop!(s)
        if canvas[current_loc] == old_val
            canvas[current_loc] = new_val
            possible_neighbors = find_neighbors(canvas, current_loc,
                                                old_val, new_val)
            for neighbor in possible_neighbors
                push!(s,neighbor)
            end
        end
        
    end
end
</code></pre>
<pre><code class="language-c">void stack_fill(struct canvas c, struct point p, int old_val, int new_val) {
    if (old_val == new_val) {
        return;
    }

    struct stack stk = get_stack();
    stack_push(&amp;stk, p);

    while (!stack_empty(stk)) {
        struct point cur_loc = stack_pop(&amp;stk);
        if (c.data[cur_loc.x + c.max_x * cur_loc.y] == old_val) {
            c.data[cur_loc.x + c.max_x * cur_loc.y] = new_val;

            struct point neighbors[4];
            int cnt = find_neighbors(c, cur_loc, old_val, new_val, neighbors);

            for (int i = 0; i &lt; cnt; ++i) {
                stack_push(&amp;stk, neighbors[i]);
            }
        }
    }

    free_stack(stk);
}
</code></pre>
<pre><code class="language-cpp">void stack_fill(
    std::vector&lt;std::vector&lt;float&gt;&gt;&amp; grid,
    CartesianIndex loc,
    float old_value,
    float new_value) {
  if (old_value == new_value) {
    return;
  }

  auto s = std::stack&lt;CartesianIndex&gt;{};
  s.push(loc);

  while (s.size() &gt; 0) {
    const auto current_loc = s.top();
    s.pop();

    const auto x = static_cast&lt;std::size_t&gt;(current_loc[0]);
    const auto y = static_cast&lt;std::size_t&gt;(current_loc[1]);

    if (grid[x][y] == old_value) {
      grid[x][y] = new_value;
      const auto possible_neighbors =
          find_neighbors(grid, current_loc, old_value, new_value);
      for (auto const&amp; neighbor : possible_neighbors) {
        s.push(neighbor);
      }
    }
  }
}
</code></pre>
<pre><code class="language-python">def stack_fill(canvas, p, old_val, new_val):
    if old_val == new_val:
        return

    stack = [p]

    while stack:
        cur_loc = stack.pop()
        canvas[cur_loc] = new_val
        stack += find_neighbors(canvas, cur_loc, old_val, new_val)
</code></pre>
<pre><code class="language-coconut">def stack_fill(canvas, location is Point, old_value, new_value):
    if new_value == old_value or not inbounds(canvas.shape, location):
        return

    stack = [location]

    while stack:
        current_location = stack.pop()
        if canvas[current_location] == old_value:
            canvas[current_location] = new_value
            stack.extend(find_neighbours(canvas, current_location, old_value))

</code></pre>
<p>This is ultimately the same method of traversal as before; however, because we are managing our own data structure, there are a few distinct differences:</p>
<ol>
<li>The manually managed stack could be slightly slower and potentially more memory-intensive</li>
<li>It is easy to reach the maximum recursion depth on certain hardware with the recursive method, so it is best to use the stack-based implementation in those cases.</li>
</ol>
<p>If we were to use either of these methods to fill a circle embedded in a two dimensional domain, we would see the following</p>
<div style="text-align:center">
<video style="width:70%" controls loop>
  <source src="res/recurse_animation.mp4" type="video/mp4">
Your browser does not support the video tag.
</video>
</div>
<p>Here, we see that these methods will traverse through one direction first before filling from there.
This is potentially the easiest method to write, but it is not the most intuitive fill pattern.
I suspect that if someone was asked to fill the contents of the circle on their own, they would fill it more evenly from the center, like so:</p>
<div style="text-align:center">
<video style="width:70%" controls loop>
  <source src="res/queue_animation.mp4" type="video/mp4">
Your browser does not support the video tag.
</video>
</div>
<p>This is simply another traversal strategy known as breadth-first traversal and comes with its own set of caveats.
We will discuss this further in the next subsection</p>
<h3 id="breadth-first-node-traversal-and-small-scale-optimizations"><a class="header" href="#breadth-first-node-traversal-and-small-scale-optimizations">Breadth-first node traversal and small-scale optimizations</a></h3>
<p>Breadth-first node traversal is as simple as switching the stack in the depth-first strategy with a queue.
The code would look something like this:</p>
<pre><code class="language-julia">function queue_fill!(canvas, loc::CartesianIndex, old_val, new_val)
    if new_val == old_val
        return
    end

    q = Queue{CartesianIndex}()
    enqueue!(q, loc)

    # Coloring the initial location
    canvas[loc] = new_val

    while length(q) &gt; 0
        current_loc = dequeue!(q)

        possible_neighbors = find_neighbors(canvas, current_loc,
                                            old_val, new_val)

        # Coloring as we are enqueuing neighbors
        for neighbor in possible_neighbors
            canvas[neighbor] = new_val
            enqueue!(q,neighbor)
        end
        
    end
end
</code></pre>
<pre><code class="language-c">void queue_fill(struct canvas c, struct point p, int old_val, int new_val) {
    if (old_val == new_val) {
        return;
    }

    struct queue q = get_queue(sizeof(struct point *));
    enqueue(&amp;q, p);

    while (!queue_empty(q)) {
        struct point cur_loc = dequeue(&amp;q);
        if (c.data[cur_loc.x + c.max_x * cur_loc.y] == old_val) {
            c.data[cur_loc.x + c.max_x * cur_loc.y] = new_val;

            struct point neighbors[4];
            int cnt = find_neighbors(c, cur_loc, old_val, new_val, neighbors);

            for (int i = 0; i &lt; cnt; ++i) {
                enqueue(&amp;q, neighbors[i]);
            }
        }
    }

    free_queue(q);
}
</code></pre>
<pre><code class="language-cpp">void queue_fill(
    std::vector&lt;std::vector&lt;float&gt;&gt;&amp; grid,
    CartesianIndex loc,
    float old_value,
    float new_value) {
  if (old_value == new_value) {
    return;
  }

  auto q = std::queue&lt;CartesianIndex&gt;{};
  q.push(loc);
  const auto x = static_cast&lt;std::size_t&gt;(loc[0]);
  const auto y = static_cast&lt;std::size_t&gt;(loc[1]);
  grid[x][y] = new_value;

  while (q.size() &gt; 0) {
    const auto current_loc = q.front();
    q.pop();
    const auto possible_neighbors =
        find_neighbors(grid, current_loc, old_value, new_value);
    for (auto const&amp; neighbor : possible_neighbors) {
      const auto neighbor_x = static_cast&lt;std::size_t&gt;(neighbor[0]);
      const auto neighbor_y = static_cast&lt;std::size_t&gt;(neighbor[1]);
      grid[neighbor_x][neighbor_y] = new_value;
      q.push(neighbor);
    }
  }
}
</code></pre>
<pre><code class="language-python">def queue_fill(canvas, p, old_val, new_val):
    if old_val == new_val:
        return

    q = Queue()
    q.put(p)

    canvas[p] = new_val

    while not q.empty():
        cur_loc = q.get()
        neighbors = find_neighbors(canvas, cur_loc, old_val, new_val)

        for neighbor in neighbors:
            canvas[neighbor] = new_val
            q.put(neighbor)
</code></pre>
<pre><code class="language-coconut">    if new_value == old_value or not inbounds(canvas.shape, location):
        return

    queue = deque()
    queue.append(location)

    canvas[location] = new_value

    while queue:
        current_location = queue.popleft()
        for neighbour in find_neighbours(canvas, current_location, old_value):
            canvas[neighbour] = new_value
            queue.append(neighbour)


</code></pre>
<p>Now, there is a small trick in this code that must be considered to make sure it runs optimally.
Namely, the nodes must be colored <em>when they are being enqueued</em>, not when visiting the node.
At least for me, it was not immediately obvious why this would be the case, but let me try to explain.</p>
<p>Let's imagine that we decided to write code that colored all neighboring nodes only when visiting them.
When querying all possible neighbors, we will add 4 elements to the queue for the north, south, east, and west neighbors of the initial node, as shown below:</p>
<p>
    <img  class="center" src="flood_fill/res/grid_2.png" style="width:70%" />
</p>
<p>Now let's imagine we travel east first.
It then enqueues three more nodes: north, south, and east again.
This is shown below:</p>
<p>
    <img  class="center" src="flood_fill/res/grid_3.png" style="width:70%" />
</p>
<p>It does not enqueue its west neighbor because this has already been colored.
At this stage, we will have six nodes ready to be colored and 2 that are already colored.
Now let's say we travel north next.
This node will enqueue three more nodes: west, north, and east, as shown below:</p>
<p>
    <img  class="center" src="flood_fill/res/grid_4.png" style="width:70%" />
</p>
<p>The problem is that the east element has <em>already been enqueued for coloring by the previous node</em>!.
This shared element is colored in red.
As we progress through all four initial neighbors, we will find 4 nodes that are doubly enqueued: all directions diagonal to the initial location!
This is again shown below:</p>
<p>
    <img  class="center" src="flood_fill/res/grid_5.png" style="width:70%" />
</p>
<p>As the number of nodes increases, so does the number of duplicate nodes.
A quick fix is to color the nodes <em>when they are being enqueued</em> like in the example code above.
When doing this, duplicates will not be enqueued with a breadth-first scheme because they will already be colored when other nodes are trying to find their neighbors.
This created a node connection pattern like so:</p>
<p>
    <img  class="center" src="flood_fill/res/grid_6.png" style="width:70%" />
</p>
<p>As some final food for thought: why wasn't this a problem with the depth-first strategy?
The simple answer is that it actually was an issue, but it was way less prevalent.
With the depth-first strategy, a number of unnecessary nodes are still pushed to the stack, but because we consistently push one direction before spreading out to other directions, it is more likely that the nodes have filled neighbors when they are looking for what to fill around them.</p>
<p>Simply put: depth-first traversal is slightly more efficient in this case unless you can color as querying for neighbors, in which case breadth-first is more efficient.</p>
<h2 id="conclusions-2"><a class="header" href="#conclusions-2">Conclusions</a></h2>
<p>As stated before, the method discussed in this chapter is just the tip of the iceberg and many other flood fill methods exist that are likely to be more efficient for most purposes.
These will all be covered in subsequent chapters which will come out somewhat regularly throughout the next few months, lest we flood that archive with flood fill methods.</p>
<h2 id="video-explanation-12"><a class="header" href="#video-explanation-12">Video Explanation</a></h2>
<p>Here is a video describing tree traversal:</p>
<div style="text-align:center">
<iframe width="560" height="315" src="https://www.youtube.com/embed/ldqAmkdthHY" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
</div>
<h2 id="example-code-18"><a class="header" href="#example-code-18">Example Code</a></h2>
<p>The example code for this chapter will be the simplest application of flood fill that still adequately tests the code to ensure it is stopping at boundaries appropriately.
For this, we will create a two dimensional array of floats, all starting at 0.0, and then set a single vertical line of elements at the center to be 1.0.
After, we will fill in the left-hand side of the array to be all ones by choosing any point within the left domain to fill.</p>
<pre><code class="language-julia">using DataStructures
using Test

# Function to check to make sure we are on the canvas
function inbounds(canvas_size, loc)

    # Make sure we are not beneath or to the left of the canvas
    if minimum(Tuple(loc)) &lt; 1
        return false

    # Make sure we are not to the right of the canvas
    elseif loc[2] &gt; canvas_size[2]
        return false

    # Make sure we are not above the canvas
    elseif loc[1] &gt; canvas_size[1]
        return false
    else
        return true
    end
end

function find_neighbors(canvas, loc::CartesianIndex, old_val, new_val)
    
    # Finding north, south, east, west neighbors
    possible_neighbors = [loc + CartesianIndex(0, 1),
                          loc + CartesianIndex(1, 0),
                          loc + CartesianIndex(0, -1),
                          loc + CartesianIndex(-1, 0)]

    # Exclusing neighbors that should not be colored
    neighbors =  []
    for possible_neighbor in possible_neighbors
        if inbounds(size(canvas), possible_neighbor) &amp;&amp;
           canvas[possible_neighbor] == old_val
            push!(neighbors, possible_neighbor)
        end
    end

    return neighbors
end

function stack_fill!(canvas, loc::CartesianIndex, old_val, new_val)
    if new_val == old_val
        return
    end

    s = Stack{CartesianIndex}()
    push!(s, loc)

    while length(s) &gt; 0
        current_loc = pop!(s)
        if canvas[current_loc] == old_val
            canvas[current_loc] = new_val
            possible_neighbors = find_neighbors(canvas, current_loc,
                                                old_val, new_val)
            for neighbor in possible_neighbors
                push!(s,neighbor)
            end
        end
        
    end
end


function queue_fill!(canvas, loc::CartesianIndex, old_val, new_val)
    if new_val == old_val
        return
    end

    q = Queue{CartesianIndex}()
    enqueue!(q, loc)

    # Coloring the initial location
    canvas[loc] = new_val

    while length(q) &gt; 0
        current_loc = dequeue!(q)

        possible_neighbors = find_neighbors(canvas, current_loc,
                                            old_val, new_val)

        # Coloring as we are enqueuing neighbors
        for neighbor in possible_neighbors
            canvas[neighbor] = new_val
            enqueue!(q,neighbor)
        end
        
    end
end

function recursive_fill!(canvas, loc::CartesianIndex, old_val, new_val)

    if (old_val == new_val)
        return
    end

    canvas[loc] = new_val

    possible_neighbors = find_neighbors(canvas, loc, old_val, new_val)
    for possible_neighbor in possible_neighbors
        recursive_fill!(canvas, possible_neighbor, old_val, new_val)
    end
end

function main()

    # Creation of a 5x5 grid with a single row of 1.0 elements 
    grid = zeros(5,5)
    grid[3,:] .= 1

    # Create solution grid
    answer_grid = zeros(5,5)
    answer_grid[1:3, :] .= 1

    # Start filling at 1,1
    start_loc = CartesianIndex(1,1)

    @testset &quot;Fill Methods&quot; begin
        # Use recursive method and reinitialize grid
        recursive_fill!(grid, start_loc, 0.0, 1.0)
        @test grid == answer_grid

        grid[1:2,:] .= 0

        # Use queue method and reinitialize grid
        queue_fill!(grid, start_loc, 0.0, 1.0)
        @test grid == answer_grid

        grid[1:2,:] .= 0

        # Use stack method and reinitialize grid
        stack_fill!(grid, start_loc, 0.0, 1.0)
        @test grid == answer_grid
    end

end

main()
</code></pre>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

struct canvas {
    int max_x, max_y;
    int *data;
};

struct point {
    int x, y;
};

struct stack {
    size_t top, capacity;
    struct point *data;
};

struct queue {
    size_t front, back, capacity;
    struct point *data;
};

int inbounds(struct point p, struct canvas c) {
    return (p.x &lt; 0 || p.y &lt; 0 || p.y &gt;= c.max_y || p.x &gt;= c.max_x) ? 0 : 1;
}

int find_neighbors(struct canvas c, struct point p, int old_val, int new_val,
        struct point *neighbors) {
    int cnt = 0;
    struct point points[4] = {
        {p.x, p.y + 1},
        {p.x + 1, p.y},
        {p.x, p.y - 1},
        {p.x - 1, p.y}
    };

    for (int i = 0; i &lt; 4; ++i) {
        if (inbounds(points[i], c) &amp;&amp;
                c.data[points[i].x + c.max_x * points[i].y] == old_val) {
            neighbors[cnt++] = points[i];
        }
    }

    return cnt;
}

struct stack get_stack() {
    struct stack stk;

    stk.data = malloc(4 * sizeof(struct point));
    stk.capacity = 4;
    stk.top = 0;

    return stk;
}

int stack_empty(struct stack stk) {
    return stk.top == 0;
}

void stack_push(struct stack *stk, struct point element) {
    if (stk-&gt;top == stk-&gt;capacity) {
        stk-&gt;capacity *= 2;
        stk-&gt;data = realloc(stk-&gt;data, stk-&gt;capacity * sizeof(stk-&gt;data[0]));
    }

    stk-&gt;data[stk-&gt;top++] = element;
}

struct point stack_pop(struct stack *stk) {
    return stk-&gt;data[--stk-&gt;top];
}

void free_stack(struct stack stk) {
    free(stk.data);
}

void stack_fill(struct canvas c, struct point p, int old_val, int new_val) {
    if (old_val == new_val) {
        return;
    }

    struct stack stk = get_stack();
    stack_push(&amp;stk, p);

    while (!stack_empty(stk)) {
        struct point cur_loc = stack_pop(&amp;stk);
        if (c.data[cur_loc.x + c.max_x * cur_loc.y] == old_val) {
            c.data[cur_loc.x + c.max_x * cur_loc.y] = new_val;

            struct point neighbors[4];
            int cnt = find_neighbors(c, cur_loc, old_val, new_val, neighbors);

            for (int i = 0; i &lt; cnt; ++i) {
                stack_push(&amp;stk, neighbors[i]);
            }
        }
    }

    free_stack(stk);
}

struct queue get_queue() {
    struct queue q;

    q.data = calloc(4, sizeof(struct point));
    q.front = 0;
    q.back = 0;
    q.capacity = 4;

    return q;
}

int queue_empty(struct queue q) {
    return q.front == q.back;
}

void enqueue(struct queue *q, struct point element) {
    if (q-&gt;front == (q-&gt;back + 1) % q-&gt;capacity) {
        size_t size = sizeof(q-&gt;data[0]);
        struct point *tmp = calloc((q-&gt;capacity * 2), size);
        memcpy(tmp, q-&gt;data + q-&gt;front, (q-&gt;capacity - q-&gt;front) * size);
        memcpy(tmp + q-&gt;capacity - q-&gt;front, q-&gt;data, (q-&gt;front - 1) * size);

        free(q-&gt;data);

        q-&gt;data = tmp;
        q-&gt;back = q-&gt;capacity - 1;
        q-&gt;front = 0;
        q-&gt;capacity *= 2;
    }

    q-&gt;data[q-&gt;back] = element;
    q-&gt;back = (q-&gt;back + 1) % q-&gt;capacity;
}

struct point dequeue(struct queue *q) {
    struct point ret = q-&gt;data[q-&gt;front];
    q-&gt;front = (q-&gt;front + 1) % q-&gt;capacity;

    return ret;
}

void free_queue(struct queue q) {
    free(q.data);
}

void queue_fill(struct canvas c, struct point p, int old_val, int new_val) {
    if (old_val == new_val) {
        return;
    }

    struct queue q = get_queue(sizeof(struct point *));
    enqueue(&amp;q, p);

    while (!queue_empty(q)) {
        struct point cur_loc = dequeue(&amp;q);
        if (c.data[cur_loc.x + c.max_x * cur_loc.y] == old_val) {
            c.data[cur_loc.x + c.max_x * cur_loc.y] = new_val;

            struct point neighbors[4];
            int cnt = find_neighbors(c, cur_loc, old_val, new_val, neighbors);

            for (int i = 0; i &lt; cnt; ++i) {
                enqueue(&amp;q, neighbors[i]);
            }
        }
    }

    free_queue(q);
}

void recursive_fill(struct canvas c, struct point p, int old_val,
        int new_val) {

    if (old_val == new_val) {
        return;
    }

    c.data[p.x + c.max_x * p.y] = new_val;

    struct point neighbors[4];
    int cnt = find_neighbors(c, p, old_val, new_val, neighbors);

    for (int i = 0; i &lt; cnt; ++i) {
        recursive_fill(c, neighbors[i], old_val, new_val);
    }
}

int grid_cmp(int *a, int *b, int size) {
    for (int i = 0; i &lt; size; ++i) {
        if (a[i] != b[i]) {
            return 0;
        }
    }

    return 1;
}

int main() {
    int grid[25] = {
        0, 0, 0, 0, 0,
        0, 0, 0, 0, 0,
        1, 1, 1, 1, 1,
        0, 0, 0, 0, 0,
        0, 0, 0, 0, 0
    };
    int grid1[25] = {
        0, 0, 0, 0, 0,
        0, 0, 0, 0, 0,
        1, 1, 1, 1, 1,
        0, 0, 0, 0, 0,
        0, 0, 0, 0, 0
    };
    int grid2[25] = {
        0, 0, 0, 0, 0,
        0, 0, 0, 0, 0,
        1, 1, 1, 1, 1,
        0, 0, 0, 0, 0,
        0, 0, 0, 0, 0
    };
    int answer_grid[25] = {
        1, 1, 1, 1, 1,
        1, 1, 1, 1, 1,
        1, 1, 1, 1, 1,
        0, 0, 0, 0, 0,
        0, 0, 0, 0, 0
    };

    struct canvas c = {5, 5, grid};
    struct canvas c1 = {5, 5, grid1};
    struct canvas c2 = {5, 5, grid2};

    struct point start_loc = {0, 0};

    int pass_cnt = 0;

    recursive_fill(c, start_loc, 0, 1);
    pass_cnt += grid_cmp(grid, answer_grid, 25);

    stack_fill(c1, start_loc, 0, 1);
    pass_cnt += grid_cmp(grid1, answer_grid, 25);

    queue_fill(c2, start_loc, 0, 1);
    pass_cnt += grid_cmp(grid2, answer_grid, 25);

    printf(&quot;Test Summary: | Pass\tTotal\n&quot;);
    printf(&quot;Fill Methods  |\t%d\t3\n&quot;, pass_cnt);

    return 0;
}

</code></pre>
<pre><code class="language-cpp">#include &lt;array&gt;
#include &lt;cassert&gt;
#include &lt;iostream&gt;
#include &lt;queue&gt;
#include &lt;stack&gt;
#include &lt;vector&gt;

using CartesianIndex = std::array&lt;int, 2&gt;;

auto inbounds(CartesianIndex size, CartesianIndex loc) {
  if (loc[0] &lt; 0 || loc[1] &lt; 0) {
    return false;
  } else if (loc[0] &gt;= size[0] || loc[1] &gt;= size[1]) {
    return false;
  }
  return true;
}

auto find_neighbors(
    std::vector&lt;std::vector&lt;float&gt;&gt; const&amp; grid,
    CartesianIndex loc,
    float old_value,
    float /* new_value */) {

  const std::vector&lt;CartesianIndex&gt; possible_neighbors{
      {loc[0], loc[1] + 1},
      {loc[0] + 1, loc[1]},
      {loc[0], loc[1] - 1},
      {loc[0] - 1, loc[1]}};

  std::vector&lt;CartesianIndex&gt; neighbors;

  for (auto const&amp; possible_neighbor : possible_neighbors) {
    const auto size = CartesianIndex{
        static_cast&lt;int&gt;(grid[0].size()), static_cast&lt;int&gt;(grid.size())};
    const auto x = static_cast&lt;std::size_t&gt;(possible_neighbor[0]);
    const auto y = static_cast&lt;std::size_t&gt;(possible_neighbor[1]);
    if (inbounds(size, possible_neighbor) &amp;&amp; grid[x][y] == old_value) {
      neighbors.push_back(possible_neighbor);
    }
  }

  return neighbors;
}

void recursive_fill(
    std::vector&lt;std::vector&lt;float&gt;&gt;&amp; grid,
    CartesianIndex loc,
    float old_value,
    float new_value) {
  if (old_value == new_value) {
    return;
  }

  const auto x = static_cast&lt;std::size_t&gt;(loc[0]);
  const auto y = static_cast&lt;std::size_t&gt;(loc[1]);

  grid[x][y] = new_value;

  const auto possible_neighbors = find_neighbors(grid, loc, old_value, new_value);
  for (auto const&amp; possible_neighbor : possible_neighbors) {
    recursive_fill(grid, possible_neighbor, old_value, new_value);
  }
}

void queue_fill(
    std::vector&lt;std::vector&lt;float&gt;&gt;&amp; grid,
    CartesianIndex loc,
    float old_value,
    float new_value) {
  if (old_value == new_value) {
    return;
  }

  auto q = std::queue&lt;CartesianIndex&gt;{};
  q.push(loc);
  const auto x = static_cast&lt;std::size_t&gt;(loc[0]);
  const auto y = static_cast&lt;std::size_t&gt;(loc[1]);
  grid[x][y] = new_value;

  while (q.size() &gt; 0) {
    const auto current_loc = q.front();
    q.pop();
    const auto possible_neighbors =
        find_neighbors(grid, current_loc, old_value, new_value);
    for (auto const&amp; neighbor : possible_neighbors) {
      const auto neighbor_x = static_cast&lt;std::size_t&gt;(neighbor[0]);
      const auto neighbor_y = static_cast&lt;std::size_t&gt;(neighbor[1]);
      grid[neighbor_x][neighbor_y] = new_value;
      q.push(neighbor);
    }
  }
}

void stack_fill(
    std::vector&lt;std::vector&lt;float&gt;&gt;&amp; grid,
    CartesianIndex loc,
    float old_value,
    float new_value) {
  if (old_value == new_value) {
    return;
  }

  auto s = std::stack&lt;CartesianIndex&gt;{};
  s.push(loc);

  while (s.size() &gt; 0) {
    const auto current_loc = s.top();
    s.pop();

    const auto x = static_cast&lt;std::size_t&gt;(current_loc[0]);
    const auto y = static_cast&lt;std::size_t&gt;(current_loc[1]);

    if (grid[x][y] == old_value) {
      grid[x][y] = new_value;
      const auto possible_neighbors =
          find_neighbors(grid, current_loc, old_value, new_value);
      for (auto const&amp; neighbor : possible_neighbors) {
        s.push(neighbor);
      }
    }
  }
}

int main() {

  const std::vector&lt;std::vector&lt;float&gt;&gt; grid{
      {0, 0, 1, 0, 0},
      {0, 0, 1, 0, 0},
      {0, 0, 1, 0, 0},
      {0, 0, 1, 0, 0},
      {0, 0, 1, 0, 0}};

  const std::vector&lt;std::vector&lt;float&gt;&gt; solution_grid{
      {1, 1, 1, 0, 0},
      {1, 1, 1, 0, 0},
      {1, 1, 1, 0, 0},
      {1, 1, 1, 0, 0},
      {1, 1, 1, 0, 0}};

  const CartesianIndex start_loc{1, 1};

  auto test_grid = grid;
  recursive_fill(test_grid, start_loc, 0.0, 1.0);
  assert(test_grid == solution_grid);

  test_grid = grid;
  queue_fill(test_grid, start_loc, 0.0, 1.0);
  assert(test_grid == solution_grid);

  test_grid = grid;
  stack_fill(test_grid, start_loc, 0.0, 1.0);
  assert(test_grid == solution_grid);

  return EXIT_SUCCESS;
}
</code></pre>
<p>{% sample lang=&quot;py&quot; %}
<a href="flood_fill/code/python/flood_fill.py">import:, lang=&quot;python&quot;</a></p>
<pre><code class="language-coconut">from collections import deque
import numpy as np


data Point(x, y):
    def __add__(self, other is Point) = Point(self.x + other.x, self.y + other.y)


# This function is necessary, because negative indices wrap around the
# array in Coconut.
def inbounds(canvas_shape, location is Point) =
    min(location) &gt;= 0 and location.x &lt; canvas_shape[0] and location.y &lt; canvas_shape[1]


def find_neighbours(canvas, location is Point, old_value):
    possible_neighbours = ((Point(0, 1), Point(1, 0), Point(0, -1), Point(-1, 0))
                          |&gt; map$(location.__add__))

    yield from possible_neighbours |&gt; filter$(x -&gt; (inbounds(canvas.shape, x)
                                                    and canvas[x] == old_value))


def stack_fill(canvas, location is Point, old_value, new_value):
    if new_value == old_value or not inbounds(canvas.shape, location):
        return

    stack = [location]

    while stack:
        current_location = stack.pop()
        if canvas[current_location] == old_value:
            canvas[current_location] = new_value
            stack.extend(find_neighbours(canvas, current_location, old_value))


def queue_fill(canvas, location is Point, old_value, new_value):
    if new_value == old_value or not inbounds(canvas.shape, location):
        return

    queue = deque()
    queue.append(location)

    canvas[location] = new_value

    while queue:
        current_location = queue.popleft()
        for neighbour in find_neighbours(canvas, current_location, old_value):
            canvas[neighbour] = new_value
            queue.append(neighbour)


def recursive_fill(canvas, location is Point, old_value, new_value):
    if new_value == old_value or not inbounds(canvas.shape, location):
        return

    canvas[location] = new_value
    # consume is important here, because otherwise, the recursive function is not called again
    consume(
        find_neighbours(canvas, location, old_value)
        |&gt; map$(recursive_fill$(canvas, ?, old_value, new_value))
    )


def test_grid(initial_canvas, final_canvas, function):
    canvas = initial_canvas.copy() # ensure the initial_canvas is unchanged
    function(canvas)
    return (canvas == final_canvas).all()

def test():
    from collections import namedtuple

    TestResults = namedtuple('TestResults', 'passes failures')
    pass_count = failure_count = 0

    grid = np.zeros((5, 5))
    grid[2,:] = 1
    solution_grid = np.zeros((5, 5))
    solution_grid[:3,] = 1

    starting_location = Point(0, 0)

    recursive_test_func = recursive_fill$(?, starting_location, 0, 1)
    # The following is manual unit testing of the function
    if test_grid(grid, solution_grid, recursive_test_func):
        pass_count += 1
        print('.', end='')
    else:
        failure_count += 1
        print('F', end='')

    stack_test_func = stack_fill$(?, starting_location, 0, 1)
    if test_grid(grid, solution_grid, stack_test_func):
        print('.', end='')
        pass_count += 1
    else:
        print('F', end='')
        failure_count += 1

    queue_test_func = queue_fill$(?, starting_location, 0, 1)
    if test_grid(grid, solution_grid, queue_test_func):
        print('.', end='')
        pass_count += 1
    else:
        print('F', end='')
        failure_count += 1

    print()
    print(TestResults(pass_count, failure_count))

if __name__ == '__main__':
    # Testing setup
    test()

</code></pre>
<h3 id="bibliography-8"><a class="header" href="#bibliography-8">Bibliography</a></h3>
<p>{% references %} {% endreferences %}</p>
<h2 id="license-35"><a class="header" href="#license-35">License</a></h2>
<h5 id="code-examples-33"><a class="header" href="#code-examples-33">Code Examples</a></h5>
<p>The code examples are licensed under the MIT license (found in <a href="https://github.com/algorithm-archivists/algorithm-archive/blob/master/LICENSE.md">LICENSE.md</a>).</p>
<h5 id="text-35"><a class="header" href="#text-35">Text</a></h5>
<p>The text of this chapter was written by <a href="https://github.com/leios">James Schloss</a> and is licensed under the <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</p>
<p><a href="https://creativecommons.org/licenses/by-sa/4.0/"><p><img  class="center" src="flood_fill/../cc/CC-BY-SA_icon.svg" /></p></a></p>
<h5 id="imagesgraphics-17"><a class="header" href="#imagesgraphics-17">Images/Graphics</a></h5>
<ul>
<li>The image &quot;<a href="flood_fill/res/example.png">Example Bucket Fill</a>&quot; was created by <a href="https://github.com/leios">James Schloss</a> and is licensed under the <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</li>
<li>The image &quot;<a href="flood_fill/res/simple_circle.png">Circle Domains</a>&quot; was created by <a href="https://github.com/leios">James Schloss</a> and is licensed under the <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</li>
<li>The image &quot;<a href="flood_fill/res/grid_1.png">Grid 1</a>&quot; was created by <a href="https://github.com/leios">James Schloss</a> and is licensed under the <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</li>
<li>The image &quot;<a href="flood_fill/res/grid_2.png">Grid 2</a>&quot; was created by <a href="https://github.com/leios">James Schloss</a> and is licensed under the <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</li>
<li>The image &quot;<a href="flood_fill/res/grid_3.png">Grid 3</a>&quot; was created by <a href="https://github.com/leios">James Schloss</a> and is licensed under the <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</li>
<li>The image &quot;<a href="flood_fill/res/grid_4.png">Grid 4</a>&quot; was created by <a href="https://github.com/leios">James Schloss</a> and is licensed under the <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</li>
<li>The image &quot;<a href="flood_fill/res/grid_5.png">Grid 5</a>&quot; was created by <a href="https://github.com/leios">James Schloss</a> and is licensed under the <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</li>
<li>The image &quot;<a href="flood_fill/res/grid_6.png">Grid 6</a>&quot; was created by <a href="https://github.com/leios">James Schloss</a> and is licensed under the <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</li>
<li>The video &quot;<a href="flood_fill/res/recurse_animation.mp4">Stack Fill</a>&quot; was created by <a href="https://github.com/leios">James Schloss</a> and is licensed under the <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</li>
<li>The video &quot;<a href="flood_fill/res/queue_animation.mp4">Queue Fill</a>&quot; was created by <a href="https://github.com/leios">James Schloss</a> and is licensed under the <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="quantum-information"><a class="header" href="#quantum-information">Quantum Information</a></h1>
<p>Quantum information theory is... intense.
It requires a strong and fundamental understanding of classical information theory and quantum mechanics.
It is not obvious in any way and deserves many textbooks on it's own.
In fact, there are numerous textbooks on the subject already.
The purpose of this section isn't to outdo any of that fundamental knowledge.
Instead, we will attempt to distill the knowledge into a short, intuitive summary, with the hopes of helping people to understand more about the topic and pursue it further on their own.</p>
<p>At the time of writing, true quantum computers do not exist.
We do have some systems that are able to simulate qubits, they are not truly universal quantum computers.
The closest market-ready system we currently have is D-WAVE, which boasts an impressive 128 qubits!</p>
<p>There are many places to start an introduction to quantum information theory, so we'll go through it one step at a time:</p>
<ol>
<li><strong>Quantum bitlogic:</strong> what is a qubit and how is it different than a classical bit?</li>
<li><strong>Quantum gates and quantum circuits:</strong> How do you fundamentally build a quantum algorithm?</li>
<li><strong>Quantum computers in the wild:</strong> Current experimental techniques to create a quantum computer and what makes them ill-suited as real quantum computers</li>
<li><strong>A survey of current quantum algorithms:</strong> There are a number of algorithms that promise fantastic advantages when performed on quantum computers and should really shake up the industry when they are finally experimentally realized.</li>
</ol>
<p>As a note, item 3 might seem out of place for a book on algorithms, and I would tend to agree; however, at this point there is a phenomenal amount of research being done to realize the first truly quantum computer and there are a number of potential systems that could work for this purpose.
These systems will change how we think about and interface with quantum computation in the future and it is important to discuss where the field might be heading and when we can expect quantum computers at home.</p>
<p>Now, there are not too many languages that can compile quantum code.
A while ago, we tried to make a quantum circuit compiler, which was modeled after the SPICE circuit simulator, but this was far from a computer language.
At this point in time, it is impossible to tell what quantum computing languages will look like when we finally have a truly quantum machine, so for the time being, we will not ask for community code for the chapters related to quantum information.</p>
<p>basically, it's hard to imagine how to would adequately implement Shor's algorithm in C.
As always, this section will be updated as we add more algorithms to the list.</p>
<h2 id="license-36"><a class="header" href="#license-36">License</a></h2>
<h5 id="code-examples-34"><a class="header" href="#code-examples-34">Code Examples</a></h5>
<p>The code examples are licensed under the MIT license (found in <a href="https://github.com/algorithm-archivists/algorithm-archive/blob/master/LICENSE.md">LICENSE.md</a>).</p>
<h5 id="text-36"><a class="header" href="#text-36">Text</a></h5>
<p>The text of this chapter was written by <a href="https://github.com/leios">James Schloss</a> and is licensed under the <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</p>
<p><a href="https://creativecommons.org/licenses/by-sa/4.0/"><p><img  class="center" src="quantum_information/../cc/CC-BY-SA_icon.svg" /></p></a></p>
<h5 id="pull-requests-32"><a class="header" href="#pull-requests-32">Pull Requests</a></h5>
<p>After initial licensing (<a href="https://github.com/algorithm-archivists/algorithm-archive/pull/560">#560</a>), the following pull requests have modified the text or graphics of this chapter:</p>
<ul>
<li>none</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-easter-algorithm-computus"><a class="header" href="#the-easter-algorithm-computus">The Easter Algorithm (Computus)</a></h1>
<p>Though the word <em>Computus</em> can technically describe any sort of computation {{ &quot;bede725&quot; | cite }} or else a set of medieval tables for calculating various astrological events {{ &quot;dictcomputus&quot; | cite }}, it is also one of the most common historical names for the calculation of the Christian holiday of Easter every year.
Nominally, Easter happens the Sunday after the first full moon after the spring equinox (roughly March 21st).
This particular full moon is known by a number of names, such as the Pink (Strawberry) Moon, Hunter's Moon, or the Snow Moon, along with several others.
The most common name for it is the paschal full moon, which translates to &quot;Passover&quot; in Greek and signifies an important Jewish festival.</p>
<p>For the first few centuries, the date of Easter each year was dictated by the Pope; however, after the church grew, it was no longer straightforward to communicate this date to all of Christendom.
As such, the church did what it could to algorithmically generate tables for clergy to determine the date of Easter each year.
To this day, the calculation of Easter still poses a problem, with western and eastern (orthodox) churches celebrating on different dates approximately 50% of the time.</p>
<p>I'll be honest, there is a lot of good, Christian drama surrounding the calculation of this event and it's remarkably interesting to read about {{ &quot;bien2004&quot; | cite }}.
Suffice it to say that the date of Easter bamboozled many historical scholars, with at least one algorithm appearing in the early archives of the now famous scientific journal of <em>Nature</em> {{ &quot;computus1876&quot; | cite }}.
The calculation was so complicated that even Frederick Gauss had to try his hand at it (and failed before being corrected by one of his students).</p>
<p>Essentially, the date of Easter depends on both the lunar and solar cycles
The date of the paschal full moon, for example, is static in the lunar calendar, but it is not in the solar calendar.
In this way, computus is the act of mapping a lunar cycle onto the Gregorian (solar) calendar everyone knows and loves.
Because many different calendar systems have existed throughout history, there was a natural question as to <em>which</em> calendar system would be used to calculate the precise date of Easter.
The western churches chose the Gregorian calendar and the eastern churches chosethe Julian one, and this is one reason why western and eastern churches sometimes celebrate on different dates.
That said, the Gregorian calendar more accurately represents the true date of the paschal full moon, so the western church's approach ended up being more precise.</p>
<p>Though there are many methods to calculate Easter, for now, we will focus only on Gauss's algorithm; however, we mayl certainly come back (in subsequent years) to incorporate other Easter algorithms if there is demand.
These algorithms are some of my favorite gems in the history of algorithm design because of all the drama surrounding the calculation of something that seems trivial!
After all, how hard could it be to calculate Easter?</p>
<h2 id="gausss-easter-algorithm-history"><a class="header" href="#gausss-easter-algorithm-history">Gauss's Easter algorithm history</a></h2>
<p>Gauss is known for a lot of things: Gaussian elimination, the Cooley-Tukey method before Cooley or Tukey even existed, Gauss's Law for electromagnetism, etc.
One thing he is <em>not</em> particularly well known for is an algorithm he devised in 1800, which was later corrected by his student Peter Paul Tittle in 1816.
In fact, there were a series of publications from Gauss in this era all relating to the precise date of Easter.
The legend goes that Gauss actually did not know his real birthday in the Gregorian calendar and used this same algorithm to determine it.
Apparently, his mother only told him that he was born on a Wednesday 8 days before Ascension Day in 1777, which corresponds to April 30th {{ &quot;bien2004&quot; | cite }}.</p>
<p>Honestly, Gauss's Easter algorithm was the 19th century equivalent of undocumented code.
I could imagine Gauss grumpily &quot;patching&quot; his method when users complained that it did not work on dates past 4200 or even certain dates within his own era!
When some of his compatriots (such as Johann Lambert and Jean Joseph Delambre) expressed their concern over the method's performance, Gauss replied by saying,</p>
<blockquote>
<p>The investigation by which the formula [...] is found is based on higher arithmetic, for which I presumably cannot refer to any publication.</p>
</blockquote>
<p>Which was the 19th century equivalent of saying, &quot;you are too dumb to understand my genius.&quot;
I have definitely met a few fledgling programmers who feel the same, but none of them were anywhere near as prolific as Gauss.</p>
<p>One of the most important fans of Gauss's work was Servois, who created a calendar based on Gauss's 1800 publication, shown below:</p>
<img class="center" src="computus/res/servois_1800.png" alt="Servois' 1800 table"  style="width:80%">
<p>This calendar shows the date the paschal full moon, indicating that Easter will be the following Sunday {{ &quot;servois&quot; | cite }}.
In this table, a value greater than 22 indicates the full moon will be on the presented number (date) in March and a value less than 22 indicates the full moon will be on that date in April.
The \( y \)-axis of this table indicates the decade and the \( x \)-axis indicates the precise year.
Admittedly, the notation is a bit funky, but it was 1813.
Times were different then.</p>
<p>The task for this chapter will be to explain (to the best of my abilities) how one would go about using Gauss's Easter algorithm to calculate the date of Easter for any given year (within the limitations of the algorithm).</p>
<h2 id="background"><a class="header" href="#background">Background</a></h2>
<p>Because Easter is the Sunday following the paschal full moon, which is the first full moon of spring, Gauss's algorithm is tasked at finding a way to map the lunar calendar to the Gregorian (solar) calendar.
For this reason, before discussing the algorithm, itself, we must first introduce both calendar systems.
The Gregorian (solar) calendar has been created to mark Earth's full revolution around the Sun, which is approximately 365.2425 days.
Unfortunately, days are based on the Earth's rotation about its axis, not its revolution around the Sun, so the number of days in a year is not an integer number (such as 365).
This discrepancy has actually lead to a large number of calendar systems, including one invented by Gauss, himself {{ &quot;standish2004&quot; | cite }}.
Before the Gregorian calendar, there was another correction made from an old Roman calendar to set the days in a year to be 365.25 days.
This was called the Julian calendar.
From there, the Julian calendar was further corrected to the Gregorian calendar with 365.2425 days.
Though there is only a small change necessary to use Gauss's Easter algorithm for the Julian calendar, this will not be covered here; however, if you want to see this, we can add it in upon request.</p>
<p>To account for the non-integer nature of the Gregorian year, a leap day is celebrated on February 29th every 4 years, with exception of when the year is a multiple of 100, where no leap-day is observed; if the year is divisible by 400, however, a leap day is still observed.
This means that every 400 years, there are 97 leap days.
This is why a leap day was celebrated in 2020 and 2000, but was not in 1900.
If at this point, you feel like your favorite calendar system is held together by duct tape and string, you would be right.</p>
<p>In addition to the solar year, Gauss's Easter algorithm also needs to keep the lunar year into account.
A lunar month corresponds to the time it takes the Moon to complete one full revolution around the Earth.
In most cases, this is approximately 27.5 days {{ &quot;lunar_month_wiki&quot; | cite }}.
That said, space is complicated and the Moon is not the only revolving body.
Lunar phases are related to the time it takes for the Moon to return to its location <em>in relation to</em> the line connecting the Sun and Earth, as shown below:</p>
<img class="center" src="computus/res/orbit.svg" alt="Synodic half year"  style="width:90%">
<p>This is called the synodic month and will be the approximation used for this chapter.
Below, we also show a snapshot of this simulation after 6 synodic months:</p>
<img class="center" src="computus/res/synodic_half_year.png" alt="Synodic half year"  style="width:90%">
<p>Here, we show an outline of the Earth and Moon in an arbitrary initial position, each with an angle of \( -\frac{\pi}{4} \) from the horizontal axis.
In addition, we show the location of the Moon and Earth again after 6 synodic months and additional outlines for each intermediate synodic month.
Red lines are drawn from the center of the sun to the moon to indicate the positioning of the moon in relation to the sun and earth.
In all positions, the Moon is hidden behind the Earth, creating the full moon phase.
In this way, the synodic month is the time between two consecutive phases, which is slightly longer than the time it takes to revolve around the Earth and return to the same angle (here \( \frac{\pi}{4} \)).
Each synodic month is approximately 29.5 days, so a synodic year of 12 lunar months is 354 days, which is 11 days shorter than the normal 365 days in a Gregorian year.
The following is a pictorial representation of offset between a solar and lunar year:</p>
<img class="center" src="computus/res/orbit.png" alt="Full year"  style="width:90%">
<p>Here, we see the Sun at the center, with the Earth and Moon starting the year at an angle of \( -\frac{\pi}{4} \) from the horizontal axis.
The initial location of the Earth and Moon are shown as an outline with the letter &quot;A&quot; at their center.
After a full synodic lunar year (12 lunar months), another outline of the Earth and Moon are shown at position B, and after a full Gregorian year, they are shown in position C.
An arc is then drawn showing the difference of 11 days between the Earth's position after a synodic year, and another arc is drawn to show the difference between the Moon's position after a full Gregorian year.</p>
<p>Because the synodic month and the solar year are not synchronized, the phase of the Moon will be different on the same day of the Gregorian year.
That said, the lunar and solar calendars will re-synchronize roughly every 19 years.
For example, if there is a new moon on January 1st, 2020, there will not be a new moon on January 1st, 2021; however, there <em>will</em> be a new moon on January 1st, 2039.
This 19-year cycle where the Moon and Sun are waiting to re-synchronize is known as the Metonic cycle and has been studied for centuries.</p>
<p>This cycle allows us to somewhat easily transition between solar and lunar calendars.
If we imagine any Gregorian date (let's say January 1st again for clarity), the moon could be in one of 19 different phases, as shown below:</p>
<img class="center" src="computus/res/metonic.png" alt="Metonic cycle"  style="width:90%">
<p>Here, we show each possible phase of the moon as an outline, but the actual phase as a grey circle.
Essentially, by knowing what year we are on in the Metonic cycle, we can single out which phase of the moon we will see on any given date.
This is powerful and will allow us to find the next full moon by looking ahead a few days.</p>
<p>As a final note, there is a small offset in the Metonic cycle of 1 hour and 45 minutes every 19 years, so in 2500 years, it will be 8 days off, but that's a problem for people in 2500.
For now, we should be able to start discussing the algorithm, itself.</p>
<h2 id="the-algorithm-1"><a class="header" href="#the-algorithm-1">The algorithm</a></h2>
<p>As alluded to in Gauss's quote above, the Easter algorithm is closer to a set of formulas than a method used to compute anything on a modern computer.
This is partially because of bad software engineering by Gauss and partially because computers did not really exist at that point.
Considering this method was literally called <em>Computus</em>, there probably was not much to compute at all at the time.
Nowadays, you could more easily find the date of Easter with loops and conditions, but this is the <em>Arcane</em> Algorithm Archive, and this is definitely an arcane algorithm, so let's go!</p>
<p>For this section, we will be following similar notation to Gauss's original 1800 work, which is a bit terse and hard to follow; however, each term is significantly meaningful.
If you are reading this and think you have a better way to present anything, please let us know (with an issue or pull request on github) and we can correct the text!</p>
<p>This method can be split into 2 parts:</p>
<ol>
<li>Calculating the days from March 21st to the next full moon</li>
<li>Calculating the days from the full moon to the next Sunday</li>
</ol>
<p>In the following sections, we will discuss both individually.</p>
<h3 id="calculating-the-date-of-the-next-full-moon"><a class="header" href="#calculating-the-date-of-the-next-full-moon">Calculating the date of the next full moon</a></h3>
<p>To start, we will be calculating \( d \), which is the number of days until the next full moon from March 21st (the first day of spring according to the pope).
To calculate this, we need to first calculate a number of auxiliary variables, starting with the current year's location on the Metonic calendar,
\[ a = \text{year}~%~19, \]
where \( % \) is the modulo operator and 19 is the length of the Metonic calendar in years.
From here, we also need to calculate an offset to \( a \), and for this we need the century index,
\[ k = \left\lfloor\frac{\text{year}}{100}\right\rfloor, \]
where \( \lfloor\cdot\rfloor \) is the flooring operation of rounding the value down to the nearest integer.
With this, we can calculate the shift in the Metonic cycle to be,</p>
<p>\[ p = \left\lfloor\frac{13+8k}{25}\right\rfloor. \]</p>
<p>This expression represents the fact that the Metonic cycle will be 8 days off every 2500 years and adds an additional offset of 13 to ensure the Metonic cycle aligns with empirical observation.</p>
<p>At this point, we know what year we are at on the Metonic calendar and have calculated an offset accordingly; however, we have yet to take into account leap years.
As stated above, there are 97 leap days every 400 years, and the calculation of \( p \) above requires correction for the 3 leap days missed.
If one adds 25 leap days per century and subtracts \( k \), they will find 96 leap days every 400 years instead, which is a close approximation, but off by one.
This accounts for the fact that leap days are not celebrated on years that are multiples of 100.
There is, however, an exception made for years that are multiples of 400, which is why Gauss calculated an additional variable,</p>
<p>\[ q = \left\lfloor\frac{k}{4}\right\rfloor. \]</p>
<p>This means that \( 100-k-q \) will provide the appropriate number of leap days every 400 years.
After this is found, we then calculate a sum of all offsets within a lunar month.</p>
<p>\[ M = (15-p+k-q)~%~30 \]</p>
<p>where 15 is an offset indicating that the full moon on year 0 is 15 days from March 21st, \( p \) is the number of days we are off from the Metonic cycle, and \( k-q \) are non-observed leap days.
The values of \( p \), \( k \), and \( q \) all provide <em>century</em> offsets, which means that the value of \( M \) will provide the correct starting point for each century.
The \( %30 \) (modulo 30 arithmetic) constricts our calculation to be within a single synodic lunar month of approximately 30 days.</p>
<p>With all this information, we can finally calculate the number of days from March 21st until the first full moon, as</p>
<p>\[ d = (19a+M)~%~30 \]</p>
<p>Again, the \( %~30 \) operation makes sense here because there is no way the next full moon could occur over 30 days (a synodic lunar month) from March 21st.
At first glance, this is simply a calculation of \( a \) (where we are on the Metonic cycle) with some offset, \( M \).
This is true, but there is an additional multiplicative factor of 19.
One might be tempted to wave this away by saying, &quot;19 is the number of years in the Metonic cycle, so this makes sense!&quot;
The truth is that that 19 is a bit more complicated.
This calculation is a calculation of <em>days</em>, not years.</p>
<p>Every 12 lunar months is roughly 354 days, which is 11 days shorter than 365.
This means that every year in the Metonic cycle, the lunar phase will be 11 days behind.
It just so happens that \( -11~%~30 = 19 \).
Thus, \( 19a \) is a combination of this 11 day offset and the fact that we are using modulo 30 arithmetic.
After 19 years, the lunar calendar will be a full 365 days off in the solar calendar, but again, we only care about <em>day</em> offsets in this calculation.
No one really keeps track of lunar years, just solar ones.</p>
<p>Regardless, we now have \( d \), the number of days until the next full moon.
Interestingly, this is all the information necessary to replicate Servois's table above.
From here, we simply need to create a two-dimensional array with the decade on the \( y \) axis and year on the \( x \) axis and set within it the value of \( (21+d)~%~31 \), where the 21 represents the 21st of March, and the \( %~31 \) comes from the fact that there are 31 days in March.
For example, if we were to do this computation for the years from 2000 to 2099, we would find the following table:</p>
<img class="center" src="computus/res/servois_2000.png" alt="Servois' 2000 table"  style="width:90%">
<p>Which shows that the date of the paschal full moon for 2020 is April 9th.
Now we can move on to finding the precise date of Easter, which should be the following Sunday</p>
<h3 id="calculating-the-next-sunday"><a class="header" href="#calculating-the-next-sunday">Calculating the next Sunday</a></h3>
<p>This calculation will take a few variables from the previous section, namely \( k-q \) (the number of non-observed leap days), and \( d \) (the number of days since March 21st to the next full moon).
For the last calculation, we synchronized the number of days in a lunar month with the Gregorian (solar) calendar.
For this computation, we do similar operations, but for the weekly calendar of 7 days, this value will be stored in \( e \).
The first step is calculating the correct offset each century based on the fact that Jan 1st, in year 1 was a Friday and then accounting for all the non-observed leap days (\( k-q \)),</p>
<p>\[ N = (4+k-q)~%~7. \]</p>
<p>From here, things get a little tricky.
There are 52 weeks in a year, but \( 52\times7=364 \), meaning we are essentially one day off every year, with exception of leap years where we are two days off.
As an example, look at the following table</p>
<table><thead><tr><th>January 1st</th><th>Day of the week</th><th>Special considerations</th></tr></thead><tbody>
<tr><td>2017</td><td>Sunday</td><td>None</td></tr>
<tr><td>2018</td><td>Monday</td><td>None</td></tr>
<tr><td>2019</td><td>Tuesday</td><td>None</td></tr>
<tr><td>2020</td><td>Wednesday</td><td>Leap Year</td></tr>
<tr><td>2021</td><td>Friday</td><td>None</td></tr>
</tbody></table>
<p>Simply put, every year we should subtract one day of the week, but on leap years, we should subtract 2.
To keep tabs on this, we need two separate counts,</p>
<p>\[ b = \text{year}~%~4, \]
and
\[ c = \text{year}~%~7, \]
where \( b \) keeps track of leap years, and \( c \) simply increments by 1 every year.
Through a bit of mathematical magic, we can find the expression \( 2b+4c \), which will be -1 in modulo 7 arithmetic for every year, except leap years where it will be -2.</p>
<p>With all these terms put together, we can finally calculate the offset from the full moon to Easter Sunday as</p>
<p>\[ e = (2b+4c+6d+N)~%~7. \]</p>
<p>Here, all terms are described as above and the multiplicative factor of 6 to \( d \) will provide an offset to Sunday without correcting for leap days.</p>
<h3 id="wrapping-up"><a class="header" href="#wrapping-up">Wrapping up</a></h3>
<p>At this point, we can calculate the days from March 21st to Easter Sunday to be \( d+e \).
In particular</p>
<p>\[
\text{Easter} = \left{
\begin{align}
d+e+22\text{ March}&amp; \qquad \text{if } 22+d+e\leq31 \\
d+e-9\text{ April}&amp; \qquad \text{if } 22+d+e&gt;31 \\
\end{align}
\right.
\]</p>
<p>Remember that March 22nd would be the first possible day to celebrate Easter because March 21st would be the first possible full moon of spring.
All said, there are a few exceptions that are somewhat tricky to understand, namely:</p>
<p>\[
e = \left{
\begin{align}
&amp;e \\
&amp;-1, \qquad \text{if } d=29 \text{ and } e=6 \text{ or } d=28, e=6, \text{ and } a&gt;10
\end{align}
\right.
\]</p>
<p>These conditionals are placed on the output of \( d \) and correspond to when Easter falls on April 26th (if \( d = 29 \)) or April 25th (if \( d = 28 \)).
In both of these cases, we are setting \( e=-1 \), which has the effect of removing a week from the date of Easter.
For example, an Easter that would be celebrated on the 26th would instead be celebrated on the 19th.</p>
<p>Many say that these conditionals are placed on the output for historical reasons, but between you and me, I feel there is a more mathematical reason that I do not fully understand.
After all, why is the correction for \( d=28 \) only placed on the Easter date output on the second half of the Metonic cycle (if \( a &gt; 10 \))?
If you think you might have a better idea as to why these dates are corrected as such, please let us know!</p>
<p>As mentioned, this particular algorithm does not make use of any standard computational techniques.
There are no loops, conditionals, stacks, or queues.
However, there can be no doubt that Gauss was a master of his craft.
The sheer complexity of this calculation both baffles and astounds me -- especially because this was done hundreds of years before computational thinking became common-place.</p>
<p>Sure, this can be done straightforwardly with a calculator, but it is no doubt an algorithm worth discussing and celebrating for its ingenuity at the time of creation.</p>
<h2 id="video-explanation-13"><a class="header" href="#video-explanation-13">Video Explanation</a></h2>
<p>Here is a video describing key elements of Gauss's Easter Algorithm:</p>
<div style="text-align:center">
<iframe width="560" height="315" src="https://www.youtube.com/embed/x6Yud882QKE" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
</div>
<h2 id="example-code-19"><a class="header" href="#example-code-19">Example Code</a></h2>
<p>Unlike many other chapters in the Algorithm Archive, this particular method can be described almost entirely by mathematical expressions.
As such, it should be relatively straightforward to implement in a number of different languages, and I heartily encourage you to do so!
For now, we have the code outputting a tuple of \( d \) and \( e \), so users can use this to calculate either the date of Easter or Servois's table, depending on their use-case; however, please modify the code however you wish!</p>
<pre><code class="language-julia">function computus(year; servois=false)

    # Year's position on the 19 year metonic cycle
    a = mod(year, 19)

    # Century index
    k = fld(year, 100)

    # Shift of metonic cycle, add a day offset every 300 years
    p = fld(13 + 8 * k, 25)

    # Correction for non-observed leap days
    q = fld(k, 4)

    # Correction to starting point of calculation each century
    M = mod(15 - p + k - q, 30)

    # Number of days from March 21st until the full moon
    d = mod(19 * a + M, 30)

    # Returning if user wants value for Servois' table
    if servois
        return string(mod(21 + d,31))
    end

    # Finding the next Sunday
    # Century-based offset in weekly calculation
    N = mod(4 + k - q, 7)

    # Correction for leap days
    b = mod(year, 4)
    c = mod(year, 7)

    # Days from d to next Sunday
    e = mod(2 * b + 4 * c + 6 * d + N, 7)

    # Historical corrections for April 26 and 25
    if (d == 29 &amp;&amp; e == 6) || (d == 28 &amp;&amp; e == 6 &amp;&amp; a &gt; 10)
        e = -1
    end

    # Determination of the correct month for Easter
    if(22 + d + e &gt; 31)
        return &quot;April &quot; * string(d + e - 9)
    else
        return &quot;March &quot; * string(22 + d + e)
    end
end

# Here, we will output the date of the Paschal full moon
# (using Servois notation), and Easter for 2020-2030

a = collect(2020:2030)
servois_numbers = computus.(a; servois=true)
easter_dates = computus.(a)

println(&quot;The following are the dates of the Paschal full moon (using Servois &quot; *
        &quot;notation) and the date of Easter for 2020-2030 AD:&quot;)
println(&quot;Year\tServois number\tEaster&quot;)
for i = 1:length(a)
    println(&quot;$(a[i])\t$(servois_numbers[i])\t\t$(easter_dates[i])&quot;)
end
</code></pre>
<pre><code class="language-haskell">data Mode = Servois | Easter

computus :: Mode -&gt; Int -&gt; String
computus mode year =
  case mode of
    Servois -&gt;
      -- Value for Servois' table
      show $ (21 + d) `mod` 31
    Easter -&gt;
      -- Determination of the correct month for Easter
      if 22 + d + f &gt; 31
        then &quot;April &quot; ++ show (d + f - 9)
        else &quot;March &quot; ++ show (22 + d + f)
  where
    a, b, c, d, e, f, k, m, n, p, q :: Int
    -- Year's position on the 19 year metonic cycle
    a = year `mod` 19
    -- Century index
    k = year `div` 100
    -- Shift of metonic cycle, add a day offset every 300 years
    p = (13 + 8 * k) `div` 25
    -- Correction for non-observed leap days
    q = k `div` 4
    -- Correction to starting point of calculation each century
    m = (15 - p + k - q) `mod` 30
    -- Number of days from March 21st until the full moon
    d = (19 * a + m) `mod` 30
    -- Finding the next Sunday
    -- Century-based offset in weekly calculation
    n = (4 + k - q) `mod` 7
    -- Correction for leap days
    b = year `mod` 4
    c = year `mod` 7
    -- Days from d to next Sunday
    e = (2 * b + 4 * c + 6 * d + n) `mod` 7
    -- Historical corrections for April 26 and 25
    f =
      if (d == 29 &amp;&amp; e == 6) || (d == 28 &amp;&amp; e == 6 &amp;&amp; a &gt; 10)
        then -1
        else e

-- Here, we will output the date of the Paschal full moon
-- (using Servois notation), and Easter for 2020-2030
main :: IO ()
main = do
  let years :: [Int]
      years = [2020 .. 2030]
      servoisNumbers, easterDates :: [String]
      servoisNumbers = map (computus Servois) years
      easterDates = map (computus Easter) years
  putStrLn &quot;The following are the dates of the Paschal full moon (using Servois notation) and the date of Easter for 2020-2030 AD:&quot;
  putStrLn &quot;Year\tServois number\tEaster&quot;
  let conc :: Int -&gt; String -&gt; String -&gt; String
      conc y s e = show y ++ &quot;\t&quot; ++ s ++ &quot;\t\t&quot; ++ e
  mapM_ putStrLn $ zipWith3 conc years servoisNumbers easterDates
</code></pre>
<pre><code class="language-python">def computus(year, servois=False):
    # Year's position on the 19-year metonic cycle
    a = year % 19

    # Century index
    k = year // 100

    # Shift of metonic cycle, add a day offset every 300 years
    p = (13 + 8 * k) // 25

    # Correction for non-observed leap days
    q = k // 4

    # Correction to starting point of calculation each century
    M = (15 - p + k - q) % 30

    # Number of days from March 21st until the full moon
    d = (19 * a + M) % 30

    # Returning if user wants value for Servois' table
    if servois:
        return str((21 + d) % 31)

    # Finding the next Sunday
    # Century-based offset in weekly calculation
    N = (4 + k - q) % 7

    # Correction for leap days
    b = year % 4
    c = year % 7

    # Days from d to next Sunday
    e = (2 * b + 4 * c + 6 * d + N) % 7

    # Historical corrections for April 26 and 25
    if (d == 29 and e == 6) or (d == 28 and e == 6 and a &gt; 10):
        e = -1

    # Determination of the correct month for Easter
    if 22 + d + e &gt; 31:
        return &quot;April &quot; + str(d + e - 9)
    else:
        return &quot;March &quot; + str(22 + d + e)


# Here, we will output the date of the Paschal full moon
# (using Servois notation), and Easter for 2020-2030

print(
    &quot;The following are the dates of the Paschal full moon (using Servois&quot;,
    &quot;notation) and the date of Easter for 2020-2030 AD:&quot;,
)
print(&quot;Year\tServois number\tEaster&quot;)
for year in range(2020, 2031):
    print(f&quot;{year}\t{computus(year, servois=True)}\t\t{computus(year)}&quot;)
</code></pre>
<pre><code class="language-crystal">def computus(year, servois = false)
  # Year's position on the 19 year metonic cycle
  a = year % 19

  # Century index
  k = year // 100

  # Shift of metonic cycle, add a day offset every 300 years
  p = (13 + 8 * k) // 25

  # Correction for non-observed leap days
  q = k // 4

  # Correction to starting point of calculation each century
  m = (15 - p + k - q) % 30

  # Number of days from March 21st until the full moon
  d = (19 * a + m) % 30

  # Returning if user wants value for Servois' table
  if servois
    return ((21 + d) % 31).to_s
  end

  # Finding the next Sunday
  # Century-based offset in weekly calculation
  n = (4 + k - q) % 7

  # Correction for leap days
  b = year % 4
  c = year % 7

  # Days from d to next Sunday
  e = (2 * b + 4 * c + 6 * d + n) % 7

  # Historical corrections for April 26 and 25
  if (d == 29 &amp;&amp; e == 6) || (d == 28 &amp;&amp; e == 6 &amp;&amp; a &gt; 10)
    e = -1
  end

  # Determination of the correct month for Easter
  if (22 + d + e &gt; 31)
    return &quot;April &quot; + (d + e - 9).to_s
  else
    return &quot;March &quot; + (22 + d + e).to_s
  end
end

# Here, we will output the date of the Paschal full moon
# (using Servois notation), and Easter for 2020-2030
def main
  a = (2020..2030).to_a
  servois_numbers = a.map { |y| computus(y, servois = true) }
  easter_dates = a.map { |y| computus(y) }

  puts &quot;The following are the dates of the Paschal full moon (using Servois &quot; +
       &quot;notation) and the date of Easter for 2020-2030 AD:&quot;
  puts &quot;Year\tServois number\tEaster&quot;
  a.each_index { |i|
    puts &quot;#{a[i]}\t#{servois_numbers[i]}\t\t#{easter_dates[i]}&quot;
  }
end

main
</code></pre>
<pre><pre class="playground"><code class="language-rust">fn computus(year: usize, servois: bool) -&gt; String {
    // Year's position on the 19 year metonic cycle
    let a = year % 19;

    // Century index
    let k = year / 100; // NOTE: dividing integers always truncates the result

    // Shift of metonic cycle, add a day offset every 300 years
    let p = (13 + 8 * k) / 25;

    // Correction for non-observed leap days
    let q = k / 4;

    // Correction to starting point of calculation each century
    let m = (15 - p + k - q) % 30;

    // Number of days from March 21st until the full moon
    let d = (19 * a + m) % 30;

    if servois {
        return ((21 + d) % 31).to_string();
    }

    // Finding the next Sunday
    // Century-based offset in weekly calculation
    let n = (4 + k - q) % 7;

    // Correction for leap days
    let b = year % 4;
    let c = year % 7;

    // Days from d to next Sunday
    let temp_e = ((2 * b + 4 * c + 6 * d + n) % 7) as isize;

    // Historical corrections for April 26 and 25
    let e = if (d == 29 &amp;&amp; temp_e == 6) || (d == 28 &amp;&amp; temp_e == 6 &amp;&amp; a &gt; 10) {
        -1
    } else {
        temp_e
    };

    // Determination of the correct month for Easter
    if (22 + d) as isize + e &gt; 31 {
        format!(&quot;April {}&quot;, d as isize + e - 9)
    } else {
        format!(&quot;March {}&quot;, 22 + d as isize + e)
    }
}

fn main() {
    // Here, we will output the date of the Paschal full moon
    // (using Servois notation), and Easter for 2020-2030

    let years = 2020..=2030;

    println!(
        &quot;The following are the dates of the Paschal full moon (using \
            Servois notation) and the date of Easter for 2020-2030 AD:&quot;
    );
    println!(&quot;Year\tServois number\tEaster&quot;);
    years.for_each(|year| {
        println!(
            &quot;{}\t{:&lt;14}\t{}&quot;,
            year,
            computus(year, true),
            computus(year, false),
        )
    });
}
</code></pre></pre>
<pre><code class="language-powershell">function Calculate-Computus([int]$Year, [switch]$Servois) {

    # Year's position on the 19 year metonic cycle
    $a = $Year % 19

    # Century index
    $k = [Math]::Floor($Year / 100)

    # Shift of metonic cycle, add a day offset every 300 years
    $p = [Math]::Floor((13 + 8 * $k) / 25)

    # Correction for non-observed leap days
    $q = [Math]::Floor($k / 4)

    # Correction to starting point of calculation each century
    $M = (15 - $p + $k - $q) % 30

    # Number of days from March 21st until the full moon
    $d = (19 * $a + $M) % 30

    # Returning if user wants value for Servois' table
    if($Servois) {
        return ((21 + $d) % 31).ToString()
    }

    # Finding the next Sunday
    # Century-based offset in weekly calculation
    $N = (4 + $k - $q) % 7

    # Correction for leap days
    $b = $Year % 4
    $c = $Year % 7

    # Days from d to next Sunday
    $e = (2 * $b + 4 * $c + 6 * $d + $N) % 7

    # Historical corrections for April 26 and 25
    if(($d -eq 29 -and $e -eq 6) -or ($d -eq 28 -and $e -eq 6 -and $a -gt 10)) {
        $e = -1
    }

    # Determination of the correct month for Easter
    if(22 + $d + $e -gt 31) {
        return &quot;April &quot; + ($d + $e - 9)
    }
    else {
        return &quot;March &quot; + (22 + $d + $e)
    }
}


# Here, we will output the date of the Paschal full moon
# (using Servois notation), and Easter for 2020-2030

Write-Host &quot;The following are the dates of the Paschal full moon (using Servois&quot;,
           &quot;notation) and the date of Easter for 2020-2030 AD:&quot;
Write-Host &quot;Year`tServois number`tEaster&quot;
foreach($year in 2020..2030) {
    Write-Host &quot;$year`t$(Calculate-Computus $year -Servois)`t`t$(Calculate-Computus $year)&quot;
}
</code></pre>
<pre><code class="language-c">#include &lt;stdio.h&gt;

char *computus(int year, int servois, char *out, size_t out_size) {
    // Year's position on the 19 year metonic cycle
    int a = year % 19;

    // Century index
    int k = year / 100;

    //Shift of metonic cycle, add a day offset every 300 years
    int p = (13 + 8 * k) / 25;

    // Correction for non-observed leap days
    int q = k / 4;

    // Correction to starting point of calculation each century
    int M = (15 - p + k - q) % 30;

    // Number of days from March 21st until the full moon
    int d = (19 * a + M) % 30;

    // Returning if user wants value for Servois' table
    if (servois) {
        snprintf(out, out_size, &quot;%d&quot;,(21 + d) % 31);
        return out;
    }

    // Finding the next Sunday
    // Century-based offset in weekly calculation
    int N = (4 + k - q) % 7;

    // Correction for leap days
    int b = year % 4;
    int c = year % 7;

    // Days from d to next Sunday
    int e = (2 * b + 4 * c + 6 * d + N) % 7;

    // Historical corrections for April 26 and 25
    if ((d == 29 &amp;&amp; e == 6) || (d == 28 &amp;&amp; e == 6 &amp;&amp; a &gt; 10)) {
        e = -1;
    }

    if ((22 + d + e) &gt; 31) {
        snprintf(out, out_size, &quot;April %d&quot;, d + e - 9);
    } else {
        snprintf(out, out_size, &quot;March %d&quot;, 22 + d + e);
    }

    return out;
}

int main() {
    char tmp1[9], tmp2[9];

    printf(&quot;The following are the dates of the Paschal full moon (using &quot;
           &quot;Servois notation) and the date of Easter for 2020-2030 AD:\n&quot;);

    printf(&quot;Year\tServois number\tEaster\n&quot;);

    for (int year = 2020; year &lt;= 2030; year++) {
        printf(&quot;%d\t\t%s\t%s\n&quot;, year, computus(year, 1, tmp1, 9),
               computus(year, 0, tmp2, 9));
    }

    return 0;
}

</code></pre>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;string&gt;

std::string computus(int year, bool servois = false) {
  // Year's position on the 19 year metonic cycle
  int a = year % 19;

  // Century index
  int k = year / 100;

  // Shift of metonic cycle, add a day offset every 300 years
  int p = (13 + 8 * k) / 25;

  // Correction for non-observed leap days
  int q = k / 4;

  // Correction to starting point of calculation each century
  int M = (15 - p + k - q) % 30;

  // Number of days from March 21st until the full moon
  int d = (19 * a + M) % 30;

  // Returning if user wants value for Servois' table
  if (servois) {
    return std::to_string((21 + d) % 31);
  }

  // Finding the next Sunday
  // Century-based offset in weekly calculation
  int N = (4 + k - q) % 7;

  // Correction for leap days
  int b = year % 4;
  int c = year % 7;

  // Days from d to next Sunday
  int e = (2 * b + 4 * c + 6 * d + N) % 7;

  // Historical corrections for April 26 and 25
  if ((d == 29 &amp;&amp; e == 6) || (d == 28 &amp;&amp; e == 6 &amp;&amp; a &gt; 10)) {
    e = -1;
  }

  // Determination of the correct month for Easter
  return 22 + d + e &gt; 31 ? &quot;April &quot; + std::to_string(d + e - 9)
                         : &quot;March &quot; + std::to_string(22 + d + e);
}

// Here, we will output the date of the Paschal full moon (using Servois
// notation), and Easter for 2020-2030
int main() {
  std::cout &lt;&lt; &quot;The following are the dates of the Paschal full moon (using &quot;
               &quot;Servois notation) and the date of Easter for 2020-2030 AD:\n&quot;
               &quot;Year\tServois number\tEaster\n&quot;;

  for (int year = 2020; year &lt;= 2030; year++) {
    std::cout &lt;&lt; year &lt;&lt; &quot;\t\t&quot; &lt;&lt; computus(year, true) &lt;&lt; '\t'
              &lt;&lt; computus(year) &lt;&lt; std::endl;
  }
}
</code></pre>
<pre><code class="language-lisp">;;;; Gauss's Easter algorithm implementation

(defun computus (year &amp;optional (servois nil))
  &quot;Calculates the day of Easter for a given year and optionally its Servois number&quot;
  (let*
    ((a (mod year 19))                  ; year's position on the 19 year metonic cycle
      (k (floor year 100))              ; century index
      (p (floor (+ 13 (* 8 k)) 25))     ; shift of metonic cycle, add a day offset every 300 years
      (q (floor k 4))                   ; correction for non-observed leap days
      (m (mod (+ 15 (- p) k (- q)) 30)) ; correction to starting point of calculation each century
      (d (mod (+ (* 19 a) m) 30))       ; number of days from March 21st until the full moon
      (n (mod (+ 4 k (- q)) 7))         ; century-based offset in weekly calculation
      (b (mod year 4))                  ; correction for leap days
      (c (mod year 7))                  ; also a correction for leap days
      ;; days from d to next Sunday
      (e (mod (+ (* 2 b) (* 4 c) (* 6 d) n) 7)))
    ;; historical corrections for April 26 and 25
    (when (or (and (eql d 29) (eql e 6)) (and (eql d 28) (eql e 6) (&gt; a 10)))
      (setf e -1))
    (values
      ;; determination of the correct month for Easter
      (if (&gt; (+ 22 d e) 31)
          (format nil &quot;April ~a&quot; (+ d e -9))
          (format nil &quot;March ~a&quot; (+ 22 d e)))
      ;; optionally return a value for the Servois' table
      (if servois (mod (+ 21 d) 31)))))

(format t &quot;~{~a~%~}&quot;
  '(&quot;The following are the dates of the Paschal full moon (using Servois&quot;
     &quot;notation) and the date of Easter for 2020-2030 AD:~%&quot;
     &quot;Year    Servois number    Easter&quot;))
(loop for year from 2020 to 2030 do
  (multiple-value-bind (easter servois) (computus year t)
    (format t &quot;~8a~18a~a~%&quot; year servois easter)))
</code></pre>
<pre><code class="language-nim">import strformat

func computus(year: int, servois: bool = false): string =
  let
    # Year's position on the 19 year metonic cycle
    a = year mod 19
    # Century index
    k = year div 100
    # Shift of metonic cycle, add a day offset every 300 years
    p = (13 + 8 * k) div 25
    # Correction for non-observed leap days
    q = k div 4
    # Correction to starting point of calculation each century
    m = (15 - p + k - q) mod 30
    # Number of days from March 21st until the full moon
    d = (19 * a + m) mod 30
  # Returning of user wants value for Servois' table
  if servois:
    return $((21 + d) mod 31)
  let
    # Find the next Sunday
    # Century-based offset in weekly calculation
    n = (4 + k - q) mod 7
    # Correction for leap days
    b = year mod 4
    c = year mod 7
    # Days from d to next Sunday
    temp_e = (2 * b + 4 * c + 6 * d + n) mod 7
    # Historical corrections for April 26 and 25
    e = if (d == 29 and temp_e == 6) or (d == 28 and temp_e == 6 and a &gt; 10):
          -1
        else:
          temp_e
  # Determination of the correct month for Easter
  if (22 + d + e) &gt; 31:
    result = &quot;April {d + e - 9}&quot;.fmt
  else:
    result = &quot;March {22 + d + e}&quot;.fmt

when isMainModule:
  echo &quot;The following are the dates of the Paschal full moon (using Servois &quot;
  echo &quot;notation) and the date of Easter for 2020-2030 AD:&quot;
  echo &quot;Year Servois number Easter&quot;
  for year in 2020..2030:
    echo &quot;{year} {computus(year, true):14} {computus(year, false):6}&quot;.fmt
</code></pre>
<pre><code class="language-scala">object GaussEaster {
  def computus(year : Int, servois: Boolean = false): String = {
    
    // Year's position on the 19 year metonic cycle
    val a = year % 19

    // Century index
    val k = (year / 100).toInt

    // Shift of metonic cycle, add a day offset every 300 years
    val p = ((13 + 8 * k) / 25).toInt

    // Correction for non-observed leap days
    val q = (k / 4).toInt

    // Correction to starting point of calculation each century
    val M = (15 - p + k - q) % 30

    // Number of days from March 21st until the full moon
    val d = (19 * a + M) % 30

    // Returning if user wants value for Servois' table
    if (servois) 
      return s&quot;${(21 + d) % 31}&quot;
    
    // Finding the next Sunday
    // Century-based offset in weekly calculation
    val N = (4 + k - q) % 7

    // Correction for leap days
    val b = year % 4
    val c = year % 7

    // Days from d to next Sunday
    var e = (2 * b + 4 * c + 6 * d + N) % 7

    // Historical corrections for April 26 and 25
    if ((d == 29 &amp;&amp; e == 6) || (d == 28 &amp;&amp; e == 6 &amp;&amp; a &gt; 10)) {
      e = -1
    }

    // Determination of the correct month for Easter
    if (22 + d + e &gt; 31) 
      s&quot;April ${d + e - 9}&quot;
    else                 
      s&quot;March ${22 + d + e}&quot;
  }
  
  def main(args: Array[String]): Unit = {
    println(&quot;The following are the dates of the Paschal full moon (using &quot; + 
            &quot;Servois notation) and the date of Easter for 2020-2030 AD:\n&quot; +
            &quot;Year\tServois number\tEaster\n&quot;)
    
    for( year &lt;- 2020 to 2030){
      println(s&quot;$year \t\t ${computus(year, true)} \t${computus(year)}&quot;) 
    }
  }
}
</code></pre>
<pre><code class="language-dart">String computus(int year, {bool servois = false}) {
  // Year's position in metonic cycle
  final a = year % 19;

  // Century index
  final k = (year / 100).floor();

  // Shift of metonic cycle, add a day offset every 300 years
  final p = ((13 + 8 * k) / 25).floor();

  // Correction for non-observed leap days
  final q = (k / 4).floor();

  // Correction to starting point of calculation each century
  final M = (15 - p + k - q) % 30;

  // Number of days from March 21st until the full moon
  final d = (19 * a + M) % 30;

  // Returning if user wants value for Servois' table
  if (servois) {
    return ((21 + d) % 31).toString();
  }

  // Finding the next Sunday
  // Century-based offset in weekly calculation
  final N = (4 + k - q) % 7;

  // Correction for leap days
  final b = year % 4;
  final c = year % 7;

  // Days from d to next Sunday
  var e = (2 * b + 4 * c + 6 * d + N) % 7;

  // Historical corrections for April 26 and 25
  if (e == 6) {
    if (d == 29 || (d == 28 &amp;&amp; a &gt; 10)) {
      e = -1;
    }
  }

  // Determination of the correct month for Easter
  if (22 + d + e &gt; 31) {
    return 'April ${d + e - 9}';
  } else {
    return 'March ${22 + d + e}';
  }
}

void main() {
  print(&quot;The following are the dates of the Paschal full moon (using Servois &quot; +
      &quot;notation) and the date of Easter for 2020-2030 AD:&quot;);

  print(&quot;Year\tServois number\tEaster&quot;);

  for (var year = 2020; year &lt;= 2030; year++) {
    final servoisNumber = computus(year, servois: true);
    final easterDate = computus(year);

    print('$year\t$servoisNumber\t\t$easterDate');
  }
}
</code></pre>
<pre><code class="language-javascript">/**
 * In this code, the modulus operator is used.
 * However, this operator in javascript/typescript doesn't support negative numbers.
 * So, where there may be negative numbers, the function mod is used.
 * This function gives the modulo of any relative number a
 */

/**
 * @param {number} a
 * @param {number} b
 * @returns {number}
 */
function mod(a, b) {
  if (a &lt; 0) return mod(a + b, b);
  else return a % b;
}

/**
 * @param {number} year
 * @param {boolean} [servois=false]
 * @returns {string}
 */
function computus(year, servois = false) {
  // Year's position in metonic cycle
  const a = year % 19;

  // Century index
  const k = Math.floor(year / 100);

  // Shift of metonic cycle, add a day offset every 300 years
  const p = Math.floor((13 + 8 * k) / 25);

  // Correction for non-observed leap days
  const q = Math.floor(k / 4);

  // Correction to starting point of calculation each century
  const M = mod(15 - p + k - q, 30);

  // Number of days from March 21st until the full moon
  const d = (19 * a + M) % 30;

  // Returning if user wants value for Servois' table
  if (servois) {
    return ((21 + d) % 31).toString();
  }

  // Finding the next Sunday
  // Century-based offset in weekly calculation
  const N = mod(4 + k - q, 7);

  // Correction for leap days
  const b = year % 4;
  const c = year % 7;

  // Days from d to next Sunday
  let e = (2 * b + 4 * c + 6 * d + N) % 7;

  // Historical corrections for April 26 and 25
  if (e === 6) {
    if (d === 29 || (d === 28 &amp;&amp; a &gt; 10)) {
      e = -1;
    }
  }

  // Determination of the correct month for Easter
  if (22 + d + e &gt; 31) {
    return `April ${d + e - 9}`;
  } else {
    return `March ${22 + d + e}`;
  }
}

console.log(
  &quot;The following are the dates of the Paschal full moon (using Servois &quot; +
    &quot;notation) and the date of Easter for 2020-2030 AD:&quot;
);

const values = [];

for (let year = 2020; year &lt;= 2030; year++) {
  const servoisNumber = computus(year, true);
  const easterDate = computus(year);

  // Creation of an object to be displayed as a line in the output table
  values[year] = {
    &quot;servois number&quot;: +servoisNumber,
    easter: easterDate,
  };
}

console.table(values);
</code></pre>
<pre><code class="language-typescript">/**
 * In this code, the modulus operator is used.
 * However, this operator in javascript/typescript doesn't support negative numbers.
 * So, where there may be negative numbers, the function mod is used.
 * This function gives the modulo of any relative number a
 */

function mod(a: number, b: number): number {
  if (a &lt; 0) {
    return mod(a + b, b);
  } else {
    return a % b;
  }
}
function computus(year: number, servois: boolean = false): string {
  // Year's position in metonic cycle
  const a: number = year % 19;

  // Century index
  const k: number = Math.floor(year / 100);

  // Shift of metonic cycle, add a day offset every 300 years
  const p: number = Math.floor((13 + 8 * k) / 25);

  // Correction for non-observed leap days
  const q: number = Math.floor(k / 4);

  // Correction to starting point of calculation each century
  const M: number = mod(15 - p + k - q, 30);

  // Number of days from March 21st until the full moon
  const d: number = (19 * a + M) % 30;

  // Returning if user wants value for Servois' table
  if (servois) {
    return ((21 + d) % 31).toString();
  }

  // Finding the next Sunday
  // Century-based offset in weekly calculation
  const N: number = mod(4 + k - q, 7);

  // Correction for leap days
  const b: number = year % 4;
  const c: number = year % 7;

  // Days from d to next Sunday
  let e: number = (2 * b + 4 * c + 6 * d + N) % 7;

  // Historical corrections for April 26 and 25
  if (e === 6) {
    if (d === 29 || (d === 28 &amp;&amp; a &gt; 10)) {
      e = -1;
    }
  }

  // Determination of the correct month for Easter
  if (22 + d + e &gt; 31) {
    return `April ${d + e - 9}`;
  } else {
    return `March ${22 + d + e}`;
  }
}

console.log(
  &quot;The following are the dates of the Paschal full moon (using Servois &quot; +
    &quot;notation) and the date of Easter for 2020-2030 AD:&quot;
);

// Type of a line in the output table
interface IOutputLine {
  &quot;servois number&quot;: number;
  easter: string;
}

const values: IOutputLine[] = [];

for (let year = 2020; year &lt;= 2030; year++) {
  const servoisNumber: string = computus(year, true);
  const easterDate: string = computus(year);

  // Creation of an object to be displayed as a line in the output table
  const line: IOutputLine = {
    &quot;servois number&quot;: +servoisNumber,
    easter: easterDate,
  };

  values[year] = line;
}

console.table(values);
</code></pre>
<h3 id="bibliography-9"><a class="header" href="#bibliography-9">Bibliography</a></h3>
<p>{% references %} {% endreferences %}</p>
<h2 id="license-37"><a class="header" href="#license-37">License</a></h2>
<h5 id="code-examples-35"><a class="header" href="#code-examples-35">Code Examples</a></h5>
<p>The code examples are licensed under the MIT license (found in <a href="https://github.com/algorithm-archivists/algorithm-archive/blob/master/LICENSE.md">LICENSE.md</a>).</p>
<h5 id="text-37"><a class="header" href="#text-37">Text</a></h5>
<p>The text of this chapter was written by <a href="https://github.com/leios">James Schloss</a> and is licensed under the <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</p>
<p><a href="https://creativecommons.org/licenses/by-sa/4.0/"><p><img  class="center" src="computus/../cc/CC-BY-SA_icon.svg" /></p></a></p>
<h5 id="imagesgraphics-18"><a class="header" href="#imagesgraphics-18">Images/Graphics</a></h5>
<ul>
<li>The image &quot;<a href="computus/res/servois_1800.png">Servois 1800 Colored Table</a>&quot; was created by <a href="https://github.com/leios">James Schloss</a> and is licensed under the <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</li>
<li>The image &quot;<a href="computus/res/orbit.svg">Relative Orbits</a>&quot; was created by <a href="https://github.com/lockcmpxchg8beax">Xadisten</a> and was provided during a discussion on Twitch. It is licensed under the <a href="https://creativecommons.org/licenses/by/4.0/legalcode">Creative Commons Attribution 4.0 International License</a>.</li>
<li>The image &quot;<a href="computus/res/synodic_half_year.png">Synodic Half Year</a>&quot; was created by <a href="https://github.com/leios">James Schloss</a> and is licensed under the <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</li>
<li>The image &quot;<a href="computus/res/metonic.png">Metonic shadows</a>&quot; was created by <a href="https://github.com/leios">James Schloss</a> and is licensed under the <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</li>
<li>The image &quot;<a href="computus/res/orbit.png">Full Year Orbit</a>&quot; was created by <a href="https://github.com/leios">James Schloss</a> and is licensed under the <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</li>
<li>The image &quot;<a href="computus/res/servois_2000.png">Servois 2000 Colored Table</a>&quot; was created by <a href="https://github.com/leios">James Schloss</a> and is licensed under the <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-approximate-counting-algorithm"><a class="header" href="#the-approximate-counting-algorithm">The Approximate Counting Algorithm</a></h1>
<p>This might seem like a straightforward question, but how high can you count on your fingers?
This depends on how many fingers you have, but in general the answer has to be 10, right?</p>
<p>Well, not exactly, it can actually go much, much higher with a few simple abstractions.</p>
<p>The first strategy is to think of your fingers as binary registers, like so {{ &quot;3b1b_finger_count&quot; | cite }}:</p>
<p>
    <img  class="center" src="approximate_counting/res/hands.png" style="width:70%" />
</p>
<p>If your fingers are out, they count as a 1 for that register.
If they are not, they count as a 0.
This means that after you have decided on the appropriate finger configuration, you have created a bitstring that can be read from left to right, where each number represents a power of 2.
For this example, we would have a bitstring of 1110010101, which reads to 917:</p>
<p>\[ 1 \cdot 2^9 + 1 \cdot 2^8 + 1 \cdot 2^7 + 0 \cdot 2^6 + 0 \cdot 2^5 + 1 \cdot 2^4 + 0 \cdot 2^3 + 1 \cdot 2^2 + 0 \cdot 2^1 + 1 \cdot 2^0 \]
\[ = \]</p>
<p>\[ 512 + 256 + 128 + 16 + 4 + 1 = 917 \]</p>
<p>Because you have 10 fingers and each one represents a power of 2, you can count up to a maximum of \( 2^{10}-1 \) or 1023, which is about 100 times higher than simple finger counting!
For those who might be wondering why you can count to \( 2^{10}-1 \) instead of \( 2^{10} \) exactly, remember that each finger represents a power of 2.
The right thumb counts as \( 2^0 = 1 \) and the left thumb is \( 2^9 = 512 \).
With all fingers out, we have  counted to \( \sum_{n=0}^9 2^n = 1023 = 2^{10}-1 \).</p>
<p>So what if we wanted to go beyond 1023?
Well, we could start counting with our fingers as trits where 0 is closed, 1 is half-up, and 2 is fully up.
There are actually a huge variety of different ways we could move our hands about to count in odd ways, but we are interested in a more concrete problem: how high can we count with only 10 bits?</p>
<p>This is almost exactly the problem that Morris encountered in Bell Labs around 1977 {{&quot;morris1978counting&quot; | cite }}.
There, he was given an 8-bit register and asked to count much higher than \( 2^8 - 1= 255 \).
His solution was to invent a new method known as the approximate counting algorithm.
With this method, he could count to about \( 130,000 \) with a relatively low error (standard deviation, \( \sigma \approx 17,000 \)).
Using 10 registers (fingers), he could count to about \( 1.1\times 10^{16} \) with similar parameters, which is undoubtedly impressive!</p>
<p>The approximate counting algorithm is an early predecessor to streaming algorithms where information must be roughly processed in real-time.
As we dive into those methods later, this chapter will certainly be updated.
For now, we will not be showing any proofs (though those might come later as well), but a rigorous mathematical description of this method can be found in a follow-up paper by Philippe Flajolet {{ &quot;flajolet1985approximate&quot; | cite }}.
In addition, there are several blogs and resources online that cover the method to varying degrees of accessibility {{&quot;arpit_counting&quot; | cite }} {{&quot;greggunderson_counting&quot; | cite }}.</p>
<p>Here, we hope to provide a basic understanding of the method, along with code implementations for anyone who might want to try something similar in the future.</p>
<h2 id="a-simple-example"><a class="header" href="#a-simple-example">A Simple Example</a></h2>
<p>If we need to count more than 255 items with 8 bits, there is one somewhat simple strategy: count every other item.
This means that we will increment our counter with 2, 4, 6, 8... items, effectively doubling the number of items we can count to 511!
(Note: that &quot;!&quot; is out of excitement and is not a factorial.)
Similarly, if we need to count above 511, we can increment our counter every 3 or 4 items; however, the obvious drawback to this method is that if we only count every other item, there is no way to represent odd numbers.
Similarly, if we count every 3rd or 4th item, we would miss out on any numbers that are not multiples of our increment number.</p>
<p>The most important thing to take away from this line of reasoning is that counting can be done somewhat approximately by splitting the process into two distinct actions: incrementing the counter and storing the count, itself.
For example, every time a sheep walks by, you could lift a finger.
In this case, the act of seeing a sheep is a trigger for incrementing your counter, which is stored on your hand.
As mentioned, you could also lift a finger every time 2 or 3 sheep go by to count higher on your hand.
In code, bits are obviously preferred to hands for long-term storage.</p>
<p>Taking this example a bit further, imagine counting 1,000,000 sheep.
If we wanted to save all of them on 8 bits (maximum size of 255), we could increment our counter every \( \sim 4000 \) sheep.
By counting in this way, we would first need to count around 4000 sheep before incrementing the main counter by 1.
After all the sheep have gone by, we would have counted up to 250 on our counter, and also counted up to \( 4000 \) on a separate counter 250 times.
This has a few important consequences:</p>
<ol>
<li>If the final number of sheep is not a multiple of 4000, then we will have an error associated with the total count of up to 4000 (0.4%).</li>
<li>There is no way to determine the final number of sheep if it is not a multiple of 4000.</li>
<li>We now need some way to count up to 4000 before incrementing the main counter.
This means we need a second counter!</li>
</ol>
<p>In a sense, 4000 would be a type of &quot;counting resolution&quot; for our system.
Overall,  a 0.4% error is not bad, but it is possible to ensure that the approximate count is more accurate (but potentially less precise) by using randomness to our advantage.</p>
<p>That is to say, instead of incrementing out counter every 4000th sheep, we could instead give each item a \( 1/4000 = 0.025% \) chance of incrementing our main counter.
This averages out to be roughly 1 count every 4000 sheep, but the expectation value of a large number of counting experiments should be the correct number.
This means that even though we need to count all the sheep multiple times to get the right expectation value, we no longer need to keep a separate counter for the counting resolution of 4000.</p>
<p>Because multiple counting trials are necessary to ensure the correct result, each counting experiment will have some associated error (sometimes much higher than 0.4%).
To quantify this error, let's actually perform multiple the experiment, as shown below:</p>
<p>
    <img  class="center" src="approximate_counting/res/approximations.png" style="width:100%" />
</p>
<p>In this image, we have counted 1,000,000 sheep (items) 10,000 different times.
In each run, we have given each item a 0.025% chance to flip our primary counter and have given each increment in our primary counter a weight of 4000 items.
We have plotted 10 of the 10,000 runs (chosen at random), and each upward tick of the lines represents one of the items winning a game of chance and adding 1 to the primary counter and thus adding 4000 to the approximate count.
We have also shaded the maximum and minimum approximate count for each true count of the 10,000 trials in gray, thereby highlighting the range of possible outputs.
On top of the plot, we have shown the distribution of all 10,000 runs for the approximate count at 10,000, 500,000, and 1,000,000 items.</p>
<p>There's a lot to unpack here, so let's start with the upward trending lines.
Here, it seems like the approximate counts are roughly following the line of \( y=x \) (dotted black line), which would indicate simple counting (without any randomness or approximation).
This makes sense because in a perfect world, the approximate count would always be exactly equal to the true number of items being counted.
Unfortunately, none of the lines shown here exactly follow \( y=x \).
In fact, it would be impossible for any of the approximations to do so because we are always increasing the approximation in steps of 4000 while the true count increments by 1 with each new item.
That said, the <em>average</em> of all these counts together is a really good approximation for the true number of items.</p>
<p>This is where the 3 additional plots come in:</p>
<p>
    <img  class="center" src="approximate_counting/res/histograms.png" style="width:100%" />
</p>
<p>Each of these is a histogram of the approximate count for all 10,000 runs at 10,000 (left), 500,000 (middle), and 1,000,000 (left) items.
All three (especially the approximation for 1,000,000) look Gaussian, and the peak of the Gaussian seems to be the correct count.
In fact, the expectation value for our approximate counting scheme will always be correct.
In practice, this means that we can approximate any count on a small number of bits by doing a large number of counting trials and averaging their results.</p>
<p>There is still a little catch that becomes more evident as we look at the approximation for 10,000 items.
In this case, even though the expectation value for the Gaussian distribution looks correct, it's kinda hard to tell exactly because there are only 8 (or so) possible values for each individual experiment.
Essentially, we are trying to count to 10,000 in steps of 4,000.
Clearly the closest we can get on any individual run is either 8,000 or 12,000, as these are multiples of 4,000.
Simply put: we cannot resolve 10,000 items with this method!</p>
<p>Does this mean that this counting method is less useful for a small number of items?
In a sense, yes.
Here is a table for the true count, approximate count, and percent error for 10,000, 500,000, and 1,000,000 for the case where we do 10,000 counting experiments:</p>
<table><thead><tr><th>True Count</th><th>Approximate Count</th><th>Percent Error</th></tr></thead><tbody>
<tr><td>10,000</td><td>9,958.0</td><td>0.42</td></tr>
<tr><td>500,000</td><td>499,813.2</td><td>0.037</td></tr>
<tr><td>1,000,000</td><td>999,466.0</td><td>0.053</td></tr>
</tbody></table>
<p>Here, it seems that the percent error is 10 times higher when we count 10,000 items; however,
with these numbers, I could imagine some people reading this are thinking that we are splitting hairs.
A 0.42% error is still really good, right?
Right.
It's definitely not bad, but this was with 10,000 counting experiments.
Here a new table where we only did 10:</p>
<table><thead><tr><th>True Count</th><th>Approximate Count</th><th>Percent Error</th></tr></thead><tbody>
<tr><td>10,000</td><td>8,000.0</td><td>20.0</td></tr>
<tr><td>500,000</td><td>483,200.0</td><td>3.36</td></tr>
<tr><td>1,000,000</td><td>961,600.0</td><td>3.84</td></tr>
</tbody></table>
<p>This time, there is a 20% error when counting to 10,000.
That's unacceptably high!</p>
<p>To solve this problem, we need to find some way to for the value of each increment on the actual counter to be more meaningful for lower counts.
This is precisely the job for a logarithm, which is what we will be looking at in the next section.
For now, it's important to look at another anomaly: why are the percent errors for the 500,000 and 1,000,000 cases so close?</p>
<p>I gotta be honest, I don't know the correct answer here, but I would guess that it has something to do with the fact that both 500,000 and 1,000,000 are multiples of 4000 so our counting scheme can resolve both of them with roughly equal precision.
On top of that, both values are significantly higher than 4,000 so the counting resolution does not have as significant of an impact on the measured count.
Simply put, 4000 is a big step size when counting to 10,000, but a smaller one when counting to 500,000 or 1,000,000.</p>
<p>As an important note, each approximate count shown in the tables above was the expectation value for a Gaussian probability distribution of different counting experiments all providing a guess at what the count could be.
Because we are no longer counting with integer increments but instead with probability distributions, we now need to quantify our error with the tools of probability, namely standard deviations.</p>
<p>In the next section, we will tackle both issues brought up here:</p>
<ol>
<li>In order to better approximate different scales of counting, it makes sense to use a logarithmic scale.</li>
<li>Because we are counting by using the expectation value of a Gaussian probability distribution from a set of counting experiments, it makes sense to quantify error with the tools we learned from probability and statistics.</li>
</ol>
<p>So I guess we should hop to it!</p>
<h2 id="adding-a-logarithm"><a class="header" href="#adding-a-logarithm">Adding a logarithm</a></h2>
<p>At this stage, I feel it's important to use terminology that more closely matches Morris's original paper {{&quot;morris1978counting&quot; | cite}}, so we will begin to talk about events, which are a general abstraction to the previous item / sheep analogy.
We will also introduce three different values:</p>
<ul>
<li>\( n \): the number of events that have occurred.</li>
<li>\( v \): the number we have stored in our bitstring.</li>
<li>\( n_v \): the approximate number of events that have occurred.</li>
</ul>
<p>It's important to stop here and think about what's actually going on.
We have a certain number of events (\( n \)) that have occurred and have stored that number on a binary register as \( v \).
Traditionally, the number stored on the binary register would be exactly equal to the number of events, but because we do not have enough space on the register, we end up settling for an approximation of the number of events, \( n_v \).
This is precisely what we did in the previous example, where \( v = \frac{n}{4000} \) and \( n_v = 4000*v \).</p>
<p>As mentioned, using a constant scaling value (4000) for our approximate counting scheme means that the approximation is not ideal for a smaller number of events.
For this reason, it might be more appropriate to create a new method of storing the number of events by using a logarithmic scale, such that</p>
<p>\[ v = \log_2(1+n), \]</p>
<p>which would mean that the approximate count would be</p>
<p>\[ n_v = 2^v-1. \]</p>
<p>In this case, we are adding 1 to the argument of the logarithm for \( v \) because \( \log_2(1) = 0 \) and we start counting at 1; therefore, we need some way to represent the value of 0.
Also, for this we can use any base logarithm (like \( e \)), but because we are dealing with bits, it makes sense to use base 2.
We'll talk about different bases next.
To be clear, here is a table of several values that could be stored in a bitstring along with their corresponding approximate counts:</p>
<table><thead><tr><th>\( v(n) \)</th><th>\( n_v \)</th></tr></thead><tbody>
<tr><td>\( 00000000 = 0 \)</td><td>0</td></tr>
<tr><td>\( 00000001 = 1 \)</td><td>\( 1 \)</td></tr>
<tr><td>\( 00000010 = 2 \)</td><td>\( 3 \)</td></tr>
<tr><td>\( 00000100 = 4 \)</td><td>\( 15 \)</td></tr>
<tr><td>\( 00010000 = 16 \)</td><td>\( 65535 \)</td></tr>
<tr><td>\( 01000000 = 64 \)</td><td>\( 1.85 \times 10^{19} \)</td></tr>
<tr><td>\( 10000000 = 128 \)</td><td>\( 3.40 \times 10^{38} \)</td></tr>
<tr><td>\( 11111111 = 255 \)</td><td>\( 5.79 \times 10^{76} \)</td></tr>
</tbody></table>
<p>This means that we can hold from \( 0 \) to \( 2^{255} - 1 \approx 5.79 \times 10^{76} \) with 8 bits using this new method.</p>
<p>So let's now think about what happens every time a new event occurs.
To do this, Morris calculated a new value:</p>
<p>\[ \Delta = \frac{1}{n_{v+1} - n_{v}} \]</p>
<p>where \( n_{v+1} \) is the approximate count for the next possible value \( v \) stored in the register.
In this case, \( \Delta \) will always be between 0 and 1, so we can consider it to be the probability of whether we should increment our stored count or not.
For example, if we have a stored value of 2 (\( v=2 \)), then</p>
<p>\[ \Delta = \frac{1}{n_3 - n_2} = \frac{1}{(2^3-1)-(2^2-1)} \approx \frac{1}{7-3} \approx 0.25. \]</p>
<p>This indicates that there will be a 25% chance to increment \( v \) from 2 to 3.
In practice, this means that we need to create another random variable \( r \) and set our counter such that</p>
<p>\[
\begin{align}
\text{if } &amp; r &lt; \Delta, \qquad v = v + 1 \\
\text{if } &amp; r &gt; \Delta, \qquad v = v.
\end{align}
\]</p>
<p>Again, \( \Delta \) is essentially the probability that we will increment our counter with each object, and as we count higher, the probability decreases exponentially.</p>
<p>
    <img  class="center" src="approximate_counting/res/deltas.png" style="width:100%" />
</p>
<p>Note: the \( y \)-axis to this figure is in logscale, which is why it looks like a straight line.</p>
<p>Before leaving this section, it's important to note that the highest anyone can count with this method in base 2 using an 8-bit register is \( 5.79 \times 10^{76} \).
That's great!
Way, way better than 255, but we can still go higher with a different base of logarithm.
For example, if we use \( e \) as our base, we can get up to \( e^{255}-1 = 5.56 \times 10^{110} \).
In addition, by choosing smaller bases, we can also find a more accurate approximate count for lower values.
In practice, we want to select a base that allows us to count to a value of the same order (or one order higher) than the number of events we are expected to have.</p>
<p>In the next section, we will consider how to generalize this logarithmic method to take arbitrary bases into account.</p>
<h2 id="a-slightly-more-general-logarithm"><a class="header" href="#a-slightly-more-general-logarithm">A slightly more general logarithm</a></h2>
<p>Let's start by considering the differences between base \( 2 \) and base \( e \).
For base \( e \),</p>
<p>\[
\begin{align}
n_v &amp;= e^v - 1 \\
v &amp;= \log_e(1+n).
\end{align}
\]</p>
<p>If we were to update our count and wanted to keep the value in the counter as accurate as possible, then the new value in the register with every new event would be</p>
<p>\[ v = \log_e(1+e^v). \]</p>
<p>This is generally not an integer value, but \( v \) <em>must</em> be an integer value (unless we want to try and store floating-point values (which we definitely don't have space for)), so what do we do in this situation?</p>
<p>Well, let's look at the very first event where we need to increment our count from 0 to 1.
With base \( e \), there would only be a 58% chance of counting the first event (\( \Delta = \frac{1}{1.72-0} = 0.58 \)), and if the event is counted, the value in the register would be \( \approx 1.71 \neq 1 \).
Again, the expectation value for a bunch of trials is correct, but we did not have this issue with base 2, because</p>
<p>\[ v = \frac{\log_e(n+1)}{\log_e(2)} = 1 \]</p>
<p>when \( n=1 \).
As a reminder, the above formula is a way to convert any logarithm from a given base (in this case \( e \)) to another base (in this case 2).</p>
<p>Going one step further, we need to chose a specific base to a logarithm that will at least ensure that the first count is correct, and for this reason, Morris studied a specific solution:</p>
<p>\[
\begin{align}
v &amp;= \frac{\log(1+n/a)}{\log(1+1/a)}. \\
n_v &amp;= a\left(\left(1+\frac{1}{a}\right)^v-1\right).
\end{align}
\]</p>
<p>Here, \( a \) is an effective tuning parameter and sets the maximum count allowed by the bitstring and the expected error.
The expression \( 1+1/a \) acts as a base for the logarithm and exponents and ensures that the first count of \( n=1 \) will also set the value \( v=1 \).
As an example, if the bitstring can be a maximum of 255 (for 8 bits) and we arbitrarily set
\( a=30 \), then the highest possible count with this approach will be \( \approx 130,000 \), which was the number reported in Morris's paper.
If we perform a few counting experiments, we find that this formula more closely tracks smaller numbers than before (when we were not using the logarithm):</p>
<p>
    <img  class="center" src="approximate_counting/res/approximationsexp.png" style="width:100%" />
</p>
<p>Now, let's pause for a second and look back at the case where our counting resolution was a constant 4000:</p>
<p>
    <img  class="center" src="approximate_counting/res/approximations.png" style="width:100%" />
</p>
<p>It would seem that for higher counts, the previous method (with a constant counting resolution) is actually better!
Remember that in the case of a constant counting resolution, the step size is really small for higher counts, so we get a higher resolution probability distribution for when we count 500,000 and 1,000,000 items.
With the logarithmic scale, this is not the case, as the counting resolution now changes with the count, itself.
This is also why all three probability distributions for the logarithmic scaling have a similar distance between each bar.
In fact, it is probably worthwhile to look at each case more specifically:</p>
<table><thead><tr><th>Constant Counting Resolution</th><th>Logarithmic Counting Resolution</th></tr></thead><tbody>
<tr><td><img  class="center" src="approximate_counting/res/hist_1.png" style="width:100%" /></td><td><img  class="center" src="approximate_counting/res/histexp_1.png" style="width:100%" /></td></tr>
<tr><td><img  class="center" src="approximate_counting/res/hist_2.png" style="width:100%" /></td><td><img  class="center" src="approximate_counting/res/histexp_2.png" style="width:100%" /></td></tr>
<tr><td><img  class="center" src="approximate_counting/res/hist_3.png" style="width:100%" /></td><td><img  class="center" src="approximate_counting/res/histexp_3.png" style="width:100%" /></td></tr>
</tbody></table>
<p>In the case where we count only to 10,000, we see a moderate increase in the resolution of the probability distribution, but in the 500,000 and 1,000,000 cases, we do not.
It's also important to notice that the logarithmic plots are a bit skewed to the left and are only Gaussian on logarithmic scales along \( x \).
On the one hand, the logarithmic plots are nice in that they have the same relative error for all scales, but on the other hand, the error is relatively high.</p>
<p>How do we fix this?
Well, by modifying the base of the logarithm with the variable \( a \):</p>
<p>
    <img  class="center" src="approximate_counting/res/a_change.png" style="width:100%" />
</p>
<p>Here, we show the differences in \( n_v \) for \( 25 \leq a \leq 35 \) when \( v=255 \).
It is important to twiddle \( a \) based on what the maximum count is expected for
each experiment.
As an important note, the expected error estimate (variance) for each count will
be</p>
<p>\[ \sigma(n,a)^2 = \frac{n(n-1)}{2a}. \]</p>
<p>Finally, before ending the paper, Morris mentioned that it is possible to pre-compute all values \( \Delta_j = (a/(a+1))^j \) for all \( j \in [1,N] \) where \( N \) is the largest value possible integer with that bitstring (as an example, 255 for 8 bits).
This was probably more useful in 1978 than it is now, but it's still nice to keep in mind if you find yourself working on a machine with compute constrictions.</p>
<h2 id="video-explanation-14"><a class="header" href="#video-explanation-14">Video Explanation</a></h2>
<p>Here is a video describing the Approximate Counting Algorithm:</p>
<div style="text-align:center">
<iframe width="560" height="315" src="https://www.youtube.com/embed/c4RJhPsc14s"
 frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; pic
ture-in-picture" allowfullscreen></iframe>
</div>
<h2 id="example-code-20"><a class="header" href="#example-code-20">Example Code</a></h2>
<p>For this example, we have returned to the question asked above: how high can someone count on their fingers using the approximate counting algorithm?
We know from the formula that with \( a=30 \) and 10 bits, we should be able to count to \( 1.1\times 10^{16} \), but what happens when we perform the actual experiment?</p>
<p>As we do not have any objects to count, we will instead simulate the counting with a <code>while</code> loop that keeps going until out bitstring is 1023 (\( 2^{10} \)).</p>
<pre><code class="language-julia">using Test 

# This function takes 
#     - v: value in register
#     - a: a  scaling value for the logarithm based on Morris's paper
# It returns n(v,a), the approximate count
function n(v, a)
    a*((1+1/a)^v-1)  
end

# This function takes
#    - v: value in register
#    - a: a scaling value for the logarithm based on Morris's paper
# It returns a new value for v
function increment(v, a)
    # delta is the probability of incrementing our counter
    delta = 1/(n(v+1, a)-n(v, a))

    if rand() &lt;= delta
        return v + 1
    else
        return v
    end
end

# This simulates counting and takes
#     - n_items: number of items to count and loop over
#     - a: a scaling value for the logarithm based on Morris's paper
# It returns n(v,a), the approximate count
function approximate_count(n_items, a)
    v = 0
    for i = 1:n_items
        v = increment(v, a)
    end

    return n(v, a)
end

# This function takes
#     - n_trials: the number of counting trials
#     - n_items: the number of items to count to
#     - a: a scaling value for the logarithm based on Morris's paper
#     - threshold: the maximum percent error allowed
# It returns a true / false test value
function test_approximate_count(n_trials, n_items, a, threshold)
    samples = [approximate_count(n_items, a) for i = 1:n_trials]

    avg = sum(samples)/n_trials

    if (abs((avg - n_items) / n_items) &lt; threshold)
        println(&quot;passed&quot;)
    else
        println(&quot;failed&quot;)
    end
end

println(&quot;[#]\nCounting Tests, 100 trials&quot;)

println(&quot;[#]\ntesting 1,000, a = 30, 10% error&quot;)
test_approximate_count(100, 1000, 30, 0.1)

println(&quot;[#]\ntesting 12,345, a = 10, 10% error&quot;)
test_approximate_count(100, 12345, 10, 0.1)

# Note: with a lower a, we need more trials, so a higher % error here.
println(&quot;[#]\ntesting 222,222, a = 0.5, 20% error&quot;)
test_approximate_count(100, 222222, 0.5, 0.2)
</code></pre>
<pre><code class="language-c">#include &lt;assert.h&gt;
#include &lt;math.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;time.h&gt;

// This function returns a pseudo-random number between 0 and 1
double drand()
{
    return (double)rand() / RAND_MAX;
}

// This function takes
//  - v: value in register
//  - a: a scaling value for the logarithm based on Morris's paper
// It returns the approximate count
double n(double v, double a)
{
    return a * (pow(1 + 1 / a, v) - 1);
}

// This function takes
//  - v: value in register
//  - a: a scaling value for the logarithm based on Morris's paper
// It returns a new value for v
double increment(double v, double a)
{
    // delta is the probability of incrementing our counter
    double delta = 1 / (n(v + 1, a) - n(v, a));

    if (drand() &lt;= delta) {
        return v + 1;
    }
    return v;
}

// This function simulates counting and takes
//  - n_items: number of items to count and loop over
//  - a: a scaling value for the logarithm based on Morris's paper
// It returns n(v, a), the approximate count
double approximate_count(size_t n_items, double a)
{
    int v = 0;
    for (size_t i = 0; i &lt; n_items; ++i) {
        v = increment(v, a);
    }

    return n(v, a);
}

// This function takes
//  - n_trials: the number of counting trials
//  - n_items: the number off items to count
//  - a: a scaling value for the logarithm based on Morris's paper
//  - threshold: the maximum percent error allowed
// It terminates the program on failure
void test_approximation_count(size_t n_trials, size_t n_items, double a,
                              double threshold)
{
    double sum = 0.0;
    for (size_t i = 0; i &lt; n_trials; ++i) {
        sum += approximate_count(n_items, a);
    }
    double avg = sum / n_trials;

    if (fabs((avg - n_items) / n_items) &lt; threshold){
        printf(&quot;passed\n&quot;);
    }
    else{
        printf(&quot;failed\n&quot;);
    }
}

int main()
{
    srand(time(NULL));

    printf(&quot;[#]\nCounting Tests, 100 trials\n&quot;);
    printf(&quot;[#]\ntesting 1,000, a = 30, 10%% error\n&quot;);
    test_approximation_count(100, 1000, 30, 0.1);
    printf(&quot;[#]\ntesting 12,345, a = 10, 10%% error\n&quot;);
    test_approximation_count(100, 12345, 10, 0.1);
    printf(&quot;[#]\ntesting 222,222, a = 0.5, 20%% error\n&quot;);
    test_approximation_count(100, 222222, 0.5, 0.2);

    return 0;
}
</code></pre>
<pre><code class="language-cpp">#include &lt;cmath&gt;
#include &lt;iostream&gt;
#include &lt;numeric&gt;
#include &lt;random&gt;

// Returns a pseudo-random number generator
std::default_random_engine&amp; rng() {
  // Initialize static pseudo-random engine with non-deterministic random seed
  static std::default_random_engine randEngine(std::random_device{}());
  return randEngine;
}

// Returns a random double in [0, 1)
double drand() {
  return std::uniform_real_distribution&lt;double&gt;(0.0, 1.0)(rng());
}

// This function takes
//     - v: value in register
//     - a: a  scaling value for the logarithm based on Morris's paper
// It returns n(v,a), the approximate count
auto n(double v, double a) { return a * (pow((1 + 1 / a), v) - 1); }

// This function takes
//    - v: value in register
//    - a: a scaling value for the logarithm based on Morris's paper
// It returns a new value for v
auto increment(int v, double a) {
  // delta is the probability of incrementing our counter
  const auto delta = 1 / (n(v + 1, a) - n(v, a));
  return (drand() &lt;= delta) ? v + 1 : v;
}

// This simulates counting and takes
//     - n_items: number of items to count and loop over
//     - a: a scaling value for the logarithm based on Morris's paper
// It returns n(v,a), the approximate count
auto approximate_count(int n_items, double a) {
  auto v = 0;
  for (auto i = 0; i &lt; n_items; ++i)
    v = increment(v, a);

  return n(v, a);
}

// This function takes
//     - n_trials: the number of counting trials
//     - n_items: the number of items to count to
//     - a: a scaling value for the logarithm based on Morris's paper
//     - threshold: the maximum percent error allowed
// It returns a &quot;pass&quot; / &quot;fail&quot; test value
auto test_approximate_count(
    int n_trials, int n_items, double a, double threshold) {
  auto sum = 0.0;
  for (auto i = 0; i &lt; n_trials; ++i)
    sum += approximate_count(n_items, a);
  const auto avg = sum / n_trials;
  return std::abs((avg - n_items) / n_items) &lt; threshold ? &quot;passed&quot; : &quot;failed&quot;;
}

int main() {
  std::cout &lt;&lt; &quot;[#]\nCounting Tests, 100 trials\n&quot;;

  std::cout &lt;&lt; &quot;[#]\ntesting 1,000, a = 30, 10% error \n&quot;
            &lt;&lt; test_approximate_count(100, 1000, 30, 0.1) &lt;&lt; &quot;\n&quot;;
  std::cout &lt;&lt; &quot;[#]\ntesting 12,345, a = 10, 10% error \n&quot;
            &lt;&lt; test_approximate_count(100, 12345, 10, 0.1) &lt;&lt; &quot;\n&quot;;
  // Note : with a lower a, we need more trials, so a higher % error here.
  std::cout &lt;&lt; &quot;[#]\ntesting 222,222, a = 0.5, 20% error \n&quot;
            &lt;&lt; test_approximate_count(100, 222222, 0.5, 0.2) &lt;&lt; &quot;\n&quot;;
}
</code></pre>
<pre><code class="language-python">from random import random

# This function takes
#   - v: value in register
#   - a: a scaling value for the logarithm based on Morris's paper
# It returns n(v,a), the approximate_count
def n(v, a):
    return a*((1 + 1/a)**v - 1)

# This function takes
#    - v: value in register
#    - a: a scaling value for the logarithm based on Morris's paper
# It returns a new value for v
def increment(v, a):
    delta = 1/(n(v + 1, a) - n(v, a))
    if random() &lt;= delta:
        return v + 1
    else:
        return v

#This simulates counting and takes
#     - n_items: number of items to count and loop over
#     - a: a scaling value for the logarithm based on Morris's paper
# It returns n(v,a), the approximate count
def approximate_count(n_items, a):
    v = 0
    for i in range(1, n_items + 1):
        v = increment(v, a)
    return n(v, a)

# This function takes
#     - n_trials: the number of counting trials
#     - n_items: the number of items to count to
#     - a: a scaling value for the logarithm based on Morris's paper
#     - threshold: the maximum percent error allowed
# It returns a true / false test value
def test_approximate_count(n_trials, n_items, a, threshold):
    samples = [approximate_count(n_items, a) for i in range(1, n_trials + 1)]
    avg = sum(samples)/n_trials

    if abs((avg - n_items)/n_items) &lt; threshold:
        print(&quot;passed&quot;)
    else:
        print(&quot;failed&quot;)

print(&quot;[#]\nCounting Tests, 100 trials&quot;)
print(&quot;[#]\ntesting 1,000, a = 30, 10% error&quot;)
test_approximate_count(100, 1000, 30, 0.1)
print(&quot;[#]\ntesting 12,345, a = 10, 10% error&quot;)
test_approximate_count(100, 12345, 10, 0.1)
print(&quot;[#]\ntesting 222,222, a = 0.5, 20% error&quot;)
test_approximate_count(100, 222222, 0.5, 0.2)
</code></pre>
<h3 id="bibliography-10"><a class="header" href="#bibliography-10">Bibliography</a></h3>
<p>{% references %} {% endreferences %}</p>
<h2 id="license-38"><a class="header" href="#license-38">License</a></h2>
<h5 id="code-examples-36"><a class="header" href="#code-examples-36">Code Examples</a></h5>
<p>The code examples are licensed under the MIT license (found in <a href="https://github.com/algorithm-archivists/algorithm-archive/blob/master/LICENSE.md">LICENSE.md</a>).</p>
<h5 id="text-38"><a class="header" href="#text-38">Text</a></h5>
<p>The text of this chapter was written by <a href="https://github.com/leios">James Schloss</a> and is licensed under the <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</p>
<p><a href="https://creativecommons.org/licenses/by-sa/4.0/"><p><img  class="center" src="approximate_counting/../cc/CC-BY-SA_icon.svg" /></p></a></p>
<h4 id="imagesgraphics-19"><a class="header" href="#imagesgraphics-19">Images/Graphics</a></h4>
<ul>
<li>The image &quot;<a href="approximate_counting/../approximate_counting/res/hands.png">Finger Counting</a>&quot; was created by <a href="https://github.com/leios">James Schloss</a> and is licensed under the <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</li>
<li>The image &quot;<a href="approximate_counting/../approximate_counting/res/approximations.png">Approximate trials</a>&quot; was created by <a href="https://github.com/leios">James Schloss</a> and is licensed under the <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</li>
<li>The image &quot;<a href="approximate_counting/../approximate_counting/res/histograms.png">Histograms</a>&quot; was created by <a href="https://github.com/leios">James Schloss</a> and is licensed under the <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</li>
<li>The image &quot;<a href="approximate_counting/../approximate_counting/res/deltas.png">Delta v v</a>&quot; was created by <a href="https://github.com/leios">James Schloss</a> and is licensed under the <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</li>
<li>The image &quot;<a href="approximate_counting/../approximate_counting/res/approximationsexp.png">Approximate trials Logarithm</a>&quot; was created by <a href="https://github.com/leios">James Schloss</a> and is licensed under the <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</li>
<li>The image &quot;<a href="approximate_counting/../approximate_counting/res/hist_1.png">Histograms 10,000</a>&quot; was created by <a href="https://github.com/leios">James Schloss</a> and is licensed under the <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</li>
<li>The image &quot;<a href="approximate_counting/../approximate_counting/res/histexp_1.png">Histograms exp 10,000</a>&quot; was created by <a href="https://github.com/leios">James Schloss</a> and is licensed under the <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</li>
<li>The image &quot;<a href="approximate_counting/../approximate_counting/res/hist_2.png">Histograms 500,000</a>&quot; was created by <a href="https://github.com/leios">James Schloss</a> and is licensed under the <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</li>
<li>The image &quot;<a href="approximate_counting/../approximate_counting/res/histexp_2.png">Histograms exp 500,000</a>&quot; was created by <a href="https://github.com/leios">James Schloss</a> and is licensed under the <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</li>
<li>The image &quot;<a href="approximate_counting/../approximate_counting/res/hist_3.png">Histograms 1,000,000</a>&quot; was created by <a href="https://github.com/leios">James Schloss</a> and is licensed under the <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</li>
<li>The image &quot;<a href="approximate_counting/../approximate_counting/res/histexp_3.png">Histograms exp 1,000,000</a>&quot; was created by <a href="https://github.com/leios">James Schloss</a> and is licensed under the <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</li>
<li>The image &quot;<a href="approximate_counting/../approximate_counting/res/a_change.png">A from 25 to 35</a>&quot; was created by <a href="https://github.com/leios">James Schloss</a> and is licensed under the <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script type="text/javascript">
            var socket = new WebSocket("ws://0.0.0.0:3000/__livereload");
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->

        <script type="text/javascript">
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>

    </body>
</html>
